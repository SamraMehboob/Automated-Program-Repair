public class GenericController extends AbstractTestElement implements Serializable , Controller , PerThreadClonable { protected List subControllersAndSamplers = new ArrayList ( ) ; protected int current ; protected Iterator controlIt ; private List configs = new LinkedList ( ) ; private boolean returnedNull = false ; private boolean done = false ; private boolean timeForNext = false ; private List assertions = new LinkedList ( ) ; public GenericController ( ) { } public boolean isNextFirst ( ) { } protected List getConfigElements ( ) { } private void addConfigElement ( TestElement el ) { } public void initialize ( ) { } public void reInitialize ( ) { } protected void removeCurrentController ( ) { } protected void resetCurrent ( ) { } protected void incrementCurrent ( ) { } protected boolean hasNextAtEnd ( ) { } protected void nextAtEnd ( ) { } public boolean hasNext ( ) { } protected void currentHasNextIsFalse ( ) { } protected boolean shortCircuitIsDone ( ) { } protected void setShortCircuit ( boolean done ) { } public boolean isDone ( ) { } protected TestElement getCurrentController ( ) { } protected List getSubControllers ( ) { } public void addTestElement ( TestElement child ) { } private void addController ( TestElement child ) { } public Sampler next ( ) { } public static class Test extends TestCase { public Test ( String name ) { } public void testProcessing ( ) throws Exception { GenericController controller = new GenericController ( ) ; GenericController sub_1 = new GenericController ( ) ; sub_1 . addTestElement ( makeSampler ( "one" ) ) ; sub_1 . addTestElement ( makeSampler ( "two" ) ) ; controller . addTestElement ( sub_1 ) ; controller . addTestElement ( makeSampler ( "three" ) ) ; GenericController sub_2 = new GenericController ( ) ; GenericController sub_3 = new GenericController ( ) ; sub_2 . addTestElement ( makeSampler ( "four" ) ) ; sub_3 . addTestElement ( makeSampler ( "five" ) ) ; sub_3 . addTestElement ( makeSampler ( "six" ) ) ; sub_2 . addTestElement ( sub_3 ) ; sub_2 . addTestElement ( makeSampler ( "seven" ) ) ; controller . addTestElement ( sub_2 ) ; String [ ] order = new String [ ] { "one" , "two" , "three" , "four" , "five" , "six" , "seven" } ; int counter = 7 ; for ( int i = 0 ; i < 2 ; i ++ ) { assertEquals ( 7 , counter ) ; counter = 0 ; while ( controller . hasNext ( ) ) { TestElement sampler = controller . next ( ) ; <START_BUG> assertEquals ( order [ ( counter ++ ) ] , sampler . getProperty ( NAME ) ) ; <END_BUG> } } } private TestElement makeSampler ( String name ) { } class TestSampler extends AbstractSampler implements PerSampleClonable { public void addCustomTestElement ( TestElement t ) { } public SampleResult sample ( Entry e ) { } } } }
public class ResourceUrlEncodingFilter extends OncePerRequestFilter { private static final Log logger = LogFactory . getLog ( ResourceUrlEncodingFilter . class ) ; @ Override protected void doFilterInternal ( HttpServletRequest request , HttpServletResponse response , FilterChain filterChain ) throws IOException , ServletException { } private static class ResourceUrlEncodingResponseWrapper extends HttpServletResponseWrapper { private HttpServletRequest request ; private Integer indexLookupPath ; private ResourceUrlEncodingResponseWrapper ( HttpServletRequest request , HttpServletResponse wrapped ) { } @ Override public String encodeURL ( String url ) { } private ResourceUrlProvider getResourceUrlProvider ( ) { } private void initIndexLookupPath ( ResourceUrlProvider urlProvider ) { if ( ( this . indexLookupPath ) == null ) { String requestUri = urlProvider . getPathHelper ( ) . getRequestUri ( this . request ) ; String lookupPath = urlProvider . getPathHelper ( ) . getLookupPathForRequest ( this . request ) ; <START_BUG> this . indexLookupPath = requestUri . indexOf ( lookupPath ) ; <END_BUG> } } } }
public class TextFile extends File { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private String encoding = null ; public TextFile ( File filename , String encoding ) { } public TextFile ( File filename ) { } public TextFile ( String filename ) { } public TextFile ( String filename , String encoding ) { } public void setText ( String body ) { } public String getText ( ) { String lineEnd = System . getProperty ( "line.separator" ) ; <START_BUG> StringBuffer sb = new StringBuffer ( ) ; <END_BUG> Reader reader = null ; BufferedReader br = null ; try { if ( ( encoding ) == null ) { reader = new FileReader ( this ) ; } else { reader = new InputStreamReader ( new FileInputStream ( this ) , encoding ) ; } br = new BufferedReader ( reader ) ; String line = "NOTNULL" ; while ( line != null ) { line = br . readLine ( ) ; if ( line != null ) { sb . append ( ( line + lineEnd ) ) ; } } } catch ( IOException ioe ) { TextFile . log . error ( "" , ioe ) ; } finally { JOrphanUtils . closeQuietly ( br ) ; } return sb . toString ( ) ; } public String getEncoding ( ) { } public void setEncoding ( String string ) { } }
public class DigestAlgorithm implements Algorithm { private static final int BYTE_MASK = 255 ; private static final int BUFFER_SIZE = 8192 ; private String algorithm = "MD5" ; private String provider = null ; private MessageDigest messageDigest = null ; private int readBufferSize = DigestAlgorithm . BUFFER_SIZE ; public void setAlgorithm ( String algorithm ) { } public void setProvider ( String provider ) { } public void initMessageDigest ( ) { } public boolean isValid ( ) { } public String getValue ( File file ) { } public String toString ( ) { <START_BUG> StringBuffer buf = new StringBuffer ( ) ; <END_BUG> buf . append ( "<DigestAlgorithm:" ) ; buf . append ( "algorithm=" ) . append ( algorithm ) ; buf . append ( ";provider=" ) . append ( provider ) ; buf . append ( ">" ) ; return buf . toString ( ) ; } }
public class GuildRoleUpdateHandler extends PacketHandler { public GuildRoleUpdateHandler ( ImplDiscordAPI api ) { } @ Override public void handle ( JSONObject packet ) { String guildId = packet . getString ( "guild_id" ) ; JSONObject roleJson = packet . getJSONObject ( "role" ) ; Server server = api . getServerById ( guildId ) ; final ImplRole role = ( ( ImplRole ) ( server . getRoleById ( roleJson . getString ( "id" ) ) ) ) ; String name = roleJson . getString ( "name" ) ; if ( ! ( role . getName ( ) . equals ( name ) ) ) { final String oldName = role . getName ( ) ; role . setName ( name ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangeNameListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangeNameListener ) ( listener ) ) . onRoleChangeName ( api , role , oldName ) ; } } } } ) ; } Permissions permissions = new ImplPermissions ( roleJson . getInt ( "permissions" ) ) ; if ( ! ( role . getPermissions ( ) . equals ( permissions ) ) ) { final Permissions oldPermissions = role . getPermissions ( ) ; role . setPermissions ( ( ( ImplPermissions ) ( permissions ) ) ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangePermissionsListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangePermissionsListener ) ( listener ) ) . onRoleChangePermissions ( api , role , oldPermissions ) ; } } } } ) ; } Color color = new Color ( roleJson . getInt ( "color" ) ) ; if ( ( role . getColor ( ) . getRGB ( ) ) != ( color . getRGB ( ) ) ) { final Color oldColor = role . getColor ( ) ; role . setColor ( color ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangeColorListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangeColorListener ) ( listener ) ) . onRoleChangeColor ( api , role , oldColor ) ; } } } } ) ; } <START_BUG> if ( ( role . getHoist ( ) ) != ( packet . getBoolean ( "hoist" ) ) ) { <END_BUG> role . setHoist ( ( ! ( role . getHoist ( ) ) ) ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangeHoistListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangeHoistListener ) ( listener ) ) . onRoleChangeHoist ( api , role , ( ! ( role . getHoist ( ) ) ) ) ; } } } } ) ; } synchronized ( Role . class ) { int position = roleJson . getInt ( "position" ) ; if ( ( role . getPosition ( ) ) != position ) { final int oldPosition = role . getPosition ( ) ; role . setPosition ( position ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangePositionListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangePositionListener ) ( listener ) ) . onRoleChangePosition ( api , role , oldPosition ) ; } } } } ) ; } } } }
public class SharedObjectFactory implements ISharedObjectFactory { private static Trace debug = Trace . create ( "containerfactory" ) ; private static Hashtable sharedobjectdescriptions = new Hashtable ( ) ; protected static ISharedObjectFactory instance = null ; protected SharedObjectFactory ( ) { } public static ISharedObjectFactory getDefault ( ) { } private static void trace ( String msg ) { } private static void dumpStack ( String msg , Throwable e ) { } public SharedObjectDescription addDescription ( SharedObjectDescription description ) { } public List getDescriptions ( ) { } protected List getDescriptions0 ( ) { } protected SharedObjectDescription addDescription0 ( SharedObjectDescription n ) { } public boolean containsDescription ( SharedObjectDescription scd ) { } protected boolean containsDescription0 ( SharedObjectDescription scd ) { } protected SharedObjectDescription getDescription0 ( SharedObjectDescription scd ) { } protected SharedObjectDescription getDescription0 ( String name ) { } public SharedObjectDescription getDescriptionByName ( String name ) throws SharedObjectInstantiationException { } public ISharedObject createSharedObject ( SharedObjectDescription desc , String [ ] argTypes , Object [ ] args ) throws SharedObjectInstantiationException { SharedObjectFactory . trace ( ( ( ( ( ( ( "createSharedObject(" + desc ) + "," ) + ( Trace . convertStringAToString ( argTypes ) ) ) + "," ) + ( Trace . convertObjectAToString ( args ) ) ) + ")" ) ) ; if ( desc == null ) throw new SharedObjectInstantiationException ( "SharedObjectDescription<seq2seq4repair_space>cannot<seq2seq4repair_space>be<seq2seq4repair_space>null" ) ; SharedObjectDescription cd = getDescription0 ( desc ) ; if ( cd == null ) throw new SharedObjectInstantiationException ( ( ( "SharedObjectDescription<seq2seq4repair_space>named<seq2seq4repair_space>'" + ( desc . getName ( ) ) ) + "'<seq2seq4repair_space>not<seq2seq4repair_space>found" ) ) ; Class [ ] clazzes = null ; ISharedObjectInstantiator instantiator = null ; try { instantiator = ( ( ISharedObjectInstantiator ) ( cd . getInstantiator ( ) ) ) ; <START_BUG> clazzes = AbstractFactory . getClassesForTypes ( argTypes , args , cd . getClassLoader ( ) ) ; <END_BUG> } catch ( Exception e ) { SharedObjectInstantiationException newexcept = new SharedObjectInstantiationException ( ( ( ( ( ( "createSharedObject<seq2seq4repair_space>exception<seq2seq4repair_space>with<seq2seq4repair_space>description:<seq2seq4repair_space>" + desc ) + ":<seq2seq4repair_space>" ) + ( e . getClass ( ) . getName ( ) ) ) + ":<seq2seq4repair_space>" ) + ( e . getMessage ( ) ) ) ) ; newexcept . setStackTrace ( e . getStackTrace ( ) ) ; SharedObjectFactory . dumpStack ( "Exception<seq2seq4repair_space>in<seq2seq4repair_space>createSharedObject" , newexcept ) ; throw newexcept ; } if ( instantiator == null ) throw new SharedObjectInstantiationException ( ( ( "Instantiator<seq2seq4repair_space>for<seq2seq4repair_space>SharedObjectDescription<seq2seq4repair_space>" + ( cd . getName ( ) ) ) + "<seq2seq4repair_space>is<seq2seq4repair_space>null" ) ) ; return ( ( ISharedObject ) ( instantiator . createInstance ( desc , clazzes , args ) ) ) ; } public ISharedObject createSharedObject ( String descriptionName ) throws SharedObjectInstantiationException { } public ISharedObject createSharedObject ( String descriptionName , Object [ ] args ) throws SharedObjectInstantiationException { } public ISharedObject createSharedObject ( String descriptionName , String [ ] argsTypes , Object [ ] args ) throws SharedObjectInstantiationException { } public SharedObjectDescription removeDescription ( SharedObjectDescription scd ) { } protected SharedObjectDescription removeDescription0 ( SharedObjectDescription n ) { } }
public class JMeterMenuBar extends JMenuBar implements LocaleChangeListener { private static final long serialVersionUID = 240L ; private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private JMenu fileMenu ; private JMenuItem file_save_as ; private JMenuItem file_selection_as ; private JMenuItem file_revert ; private JMenuItem file_load ; private List < JComponent > file_load_recent_files ; private JMenuItem file_merge ; private JMenuItem file_exit ; private JMenuItem file_close ; private JMenu editMenu ; private JMenu edit_add ; private JMenuItem edit_remove ; private JMenu runMenu ; private JMenuItem run_start ; private JMenu remote_start ; private JMenuItem remote_start_all ; private Collection < JMenuItem > remote_engine_start ; private JMenuItem run_stop ; private JMenuItem run_shut ; private JMenu remote_stop ; private JMenu remote_shut ; private JMenuItem remote_stop_all ; private JMenuItem remote_shut_all ; private Collection < JMenuItem > remote_engine_stop ; private Collection < JMenuItem > remote_engine_shut ; private JMenuItem run_clear ; private JMenuItem run_clearAll ; private JMenu optionsMenu ; private JMenu lafMenu ; private JMenuItem sslManager ; private JMenu helpMenu ; private JMenuItem help_about ; private String [ ] remoteHosts ; private JMenu remote_exit ; private JMenuItem remote_exit_all ; private Collection < JMenuItem > remote_engine_exit ; public JMeterMenuBar ( ) { } public void setFileSaveEnabled ( boolean enabled ) { } public void setFileLoadEnabled ( boolean enabled ) { } public void setFileRevertEnabled ( boolean enabled ) { } public void setProjectFileLoaded ( String file ) { } public void setEditEnabled ( boolean enabled ) { } public void setEditAddMenu ( JMenu menu ) { } public void setEditMenu ( JPopupMenu menu ) { } public void setEditAddEnabled ( boolean enabled ) { } public void setEditRemoveEnabled ( boolean enabled ) { } public void createMenuBar ( ) { } private void makeHelpMenu ( ) { } private void makeOptionsMenu ( ) { } private static class LangMenuHelper { final ActionRouter actionRouter = ActionRouter . getInstance ( ) ; final JMenu languageMenu ; LangMenuHelper ( JMenu _languageMenu ) { } void addLang ( String locale ) { } } public static String [ ] getLanguages ( ) { } static JMenu makeLanguageMenu ( ) { } private void makeRunMenu ( ) { } private void makeEditMenu ( ) { } private void makeFileMenu ( ) { } public void setRunning ( boolean running , String host ) { JMeterMenuBar . log . info ( ( ( ( ( "setRunning(" + running ) + "," ) + host ) + ")" ) ) ; Iterator < JMenuItem > iter = remote_engine_start . iterator ( ) ; Iterator < JMenuItem > iter2 = remote_engine_stop . iterator ( ) ; Iterator < JMenuItem > iter3 = remote_engine_exit . iterator ( ) ; Iterator < JMenuItem > iter4 = remote_engine_shut . iterator ( ) ; while ( ( ( ( iter . hasNext ( ) ) && ( iter2 . hasNext ( ) ) ) && ( iter3 . hasNext ( ) ) ) && ( iter4 . hasNext ( ) ) ) { JMenuItem start = iter . next ( ) ; JMenuItem stop = iter2 . next ( ) ; JMenuItem exit = iter3 . next ( ) ; JMenuItem shut = iter4 . next ( ) ; if ( start . getText ( ) . equals ( host ) ) { JMeterMenuBar . log . debug ( ( "Found<seq2seq4repair_space>start<seq2seq4repair_space>host:<seq2seq4repair_space>" + ( start . getText ( ) ) ) ) ; start . setEnabled ( ( ! running ) ) ; } if ( stop . getText ( ) . equals ( host ) ) { JMeterMenuBar . log . debug ( ( "Found<seq2seq4repair_space>stop<seq2seq4repair_space>host:<seq2seq4repair_space>" + ( stop . getText ( ) ) ) ) ; stop . setEnabled ( running ) ; } if ( exit . getText ( ) . equals ( host ) ) { JMeterMenuBar . log . debug ( ( "Found<seq2seq4repair_space>exit<seq2seq4repair_space>host:<seq2seq4repair_space>" + ( exit . getText ( ) ) ) ) ; exit . setEnabled ( true ) ; } if ( shut . getText ( ) . equals ( host ) ) { JMeterMenuBar . log . debug ( ( "Found<seq2seq4repair_space>exit<seq2seq4repair_space>host:<seq2seq4repair_space>" + ( exit . getText ( ) ) ) ) ; <START_BUG> exit . setEnabled ( true ) ; <END_BUG> } } } @ Override public void setEnabled ( boolean enable ) { } private void getRemoteItems ( ) { } public void localeChanged ( LocaleChangeEvent event ) { } private void updateMenuElement ( MenuElement menu ) { } private static boolean isResource ( String actionCommand ) { } private static JMenu makeMenuRes ( String resource ) { } private static JMenu makeMenuRes ( String resource , int mnemonic ) { } private static JMenuItem makeMenuItemNoRes ( String label , String actionCommand ) { } private static JMenuItem makeMenuItemRes ( String resource , String actionCommand ) { } private static JMenuItem makeMenuItemRes ( String resource , String actionCommand , KeyStroke keyStroke ) { } private static JMenuItem makeMenuItemRes ( String resource , int mnemonic , String actionCommand ) { } private static JMenuItem makeMenuItemRes ( String resource , int mnemonic , String actionCommand , KeyStroke keyStroke ) { } }
public class CodeFlow implements Opcodes { private final Stack < ArrayList < String > > compilationScopes ; public CodeFlow ( ) { } public void loadTarget ( MethodVisitor mv ) { } public void pushDescriptor ( String descriptor ) { <START_BUG> Assert . notNull ( descriptor ) ; <END_BUG> this . compilationScopes . peek ( ) . add ( descriptor ) ; } public void enterCompilationScope ( ) { } public void exitCompilationScope ( ) { } public String lastDescriptor ( ) { } public void unboxBooleanIfNecessary ( MethodVisitor mv ) { } public static void insertUnboxInsns ( MethodVisitor mv , char ch , boolean isObject ) { } public static String createSignatureDescriptor ( Method method ) { } public static String createSignatureDescriptor ( Constructor < ? > ctor ) { } public static String toJVMDescriptor ( Class < ? > clazz ) { } public static String toDescriptorFromObject ( Object value ) { } public static boolean isBooleanCompatible ( String descriptor ) { } public static boolean isPrimitive ( String descriptor ) { } public static boolean isPrimitiveArray ( String descriptor ) { } public static boolean areBoxingCompatible ( String desc1 , String desc2 ) { } public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean ( String descriptor ) { } public static boolean isPrimitiveOrUnboxableSupportedNumber ( String descriptor ) { } public static char toPrimitiveTargetDesc ( String descriptor ) { } public static void insertCheckCast ( MethodVisitor mv , String descriptor ) { } public static void insertBoxIfNecessary ( MethodVisitor mv , String descriptor ) { } public static void insertBoxIfNecessary ( MethodVisitor mv , char ch ) { } public static String toDescriptor ( Class < ? > type ) { } public static String [ ] toParamDescriptors ( Method method ) { } public static String [ ] toParamDescriptors ( Constructor < ? > ctor ) { } private static String [ ] toDescriptors ( Class < ? > [ ] types ) { } }
public class WeatherDetail extends Activity { private static final String TAG = WeatherDetail . class . getSimpleName ( ) ; private TextView cityName ; private TextView weatherDate ; private ProgressBar progressBar ; private ImageView weatherIcon ; private TextView noImage ; private TextView tempLabel ; private TextView tempEve ; private TextView tempMax ; private TextView tempMin ; private TextView des ; private int day ; private WeatherJSONEntity weatherResult ; private List weatherList ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } private void findViews ( ) { } private void extractFromBundle ( ) { } private void initViews ( ) { Calendar currentDate = Calendar . getInstance ( ) ; SimpleDateFormat myFmt = new SimpleDateFormat ( getString ( format_date ) , Locale . getDefault ( ) ) ; currentDate . add ( Calendar . DAY_OF_MONTH , ( ( day ) + 1 ) ) ; cityName . setText ( ( ( ( weatherResult . city . name ) + "<seq2seq4repair_space>" ) + ( getString ( weather ) ) ) ) ; weatherDate . setText ( ( ( day ) == 0 ? getString ( tmr ) : myFmt . format ( currentDate . getTime ( ) ) ) ) ; <START_BUG> tempEve . setText ( ( ( weatherList . temp . eve ) + ( getString ( tempsymbol ) ) ) ) ; <END_BUG> tempMax . setText ( ( ( ( ( getString ( max ) ) + "<seq2seq4repair_space>" ) + ( weatherList . temp . max ) ) + ( getString ( tempsymbol ) ) ) ) ; tempMin . setText ( ( ( ( ( getString ( min ) ) + "<seq2seq4repair_space>" ) + ( weatherList . temp . min ) ) + ( getString ( tempsymbol ) ) ) ) ; des . setText ( weatherList . weather . get ( 0 ) . description ) ; } private void showProgress ( final boolean show ) { } private void downloadIcon ( ) { } class DownloadIconTask extends AsyncTask < String , Integer , Bitmap > { Bitmap bm = null ; @ Override protected Bitmap doInBackground ( String ... params ) { } @ Override protected void onCancelled ( ) { } @ Override protected void onPostExecute ( Bitmap result ) { } @ Override protected void onPreExecute ( ) { } } }
public final class LegacyActionPersistence extends RegistryPersistence { private static final int INDEX_ACTION_SETS = 0 ; private static final int INDEX_EDITOR_CONTRIBUTIONS = 1 ; private static final int INDEX_OBJECT_CONTRIBUTIONS = 2 ; private static final int INDEX_VIEW_CONTRIBUTIONS = 3 ; private static final int INDEX_VIEWER_CONTRIBUTIONS = 4 ; private static final SLocation createLocation ( final String barType , final String path , final LegacyLocationInfo locationInfo , final char mnemonic , final String imageStyle ) { final LeafLocationElement leafElement = new SBar ( barType , path ) ; final LocationElement locationElement ; if ( locationInfo == null ) { locationElement = leafElement ; } else { locationElement = locationInfo . append ( leafElement ) ; } <START_BUG> return new SLocation ( mnemonic , imageStyle , null , locationElement ) ; <END_BUG> } private static final Expression readVisibility ( final IConfigurationElement parentElement , final String parentId , final List warningsToLog ) { } private final BindingManager bindingManager ; private final CommandImageManager commandImageManager ; private final CommandManager commandManager ; private final Collection menuContributions = new ArrayList ( ) ; private final IMenuService menuService ; public LegacyActionPersistence ( final CommandManager commandManager , final BindingManager bindingManager , final CommandImageManager commandImageManager , final IMenuService menuService ) { } private final void clearBindings ( ) { } private final void clearImages ( ) { } private final void clearMenus ( ) { } private final void convertActionToBinding ( final IConfigurationElement element , final ParameterizedCommand command ) { } private final ParameterizedCommand convertActionToCommand ( final IConfigurationElement element , final String primaryId , final String secondaryId , final List warningsToLog ) { } private final String convertActionToImages ( final IConfigurationElement element , final ParameterizedCommand command ) { } private final void convertActionToItem ( final IConfigurationElement element , final List warningsToLog , final ParameterizedCommand command , final String imageStyle , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression ) { } protected final boolean isChangeImportant ( final IRegistryChangeEvent event ) { } public final void dispose ( ) { } public final void read ( ) { } private final SReference [ ] readActions ( final String primaryId , final IConfigurationElement [ ] elements , final List warningsToLog , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression ) { } private final SReference [ ] readActionsAndMenus ( final IConfigurationElement element , final String id , final List warningsToLog , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression ) { } private final void readActionSets ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } private final void readEditorContributions ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } private final SReference [ ] readGroups ( final IConfigurationElement [ ] elements , final List warningsToLog , final String path , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression , final boolean separatorsVisible ) { } private final SReference [ ] readMenusAndGroups ( final IConfigurationElement [ ] menuElements , final String contributionId , final List warningsToLog , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression ) { } private final void readObjectContributions ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } private final void readViewContributions ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } private final void readViewerContributions ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } }
public class HelloHostApplication implements IDistributionConstants , IApplication { private static final String DEFAULT_CONTAINER_TYPE = "ecf.r_osgi.peer" ; public static final String DEFAULT_CONTAINER_ID = null ; private BundleContext bundleContext ; private ServiceTracker containerManagerServiceTracker ; private String containerType = HelloHostApplication . DEFAULT_CONTAINER_TYPE ; private String containerId = HelloHostApplication . DEFAULT_CONTAINER_ID ; private final Object appLock = new Object ( ) ; private boolean done = false ; private ServiceRegistration helloRegistration ; public Object start ( IApplicationContext appContext ) throws Exception { bundleContext = Activator . getContext ( ) ; processArgs ( appContext ) ; IContainerManager containerManager = getContainerManagerService ( ) ; if ( ( ( containerId ) == null ) || ( "" . equals ( containerId ) ) ) containerManager . getContainerFactory ( ) . createContainer ( containerType ) ; else containerManager . getContainerFactory ( ) . createContainer ( containerType , new Object [ ] { containerId } ) ; Properties props = new Properties ( ) ; <START_BUG> props . put ( REMOTE_INTERFACES , REMOTE_INTERFACES_WILDCARD ) ; <END_BUG> helloRegistration = bundleContext . registerService ( IHello . class . getName ( ) , new Hello ( ) , props ) ; System . out . println ( "Host:<seq2seq4repair_space>Hello<seq2seq4repair_space>Service<seq2seq4repair_space>Registered" ) ; waitForDone ( ) ; return IApplication . EXIT_OK ; } public void stop ( ) { } private IContainerManager getContainerManagerService ( ) { } private void processArgs ( IApplicationContext appContext ) { } private void waitForDone ( ) { } }
public class TestMultiTermConstantScore extends BaseTestRangeFilter { public static final float SCORE_COMP_THRESH = 1.0E-6F ; static Directory small ; static IndexReader reader ; public static void assertEquals ( String m , int e , int a ) { } @ BeforeClass public static void beforeClass ( ) throws Exception { String [ ] data = new String [ ] { "A<seq2seq4repair_space>1<seq2seq4repair_space>2<seq2seq4repair_space>3<seq2seq4repair_space>4<seq2seq4repair_space>5<seq2seq4repair_space>6" , "Z<seq2seq4repair_space>4<seq2seq4repair_space>5<seq2seq4repair_space>6" , null , "B<seq2seq4repair_space>2<seq2seq4repair_space>4<seq2seq4repair_space>5<seq2seq4repair_space>6" , "Y<seq2seq4repair_space>3<seq2seq4repair_space>5<seq2seq4repair_space>6" , null , "C<seq2seq4repair_space>3<seq2seq4repair_space>6" , "X<seq2seq4repair_space>4<seq2seq4repair_space>5<seq2seq4repair_space>6" } ; TestMultiTermConstantScore . small = newDirectory ( ) ; RandomIndexWriter writer = new RandomIndexWriter ( random ( ) , TestMultiTermConstantScore . small , newIndexWriterConfig ( TEST_VERSION_CURRENT , new org . apache . lucene . analysis . MockAnalyzer ( random ( ) , MockTokenizer . WHITESPACE , false ) ) . setMergePolicy ( newLogMergePolicy ( ) ) ) ; FieldType customType = new FieldType ( TextField . TYPE_STORED ) ; customType . setTokenized ( false ) ; for ( int i = 0 ; i < ( data . length ) ; i ++ ) { Document doc = new Document ( ) ; doc . add ( newField ( "id" , String . valueOf ( i ) , customType ) ) ; doc . add ( newField ( "all" , "all" , customType ) ) ; if ( null != ( data [ i ] ) ) { doc . add ( newTextField ( "data" , data [ i ] , YES ) ) ; } writer . addDocument ( doc ) ; } TestMultiTermConstantScore . reader = writer . getReader ( ) ; <START_BUG> writer . close ( ) ; <END_BUG> } @ AfterClass public static void afterClass ( ) throws Exception { } public static Query csrq ( String f , String l , String h , boolean il , boolean ih ) { } public static Query csrq ( String f , String l , String h , boolean il , boolean ih , MultiTermQuery . RewriteMethod method ) { } public static Query cspq ( Term prefix ) { } public static Query cswcq ( Term wild ) { } @ Test public void testBasics ( ) throws IOException { } @ Test public void testEqualScores ( ) throws IOException { } @ Test public void testEqualScoresWhenNoHits ( ) throws IOException { } @ Test public void testBoost ( ) throws IOException { } @ Test public void testBooleanOrderUnAffected ( ) throws IOException { } @ Test public void testRangeQueryId ( ) throws IOException { } @ Test public void testRangeQueryRand ( ) throws IOException { } }
public class HiddenQuickActionSetup extends HiddenViewSetup { private HiddenQuickActionSetup . UnpressableLinearLayout mLinearLayout ; private int mImageWidth = LayoutParams . WRAP_CONTENT ; private int mImageHeight = LayoutParams . WRAP_CONTENT ; private HiddenQuickActionSetup . OnQuickActionListener mQuickActionListener ; private OnTouchListener mTouchListener ; private PopupWindow mIndicatorPopup ; private int mIndicatorDelay = 300 ; private ImageView mIndicatorImage ; private TextView mIndicatorTitle ; private Handler mPopupDelayHandler = new Handler ( ) ; private Runnable mIndicatorStart ; private View mClickedActionView ; private Rect mIndicatorSpacing ; private boolean mCloseSwipeableOnQuickAction = true ; public static interface OnQuickActionListener { public void onQuickAction ( AdapterView < ? > parent , View view , int position , int quickActionId ) { } } public HiddenQuickActionSetup ( Context context ) { } public void setBackgroundDrawable ( Drawable d ) { } public void setBackgroundResource ( int resId ) { } public void setBackgroundColor ( int color ) { } public void setViewPadding ( int left , int top , int right , int bottom ) { } public void setImageSize ( int width , int height ) { } public void setCloseSwipableOnQuickActionClick ( boolean close ) { } public void setIndicatorDelay ( int delay ) { } public void setIndicatorLayout ( int resId ) { } public void setIndicatorLayout ( View content ) { } public void setIndicatorImageSize ( int width , int height ) { } public void setIndicatorSpacing ( int left , int top , int right , int bottom ) { } public boolean addAction ( int actionId , int actionDescriptionResId , int drawableResId ) { } public boolean addAction ( int actionId , int actionDescriptionResId , Drawable drawable ) { } public boolean addAction ( int actionId , String actionDescription , int drawableResId ) { } public boolean addAction ( int actionId , String actionDescription , Drawable drawable ) { } public boolean removeAction ( int actionId ) { } public void setOnQuickActionListener ( HiddenQuickActionSetup . OnQuickActionListener l ) { } @ Override public View getHiddenView ( ) { } private void setupDefaultIndicator ( ) { } private void setupQuickActionTouchListener ( ) { mTouchListener = new OnTouchListener ( ) { @ Override public boolean onTouch ( View v , MotionEvent event ) { int a = event . getAction ( ) ; if ( a == ( MotionEvent . ACTION_DOWN ) ) { <START_BUG> if ( ! ( isHiddenViewInteractionPossible ( ) ) ) { <END_BUG> return false ; } Drawable drawable = ( ( ImageView ) ( ( ( android . view . ViewGroup ) ( v ) ) . getChildAt ( 0 ) ) ) . getDrawable ( ) ; if ( drawable instanceof StateListDrawable ) { drawable = ( ( StateListDrawable ) ( drawable ) ) . getCurrent ( ) ; } mIndicatorImage . setImageDrawable ( drawable ) ; mClickedActionView = v ; if ( ( mIndicatorDelay ) == 0 ) { mIndicatorStart . run ( ) ; } else if ( ( mIndicatorDelay ) > 0 ) { mPopupDelayHandler . postDelayed ( mIndicatorStart , mIndicatorDelay ) ; } v . setPressed ( true ) ; v . invalidate ( ) ; } else if ( ( a == ( MotionEvent . ACTION_UP ) ) || ( a == ( MotionEvent . ACTION_CANCEL ) ) ) { if ( ( a == ( MotionEvent . ACTION_UP ) ) && ( ( mQuickActionListener ) != null ) ) { if ( mCloseSwipeableOnQuickAction ) { closeHiddenView ( ) ; } mQuickActionListener . onQuickAction ( getCurrentListView ( ) , getCurrentSwipeableHiddenView ( ) , getCurrentPosition ( ) , ( ( HiddenQuickActionSetup . ActionInfo ) ( v . getTag ( ) ) ) . id ) ; } mPopupDelayHandler . removeCallbacks ( mIndicatorStart ) ; mIndicatorPopup . dismiss ( ) ; v . setPressed ( false ) ; v . invalidate ( ) ; } return true ; } } ; } private void setupShowPopupStart ( ) { } private class UnpressableLinearLayout extends LinearLayout { public UnpressableLinearLayout ( Context context ) { } @ Override public void dispatchSetPressed ( boolean pressed ) { } } private class ActionInfo { int id ; String description ; } }
public class ClientUpdateComponent extends Component { public ClientUpdateComponent ( final DynmapCore plugin , ConfigurationNode configuration ) { } protected void buildClientUpdate ( ClientUpdateEvent e ) { DynmapWorld world = e . world ; JSONObject u = e . update ; long since = e . timestamp ; String worldName = world . getName ( ) ; int hideifshadow = configuration . getInteger ( "hideifshadow" , 15 ) ; int hideifunder = configuration . getInteger ( "hideifundercover" , 15 ) ; boolean hideifsneaking = configuration . getBoolean ( "hideifsneaking" , false ) ; JSONUtils . s ( u , "confighash" , core . getConfigHashcode ( ) ) ; JSONUtils . s ( u , "servertime" , ( ( world . getTime ( ) ) % 24000 ) ) ; JSONUtils . s ( u , "hasStorm" , world . hasStorm ( ) ) ; JSONUtils . s ( u , "isThundering" , world . isThundering ( ) ) ; JSONUtils . s ( u , "players" , new JSONArray ( ) ) ; List < DynmapPlayer > players = playerList . getVisiblePlayers ( ) ; for ( DynmapPlayer p : players ) { boolean hide = false ; DynmapLocation pl = p . getLocation ( ) ; DynmapWorld pw = core . getWorld ( pl . world ) ; <START_BUG> if ( pw != null ) <END_BUG> hide = true ; JSONObject jp = new JSONObject ( ) ; JSONUtils . s ( jp , "type" , "player" ) ; JSONUtils . s ( jp , "name" , Client . stripColor ( p . getDisplayName ( ) ) ) ; JSONUtils . s ( jp , "account" , p . getName ( ) ) ; if ( ( ! hide ) && ( hideifshadow < 15 ) ) { if ( ( pw . getLightLevel ( ( ( int ) ( pl . x ) ) , ( ( int ) ( pl . y ) ) , ( ( int ) ( pl . z ) ) ) ) <= hideifshadow ) hide = true ; } if ( ( ! hide ) && ( hideifunder < 15 ) ) { if ( pw . canGetSkyLightLevel ( ) ) { if ( ( pw . getSkyLightLevel ( ( ( int ) ( pl . x ) ) , ( ( int ) ( pl . y ) ) , ( ( int ) ( pl . z ) ) ) ) <= hideifunder ) hide = true ; } else { if ( ( pw . getHighestBlockYAt ( ( ( int ) ( pl . x ) ) , ( ( int ) ( pl . z ) ) ) ) > ( pl . y ) ) hide = true ; } } if ( ( ( ! hide ) && hideifsneaking ) && ( p . isSneaking ( ) ) ) hide = true ; DynmapWorld pworld = worldsLookup . get ( pl . world ) ; if ( ( ( ( ( configuration . getBoolean ( "sendposition" , true ) ) && ( configuration . getBoolean ( "sendpositon" , true ) ) ) && ( pworld != null ) ) && ( pworld . sendposition ) ) && ( ! hide ) ) { JSONUtils . s ( jp , "world" , pl . world ) ; JSONUtils . s ( jp , "x" , pl . x ) ; JSONUtils . s ( jp , "y" , pl . y ) ; JSONUtils . s ( jp , "z" , pl . z ) ; } else { JSONUtils . s ( jp , "world" , "-some-other-bogus-world-" ) ; JSONUtils . s ( jp , "x" , 0.0 ) ; JSONUtils . s ( jp , "y" , 64.0 ) ; JSONUtils . s ( jp , "z" , 0.0 ) ; } if ( ( ( ( configuration . getBoolean ( "sendhealth" , false ) ) && ( pworld != null ) ) && ( pworld . sendhealth ) ) && ( ! hide ) ) { JSONUtils . s ( jp , "health" , p . getHealth ( ) ) ; JSONUtils . s ( jp , "armor" , p . getArmorPoints ( ) ) ; } else { JSONUtils . s ( jp , "health" , 0 ) ; JSONUtils . s ( jp , "armor" , 0 ) ; } JSONUtils . a ( u , "players" , jp ) ; } if ( configuration . getBoolean ( "includehiddenplayers" , false ) ) { List < DynmapPlayer > hidden = playerList . getHiddenPlayers ( ) ; for ( DynmapPlayer p : hidden ) { JSONObject jp = new JSONObject ( ) ; JSONUtils . s ( jp , "type" , "player" ) ; JSONUtils . s ( jp , "name" , Client . stripColor ( p . getDisplayName ( ) ) ) ; JSONUtils . s ( jp , "account" , p . getName ( ) ) ; JSONUtils . s ( jp , "world" , "-hidden-player-" ) ; JSONUtils . s ( jp , "x" , 0.0 ) ; JSONUtils . s ( jp , "y" , 64.0 ) ; JSONUtils . s ( jp , "z" , 0.0 ) ; JSONUtils . s ( jp , "health" , 0 ) ; JSONUtils . s ( jp , "armor" , 0 ) ; JSONUtils . a ( u , "players" , jp ) ; } } JSONUtils . s ( u , "updates" , new JSONArray ( ) ) ; for ( Object update : mapManager . getWorldUpdates ( worldName , since ) ) { JSONUtils . a ( u , "updates" , ( ( Client . Update ) ( update ) ) ) ; } } }
public class ReturnStatement extends Statement { public Expression expression ; public TypeBinding expressionType ; public boolean isSynchronized ; public AstNode [ ] subroutines ; public LocalVariableBinding saveValueVariable ; public ReturnStatement ( Expression expr , int s , int e ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public void generateReturnBytecode ( BlockScope currentScope , CodeStream codeStream ) { } public void generateStoreSaveValueIfNecessary ( BlockScope currentScope , CodeStream codeStream ) { } public boolean needValue ( ) { } public void prepareSaveValueLocation ( TryStatement targetTryStatement ) { } public void resolve ( BlockScope scope ) { MethodScope methodScope = scope . methodScope ( ) ; MethodBinding methodBinding ; TypeBinding methodType = ( ( methodScope . referenceContext ) instanceof AbstractMethodDeclaration ) ? ( methodBinding = ( ( AbstractMethodDeclaration ) ( methodScope . referenceContext ) ) . binding ) == null ? null : methodBinding . returnType : VoidBinding ; if ( methodType == ( VoidBinding ) ) { if ( ( expression ) == null ) return ; if ( ( expressionType = expression . resolveType ( scope ) ) != null ) scope . problemReporter ( ) . attemptToReturnNonVoidExpression ( this , expressionType ) ; return ; } if ( ( expression ) == null ) { if ( methodType != null ) scope . problemReporter ( ) . shouldReturn ( methodType , this ) ; return ; } if ( ( expressionType = expression . resolveType ( scope ) ) == null ) return ; if ( ( methodType != null ) && ( expression . isConstantValueOfTypeAssignableToType ( expressionType , methodType ) ) ) { expression . implicitWidening ( methodType , expressionType ) ; return ; } if ( ( expressionType ) == ( VoidBinding ) ) { scope . problemReporter ( ) . attemptToReturnVoidValue ( this ) ; return ; } <START_BUG> if ( ( methodType != null ) && ( org . eclipse . jdt . internal . compiler . lookup . Scope . areTypesCompatible ( expressionType , methodType ) ) ) { <END_BUG> expression . implicitWidening ( methodType , expressionType ) ; return ; } if ( methodType != null ) { scope . problemReporter ( ) . typeMismatchErrorActualTypeExpectedType ( expression , expressionType , methodType ) ; } } public String toString ( int tab ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope scope ) { } }
public class PasswordCreatedialog { private static final String DUMMYTEXT = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" ; private Window mainwindow ; private Window thiswindow ; public PasswordCreatedialog ( ) { } public PasswordCreatedialog ( Window mainwindow ) { } public PasswordCreatedialog ( Object page ) { } public void main ( final SimpleCallback < char [ ] > sr ) { if ( ( mainwindow ) == null ) { JFrame jf = new JFrame ( ) ; jf . setTitle ( PasswordEncrypt_title . val ( ) ) ; jf . setResizable ( false ) ; jf . setIconImages ( icons ) ; jf . getContentPane ( ) . setLayout ( new BoxLayout ( jf . getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; jf . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; thiswindow = jf ; } else { JDialog jd = new JDialog ( mainwindow ) ; jd . setModal ( true ) ; jd . setTitle ( PasswordEncrypt_title . val ( ) ) ; jd . setResizable ( false ) ; jd . setIconImages ( icons ) ; jd . getContentPane ( ) . setLayout ( new BoxLayout ( jd . getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; jd . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; thiswindow = jd ; } JPanel line1 = new JPanel ( new FlowLayout ( FlowLayout . RIGHT ) ) ; JPanel line2 = new JPanel ( new FlowLayout ( FlowLayout . RIGHT ) ) ; JPanel lineok = new JPanel ( new GridBagLayout ( ) ) ; final JPasswordField tf = new JPasswordField ( ) ; tf . setPreferredSize ( new Dimension ( 200 , 25 ) ) ; final JPasswordField tf2 = new JPasswordField ( ) ; tf2 . setPreferredSize ( new Dimension ( 200 , 25 ) ) ; JButton b = new JButton ( "OK" ) ; ActionListener act = new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { char [ ] s1 = tf . getPassword ( ) ; char [ ] s2 = tf2 . getPassword ( ) ; if ( ( ( ( s1 == null ) || ( s2 == null ) ) || ( ( s1 . length ) == 0 ) ) || ( ( s2 . length ) == 0 ) ) return ; int minlen = CryptoCodes . STANDARD_PBKDF2_PWLEN ; tf . setText ( PasswordCreatedialog . DUMMYTEXT ) ; tf2 . setText ( PasswordCreatedialog . DUMMYTEXT ) ; tf . setText ( "" ) ; tf2 . setText ( "" ) ; if ( ( Arrays . equals ( s1 , s2 ) ) && ( ( s1 . length ) >= minlen ) ) { thiswindow . dispose ( ) ; CryptoUtils . kill ( s2 ) ; sr . callbackValue ( PasswordCreatedialog . this , s1 ) ; } else { CryptoUtils . kill ( s1 ) ; CryptoUtils . kill ( s2 ) ; tf . requestFocus ( ) ; if ( ( s1 . length ) < minlen ) JOptionPane . showMessageDialog ( thiswindow , PasswordEncrypt_len . msg ( minlen ) ) ; else JOptionPane . showMessageDialog ( thiswindow , PasswordEncrypt_nomatch ) ; } } } ; b . addActionListener ( act ) ; tf . addActionListener ( act ) ; tf2 . addActionListener ( act ) ; JLabel jl = new JLabel ( ( ( _T . PasswordEncrypt_label ) + ":<seq2seq4repair_space>" ) ) ; line1 . add ( jl ) ; line1 . add ( tf ) ; thiswindow . add ( line1 ) ; jl = new JLabel ( ( ( _T . PasswordEncrypt_retype ) + ":<seq2seq4repair_space>" ) ) ; line2 . add ( jl ) ; line2 . add ( tf2 ) ; thiswindow . add ( line2 ) ; b . setPreferredSize ( new Dimension ( 200 , 35 ) ) ; GridBagConstraints gbc = new GridBagConstraints ( ) ; gbc . insets = new Insets ( 5 , 5 , 5 , 5 ) ; gbc . fill = GridBagConstraints . BOTH ; gbc . weightx = gbc . weighty = 1.0 ; lineok . add ( b , gbc ) ; thiswindow . add ( lineok ) ; thiswindow . pack ( ) ; <START_BUG> thiswindow . setLocationRelativeTo ( null ) ; <END_BUG> thiswindow . setVisible ( true ) ; thiswindow . addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosed ( WindowEvent e ) { try { tf . setText ( PasswordCreatedialog . DUMMYTEXT ) ; tf2 . setText ( PasswordCreatedialog . DUMMYTEXT ) ; tf . setText ( "" ) ; tf2 . setText ( "" ) ; } catch ( Exception ex ) { } } } ) ; if ( Toolkit . getDefaultToolkit ( ) . getLockingKeyState ( KeyEvent . VK_CAPS_LOCK ) ) { JOptionPane . showMessageDialog ( thiswindow , Password_caps ) ; } } }
public class EJJasperReports { static final Logger LOGGER = LoggerFactory . getLogger ( EJJasperReports . class ) ; static Map < String , Object > toParameters ( EJJasperReportParameter ... parameters ) { } public static JasperPrint fillReport ( String reportFile , JRDataSource dataSource , EJJasperReportParameter ... parameters ) { } public static JasperPrint fillReport ( InputStream reportFile , JRDataSource dataSource , EJJasperReportParameter ... parameters ) { } public static JasperPrint fillReport ( JasperReport reportFile , JRDataSource dataSource , EJJasperReportParameter ... parameters ) { } public static JasperPrint fillReport ( String reportFile , Connection connection , EJJasperReportParameter ... parameters ) { } public static JasperPrint fillReport ( EJReportFrameworkManager manager , final EJReport report , EJJasperReportParameter ... parameters ) { try { EJReportJasperReportBuilder builder = new EJReportJasperReportBuilder ( ) ; builder . buildDesign ( report ) ; long start = System . currentTimeMillis ( ) ; EJJasperReports . LOGGER . info ( ( "START<seq2seq4repair_space>Genarate<seq2seq4repair_space>EjReport<seq2seq4repair_space>-><seq2seq4repair_space>Jasper<seq2seq4repair_space>Report<seq2seq4repair_space>:" + ( report . getName ( ) ) ) ) ; JasperReport jasperReport = builder . toReport ( ) ; List < EJJasperReportParameter > reportParameters = new ArrayList < EJJasperReportParameter > ( ) ; for ( EJApplicationLevelParameter parameter : manager . getApplicationLevelParameters ( ) ) { EJJasperReportParameter jasperReportParameter = new EJJasperReportParameter ( parameter . getName ( ) , parameter . getValue ( ) ) ; reportParameters . add ( jasperReportParameter ) ; } Collection < EJReportParameter > allParameters = report . getParameterList ( ) . getAllParameters ( ) ; for ( EJReportParameter parameter : allParameters ) { EJJasperReportParameter jasperReportParameter = new EJJasperReportParameter ( parameter . getName ( ) , parameter . getValue ( ) ) ; reportParameters . add ( jasperReportParameter ) ; } EJReportBlockContext blockContext = new EJReportBlockContext ( ) { @ Override public JasperReport getBlockReport ( String blockName ) { EJReportBlock block = report . getBlock ( blockName ) ; EJReportJasperReportBuilder sbBuilder = new EJReportJasperReportBuilder ( ) ; sbBuilder . buildDesign ( block ) ; return sbBuilder . toReport ( ) ; } @ Override public JasperReport getBlockReportFixed ( String blockName ) { EJReportBlock block = report . getBlock ( blockName ) ; EJReportJasperReportBuilder sbBuilder = new EJReportJasperReportBuilder ( ) ; <START_BUG> sbBuilder . buildDesign ( block ) ; <END_BUG> return sbBuilder . toReport ( ) ; } } ; EJJasperReportParameter subRPTParameter = new EJJasperReportParameter ( "EJRJ_BLOCK_RPT" , blockContext ) ; reportParameters . add ( subRPTParameter ) ; reportParameters . addAll ( Arrays . asList ( parameters ) ) ; EJJasperReports . LOGGER . info ( ( ( ( "END<seq2seq4repair_space>Genarate<seq2seq4repair_space>EjReport<seq2seq4repair_space>-><seq2seq4repair_space>Jasper<seq2seq4repair_space>Report<seq2seq4repair_space>:" + ( report . getName ( ) ) ) + "<seq2seq4repair_space>TIME(sec):" ) + ( ( ( System . currentTimeMillis ( ) ) - start ) / 1000 ) ) ) ; EJJasperReports . LOGGER . info ( ( "START<seq2seq4repair_space>Filling<seq2seq4repair_space>Report<seq2seq4repair_space>:" + ( report . getName ( ) ) ) ) ; start = System . currentTimeMillis ( ) ; JasperPrint print = EJJasperReports . fillReport ( jasperReport , new org . entirej . report . jasper . data . EJReportDataSource ( report ) , reportParameters . toArray ( parameters ) ) ; report . getActionController ( ) . afterReport ( report ) ; EJJasperReports . LOGGER . info ( ( ( ( "END<seq2seq4repair_space>Filling<seq2seq4repair_space>Report<seq2seq4repair_space>:" + ( report . getName ( ) ) ) + "<seq2seq4repair_space>TIME(sec):" ) + ( ( ( System . currentTimeMillis ( ) ) - start ) / 1000 ) ) ) ; return print ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new EJReportRuntimeException ( e ) ; } } public static JasperPrint fillReport ( InputStream reportFile , Connection connection , EJJasperReportParameter ... parameters ) { } public static JasperPrint fillReport ( JasperReport reportFile , Connection connection , EJJasperReportParameter ... parameters ) { } public static void exportReport ( String reportFile , String outputFile , EJReportExportType type , JRDataSource dataSource , EJJasperReportParameter ... parameters ) { } public static void exportReport ( EJReportFrameworkManager manager , EJReport report , String outputFile , EJJasperReportParameter ... parameters ) { } public static void exportReport ( EJReportFrameworkManager manager , EJReport report , String outputFile , EJReportExportType type , EJJasperReportParameter ... parameters ) { } public static void exportReport ( String reportFile , String outputFile , EJReportExportType type , Connection connection , EJJasperReportParameter ... parameters ) { } public static void exportReport ( InputStream reportFile , String outputFile , EJReportExportType type , JRDataSource dataSource , EJJasperReportParameter ... parameters ) { } public static void exportReport ( InputStream reportFile , String outputFile , EJReportExportType type , Connection connection , EJJasperReportParameter ... parameters ) { } public static void exportReport ( EJReportExportType type , JasperPrint print , String outputFile ) { } public static void tempRUN ( String reportFile , JRDataSource dataSource ) { } public static void tempEJReportRun ( EJReportFrameworkManager manager , EJReport report , EJJasperReportParameter ... parameters ) { } private static void removeBlankPage ( List < JRPrintPage > pages ) { } }
public class SignUpActivity extends Activity { protected EditText usernameEditText ; protected EditText passwordEditText ; protected EditText emailEditText ; protected Button signUpButton ; String username ; String password ; String email ; ParseFile file ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestWindowFeature ( FEATURE_INDETERMINATE_PROGRESS ) ; getActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; setContentView ( activity_sign_up ) ; usernameEditText = ( ( EditText ) ( findViewById ( usernameField ) ) ) ; passwordEditText = ( ( EditText ) ( findViewById ( passwordField ) ) ) ; emailEditText = ( ( EditText ) ( findViewById ( emailField ) ) ) ; signUpButton = ( ( Button ) ( findViewById ( signupButton ) ) ) ; signUpButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { username = usernameEditText . getText ( ) . toString ( ) ; password = passwordEditText . getText ( ) . toString ( ) ; email = emailEditText . getText ( ) . toString ( ) ; username = username . trim ( ) ; password = password . trim ( ) ; email = email . trim ( ) ; if ( ( ( username . isEmpty ( ) ) || ( password . isEmpty ( ) ) ) || ( email . isEmpty ( ) ) ) { AlertDialog . Builder builder = new AlertDialog . Builder ( SignUpActivity . this ) ; builder . setMessage ( signup_error_message ) . setTitle ( signup_error_title ) . setPositiveButton ( ok , null ) ; AlertDialog dialog = builder . create ( ) ; dialog . show ( ) ; } else { setProgressBarIndeterminateVisibility ( true ) ; ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; <START_BUG> Bitmap pictureBitMap = BitmapFactory . decodeResource ( getResources ( ) , default_avatar ) ; <END_BUG> pictureBitMap . compress ( JPEG , 75 , stream ) ; byte [ ] data = stream . toByteArray ( ) ; file = new ParseFile ( "default_picture.png" , data ) ; file . saveInBackground ( new SaveCallback ( ) { @ Override public void done ( ParseException e ) { ParseUser newUser = new ParseUser ( ) ; newUser . setUsername ( username ) ; newUser . setPassword ( password ) ; newUser . setEmail ( email ) ; newUser . put ( "Picture" , file ) ; newUser . put ( "Role" , "visitor" ) ; newUser . signUpInBackground ( new SignUpCallback ( ) { @ Override public void done ( ParseException e ) { setProgressBarIndeterminateVisibility ( false ) ; if ( e == null ) { Intent intent = new Intent ( SignUpActivity . this , MainActivity . class ) ; intent . addFlags ( FLAG_ACTIVITY_NEW_TASK ) ; intent . addFlags ( FLAG_ACTIVITY_CLEAR_TASK ) ; startActivity ( intent ) ; } else { AlertDialog . Builder builder = new AlertDialog . Builder ( SignUpActivity . this ) ; builder . setMessage ( e . getMessage ( ) ) . setTitle ( signup_error_title ) . setPositiveButton ( ok , null ) ; AlertDialog dialog = builder . create ( ) ; dialog . show ( ) ; } } } ) ; } } ) ; } } } ) ; } }
public class FieldReference extends Reference implements InvocationSite { public Expression receiver ; public char [ ] token ; public FieldBinding binding ; public FieldBinding codegenBinding ; public long nameSourcePosition ; MethodBinding syntheticReadAccessor ; MethodBinding syntheticWriteAccessor ; public TypeBinding receiverType ; public FieldReference ( char [ ] source , long pos ) { } public FlowInfo analyseAssignment ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , Assignment assignment , boolean isCompound ) { if ( isCompound ) { if ( ( ( ( binding . isBlankFinal ( ) ) && ( receiver . isThis ( ) ) ) && ( currentScope . allowBlankFinalFieldAssignment ( binding ) ) ) && ( ! ( flowInfo . isDefinitelyAssigned ( binding ) ) ) ) { currentScope . problemReporter ( ) . uninitializedBlankFinalField ( binding , this ) ; } manageSyntheticReadAccessIfNecessary ( currentScope , flowInfo ) ; } flowInfo = receiver . analyseCode ( currentScope , flowContext , flowInfo , ( ! ( binding . isStatic ( ) ) ) ) . unconditionalInits ( ) ; if ( ( assignment . expression ) != null ) { flowInfo = assignment . expression . analyseCode ( currentScope , flowContext , flowInfo ) . unconditionalInits ( ) ; } manageSyntheticWriteAccessIfNecessary ( currentScope , flowInfo ) ; if ( binding . isFinal ( ) ) { if ( ( ( ( ( ( binding . isBlankFinal ( ) ) && ( ! isCompound ) ) && ( receiver . isThis ( ) ) ) && ( ! ( ( receiver ) instanceof QualifiedThisReference ) ) ) && ( ( ( receiver . bits ) & ( ASTNode . ParenthesizedMASK ) ) == 0 ) ) && ( currentScope . allowBlankFinalFieldAssignment ( binding ) ) ) { if ( flowInfo . isPotentiallyAssigned ( binding ) ) { currentScope . problemReporter ( ) . duplicateInitializationOfBlankFinalField ( binding , this ) ; } else { <START_BUG> flowContext . recordSettingFinal ( binding , this ) ; <END_BUG> } flowInfo . markAsDefinitelyAssigned ( binding ) ; } else { currentScope . problemReporter ( ) . cannotAssignToFinalField ( binding , this ) ; } } return flowInfo ; } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , boolean valueRequired ) { } public FieldBinding fieldBinding ( ) { } public void generateAssignment ( BlockScope currentScope , CodeStream codeStream , Assignment assignment , boolean valueRequired ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public void generateCompoundAssignment ( BlockScope currentScope , CodeStream codeStream , Expression expression , int operator , int assignmentImplicitConversion , boolean valueRequired ) { } public void generatePostIncrement ( BlockScope currentScope , CodeStream codeStream , CompoundAssignment postIncrement , boolean valueRequired ) { } public static final Constant getConstantFor ( FieldBinding binding , Reference reference , boolean isImplicit , Scope referenceScope ) { } public boolean isSuperAccess ( ) { } public boolean isTypeAccess ( ) { } public void manageSyntheticReadAccessIfNecessary ( BlockScope currentScope , FlowInfo flowInfo ) { } public void manageSyntheticWriteAccessIfNecessary ( BlockScope currentScope , FlowInfo flowInfo ) { } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public TypeBinding resolveType ( BlockScope scope ) { } public void setActualReceiverType ( ReferenceBinding receiverType ) { } public void setDepth ( int depth ) { } public void setFieldIndex ( int index ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope scope ) { } }
public class CharEncoding { public static final String ISO_8859_1 = "ISO-8859-1" ; public static final String US_ASCII = "US-ASCII" ; public static final String UTF_16 = "UTF-16" ; public static final String UTF_16BE = "UTF-16BE" ; public static final String UTF_16LE = "UTF-16LE" ; public static final String UTF_8 = "UTF-8" ; <START_BUG> public static boolean isSupported ( String name ) { <END_BUG> if ( name == null ) { return false ; } try { return Charset . isSupported ( name ) ; } catch ( IllegalCharsetNameException ex ) { return false ; } } }
public class PossibleMatch implements ICompilationUnit { public static final String NO_SOURCE_FILE_NAME = "NO<seq2seq4repair_space>SOURCE<seq2seq4repair_space>FILE<seq2seq4repair_space>NAME" ; public IResource resource ; public Openable openable ; public MatchingNodeSet nodeSet ; public char [ ] [ ] compoundName ; CompilationUnitDeclaration parsedUnit ; public SearchDocument document ; private String sourceFileName ; private char [ ] source ; public PossibleMatch ( MatchLocator locator , IResource resource , Openable openable , SearchDocument document , boolean mustResolve ) { } public void cleanUp ( ) { } public boolean equals ( Object obj ) { } public char [ ] getContents ( ) { } public char [ ] getFileName ( ) { } public char [ ] getMainTypeName ( ) { } public char [ ] [ ] getPackageName ( ) { } private char [ ] getQualifiedName ( ) { if ( ( this . openable ) instanceof CompilationUnit ) { <START_BUG> String fileName = this . resource . getFullPath ( ) . lastSegment ( ) ; <END_BUG> char [ ] mainTypeName = Util . getNameWithoutJavaLikeExtension ( fileName ) . toCharArray ( ) ; CompilationUnit cu = ( ( CompilationUnit ) ( this . openable ) ) ; return cu . getType ( new String ( mainTypeName ) ) . getFullyQualifiedName ( ) . toCharArray ( ) ; } else if ( ( this . openable ) instanceof ClassFile ) { String fileName = getSourceFileName ( ) ; if ( fileName == ( PossibleMatch . NO_SOURCE_FILE_NAME ) ) return ( ( ClassFile ) ( this . openable ) ) . getType ( ) . getFullyQualifiedName ( '.' ) . toCharArray ( ) ; int index = Util . indexOfJavaLikeExtension ( fileName ) ; String simpleName = ( index == ( - 1 ) ) ? fileName : fileName . substring ( 0 , index ) ; PackageFragment pkg = ( ( PackageFragment ) ( this . openable . getParent ( ) ) ) ; return Util . concatWith ( pkg . names , simpleName , '.' ) . toCharArray ( ) ; } return null ; } private String getSourceFileName ( ) { } public int hashCode ( ) { } public String toString ( ) { } }
public class DomainClientImpl implements DomainClient { private volatile DomainDeploymentManager deploymentManager ; private final ModelControllerClient delegate ; public DomainClientImpl ( InetAddress address , int port ) { } @ Override public OperationResult execute ( ModelNode operation , ResultHandler handler ) { } @ Override public ModelNode execute ( ModelNode operation ) throws IOException , CancellationException { } @ Override public OperationResult execute ( Operation operation , ResultHandler handler ) { } @ Override public ModelNode execute ( Operation operation ) throws IOException , CancellationException { } @ Override public byte [ ] addDeploymentContent ( InputStream stream ) { } @ Override public DomainDeploymentManager getDeploymentManager ( ) { } @ Override public List < String > getHostControllerNames ( ) { } @ Override public Map < ServerIdentity , ServerStatus > getServerStatuses ( ) { } private Set < String > getServerNames ( String host ) { ModelNode op = new ModelNode ( ) ; op . get ( "operation" ) . set ( "read-children-names" ) ; op . get ( "child-type" ) . set ( "server-config" ) ; <START_BUG> op . get ( "address" ) . set ( "host" , host ) ; <END_BUG> ModelNode result = executeForResult ( Factory . create ( op ) . build ( ) ) ; Set < String > servers = new HashSet < String > ( ) ; for ( ModelNode server : result . asList ( ) ) { servers . add ( server . asString ( ) ) ; } return servers ; } private ModelNode readAttribute ( String name , ModelNode address ) { } @ Override public ServerStatus startServer ( String hostControllerName , String serverName ) { } @ Override public ServerStatus stopServer ( String hostControllerName , String serverName , long gracefulShutdownTimeout , TimeUnit timeUnit ) { } @ Override public ServerStatus restartServer ( String hostControllerName , String serverName , long gracefulShutdownTimeout , TimeUnit timeUnit ) { } boolean isDeploymentNameUnique ( final String deploymentName ) { } @ Override public void close ( ) throws IOException { } ModelNode executeForResult ( Operation op ) { } }
public class RarConfigProcessor implements DeploymentUnitProcessor { private static ModuleIdentifier JAVAX_ID = ModuleIdentifier . create ( "javax.resource.api" ) ; private static ModuleIdentifier LOGGING_ID = ModuleIdentifier . create ( "org.jboss.logging" ) ; private static ModuleIdentifier IRON_JACAMAR_ID = ModuleIdentifier . create ( "org.jboss.ironjacamar.api" ) ; private static ModuleIdentifier IRON_JACAMAR_IMPL_ID = ModuleIdentifier . create ( "org.jboss.ironjacamar.impl" ) ; private static ModuleIdentifier NAMING_ID = ModuleIdentifier . create ( "org.jboss.as.naming" ) ; private static ModuleIdentifier VALIDATION_ID = ModuleIdentifier . create ( "javax.validation.api" ) ; private static ModuleIdentifier HIBERNATE_VALIDATOR_ID = ModuleIdentifier . create ( "org.hibernate.validator" ) ; private static ModuleIdentifier COMMON_CORE_ID = ModuleIdentifier . create ( "org.jboss.common-core" ) ; private static ModuleIdentifier SYSTEM_ID = ModuleIdentifier . create ( "javax.api" ) ; public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { if ( ( phaseContext . getDeploymentUnit ( ) . getAttachment ( ATTACHMENT_KEY ) ) == null ) { return ; } final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; <START_BUG> final ModuleLoader moduleLoader = Module . getSystemModuleLoader ( ) ; <END_BUG> final ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( MODULE_SPECIFICATION ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . JAVAX_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . LOGGING_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . IRON_JACAMAR_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . IRON_JACAMAR_IMPL_ID , false , true , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . SYSTEM_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . NAMING_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . VALIDATION_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . HIBERNATE_VALIDATOR_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . COMMON_CORE_ID , false , false , false ) ) ; } public void undeploy ( final DeploymentUnit context ) { } }
public class ComplexTest { private double inf = Double . POSITIVE_INFINITY ; private double neginf = Double . NEGATIVE_INFINITY ; private double nan = Double . NaN ; private double pi = FastMath . PI ; private Complex oneInf = new Complex ( 1 , inf ) ; private Complex oneNegInf = new Complex ( 1 , neginf ) ; private Complex infOne = new Complex ( inf , 1 ) ; private Complex infZero = new Complex ( inf , 0 ) ; private Complex infNaN = new Complex ( inf , nan ) ; private Complex infNegInf = new Complex ( inf , neginf ) ; private Complex infInf = new Complex ( inf , inf ) ; private Complex negInfInf = new Complex ( neginf , inf ) ; private Complex negInfZero = new Complex ( neginf , 0 ) ; private Complex negInfOne = new Complex ( neginf , 1 ) ; private Complex negInfNaN = new Complex ( neginf , nan ) ; private Complex negInfNegInf = new Complex ( neginf , neginf ) ; private Complex oneNaN = new Complex ( 1 , nan ) ; private Complex zeroInf = new Complex ( 0 , inf ) ; private Complex zeroNaN = new Complex ( 0 , nan ) ; private Complex nanInf = new Complex ( nan , inf ) ; private Complex nanNegInf = new Complex ( nan , neginf ) ; private Complex nanZero = new Complex ( nan , 0 ) ; @ Test public void testConstructor ( ) { } @ Test public void testConstructorNaN ( ) { } @ Test public void testAbs ( ) { } @ Test public void testAbsNaN ( ) { } @ Test public void testAbsInfinite ( ) { } @ Test public void testAdd ( ) { } @ Test public void testAddNaN ( ) { } @ Test public void testAddInf ( ) { } @ Test public void testScalarAdd ( ) { } @ Test public void testScalarAddNaN ( ) { } @ Test public void testScalarAddInf ( ) { } @ Test public void testConjugate ( ) { } @ Test public void testConjugateNaN ( ) { } @ Test public void testConjugateInfiinite ( ) { } @ Test public void testDivide ( ) { } @ Test public void testDivideReal ( ) { } @ Test public void testDivideImaginary ( ) { } @ Test public void testDivideInf ( ) { } @ Test public void testDivideZero ( ) { } @ Test public void testDivideZeroZero ( ) { } @ Test public void testDivideNaN ( ) { } @ Test public void testDivideNaNInf ( ) { } @ Test public void testScalarDivide ( ) { } @ Test public void testScalarDivideNaN ( ) { } @ Test public void testScalarDivideInf ( ) { } @ Test public void testScalarDivideZero ( ) { } @ Test public void testReciprocal ( ) { } @ Test public void testReciprocalReal ( ) { } @ Test public void testReciprocalImaginary ( ) { } @ Test public void testReciprocalInf ( ) { } @ Test public void testReciprocalZero ( ) { <START_BUG> Assert . assertEquals ( ZERO . reciprocal ( ) , NaN ) ; <END_BUG> } @ Test public void testReciprocalNaN ( ) { } @ Test public void testMultiply ( ) { } @ Test public void testMultiplyNaN ( ) { } @ Test public void testMultiplyInfInf ( ) { } @ Test public void testMultiplyNaNInf ( ) { } @ Test public void testScalarMultiply ( ) { } @ Test public void testScalarMultiplyNaN ( ) { } @ Test public void testScalarMultiplyInf ( ) { } @ Test public void testNegate ( ) { } @ Test public void testNegateNaN ( ) { } @ Test public void testSubtract ( ) { } @ Test public void testSubtractNaN ( ) { } @ Test public void testSubtractInf ( ) { } @ Test public void testScalarSubtract ( ) { } @ Test public void testScalarSubtractNaN ( ) { } @ Test public void testScalarSubtractInf ( ) { } @ Test public void testEqualsNull ( ) { } @ Test public void testEqualsClass ( ) { } @ Test public void testEqualsSame ( ) { } @ Test public void testEqualsTrue ( ) { } @ Test public void testEqualsRealDifference ( ) { } @ Test public void testEqualsImaginaryDifference ( ) { } @ Test public void testEqualsNaN ( ) { } @ Test public void testHashCode ( ) { } @ Test public void testAcos ( ) { } @ Test public void testAcosInf ( ) { } @ Test public void testAcosNaN ( ) { } @ Test public void testAsin ( ) { } @ Test public void testAsinNaN ( ) { } @ Test public void testAsinInf ( ) { } @ Test public void testAtan ( ) { } @ Test public void testAtanInf ( ) { } @ Test public void testAtanI ( ) { } @ Test public void testAtanNaN ( ) { } @ Test public void testCos ( ) { } @ Test public void testCosNaN ( ) { } @ Test public void testCosInf ( ) { } @ Test public void testCosh ( ) { } @ Test public void testCoshNaN ( ) { } @ Test public void testCoshInf ( ) { } @ Test public void testExp ( ) { } @ Test public void testExpNaN ( ) { } @ Test public void testExpInf ( ) { } @ Test public void testLog ( ) { } @ Test public void testLogNaN ( ) { } @ Test public void testLogInf ( ) { } @ Test public void testLogZero ( ) { } @ Test public void testPow ( ) { } @ Test public void testPowNaNBase ( ) { } @ Test public void testPowNaNExponent ( ) { }
public class TabIdentTest { private TabIdent t ; @ Before public void init ( ) { } @ Test public void searchIdentTest ( ) { t . addVariable ( "john" , ENTIER ) ; Ident i = t . searchIdent ( "john" ) ; assertEquals ( i . getType ( ) , ENTIER ) ; assertEquals ( errorLog , "" ) ; t . addVariable ( "fail" , FONCTION ) ; assertEquals ( t . searchIdent ( "fail" ) , null ) ; <START_BUG> assertNotEquals ( errorLog , "" ) ; <END_BUG> } @ Test public void searchFnTest ( ) { } }
public class SegmentTest { @ Test public void testDistance ( ) { Vector2D start = new Vector2D ( 2 , 2 ) ; Vector2D end = new Vector2D ( ( - 2 ) , ( - 2 ) ) ; <START_BUG> Segment segment = new Segment ( start , end , new Line ( start , end ) ) ; <END_BUG> Assert . assertEquals ( FastMath . sqrt ( 2 ) , segment . distance ( new Vector2D ( 1 , ( - 1 ) ) ) , 1.0E-10 ) ; Assert . assertEquals ( FastMath . sin ( ( ( Math . PI ) / 4.0 ) ) , segment . distance ( new Vector2D ( 0 , ( - 1 ) ) ) , 1.0E-10 ) ; Assert . assertEquals ( FastMath . sqrt ( 8 ) , segment . distance ( new Vector2D ( 0 , 4 ) ) , 1.0E-10 ) ; Assert . assertEquals ( FastMath . sqrt ( 8 ) , segment . distance ( new Vector2D ( 0 , ( - 4 ) ) ) , 1.0E-10 ) ; } }
public class CameraActivity extends Activity implements onBtnClickedListener , onSettingsInterface , Preference . OnPreferenceChangeListener , SurfaceHolder . Callback { private static final String TAG = "CameraActivity" ; private Camera mCamera ; private int mCameraId ; private Parameters mParams ; private SurfaceHolder mSurfaceHolder ; private CameraSettings mSettings ; private boolean mOpenCameraFail = false ; private boolean isPreviewing = false ; private ImageSaverThread mImageSaver ; private CameraFragment mCameraFragment ; private SettingFragment mSettingFragment ; private Preference mPictureSizePref ; private boolean isInitialedFlag = false ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } @ Override protected void onResume ( ) { } @ Override protected void onStart ( ) { } @ Override protected void onPause ( ) { } @ Override protected void onStop ( ) { } @ Override protected void onDestroy ( ) { } @ Override public void onSettingsBtnClicked ( ) { } @ Override public boolean onPreferenceChange ( Preference preference , Object newValue ) { } @ Override public void initialPref ( Preference pref ) { } @ Override public void surfaceCreated ( SurfaceHolder holder ) { } @ Override public void surfaceChanged ( SurfaceHolder holder , int format , int width , int height ) { } @ Override public void surfaceDestroyed ( SurfaceHolder holder ) { } public void openSettingsFlag ( ) { } public void doStartPreview ( SurfaceHolder holder ) { } public void doStopPreview ( ) { } Thread mCameraOpenThread = new Thread ( new Runnable ( ) { public void run ( ) { } } ) ; public void openCamera ( ) { } public void releaseCamera ( ) { } public void doTakePicture ( ) { } private Camera . ShutterCallback mShutterCallback = new CameraActivity . ShutterCallback ( ) ; private PictureCallback mRowPicture = new CameraActivity . RawPictureCallback ( ) ; private final class ShutterCallback implements Camera . ShutterCallback { public void onShutter ( ) { } } private final class RawPictureCallback implements Camera . PictureCallback { public void onPictureTaken ( byte [ ] rawData , Camera camera ) { } } private PictureCallback mPicture = new Camera . PictureCallback ( ) { @ Override public void onPictureTaken ( byte [ ] data , Camera camera ) { } } ; public void setFocusMode ( ) { } public void zoom ( int progress ) { } public void zoom ( boolean isUp ) { } public void changePicSize ( String size ) { } public void onBackPressed ( ) { } public boolean onKeyDown ( int keyCode , KeyEvent event ) { switch ( keyCode ) { case KeyEvent . KEYCODE_VOLUME_DOWN : zoom ( false ) ; return true ; case KeyEvent . KEYCODE_VOLUME_UP : zoom ( true ) ; return true ; } <START_BUG> return super . onKeyUp ( keyCode , event ) ; <END_BUG> } }
public class HeadToHeadActivity extends BaseToolbarListActivity { private static final String CNAME = "com.garpr.android.activities.HeadToHeadActivity" ; private static final String EXTRA_PLAYER = ( HeadToHeadActivity . CNAME ) + ".EXTRA_PLAYER" ; private static final String EXTRA_OPPONENT = ( HeadToHeadActivity . CNAME ) + ".EXTRA_OPPONENT" ; private static final String KEY_BUNDLE = "KEY_BUNDLE" ; private static final String KEY_SHOWING = "KEY_SHOWING" ; private static final String TAG = "HeadToHeadActivity" ; private ArrayList < HeadToHeadActivity . ListItem > mListItems ; private ArrayList < HeadToHeadActivity . ListItem > mListItemsShown ; private ArrayList < HeadToHeadActivity . ListItem > mLoseListItems ; private ArrayList < HeadToHeadActivity . ListItem > mWinListItems ; private boolean mSetMenuItemsVisible ; private HeadToHeadBundle mBundle ; private MenuItem mShow ; private MenuItem mShowAll ; private MenuItem mShowLoses ; private MenuItem mShowWins ; private Player mOpponent ; private Player mPlayer ; private Result mShowing ; public static void start ( final Activity activity , final Player player , final Player opponent ) { } private void createListItems ( ) { } private ArrayList < HeadToHeadActivity . ListItem > createSortedListItems ( final Result result ) { } private void fetchMatches ( ) { } @ Override protected String getActivityName ( ) { } @ Override protected String getErrorText ( ) { } @ Override protected int getOptionsMenu ( ) { } private boolean isMenuNull ( ) { } @ Override protected void onCreate ( final Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setTitle ( getString ( x_vs_y , mPlayer . getName ( ) , mOpponent . getName ( ) ) ) ; if ( ( savedInstanceState != null ) && ( ! ( savedInstanceState . isEmpty ( ) ) ) ) { mBundle = savedInstanceState . getParcelable ( HeadToHeadActivity . KEY_BUNDLE ) ; mShowing = savedInstanceState . getParcelable ( HeadToHeadActivity . KEY_SHOWING ) ; } if ( ( mBundle ) == null ) { fetchMatches ( ) ; } else { <START_BUG> createListItems ( ) ; <END_BUG> } } @ Override public boolean onOptionsItemSelected ( final MenuItem item ) { } @ Override public boolean onPrepareOptionsMenu ( final Menu menu ) { } @ Override public void onRefresh ( ) { } @ Override protected void onSaveInstanceState ( final Bundle outState ) { } private void prepareList ( ) { } @ Override protected void readIntentData ( final Intent intent ) { } @ Override protected void setAdapter ( final BaseListAdapter adapter ) { } @ Override protected boolean showDrawerIndicator ( ) { } private void show ( final Result result ) { } private void showMenuItems ( ) { } private static final class ListItem { private Match mMatch ; private String mDate ; private String mHeader ; private HeadToHeadActivity . ListItem . Type mType ; private static HeadToHeadActivity . ListItem createDate ( final String date ) { } private static HeadToHeadActivity . ListItem createHeader ( final String header ) { } private static HeadToHeadActivity . ListItem createTournament ( final Match match ) { } @ Override public boolean equals ( final Object o ) { } private boolean isDate ( ) { } private boolean isHeader ( ) { } private boolean isTournament ( ) { } @ Override public String toString ( ) { } private static enum Type { DATE , HEADER , TOURNAMENT ; @ Override public String toString ( ) { } } } private final class MatchesAdapter extends BaseListAdapter { private static final String TAG = "MatchesAdapter" ; private final int mColorLose ; private final int mColorWin ; private MatchesAdapter ( ) { } private void bindDateViewHolder ( final HeadToHeadActivity . DateViewHolder holder , final HeadToHeadActivity . ListItem listItem ) { } private void bindHeaderViewHolder ( final HeadToHeadActivity . HeaderViewHolder holder , final HeadToHeadActivity . ListItem listItem ) { } private void bindTournamentViewHolder ( final HeadToHeadActivity . TournamentViewHolder holder , final HeadToHeadActivity . ListItem listItem ) { } @ Override public String getAdapterName ( ) { } @ Override public int getItemCount ( ) { } @ Override public long getItemId ( final int position ) { } @ Override public int getItemViewType ( final int position ) { } @ Override public void onBindViewHolder ( final RecyclerView . ViewHolder holder , final int position ) { } @ Override public ViewHolder onCreateViewHolder ( final ViewGroup parent , final int viewType ) { } } private static final class DateViewHolder extends RecyclerView . ViewHolder { private final TextView mDate ; private DateViewHolder ( final View view ) { } } private static final class HeaderViewHolder extends RecyclerView . ViewHolder { private final TextView mHeader ; private HeaderViewHolder ( final View view ) { } } private static final class TournamentViewHolder extends RecyclerView . ViewHolder { private final TextView mDate ; private final TextView mName ; private TournamentViewHolder ( final View view ) { } } }
public class Wizard extends Panel implements IWizard , IWizardModelListener { public static final String BUTTONS_ID = "buttons" ; public static final String FEEDBACK_ID = "feedback" ; public static final String HEADER_ID = "header" ; public static final String OVERVIEW_ID = "overview" ; public static final String FORM_ID = "form" ; public static final String VIEW_ID = "view" ; private static final long serialVersionUID = 1L ; private IWizardStep activeStep ; private Form form ; private IWizardModel wizardModel ; public Wizard ( String id ) { } public Wizard ( String id , boolean addDefaultCssStyle ) { } public Wizard ( String id , IWizardModel wizardModel ) { } public Wizard ( String id , IWizardModel wizardModel , boolean addDefaultCssStyle ) { } public final void addDefaultCssStyle ( ) { } public final IWizardStep getActiveStep ( ) { } public Form getForm ( ) { } public final IWizardModel getWizardModel ( ) { } public boolean isVersioned ( ) { } public void onActiveStepChanged ( IWizardStep newStep ) { } public void onCancel ( ) { } public void onFinish ( ) { } protected void init ( IWizardModel wizardModel ) { } protected Component newButtonBar ( String id ) { } protected FeedbackPanel newFeedbackPanel ( String id ) { } protected Form newForm ( String id ) { } protected void onBeforeRender ( ) { super . onBeforeRender ( ) ; <START_BUG> Component buttonBar = get ( Wizard . BUTTONS_ID ) ; <END_BUG> if ( buttonBar instanceof IDefaultButtonProvider ) { IFormSubmittingComponent defaultButton = ( ( IDefaultButtonProvider ) ( buttonBar ) ) . getDefaultButton ( wizardModel ) ; form . setDefaultButton ( defaultButton ) ; } } protected Component newOverviewBar ( String id ) { } }
public class AjaxGetSprintBacklogDateInfoActionTest extends MockStrutsTestCase { private CreateProject mCP ; private CreateSprint mCS ; private Configuration mConfig ; private IProject mIProject ; private long mSprintId ; private IUserSession mUserSession ; private final String mActionPath = "/AjaxGetSprintBacklogDateInfo" ; public AjaxGetSprintBacklogDateInfoActionTest ( String testName ) { } protected void setUp ( ) throws Exception { } protected void tearDown ( ) throws Exception { } public void testGetSprintBacklogDateInfoAction ( ) { List < String > sprintIdList = mCS . getSprintIDList ( ) ; String projectName = mIProject . getName ( ) ; request . setHeader ( "Referer" , ( "?PID=" + projectName ) ) ; addRequestParameter ( "SprintID" , sprintIdList . get ( 0 ) ) ; request . getSession ( ) . setAttribute ( "UserSession" , mConfig . getUserSession ( ) ) ; actionPerform ( ) ; verifyNoActionErrors ( ) ; verifyNoActionMessages ( ) ; int availableDays = new ntut . csie . ezScrum . web . logic . SprintBacklogLogic ( mIProject , mUserSession , String . valueOf ( mSprintId ) ) . getSprintAvailableDays ( mSprintId ) ; <START_BUG> List < String > dateList = getWorkDate ( mCS . Today , availableDays ) ; <END_BUG> StringBuilder expectedResponseText = new StringBuilder ( ) ; expectedResponseText . append ( "{\"Dates\":[" ) ; for ( int i = 0 ; i < ( dateList . size ( ) ) ; i ++ ) { expectedResponseText . append ( "{\"Id\":\"Date_" ) . append ( ( i + 1 ) ) . append ( "\"," ) . append ( "\"Name\":\"" ) . append ( dateList . get ( i ) ) . append ( "\"}" ) ; if ( i != ( ( dateList . size ( ) ) - 1 ) ) { expectedResponseText . append ( "," ) ; } } expectedResponseText . append ( "]}" ) ; String actualResponseText = response . getWriterBuffer ( ) . toString ( ) ; assertEquals ( expectedResponseText . toString ( ) , actualResponseText ) ; } private List < String > getWorkDate ( Date startDate , int availableDays ) { } }
class SecurityBreachHandler { private final Logger logger = LogManager . getLogger ( this . getClass ( ) ) ; private final String toAddress ; private static boolean exists = false ; public static SecurityBreachHandler createBreachHandler ( String toAddress ) throws IllegalAccessException { } private SecurityBreachHandler ( String toAddress ) { } public void handleBreach ( Exception e , Class [ ] classesStack ) { } private void sendErrorReport ( String subject , Exception e , Class [ ] classesStack ) { } private String generateContent ( Exception excep , Class [ ] classesStack ) { String intro = "An<seq2seq4repair_space>attempted<seq2seq4repair_space>security<seq2seq4repair_space>breach<seq2seq4repair_space>was<seq2seq4repair_space>discovered<seq2seq4repair_space>in<seq2seq4repair_space>Izou:<seq2seq4repair_space>\n\n\n" ; String exception = "EXCEPTION:<seq2seq4repair_space>\n\n" ; <START_BUG> exception += excep . getMessage ( ) ; <END_BUG> StackTraceElement [ ] stackTraceElements = excep . getStackTrace ( ) ; for ( StackTraceElement element : stackTraceElements ) { exception += ( element . toString ( ) ) + "\n" ; } exception += "\n\n\n" ; String classesStackString = "" ; if ( classesStack != null ) { classesStackString = "CLASS<seq2seq4repair_space>STACK:\n\n" ; for ( int i = 0 ; i < ( classesStack . length ) ; i ++ ) { Class clazz = classesStack [ i ] ; classesStackString += ( "Class<seq2seq4repair_space>" + i ) + ":<seq2seq4repair_space>\n" ; classesStackString += ( clazz . toString ( ) ) + "\n" ; classesStackString += ( "Class<seq2seq4repair_space>Loader<seq2seq4repair_space>" + i ) + ":<seq2seq4repair_space>\n" ; ClassLoader classLoader = clazz . getClassLoader ( ) ; if ( classLoader == null ) { classesStackString += "null\n" ; } else { classesStackString += ( clazz . getClassLoader ( ) . toString ( ) ) + "\n" ; } } } return ( intro + exception ) + classesStackString ; } }
public class MatchAll extends Query { private static final Logger fileLog = LoggerFactory . getLogger ( "match_all" ) ; public MatchAll ( ) { } @ Override protected void execute ( Client esClient , String index , boolean verbose ) { <START_BUG> this . searchResponse = esClient . prepareSearch ( index ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . get ( ) ; <END_BUG> printResult ( ) ; } @ Override protected void printResult ( ) { } @ Override protected void printQueryStatistics ( ) { } }
public class BookDetailFragment extends Fragment implements LoaderManager . LoaderCallbacks < Cursor > { public static final String EAN_KEY = "EAN" ; private static final int LOADER_ID = 10 ; private View rootView ; private String ean ; private ShareActionProvider shareActionProvider ; public BookDetailFragment ( ) { } @ Override public void onCreate ( Bundle savedInstanceState ) { } @ Override public View onCreateView ( final LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { } @ Override public void onCreateOptionsMenu ( Menu menu , MenuInflater inflater ) { } @ Override public Loader < Cursor > onCreateLoader ( int id , Bundle args ) { } @ Override public void onLoadFinished ( Loader < Cursor > loader , Cursor data ) { } @ Override public void onLoaderReset ( Loader < Cursor > loader ) { } @ Override public void onPause ( ) { super . onDestroyView ( ) ; <START_BUG> if ( ( MainActivity . IS_TABLET ) && ( ( rootView . findViewById ( right_container ) ) == null ) ) { <END_BUG> getActivity ( ) . getSupportFragmentManager ( ) . popBackStack ( ) ; } } No newline ; at end ; of file ; }
public class Promise < A > extends SettableListenableFuture < A > implements MappableListenableFuture < A > , ListenableFutureCallback < A > { static class JoinedPromise < A , B > extends Promise < Tuple2 < A , B > > { final AtomicReference < A > a = new AtomicReference < > ( ) ; final AtomicReference < B > b = new AtomicReference < > ( ) ; CountDownLatch cdl = new CountDownLatch ( 2 ) ; < X > void addLatchedListener ( AtomicReference < X > ref , ListenableFuture < X > lfx ) { } public JoinedPromise ( ListenableFuture < A > lfa , ListenableFuture < B > lfb ) { } } public Promise ( ) { } public Promise ( ListenableFuture < A > other ) { } @ Override public < B > Promise < B > map ( Function < ? super A , B > f ) { } @ Override public < B > Promise < B > flatMap ( Function < ? super A , ListenableFuture < B > > f ) { } @ Override public < B > Promise < Tuple2 < A , B > > join ( ListenableFuture < B > bf ) { } @ Override public Promise < A > rescue ( Function < Throwable , A > f ) { final Promise < A > rescued = new Promise < > ( ) ; Promise . addCallback ( new ListenableFutureCallback < A > ( ) { @ Override public void onFailure ( Throwable throwable ) { rescued . set ( f . apply ( throwable ) ) ; } @ Override public void onSuccess ( A a ) { <START_BUG> set ( a ) ; <END_BUG> } } ) ; return rescued ; } @ Override public void onFailure ( Throwable throwable ) { } @ Override public void onSuccess ( A o ) { } }
public class MergeAction extends AbstractOpenAction implements PropertyChangeListener { private static final long serialVersionUID = 1L ; private static final Logger LOGGER = Logger . getLogger ( MergeAction . class . getName ( ) ) ; private static final String ERR_FILE = "You<seq2seq4repair_space>can't<seq2seq4repair_space>merge<seq2seq4repair_space>a<seq2seq4repair_space>plan<seq2seq4repair_space>into<seq2seq4repair_space>itself!" ; private static final String ERR_SITE = "The<seq2seq4repair_space>plan<seq2seq4repair_space>you<seq2seq4repair_space>selected<seq2seq4repair_space>is<seq2seq4repair_space>from<seq2seq4repair_space>the<seq2seq4repair_space>other<seq2seq4repair_space>site!" ; private static final String ERR_NIGHT = "The<seq2seq4repair_space>plan<seq2seq4repair_space>you<seq2seq4repair_space>selected<seq2seq4repair_space>seems<seq2seq4repair_space>to<seq2seq4repair_space>be<seq2seq4repair_space>from<seq2seq4repair_space>another<seq2seq4repair_space>night!" ; private static final String PROMPT = "This<seq2seq4repair_space>command<seq2seq4repair_space>opens<seq2seq4repair_space>another<seq2seq4repair_space>plan<seq2seq4repair_space>and<seq2seq4repair_space>adds<seq2seq4repair_space>its<seq2seq4repair_space>variants<seq2seq4repair_space>to<seq2seq4repair_space>the<seq2seq4repair_space>current<seq2seq4repair_space>plan.\n" + "Is<seq2seq4repair_space>this<seq2seq4repair_space>what<seq2seq4repair_space>you<seq2seq4repair_space>want<seq2seq4repair_space>to<seq2seq4repair_space>do?" ; public MergeAction ( IShell shell , KeyChain authClient ) { } @ Override protected void asyncActionPerformed ( ActionEvent e ) { IShell shell = getShell ( ) ; try { shell . getPeer ( ) . getGlassPane ( ) . setVisible ( true ) ; Schedule current = ( ( Schedule ) ( shell . getModel ( ) ) ) ; if ( current == null ) { MergeAction . LOGGER . warning ( "Model<seq2seq4repair_space>is<seq2seq4repair_space>null.<seq2seq4repair_space>Shouldn't<seq2seq4repair_space>be<seq2seq4repair_space>possible." ) ; return ; } int opt = JOptionPane . showConfirmDialog ( shell . getPeer ( ) , MergeAction . PROMPT , "Merge<seq2seq4repair_space>Plans" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( opt != ( JOptionPane . YES_OPTION ) ) return ; Schedule other = open ( ) ; if ( other != null ) { if ( other . getFile ( ) . equals ( current . getFile ( ) ) ) { JOptionPane . showMessageDialog ( shell . getPeer ( ) , MergeAction . ERR_FILE , "Cannot<seq2seq4repair_space>Merge" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( ( current . getSite ( ) ) != ( other . getSite ( ) ) ) { JOptionPane . showMessageDialog ( shell . getPeer ( ) , MergeAction . ERR_SITE , "Cannot<seq2seq4repair_space>Merge" , JOptionPane . ERROR_MESSAGE ) ; return ; } TwilightBoundedNight prevNight = new TwilightBoundedNight ( TwilightBoundType . NAUTICAL , current . getStart ( ) , current . getSite ( ) ) ; TwilightBoundedNight nextNight = new TwilightBoundedNight ( TwilightBoundType . NAUTICAL , other . getStart ( ) , other . getSite ( ) ) ; if ( ( prevNight . getStartTime ( ) ) != ( nextNight . getStartTime ( ) ) ) { JOptionPane . showMessageDialog ( shell . getPeer ( ) , MergeAction . ERR_NIGHT , "Cannot<seq2seq4repair_space>Merge" , JOptionPane . ERROR_MESSAGE ) ; return ; } for ( String semester : other . getExtraSemesters ( ) ) <START_BUG> current . addExtraSemseter ( semester ) ; <END_BUG> for ( Enum < ? > facility : other . getFacilities ( ) ) current . addFacility ( facility ) ; for ( Variant variant : other . getVariants ( ) ) current . duplicateVariant ( variant ) ; new RefreshAction ( shell , authClient ) . asyncActionPerformed ( e ) ; } } finally { shell . getPeer ( ) . getGlassPane ( ) . setVisible ( false ) ; } } public void propertyChange ( PropertyChangeEvent evt ) { } }
public class OSGiSubsystemSupport { private static final Logger log = Logger . getLogger ( OSGiSubsystemSupport . class ) ; public static final byte [ ] BLANK_SHA1 = new byte [ 20 ] ; private static final AtomicInteger archiveCount = new AtomicInteger ( ) ; private final ServiceContainer serviceContainer ; private OSGiSubsystemState subsystemState ; private DeploymentChain deploymentChain ; private Selector selector ; public OSGiSubsystemSupport ( ) throws Exception { } public OSGiSubsystemSupport ( final OSGiSubsystemState subsystemState ) throws Exception { } public ServiceContainer getServiceContainer ( ) { } public ModuleLoader getClassifyingModuleLoader ( ) { } public OSGiSubsystemSupport . TestModuleLoader getTestModuleLoader ( ) { } public DeploymentChain getDeploymentChain ( ) { } public String getUniqueName ( String prefix ) { } public void assertServiceUp ( ServiceName serviceName ) { } public void assertServiceDown ( ServiceName serviceName ) { } public void shutdown ( ) { } public void removeDeploymentChain ( ) { } public void setupServices ( final BatchBuilder batchBuilder ) throws Exception { } public void setupEnvironmentServices ( final BatchBuilder batchBuilder ) { } public void setupModuleLoaderServices ( final BatchBuilder batchBuilder ) { } public void setupDeploymentServices ( final BatchBuilder batchBuilder ) { } public void setupFrameworkServices ( final BatchBuilder batchBuilder ) { batchBuilder . addService ( SERVICE_NAME , new MBeanServerService ( ) ) ; OSGiSubsystemSupport . TestBundleManagerService . addService ( batchBuilder ) ; <START_BUG> FrameworkService . addService ( batchBuilder , IMMEDIATE ) ; <END_BUG> PackageAdminService . addService ( batchBuilder ) ; } private Selector getDeploymentChainSelector ( ) { } public BundleManager getBundleManager ( ) { } public BundleContext getSystemContext ( ) { } public Configuration getSubsystemConfig ( ) { } public void assertLoadClass ( ModuleIdentifier identifier , String className ) throws Exception { } public void assertLoadClass ( ModuleIdentifier identifier , String className , ModuleIdentifier exporterId ) throws Exception { } public void assertLoadClassFails ( ModuleIdentifier identifier , String className ) throws Exception { } public Class < ? > loadClass ( ModuleIdentifier identifier , String className ) throws Exception { } public Module loadModule ( ModuleIdentifier identifier ) throws ModuleLoadException { } public Bundle executeDeploy ( final JavaArchive archive ) throws Exception { } public void executeUndeploy ( final JavaArchive archive ) throws Exception { } List < ServiceName > runWithLatchedBatch ( final OSGiSubsystemSupport . BatchedWork work ) throws Exception { } public interface BatchedWork { void execute ( final BatchBuilder batchBuilder ) throws Exception { } } private static class TestServiceListener extends AbstractServiceListener < Object > { final List < ServiceName > registeredServices = new ArrayList < ServiceName > ( ) ; final List < ServiceName > startedServices = new ArrayList < ServiceName > ( ) ; final List < ServiceName > failedServices = new ArrayList < ServiceName > ( ) ; final Map < Mode , List < ServiceName > > initialModes ; private final AtomicInteger count = new AtomicInteger ( 1 ) ; private final Runnable finishTask ; public TestServiceListener ( Runnable finishTask , Map < Mode , List < ServiceName > > initialModes ) { } public void listenerAdded ( final ServiceController < ? extends Object > controller ) { } public void serviceStarted ( final ServiceController < ? extends Object > controller ) { } public void serviceFailed ( ServiceController < ? extends Object > controller , StartException reason ) { } @ Override public void serviceRemoved ( ServiceController < ? extends Object > controller ) { } public void finishBatch ( ) { } private void batchComplete ( ) { } } public static class TestModuleLoader extends ModuleLoader implements Service < OSGiSubsystemSupport . TestModuleLoader > { public static final ServiceName SERVICE_NAME = JBOSS . append ( "module" , "loader" , "support" ) ; private String prefix ; private Map < ModuleIdentifier , ModuleSpec > modules = new HashMap < ModuleIdentifier , ModuleSpec > ( ) ; private Injector < ClassifyingModuleLoaderService > injector ; TestModuleLoader ( String prefix ) { } public void addModuleSpec ( ModuleSpec moduleSpec ) { } @ Override protected ModuleSpec findModule ( ModuleIdentifier identifier ) throws ModuleLoadException { } public static OSGiSubsystemSupport . TestModuleLoader getServiceValue ( ServiceContainer container ) { } public synchronized void start ( StartContext context ) throws StartException { } public synchronized void stop ( StopContext context ) { } public synchronized OSGiSubsystemSupport . TestModuleLoader getValue ( ) throws IllegalStateException { } @ Override public String toString ( ) { } } static class TestBundleManagerService implements Service < BundleManager > { public static final ServiceName SERVICE_NAME = BundleManagerService . SERVICE_NAME ; private static final Logger log = Logger . getLogger ( "org.jboss.as.osgi" ) ; private InjectedValue < Configuration > injectedConfig = new InjectedValue < Configuration > ( ) ; private InjectedValue < ClassifyingModuleLoaderService > injectedModuleLoader = new InjectedValue < ClassifyingModuleLoaderService > ( ) ; private Injector < ClassifyingModuleLoaderService > moduleLoaderInjector ; private BundleManager bundleManager ; public static void addService ( final BatchBuilder batchBuilder ) { } public static BundleManager getServiceValue ( ServiceContainer container ) { } public synchronized void start ( StartContext context ) throws StartException { } public synchronized void stop ( StopContext context ) { } @ Override public BundleManager getValue ( ) throws IllegalStateException { } } static class TestServerDeploymentRepository implements ServerDeploymentRepository , Service < ServerDeploymentRepository > { private Map < String , JavaArchive > repository = new HashMap < String , JavaArchive > ( ) ; public static OSGiSubsystemSupport . TestServerDeploymentRepository getServiceValue ( ServiceContainer container ) { } public void registerDeploymentArchive ( String name , JavaArchive archive ) { } @ Override public void start ( StartContext context ) throws StartException { } @ Override public void stop ( StopContext context ) { } @ Override public ServerDeploymentRepository getValue ( ) throws IllegalStateException { } @ Override public byte [ ] addDeploymentContent ( String name , String runtimeName , InputStream stream ) throws IOException { } @ Override public Closeable mountDeploymentContent ( String name , String runtimeName , byte [ ] deploymentHash , VirtualFile mountPoint ) throws IOException { } } }
public class NativeTest { private static int execIntIntInt ( int a0 , int a1 , byte [ ] code , int size ) { } private static float execFloatFloatFloat ( float a0 , float a1 , byte [ ] code , int size ) { } public static void main ( String [ ] args ) throws IOException , ClassNotFoundException , SecurityException { } private static void generateCode ( X86Assembler os , String className ) throws ClassNotFoundException , MalformedURLException { VmByteCode code = NativeTest . loadByteCode ( className ) ; X86CodeGenerator x86cg = null ; IRControlFlowGraph cfg = new IRControlFlowGraph ( code ) ; BytecodeViewer bv = new BytecodeViewer ( ) ; BytecodeParser . parse ( code , bv ) ; System . out . println ( cfg ) ; <START_BUG> IRGenerator irg = new IRGenerator ( cfg ) ; <END_BUG> BytecodeParser . parse ( code , irg ) ; } private static VmByteCode loadByteCode ( String className ) throws ClassNotFoundException , MalformedURLException { } public static void printQuadDetail ( Quad quad ) { } }
public class OracleDictionary extends DBDictionary { public static final String SELECT_HINT = "openjpa.hint.OracleSelectHint" ; public static final String VENDOR_ORACLE = "oracle" ; private static final int BEHAVE_OTHER = 0 ; private static final int BEHAVE_ORACLE = 1 ; private static final int BEHAVE_DATADIRECT31 = 2 ; private static Blob EMPTY_BLOB = null ; private static Clob EMPTY_CLOB = null ; private static final Localizer _loc = Localizer . forPackage ( OracleDictionary . class ) ; public boolean useTriggersForAutoAssign = false ; public String autoAssignSequenceName = null ; public boolean openjpa3GeneratedKeyNames = false ; public boolean useSetFormOfUseForUnicode = true ; private boolean _checkedUpdateBug = false ; private boolean _warnedCharColumn = false ; private boolean _warnedNcharColumn = false ; private int _driverBehavior = - 1 ; private Method _putBytes = null ; private Method _putString = null ; private Method _putChars = null ; private int defaultBatchLimit = 100 ; public OracleDictionary ( ) { } public void endConfiguration ( ) { } public void connectedConfiguration ( Connection conn ) throws SQLException { } private void cacheDriverBehavior ( String driverVendor ) { } public void ensureDriverVendor ( ) { } public boolean supportsLocking ( Select sel ) { } protected SQLBuffer getSelects ( Select sel , boolean distinctIdentifiers , boolean forUpdate ) { } public boolean canOuterJoin ( int syntax , ForeignKey fk ) { } public SQLBuffer toNativeJoin ( Join join ) { } protected SQLBuffer toSelect ( SQLBuffer select , JDBCFetchConfiguration fetch , SQLBuffer tables , SQLBuffer where , SQLBuffer group , SQLBuffer having , SQLBuffer order , boolean distinct , boolean forUpdate , long start , long end , boolean subselect , Select sel ) { } protected SQLBuffer toSelect ( SQLBuffer select , JDBCFetchConfiguration fetch , SQLBuffer tables , SQLBuffer where , SQLBuffer group , SQLBuffer having , SQLBuffer order , boolean distinct , boolean forUpdate , long start , long end , Select sel ) { } private boolean requiresSubselectForRange ( long start , long end , boolean distinct , SQLBuffer order ) { } public String getSelectOperation ( JDBCFetchConfiguration fetch ) { } public void setString ( PreparedStatement stmnt , int idx , String val , Column col ) throws SQLException { } public void setNull ( PreparedStatement stmnt , int idx , int colType , Column col ) throws SQLException { } public String getClobString ( ResultSet rs , int column ) throws SQLException { } public Timestamp getTimestamp ( ResultSet rs , int column , Calendar cal ) throws SQLException { } public Object getObject ( ResultSet rs , int column , Map map ) throws SQLException { } private static Object convertFromOracleType ( Object obj , String convertMethod ) throws SQLException { } public Column [ ] getColumns ( DatabaseMetaData meta , String catalog , String schemaName , String tableName , String columnName , Connection conn ) throws SQLException { } public PrimaryKey [ ] getPrimaryKeys ( DatabaseMetaData meta , String catalog , String schemaName , String tableName , Connection conn ) throws SQLException { } public Index [ ] getIndexInfo ( DatabaseMetaData meta , String catalog , String schemaName , String tableName , boolean unique , boolean approx , Connection conn ) throws SQLException { } public ForeignKey [ ] getImportedKeys ( DatabaseMetaData meta , String catalog , String schemaName , String tableName , Connection conn , boolean partialKeys ) throws SQLException { } public String [ ] getCreateTableSQL ( Table table ) { } public String [ ] getCreateSequenceSQL ( Sequence seq ) { } @ Override public int getJDBCType ( int metaTypeCode , boolean lob , int precis , int scale , boolean xml ) { <START_BUG> return getJDBCType ( metaTypeCode , ( lob && ( ! xml ) ) , precis , scale ) ; <END_BUG> } protected String getSequencesSQL ( String schemaName , String sequenceName ) { } public boolean isSystemSequence ( String name , String schema , boolean targetSchema ) { } public Object getGeneratedKey ( Column col , Connection conn ) throws SQLException { } protected String getGeneratedKeyTriggerName ( Column col ) { } protected String getOpenJPA3GeneratedKeySequenceName ( Column col ) { } protected String getOpenJPA3GeneratedKeyTriggerName ( Column col ) { } public void putBytes ( Blob blob , byte [ ] data ) throws SQLException { } public void putString ( Clob clob , String data ) throws SQLException { } public void putChars ( Clob clob , char [ ] data ) throws SQLException { } private static void invokePutLobMethod ( Method method , Object target , Object data ) throws SQLException { } private Clob getEmptyClob ( ) throws SQLException { } private Blob getEmptyBlob ( ) throws SQLException { } private static boolean isOraclePreparedStatement ( Statement stmnt ) { } public void appendXmlComparison ( SQLBuffer buf , String op , FilterValue lhs , FilterValue rhs , boolean lhsxml , boolean rhsxml ) { } private void appendXmlComparison1 ( SQLBuffer buf , String op , FilterValue lhs , FilterValue rhs ) { } private void appendXmlComparison2 ( SQLBuffer buf , String op , FilterValue lhs , FilterValue rhs ) { } private void appendXmlExtractValue ( SQLBuffer buf , FilterValue val ) { } public void insertClobForStreamingLoad ( Row row , Column col , Object ob ) throws SQLException { } public int getBatchUpdateCount ( PreparedStatement ps ) throws SQLException { } @ Override protected Boolean matchErrorState ( int subtype , Set < String > errorStates , SQLException ex ) { } @ Override public void insertBlobForStreamingLoad ( Row row , Column col , JDBCStore store , Object ob , Select sel ) throws SQLException { } }
public class ModClusterEnableContext implements OperationStepHandler , DescriptionProvider { static final ModClusterEnableContext INSTANCE = new ModClusterEnableContext ( ) ; @ Override public ModelNode getModelDescription ( Locale locale ) { } @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { <START_BUG> if ( context . getProcessType ( ) . isServer ( ) ) { <END_BUG> context . addStep ( new OperationStepHandler ( ) { @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { ServiceController < ? > controller = context . getServiceRegistry ( false ) . getService ( NAME ) ; ModCluster modcluster = ( ( ModCluster ) ( controller . getValue ( ) ) ) ; ModClusterLogger . ROOT_LOGGER . debugf ( "enable-context:<seq2seq4repair_space>%s" , operation ) ; ContextHost contexthost = new ContextHost ( operation ) ; modcluster . enableContext ( contexthost . webhost , contexthost . webcontext ) ; context . completeStep ( ) ; } } , RUNTIME ) ; } context . completeStep ( ) ; } }
public class Metadata extends Properties { private static final long serialVersionUID = - 582452926111226898L ; public static final String FILE = "application.properties" ; public static final String APPLICATION_VERSION = "app.version" ; public static final String APPLICATION_NAME = "app.name" ; public static final String APPLICATION_GRAILS_VERSION = "app.grails.version" ; public static final String SERVLET_VERSION = "app.servlet.version" ; public static final String WAR_DEPLOYED = "grails.war.deployed" ; public static final String DEFAULT_SERVLET_VERSION = "2.4" ; private static Reference < Metadata > metadata = new SoftReference < Metadata > ( new Metadata ( ) ) ; private boolean initialized ; private File metadataFile ; private Metadata ( ) { } private Metadata ( File f ) { } public File getMetadataFile ( ) { } public static void reset ( ) { } public static Metadata getCurrent ( ) { } public static Metadata getInstance ( InputStream inputStream ) { } public static Metadata getInstance ( File file ) { } public static Metadata reload ( ) { } public String getApplicationVersion ( ) { } public String getGrailsVersion ( ) { } public String getEnvironment ( ) { } public String getApplicationName ( ) { } public Map < String , String > getInstalledPlugins ( ) { } public String getServletVersion ( ) { } public void persist ( ) { } public boolean propertiesHaveNotChanged ( ) { <START_BUG> Metadata transientMetadata = Metadata . getCurrent ( ) ; <END_BUG> Metadata allStringValuesMetadata = new Metadata ( ) ; Map < Object , Object > transientMap = transientMetadata ; for ( Map . Entry < Object , Object > entry : transientMap . entrySet ( ) ) { if ( ( entry . getValue ( ) ) != null ) { allStringValuesMetadata . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) . toString ( ) ) ; } } Metadata persistedMetadata = Metadata . reload ( ) ; boolean result = allStringValuesMetadata . equals ( persistedMetadata ) ; Metadata . metadata = new SoftReference < Metadata > ( transientMetadata ) ; return result ; } @ Override @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public synchronized Enumeration keys ( ) { } public boolean isWarDeployed ( ) { } private static void closeQuietly ( Closeable c ) { } static class FinalReference < T > extends SoftReference < T > { private T ref ; public FinalReference ( T t ) { } @ Override public T get ( ) { } } }
public class TestBufferedIndexInput extends LuceneTestCase { private static void writeBytes ( File aFile , long size ) throws IOException { } private static final long TEST_FILE_LENGTH = 1024 * 1024 ; public void testReadByte ( ) throws Exception { } public void testReadBytes ( ) throws Exception { } private void runReadBytesAndClose ( IndexInput input , int bufferSize , Random r ) throws IOException { } private void runReadBytes ( IndexInput input , int bufferSize , Random r ) throws IOException { } private byte [ ] buffer = new byte [ 10 ] ; private void checkReadBytes ( IndexInput input , int size , int pos ) throws IOException { } public void testEOF ( ) throws Exception { } private static byte byten ( long n ) { } private static class MyBufferedIndexInput extends BufferedIndexInput { private long pos ; private long len ; public MyBufferedIndexInput ( long len ) { } public MyBufferedIndexInput ( ) { } protected void readInternal ( byte [ ] b , int offset , int length ) throws IOException { } protected void seekInternal ( long pos ) throws IOException { } public void close ( ) throws IOException { } public long length ( ) { } } public void testSetBufferSize ( ) throws IOException { File indexDir = new File ( System . getProperty ( "tempDir" ) , "testSetBufferSize" ) ; TestBufferedIndexInput . MockFSDirectory dir = new TestBufferedIndexInput . MockFSDirectory ( indexDir , newRandom ( ) ) ; try { IndexWriter writer = new IndexWriter ( dir , new WhitespaceAnalyzer ( ) , true , MaxFieldLength . LIMITED ) ; writer . setUseCompoundFile ( false ) ; for ( int i = 0 ; i < 37 ; i ++ ) { Document doc = new Document ( ) ; doc . add ( new org . apache . lucene . document . Field ( "content" , ( "aaa<seq2seq4repair_space>bbb<seq2seq4repair_space>ccc<seq2seq4repair_space>ddd" + i ) , Store . YES , Index . ANALYZED ) ) ; doc . add ( new org . apache . lucene . document . Field ( "id" , ( "" + i ) , Store . YES , Index . ANALYZED ) ) ; writer . addDocument ( doc ) ; } writer . close ( ) ; dir . allIndexInputs . clear ( ) ; <START_BUG> IndexReader reader = IndexReader . open ( dir ) ; <END_BUG> Term aaa = new Term ( "content" , "aaa" ) ; Term bbb = new Term ( "content" , "bbb" ) ; Term ccc = new Term ( "content" , "ccc" ) ; assertEquals ( 37 , reader . docFreq ( ccc ) ) ; reader . deleteDocument ( 0 ) ; assertEquals ( 37 , reader . docFreq ( aaa ) ) ; dir . tweakBufferSizes ( ) ; reader . deleteDocument ( 4 ) ; assertEquals ( reader . docFreq ( bbb ) , 37 ) ; dir . tweakBufferSizes ( ) ; IndexSearcher searcher = new IndexSearcher ( reader ) ; ScoreDoc [ ] hits = searcher . search ( new org . apache . lucene . search . TermQuery ( bbb ) , null , 1000 ) . scoreDocs ; dir . tweakBufferSizes ( ) ; assertEquals ( 35 , hits . length ) ; dir . tweakBufferSizes ( ) ; hits = searcher . search ( new org . apache . lucene . search . TermQuery ( new Term ( "id" , "33" ) ) , null , 1000 ) . scoreDocs ; dir . tweakBufferSizes ( ) ; assertEquals ( 1 , hits . length ) ; hits = searcher . search ( new org . apache . lucene . search . TermQuery ( aaa ) , null , 1000 ) . scoreDocs ; dir . tweakBufferSizes ( ) ; assertEquals ( 35 , hits . length ) ; searcher . close ( ) ; reader . close ( ) ; } finally { _TestUtil . rmDir ( indexDir ) ; } } private static class MockFSDirectory extends Directory { List allIndexInputs = new ArrayList ( ) ; Random rand ; private Directory dir ; public MockFSDirectory ( File path , Random rand ) throws IOException { } public IndexInput openInput ( String name ) throws IOException { } public void tweakBufferSizes ( ) { } public IndexInput openInput ( String name , int bufferSize ) throws IOException { } public IndexOutput createOutput ( String name ) throws IOException { } public void close ( ) throws IOException { } public void deleteFile ( String name ) throws IOException { } public void touchFile ( String name ) throws IOException { } public long fileModified ( String name ) throws IOException { } public boolean fileExists ( String name ) throws IOException { } public String [ ] list ( ) throws IOException { } public String [ ] listAll ( ) throws IOException { } public long fileLength ( String name ) throws IOException { } public void renameFile ( String from , String to ) throws IOException { } } }
public class EditorStatusController extends BasicController { private Boolean errorIsOpen = Boolean . TRUE ; private Boolean warningIsOpen = Boolean . FALSE ; private VelocityContainer main ; public EditorStatusController ( UserRequest ureq , WindowControl wControl ) { } @ Override protected void doDispose ( ) { } @ Override protected void event ( UserRequest ureq , Component source , Event event ) { } public void updateStatus ( CourseEditorTreeModel cetm , StatusDescription [ ] courseStatus ) { main . contextRemove ( "hasWarnings" ) ; main . contextRemove ( "warningIsForNode" ) ; main . contextRemove ( "warningMessage" ) ; main . contextRemove ( "warningHelpWizardLink" ) ; main . contextRemove ( "warningsCount" ) ; main . contextRemove ( "warningIsOpen" ) ; main . contextRemove ( "hasErrors" ) ; main . contextRemove ( "errorIsForNode" ) ; main . contextRemove ( "errorMessage" ) ; main . contextRemove ( "errorHelpWizardLink" ) ; main . contextRemove ( "errorsCount" ) ; main . contextRemove ( "errorIsOpen" ) ; long lpTimeStamp = cetm . getLatestPublishTimestamp ( ) ; if ( lpTimeStamp == ( - 1 ) ) { <START_BUG> main . contextPut ( "publishInfos" , "published.never.yet" ) ; <END_BUG> } else { Date d = new Date ( lpTimeStamp ) ; main . contextPut ( "publishInfos" , translate ( "published.latest" , Formatter . getInstance ( getLocale ( ) ) . formatDateAndTime ( d ) ) ) ; } if ( ( courseStatus == null ) || ( ( courseStatus . length ) == 0 ) ) { main . contextPut ( "hasCourseStatus" , Boolean . FALSE ) ; main . contextPut ( "errorIsOpen" , Boolean . FALSE ) ; } else { List < String > errorIsForNode = new ArrayList < String > ( ) ; List < String > errorMessage = new ArrayList < String > ( ) ; List < String > errorHelpWizardLink = new ArrayList < String > ( ) ; List < String > warningIsForNode = new ArrayList < String > ( ) ; List < String > warningMessage = new ArrayList < String > ( ) ; List < String > warningHelpWizardLink = new ArrayList < String > ( ) ; int errCnt = 0 ; int warCnt = 0 ; String helpWizardCmd ; for ( int i = 0 ; i < ( courseStatus . length ) ; i ++ ) { StatusDescription description = courseStatus [ i ] ; String nodeId = courseStatus [ i ] . getDescriptionForUnit ( ) ; String nodeName = cetm . getCourseNode ( nodeId ) . getShortName ( ) ; helpWizardCmd = courseStatus [ i ] . getActivateableViewIdentifier ( ) ; if ( helpWizardCmd != null ) { helpWizardCmd = ( ( "start.help.wizard" + ( courseStatus [ i ] . getDescriptionForUnit ( ) ) ) + "." ) + ( courseStatus [ i ] . getShortDescriptionKey ( ) ) ; } else { helpWizardCmd = "NONE" ; } if ( description . isError ( ) ) { errCnt ++ ; errorIsForNode . add ( nodeName ) ; errorMessage . add ( description . getShortDescription ( getLocale ( ) ) ) ; errorHelpWizardLink . add ( helpWizardCmd ) ; } else if ( description . isWarning ( ) ) { warCnt ++ ; warningIsForNode . add ( nodeName ) ; warningMessage . add ( description . getShortDescription ( getLocale ( ) ) ) ; warningHelpWizardLink . add ( helpWizardCmd ) ; } } if ( ( errCnt > 0 ) || ( warCnt > 0 ) ) { if ( warCnt > 0 ) { main . contextPut ( "hasWarnings" , Boolean . TRUE ) ; main . contextPut ( "warningIsForNode" , warningIsForNode ) ; main . contextPut ( "warningMessage" , warningMessage ) ; main . contextPut ( "warningHelpWizardLink" , warningHelpWizardLink ) ; main . contextPut ( "warningsCount" , new String [ ] { Integer . toString ( warCnt ) } ) ; main . contextPut ( "warningIsOpen" , warningIsOpen ) ; } if ( errCnt > 0 ) { main . contextPut ( "hasErrors" , Boolean . TRUE ) ; main . contextPut ( "errorIsForNode" , errorIsForNode ) ; main . contextPut ( "errorMessage" , errorMessage ) ; main . contextPut ( "errorHelpWizardLink" , errorHelpWizardLink ) ; main . contextPut ( "errorsCount" , new String [ ] { Integer . toString ( errCnt ) } ) ; main . contextPut ( "errorIsOpen" , errorIsOpen ) ; } } else { main . contextPut ( "hasWarnings" , Boolean . FALSE ) ; main . contextPut ( "hasErrors" , Boolean . FALSE ) ; } } } }
public class TestCustomSearcherSort extends LuceneTestCase implements Serializable { private Directory index = null ; private Query query = null ; private static final int INDEX_SIZE = 2000 ; public TestCustomSearcherSort ( String name ) { } public static void main ( String [ ] argv ) { } public static Test suite ( ) { } private Directory getIndex ( ) throws IOException { RAMDirectory indexStore = new RAMDirectory ( ) ; <START_BUG> IndexWriter writer = new IndexWriter ( indexStore , new org . apache . lucene . analysis . standard . StandardAnalyzer ( Version . LUCENE_CURRENT ) , true , MaxFieldLength . LIMITED ) ; <END_BUG> TestCustomSearcherSort . RandomGen random = new TestCustomSearcherSort . RandomGen ( newRandom ( ) ) ; for ( int i = 0 ; i < ( TestCustomSearcherSort . INDEX_SIZE ) ; ++ i ) { Document doc = new Document ( ) ; if ( ( i % 5 ) != 0 ) { doc . add ( new org . apache . lucene . document . Field ( "publicationDate_" , random . getLuceneDate ( ) , Store . YES , Index . NOT_ANALYZED ) ) ; } if ( ( i % 7 ) == 0 ) { doc . add ( new org . apache . lucene . document . Field ( "content" , "test" , Store . YES , Index . ANALYZED ) ) ; } doc . add ( new org . apache . lucene . document . Field ( "mandant" , Integer . toString ( ( i % 3 ) ) , Store . YES , Index . NOT_ANALYZED ) ) ; writer . addDocument ( doc ) ; } writer . optimize ( ) ; writer . close ( ) ; return indexStore ; } @ Override public void setUp ( ) throws Exception { } public void testFieldSortCustomSearcher ( ) throws Exception { } public void testFieldSortSingleSearcher ( ) throws Exception { } public void testFieldSortMultiCustomSearcher ( ) throws Exception { } private void matchHits ( Searcher searcher , Sort sort ) throws IOException { } private void checkHits ( ScoreDoc [ ] hits , String prefix ) { } private void log ( String message ) { } public class CustomSearcher extends IndexSearcher { private int switcher ; public CustomSearcher ( Directory directory , int switcher ) throws IOException { } public CustomSearcher ( IndexReader r , int switcher ) { } @ Override public TopFieldDocs search ( Query query , Filter filter , int nDocs , Sort sort ) throws IOException { } @ Override public TopDocs search ( Query query , Filter filter , int nDocs ) throws IOException { } } private class RandomGen { RandomGen ( Random random ) { } private Random random ; private Calendar base = new GregorianCalendar ( 1980 , 1 , 1 ) ; private String getLuceneDate ( ) { } } }
public class TaxiPolygonSearcher { private final TaxiPolygonList polygons ; private Optional < TaxiPolygon > lastPolygon = Optional . empty ( ) ; private Optional < TaxiPolygon > lastPolygon2 = Optional . empty ( ) ; public TaxiPolygonSearcher ( TaxiPolygonList polygons ) { } public synchronized Optional < TaxiPolygon > search ( float lat , float lon ) { } public Optional < TaxiPolygon > search ( Point p ) { if ( ( p == null ) || ( ( polygons ) == null ) ) { <START_BUG> return null ; <END_BUG> } return search ( ( ( float ) ( p . lat ) ) , ( ( float ) ( p . lon ) ) ) ; } }
public class move extends Configured implements Tool { static ZooKeeper zkInstance ; static ZooKeeperWatcher zkWatcher ; private static final Logger logger = Logger . getLogger ( move . class ) ; public static enum toFrom { LOCAL2REMOTE , REMOTE2LOCAL , LOCAL2LOCAL , REMOTE2REMOTE , ERROR ; } public static void main ( String [ ] args ) throws Exception { } public int run ( String [ ] args ) throws Exception { } private static boolean setup ( Hashtable < String , String > curConf , Configuration argConf ) { } private static String lock ( String lock ) { } private static boolean unlock ( String lock ) { <START_BUG> move . logger . debug ( ( "Releasing<seq2seq4repair_space>lock<seq2seq4repair_space>" + lock ) ) ; <END_BUG> try { move . zkInstance . delete ( lock , ( - 1 ) ) ; } catch ( Exception E ) { move . logger . debug ( ( "Error<seq2seq4repair_space>releasing<seq2seq4repair_space>lock:<seq2seq4repair_space>" + ( E . toString ( ) ) ) ) ; return true ; } return true ; } private static boolean checksumLocalTest ( Path localPath , String checksum ) { } private static boolean writeChecksum ( Path localPath , String checksum ) { } private static String getConfigString ( Configuration config ) { } private static move . toFrom checkArgs ( Hashtable config ) { } private static String getSuffix ( String base_file , String extended_file ) { } private static Vector < Path > getFile ( FileSystem fs , Hashtable < String , String > config , dbutil db_util ) throws Exception { } private static Long latestVersion ( Hashtable < String , String > config , dbutil db_util ) throws Exception { } private static boolean putFileEntry ( dbutil db_util , FileSystem fs , String db_name , String file_id , String file_path , String source ) throws Exception { } private static boolean hasFile ( dbutil db_util , FileSystem fs , String db_name , String file_id , String file_path ) throws Exception { } private static String getFullPath ( Hashtable < String , String > config ) { } private static String getFileNames ( dbutil db_util , String db_name , String file_id , String file_path ) throws Exception { } private static String getSource ( dbutil db_util , String db_name , String file_id ) throws Exception { } private static String isDatabase ( dbutil db_util , String db_name , String file_id ) throws Exception { } private static boolean putRunEntry ( dbutil db_util , String db_name , String run_id , String file_id , String type , String timestamp , String timestamp_stop , String path , String regex ) throws Exception { } private static String getFileName ( Hashtable < String , String > config ) { } private static void printUsage ( ) { } }
public class TestPlan extends AbstractTestElement implements Serializable , TestListener { private static final long serialVersionUID = 233L ; private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final String FUNCTIONAL_MODE = "TestPlan.functional_mode" ; private static final String USER_DEFINED_VARIABLES = "TestPlan.user_defined_variables" ; private static final String SERIALIZE_THREADGROUPS = "TestPlan.serialize_threadgroups" ; private static final String CLASSPATHS = "TestPlan.user_define_classpath" ; private static final String CLASSPATH_SEPARATOR = "," ; private static final String BASEDIR = "basedir" ; private transient List < ThreadGroup > threadGroups = new LinkedList < ThreadGroup > ( ) ; private static volatile boolean functionalMode = false ; public TestPlan ( ) { } public TestPlan ( String name ) { } private Object readResolve ( ) { } public void prepareForPreCompile ( ) { } public boolean isFunctionalMode ( ) { } public void setUserDefinedVariables ( Arguments vars ) { } public JMeterProperty getUserDefinedVariablesAsProperty ( ) { } public String getBasedir ( ) { } public void setBasedir ( String b ) { } public Arguments getArguments ( ) { } public Map < String , String > getUserDefinedVariables ( ) { } private Arguments getVariables ( ) { } public void setFunctionalMode ( boolean funcMode ) { } public static boolean getFunctionalMode ( ) { } public void setSerialized ( boolean serializeTGs ) { } public void setTestPlanClasspath ( String text ) { } public void setTestPlanClasspathArray ( String [ ] text ) { <START_BUG> StringBuffer cat = new StringBuffer ( ) ; <END_BUG> for ( int idx = 0 ; idx < ( text . length ) ; idx ++ ) { if ( idx > 0 ) { cat . append ( TestPlan . CLASSPATH_SEPARATOR ) ; } cat . append ( text [ idx ] ) ; } this . setTestPlanClasspath ( cat . toString ( ) ) ; } public String [ ] getTestPlanClasspathArray ( ) { } public String getTestPlanClasspath ( ) { } public boolean isSerialized ( ) { } public void addParameter ( String name , String value ) { } @ Override public void addTestElement ( TestElement tg ) { } public void addThreadGroup ( ThreadGroup group ) { } public void testEnded ( ) { } public void testEnded ( String host ) { } public void testIterationStart ( LoopIterationEvent event ) { } public void testStarted ( ) { } public void testStarted ( String host ) { } }
public class SQLExec extends Task { public static class DelimiterType extends EnumeratedAttribute { public static final String NORMAL = "normal" ; public static final String ROW = "row" ; public String [ ] getValues ( ) { } } private int goodSql = 0 ; private int totalSql = 0 ; private Path classpath ; private AntClassLoader loader ; private Vector filesets = new Vector ( ) ; private Connection conn = null ; private boolean autocommit = false ; private Statement statement = null ; private String driver = null ; private String url = null ; private String userId = null ; private String password = null ; private File srcFile = null ; private String sqlCommand = "" ; private Vector transactions = new Vector ( ) ; private String delimiter = ";" ; private String delimiterType = SQLExec . DelimiterType . NORMAL ; private boolean print = false ; private boolean showheaders = true ; private File output = null ; private String rdbms = null ; private String version = null ; private String onError = "abort" ; private String encoding = null ; public void setClasspath ( Path classpath ) { } public Path createClasspath ( ) { } public void setClasspathRef ( Reference r ) { } public void setSrc ( File srcFile ) { } public void addText ( String sql ) { } public void addFileset ( FileSet set ) { } public SQLExec . Transaction createTransaction ( ) { } public void setDriver ( String driver ) { } public void setUrl ( String url ) { } public void setUserid ( String userId ) { } public void setEncoding ( String encoding ) { } public void setPassword ( String password ) { } public void setAutocommit ( boolean autocommit ) { } public void setDelimiter ( String delimiter ) { } public void setDelimiterType ( SQLExec . DelimiterType delimiterType ) { } public void setPrint ( boolean print ) { } public void setShowheaders ( boolean showheaders ) { } public void setOutput ( File output ) { } public void setRdbms ( String vendor ) { } public void setVersion ( String version ) { } public void setOnerror ( SQLExec . OnError action ) { } public void execute ( ) throws BuildException { } protected void runStatements ( Reader reader , PrintStream out ) throws IOException , SQLException { String sql = "" ; String line = "" ; BufferedReader in = new BufferedReader ( reader ) ; try { while ( ( line = in . readLine ( ) ) != null ) { line = line . trim ( ) ; <START_BUG> line = ProjectHelper . replaceProperties ( project , line ) ; <END_BUG> if ( line . startsWith ( "//" ) ) continue ; if ( line . startsWith ( "--" ) ) continue ; StringTokenizer st = new StringTokenizer ( line ) ; if ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( "REM" . equalsIgnoreCase ( token ) ) { continue ; } } sql += "<seq2seq4repair_space>" + line ; sql = sql . trim ( ) ; if ( ( line . indexOf ( "--" ) ) >= 0 ) sql += "\n" ; if ( ( ( delimiterType . equals ( SQLExec . DelimiterType . NORMAL ) ) && ( sql . endsWith ( delimiter ) ) ) || ( ( delimiterType . equals ( SQLExec . DelimiterType . ROW ) ) && ( line . equals ( delimiter ) ) ) ) { log ( ( "SQL:<seq2seq4repair_space>" + sql ) , MSG_VERBOSE ) ; execSQL ( sql . substring ( 0 , ( ( sql . length ( ) ) - ( delimiter . length ( ) ) ) ) , out ) ; sql = "" ; } } if ( ! ( sql . equals ( "" ) ) ) { execSQL ( sql , out ) ; } } catch ( SQLException e ) { throw e ; } } protected boolean isValidRdbms ( Connection conn ) { } protected void execSQL ( String sql , PrintStream out ) throws SQLException { } protected void printResults ( PrintStream out ) throws SQLException { } public static class OnError extends EnumeratedAttribute { public String [ ] getValues ( ) { } } public class Transaction { private File tSrcFile = null ; private String tSqlCommand = "" ; public void setSrc ( File src ) { } public void addText ( String sql ) { } private void runTransaction ( PrintStream out ) throws IOException , SQLException { } } }
public class AboutFeaturesDialog extends ProductInfoDialog { private static final int TABLE_HEIGHT = 150 ; private static final int INFO_HEIGHT = 100 ; private static final int MORE_ID = ( IDialogConstants . CLIENT_ID ) + 1 ; private static final int PLUGINS_ID = ( IDialogConstants . CLIENT_ID ) + 2 ; private static final int COLUMNS_ID = ( IDialogConstants . CLIENT_ID ) + 3 ; private Table table ; private Label imageLabel ; private StyledText text ; private Composite infoArea ; private Map cachedImages = new HashMap ( ) ; private String [ ] columnTitles = new String [ ] { WorkbenchMessages . AboutFeaturesDialog_provider , WorkbenchMessages . AboutFeaturesDialog_featureName , WorkbenchMessages . AboutFeaturesDialog_version , WorkbenchMessages . AboutFeaturesDialog_featureId } ; private String productName ; private AboutBundleGroupData [ ] bundleGroupInfos ; private int lastColumnChosen = 0 ; private boolean reverseSort = false ; private AboutBundleGroupData lastSelection = null ; private Button moreButton ; private Button pluginsButton ; private static Map featuresMap ; public AboutFeaturesDialog ( Shell parentShell , String productName , AboutBundleGroupData [ ] bundleGroupInfos ) { } private void handleMoreInfoPressed ( ) { } private void handlePluginInfoPressed ( ) { } protected void buttonPressed ( int buttonId ) { } private void handleColumnsPressed ( ) { } protected void configureShell ( Shell newShell ) { } protected void createButtonsForButtonBar ( Composite parent ) { } protected Control createDialogArea ( Composite parent ) { } protected void createInfoArea ( Composite parent ) { Font font = parent . getFont ( ) ; infoArea = new Composite ( parent , SWT . NULL ) ; GridData data = new GridData ( GridData . FILL , GridData . FILL , true , true ) ; data . heightHint = convertVerticalDLUsToPixels ( AboutFeaturesDialog . INFO_HEIGHT ) ; infoArea . setLayoutData ( data ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 2 ; infoArea . setLayout ( layout ) ; imageLabel = new Label ( infoArea , SWT . NONE ) ; data = new GridData ( GridData . FILL , GridData . BEGINNING , false , false ) ; data . widthHint = 32 ; data . heightHint = 32 ; imageLabel . setLayoutData ( data ) ; imageLabel . setFont ( font ) ; <START_BUG> text = new StyledText ( infoArea , ( ( SWT . MULTI ) | ( SWT . READ_ONLY ) ) ) ; <END_BUG> text . setCaret ( null ) ; text . setFont ( parent . getFont ( ) ) ; data = new GridData ( GridData . FILL , GridData . FILL , true , true ) ; text . setLayoutData ( data ) ; text . setFont ( font ) ; text . setCursor ( null ) ; text . setBackground ( infoArea . getBackground ( ) ) ; addListeners ( text ) ; TableItem [ ] items = table . getSelection ( ) ; if ( ( items . length ) > 0 ) { updateInfoArea ( ( ( AboutBundleGroupData ) ( items [ 0 ] . getData ( ) ) ) ) ; } } protected void createTable ( Composite parent ) { } public boolean close ( ) { } private void updateButtons ( AboutBundleGroupData info ) { } private void updateInfoArea ( AboutBundleGroupData info ) { } public void setInitialSelection ( AboutBundleGroupData info ) { } private void sort ( int column ) { } private void refreshTable ( ) { } private static String [ ] createRow ( AboutBundleGroupData info ) { } }
public class LoginForm extends JFrame { private JPanel contentPane ; private JButton jButton1 ; private JLabel jLabel1 ; private JTextField jTextField1 ; public static void main ( String [ ] args ) { } public LoginForm ( ) { } private void initComponents ( ) { setTitle ( "Liquid" ) ; setSize ( 400 , 250 ) ; setResizable ( false ) ; setLocationRelativeTo ( null ) ; setDefaultCloseOperation ( WindowConstants . EXIT_ON_CLOSE ) ; contentPane = new JPanel ( ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( null ) ; jTextField1 = new JTextField ( ) ; jButton1 = new JButton ( ) ; jButton1 . setText ( "OK" ) ; try { jLabel1 = new JLabel ( new ImageIcon ( ImageIO . read ( this . getClass ( ) . getResource ( "/com/liquidbol/images/logo.jpg" ) ) ) ) ; } catch ( IOException ex ) { Logger . getLogger ( LoginForm . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } jLabel1 . setHorizontalAlignment ( SwingConstants . CENTER ) ; jTextField1 . setBounds ( 90 , 160 , 200 , 30 ) ; <START_BUG> jButton1 . setBounds ( 280 , 160 , ( - 1 ) , 30 ) ; <END_BUG> jLabel1 . setBounds ( 0 , 0 , 400 , 250 ) ; jLabel1 . setHorizontalAlignment ( SwingConstants . CENTER ) ; contentPane . add ( jTextField1 ) ; contentPane . add ( jButton1 ) ; contentPane . add ( jLabel1 ) ; } private void setStyle ( ) { } No newline ; at end ; of file ; }
public class ActivityPage extends Activity { @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; <START_BUG> setContentView ( main ) ; <END_BUG> } @ Override public void onResume ( ) { } }
public abstract class UploadForm extends Form { Bytes maxSize = Bytes . MAX ; public UploadForm ( String id ) { } public UploadForm ( final String id , IFeedback validationFeedback ) { } public UploadForm ( final String id , IModel model , IFeedback feedback ) { } public void process ( ) { final HttpServletRequest request = ( ( wicket . protocol . http . WebRequest ) ( getRequest ( ) ) ) . getHttpServletRequest ( ) ; try { final MultipartWebRequest multipartWebRequest = new MultipartWebRequest ( this , request ) ; getRequestCycle ( ) . setRequest ( multipartWebRequest ) ; <START_BUG> super . onFormSubmitted ( ) ; <END_BUG> } catch ( FileUploadException e ) { final HashMap model = new HashMap ( ) ; model . put ( "exception" , e ) ; model . put ( "maxSize" , maxSize ) ; if ( e instanceof SizeLimitExceededException ) { final String defaultValue = "Upload<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>less<seq2seq4repair_space>than<seq2seq4repair_space>" + ( maxSize ) ; error ( getString ( ( ( getId ( ) ) + ".uploadTooLarge" ) , Model . valueOf ( model ) , defaultValue ) ) ; } else { final String defaultValue = "Upload<seq2seq4repair_space>failed:<seq2seq4repair_space>" + ( e . getLocalizedMessage ( ) ) ; error ( getString ( ( ( getId ( ) ) + ".uploadFailed" ) , Model . valueOf ( model ) , defaultValue ) ) ; } } } public void setMaxSize ( final Bytes maxSize ) { } protected final void onComponentTag ( final ComponentTag tag ) { } protected abstract void onSubmit ( ) { } }
public class SSTableExport { private static int INPUT_FILE_BUFFER_SIZE = ( 8 * 1024 ) * 1024 ; private static final String KEY_OPTION = "k" ; private static final String EXCLUDEKEY_OPTION = "x" ; private static final String ENUMERATEKEYS_OPTION = "e" ; private static Options options ; private static CommandLine cmd ; private static String quote ( String val ) { } private static String asKey ( String val ) { } @ Deprecated private static String asStr ( byte [ ] val ) { } private static String serializeColumns ( Collection < IColumn > cols , AbstractType comp ) { } private static String serializeRow ( SSTableIdentityIterator row ) throws IOException { } public static void enumeratekeys ( String ssTableFile , PrintStream outs ) throws IOException { IPartitioner partitioner = StorageService . getPartitioner ( ) ; BufferedRandomAccessFile input = new BufferedRandomAccessFile ( SSTable . indexFilename ( ssTableFile ) , "r" ) ; while ( ! ( input . isEOF ( ) ) ) { <START_BUG> DecoratedKey decoratedKey = partitioner . convertFromDiskFormat ( input . readUTF ( ) ) ; <END_BUG> long dataPosition = input . readLong ( ) ; outs . println ( SSTableExport . asStr ( decoratedKey . key ) ) ; } outs . flush ( ) ; } public static void enumeratekeys ( String ssTableFile , String outFile ) throws IOException { } public static void export ( String ssTableFile , PrintStream outs , String [ ] keys , String [ ] excludes ) throws IOException { } public static void export ( String ssTableFile , String outFile , String [ ] keys , String [ ] excludes ) throws IOException { } static void export ( SSTableReader reader , PrintStream outs , String [ ] excludes ) throws IOException { } public static void export ( String ssTableFile , PrintStream outs , String [ ] excludes ) throws IOException { } public static void export ( String ssTableFile , String outFile , String [ ] excludes ) throws IOException { } public static void export ( String ssTableFile , String [ ] excludes ) throws IOException { } public static void main ( String [ ] args ) throws IOException { } }
public class DomainUtil { public static void writeResponse ( final HttpServerExchange exchange , final int status , ModelNode response , OperationParameter operationParameter ) { } private static int getResponseLength ( final ModelNode modelNode , final OperationParameter operationParameter ) throws IOException { } public static void writeCacheHeaders ( final HttpServerExchange exchange , final int status , final OperationParameter operationParameter ) { } public static String constructUrl ( final HttpServerExchange exchange , final String path ) { final HeaderMap headers = exchange . getRequestHeaders ( ) ; String host = headers . getFirst ( HOST ) ; <START_BUG> String protocol = ( ( exchange . getConnection ( ) . getSslSession ( ) ) != null ) ? "https" : "http" ; <END_BUG> return ( ( protocol + "://" ) + host ) + path ; } }
public abstract class MarkupContainer extends Component implements Iterable < Component > { private static final long serialVersionUID = 1L ; private static final Logger log = LoggerFactory . getLogger ( MarkupContainer . class ) ; private Object children ; private transient MarkupStream markupStream ; public MarkupContainer ( final String id ) { } public MarkupContainer ( final String id , IModel < ? > model ) { } public MarkupContainer add ( final Component ... childs ) { } public final MarkupContainer addOrReplace ( final Component ... childs ) { } public final boolean autoAdd ( final Component component , MarkupStream markupStream ) { } public final boolean contains ( final Component component , final boolean recurse ) { } @ Override public final Component get ( final String path ) { } public MarkupStream getAssociatedMarkupStream ( final boolean throwException ) { } public IMarkupFragment getAssociatedMarkup ( ) { } public final MarkupStream getMarkupStream ( ) { } public IMarkupFragment getMarkup ( final Component child ) { } public MarkupType getMarkupType ( ) { } public void internalAdd ( final Component child ) { } public Iterator < Component > iterator ( ) { } public final Iterator < Component > iterator ( Comparator < Component > comparator ) { } public void remove ( final Component component ) { } public final void remove ( final String id ) { } public final void removeAll ( ) { } public final void renderAssociatedMarkup ( final String openTagName , final String exceptionMessage ) { } public final MarkupContainer replace ( final Component child ) { checkHierarchyChange ( child ) ; if ( child == null ) { throw new IllegalArgumentException ( "argument<seq2seq4repair_space>child<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>not<seq2seq4repair_space>null" ) ; } if ( MarkupContainer . log . isDebugEnabled ( ) ) { MarkupContainer . log . debug ( ( ( ( "Replacing<seq2seq4repair_space>" + ( child . getId ( ) ) ) + "<seq2seq4repair_space>in<seq2seq4repair_space>" ) + ( this ) ) ) ; } if ( ( child . getParent ( ) ) != ( this ) ) { final Component replaced = put ( child ) ; if ( replaced == null ) { throw new WicketRuntimeException ( exceptionMessage ( ( ( ( "Cannot<seq2seq4repair_space>replace<seq2seq4repair_space>a<seq2seq4repair_space>component<seq2seq4repair_space>which<seq2seq4repair_space>has<seq2seq4repair_space>not<seq2seq4repair_space>been<seq2seq4repair_space>added:<seq2seq4repair_space>id='" + ( child . getId ( ) ) ) + "',<seq2seq4repair_space>component=" ) + child ) ) ) ; } removedComponent ( replaced ) ; addedComponent ( child ) ; <START_BUG> child . setMarkupIdImpl ( replaced . getMarkupIdImpl ( ) ) ; <END_BUG> } return this ; } @ Override public MarkupContainer setDefaultModel ( final IModel < ? > model ) { } public final int size ( ) { } @ Override public String toString ( ) { } @ Override public String toString ( final boolean detailed ) { } public final < S extends Component , R > R visitChildren ( final Class < ? > clazz , final IVisitor < S , R > visitor ) { } public final < R > R visitChildren ( final IVisitor < Component , R > visitor ) { } private final void addedComponent ( final Component child ) { } @ Override final void initialize ( ) { } private final void children_add ( final Component child ) { } public final Component get ( int index ) { } private final Component children_get ( int index ) { } private final Object postprocess ( Object object , boolean reconstruct , MarkupContainer parent , int index ) { } private final Object children_get ( int index , boolean reconstruct ) { } private final String getId ( Object object ) { } private final Component children_get ( final String id ) { } private final int children_indexOf ( Component child ) { } private final Component children_remove ( Component component ) { } private final Component children_remove ( int index ) { } private final Object children_set ( int index , Object child , boolean reconstruct ) { } private final Component children_set ( int index , Component child ) { } private final int children_size ( ) { } private final Component put ( final Component child ) { } private final void removedComponent ( final Component component ) { } protected final void renderNext ( final MarkupStream markupStream ) { } @ Override protected void onComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } @ Override protected void onRender ( ) { } private final void renderComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } protected final void renderAll ( final MarkupStream markupStream , final ComponentTag openTag ) { } @ Override protected final void setMarkupStream ( final MarkupStream markupStream ) { } private static class ComponentSourceEntry extends org . apache . wicket . ComponentSourceEntry { private ComponentSourceEntry ( MarkupContainer container , Component component , IComponentSource componentSource ) { } private static final long serialVersionUID = 1L ; @ Override protected void setChild ( MarkupContainer parent , int index , Component child ) { } } @ Override void removeChildren ( ) { } @ Override void detachChildren ( ) { } @ Override void internalMarkRendering ( boolean setRenderingFlag ) { } private Component [ ] copyChildren ( ) { } @ Override void onBeforeRenderChildren ( ) { } @ Override void onEnabledStateChanged ( ) { } @ Override void onVisibleStateChanged ( ) { } @ Override void onAfterRenderChildren ( ) { } public boolean hasAssociatedMarkup ( ) { } @ Override void setRenderAllowed ( ) { } private static class ChildList extends AbstractList < Object > implements IClusterable { private static final long serialVersionUID = - 7861580911447631127L ; private int size ; private Object [ ] childs ; public ChildList ( Object children ) { } @ Override public Object get ( int index ) { } @ Override public int size ( ) { } @ Override public boolean add ( Object o ) { } @ Override public void add ( int index , Object element ) { }
public class YVM { protected OutputStream f ; private ArrayDeque < TypeOperateur > operateurs = new ArrayDeque < TypeOperateur > ( ) ; private ArrayDeque < Ident > operandes = new ArrayDeque < Ident > ( ) ; private TabIdent tab ; private int compteur_iteration = 1 ; private int compteur_conditionnelle = 1 ; private ArrayDeque < Integer > pile_iteration = new ArrayDeque < Integer > ( ) ; private ArrayDeque < Integer > pile_conditionnelle = new ArrayDeque < Integer > ( ) ; private String currentFonction ; private IdFunction currentIdFunction ; public YVM ( String s , TabIdent tab ) { } public void addEntier ( int valeur ) { } public void addBooleen ( int valeur ) { } public void addSource ( String ident ) { } public void addIdent ( String ident ) { } public void addOperateur ( TypeOperateur op ) { } public void opRel ( ) { } public void opAdd ( ) { } public void opMul ( ) { } public void opNeg ( ) { } public void entete ( ) { } public void main ( ) { } public void iadd ( ) { } public void isub ( ) { } public void imul ( ) { } public void idiv ( ) { } public void inot ( ) { } public void ineg ( ) { } public void ior ( ) { } public void iand ( ) { } public void iinf ( ) { } public void isup ( ) { } public void iinfegal ( ) { } public void isupegal ( ) { } public void iegal ( ) { } public void idiff ( ) { } public void iload ( int offset ) { } public void istore ( int offset ) { } public void iconst ( int valeur ) { } public void ifeq ( String etiquette ) { } public void iffaux ( String etiquette ) { } public void igoto ( String etiquette ) { } public void queue ( ) { } public void ecrireExpression ( TypeVariable typeVariable ) { } public void printIstore ( ) { } public void aLaLigne ( ) { } public void ecrireEnt ( ) { } public void ecrireChaine ( String chaine ) { } public void ecrireBool ( ) { } public void lireEnt ( String ident ) { } public void lireEnt ( int offset ) { } public void printIfFaux ( ) { } public void iFaire ( ) { } public void iFait ( ) { } public void iAlors ( ) { } public void iSinon ( ) { } public void iFsi ( ) { } public void setCurrentFonction ( String fonctionName ) { } public void printOuvreBloc ( ) { } public void ouvreBloc ( int taille ) { } public void printFermeBloc ( ) { } public void fermeBloc ( int taille ) { } public void printIreturn ( ) { <START_BUG> ireturn ( ( ( tab . calculer_return_offset ( ) ) + 2 ) ) ; <END_BUG> } public void ireturn ( int offset ) { } public void reserveRetour ( ) { } public void printCall ( ) { } public void call ( String nom ) { } public void iEtiquette ( String etiquette ) { } }
class MethodVerifier15 extends MethodVerifier { MethodVerifier15 ( LookupEnvironment environment ) { } boolean areMethodsEqual ( MethodBinding one , MethodBinding substituteTwo ) { } boolean areParametersEqual ( MethodBinding one , MethodBinding two ) { } boolean areReturnTypesEqual ( MethodBinding one , MethodBinding substituteTwo ) { } boolean areTypesEqual ( TypeBinding one , TypeBinding two ) { } boolean canSkipInheritedMethods ( ) { } boolean canSkipInheritedMethods ( MethodBinding one , MethodBinding two ) { } void checkConcreteInheritedMethod ( MethodBinding concreteMethod , MethodBinding [ ] abstractMethods ) { } void checkForBridgeMethod ( MethodBinding currentMethod , MethodBinding inheritedMethod , MethodBinding [ ] otherInheritedMethods ) { } void checkForInheritedNameClash ( MethodBinding inheritedMethod , MethodBinding otherInheritedMethod ) { } void checkForNameClash ( MethodBinding currentMethod , MethodBinding inheritedMethod ) { } void checkInheritedMethods ( MethodBinding [ ] methods , int length ) { } void checkTypeVariableMethods ( ) { } MethodBinding computeSubstituteMethod ( MethodBinding inheritedMethod , MethodBinding currentMethod ) { } boolean detectInheritedMethodClash ( MethodBinding inherited , MethodBinding otherInherited ) { } boolean detectNameClash ( MethodBinding current , MethodBinding inherited ) { } public boolean doesMethodOverride ( MethodBinding one , MethodBinding two ) { } boolean doParametersClash ( MethodBinding one , MethodBinding substituteTwo ) { } public boolean doReturnTypesCollide ( MethodBinding method , MethodBinding inheritedMethod ) { } boolean doTypeVariablesClash ( MethodBinding one , MethodBinding substituteTwo ) { <START_BUG> return ( ( one . typeVariables . length ) > 0 ) && ( ! ( one . areTypeVariableErasuresEqual ( substituteTwo . original ( ) ) ) ) ; <END_BUG> } boolean isInterfaceMethodImplemented ( MethodBinding inheritedMethod , MethodBinding existingMethod , ReferenceBinding superType ) { } boolean mustImplementAbstractMethod ( ReferenceBinding declaringClass ) { } void verify ( SourceTypeBinding someType ) { } }
public class ManagementMain { private static int schedulerTCPPort ; private static int preparationCosts ; private static String schedulerHost ; @ SuppressWarnings ( "unused" ) public static void main ( String [ ] args ) { int noOfParams = 5 ; if ( ( args . length ) != noOfParams ) { System . out . println ( "Error:<seq2seq4repair_space>Too<seq2seq4repair_space>few<seq2seq4repair_space>arguments!" ) ; return ; } String bindingName = args [ 0 ] ; ManagementMain . schedulerHost = args [ 1 ] ; ManagementMain . schedulerTCPPort = Integer . parseInt ( args [ 2 ] ) ; ManagementMain . preparationCosts = Integer . parseInt ( args [ 3 ] ) ; File taskDir = new File ( args [ 4 ] ) ; try { RegistryReader registryLocation = new RegistryReader ( ) ; Registry registry = LocateRegistry . createRegistry ( registryLocation . getRegistryPort ( ) ) ; ILogin login = new LoginImpl ( ) ; UnicastRemoteObject . exportObject ( login , 0 ) ; registry . bind ( bindingName , login ) ; } catch ( IOException e1 ) { System . out . println ( "Something<seq2seq4repair_space>wrong<seq2seq4repair_space>with<seq2seq4repair_space>registry.properties" ) ; e1 . printStackTrace ( ) ; } catch ( AlreadyBoundException e ) { System . err . println ( "mgmt<seq2seq4repair_space>registry<seq2seq4repair_space>already<seq2seq4repair_space>bound" ) ; e . printStackTrace ( ) ; } MgmtInfoPoint commandReader ; try { <START_BUG> commandReader = new MgmtInfoPoint ( UserManager . getInstance ( ) , MgmtTaskManager . getInstance ( ) ) ; <END_BUG> } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static synchronized int getSchedulerTCPPort ( ) { } public static synchronized int getPreparationCosts ( ) { } public static synchronized String getSchedulerHost ( ) { } }
public class CastExpression extends Expression { public Expression expression ; public Expression type ; public TypeBinding expectedType ; public CastExpression ( Expression expression , Expression type ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public static void checkNeedForAssignedCast ( BlockScope scope , TypeBinding expectedType , CastExpression rhs ) { } public static void checkNeedForEnclosingInstanceCast ( BlockScope scope , Expression enclosingInstance , TypeBinding enclosingInstanceType , TypeBinding memberType ) { } public static void checkNeedForArgumentCast ( BlockScope scope , int operator , int operatorSignature , Expression expression , int expressionTypeId ) { } public static void checkNeedForArgumentCasts ( BlockScope scope , Expression receiver , TypeBinding receiverType , MethodBinding binding , Expression [ ] arguments , TypeBinding [ ] argumentTypes , final InvocationSite invocationSite ) { } public static void checkNeedForArgumentCasts ( BlockScope scope , int operator , int operatorSignature , Expression left , int leftTypeId , boolean leftIsCast , Expression right , int rightTypeId , boolean rightIsCast ) { } private static void checkAlternateBinding ( BlockScope scope , Expression receiver , TypeBinding receiverType , MethodBinding binding , Expression [ ] arguments , TypeBinding [ ] originalArgumentTypes , TypeBinding [ ] alternateArgumentTypes , final InvocationSite invocationSite ) { } public boolean checkUnsafeCast ( Scope scope , TypeBinding castType , TypeBinding expressionType , TypeBinding match , boolean isNarrowing ) { if ( match == castType ) { if ( ( ! isNarrowing ) && ( match == ( this . resolvedType . leafComponentType ( ) ) ) ) { tagAsUnnecessaryCast ( scope , castType ) ; } return true ; } if ( match != null ) { if ( isNarrowing ? checkProvablyDistinctTypes ( scope , match , expressionType , 0 ) : checkProvablyDistinctTypes ( scope , castType , match , 0 ) ) { return false ; } } switch ( castType . kind ( ) ) { case Binding . PARAMETERIZED_TYPE : if ( castType . isBoundParameterizedType ( ) ) { if ( match == null ) { this . bits |= ASTNode . UnsafeCast ; return true ; } switch ( match . kind ( ) ) { case Binding . PARAMETERIZED_TYPE : if ( isNarrowing ) { if ( ( expressionType . isRawType ( ) ) || ( ! ( expressionType . isEquivalentTo ( match ) ) ) ) { this . bits |= ASTNode . UnsafeCast ; return true ; } TypeBinding genericCastType = castType . erasure ( ) ; <START_BUG> TypeBinding genericMatch = genericCastType . findSuperTypeWithSameErasure ( expressionType ) ; <END_BUG> if ( genericMatch == match ) { this . bits |= ASTNode . UnsafeCast ; } return true ; } else { if ( ! ( match . isEquivalentTo ( castType ) ) ) { this . bits |= ASTNode . UnsafeCast ; return true ; } } break ; case Binding . RAW_TYPE : this . bits |= ASTNode . UnsafeCast ; return true ; default : if ( isNarrowing ) { this . bits |= ASTNode . UnsafeCast ; return true ; } break ; } } break ; case Binding . ARRAY_TYPE : TypeBinding leafType = castType . leafComponentType ( ) ; if ( isNarrowing && ( ( leafType . isBoundParameterizedType ( ) ) || ( leafType . isTypeVariable ( ) ) ) ) { this . bits |= ASTNode . UnsafeCast ; return true ; } break ; case Binding . TYPE_PARAMETER : this . bits |= ASTNode . UnsafeCast ; return true ; } if ( ( ! isNarrowing ) && ( match == ( this . resolvedType . leafComponentType ( ) ) ) ) { tagAsUnnecessaryCast ( scope , castType ) ; } return true ; } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public Expression innermostCastedExpression ( ) { } public LocalVariableBinding localVariableBinding ( ) { } public int nullStatus ( FlowInfo flowInfo ) { } public Constant optimizedBooleanConstant ( ) { } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public TypeBinding resolveType ( BlockScope scope ) { } public void setExpectedType ( TypeBinding expectedType ) { } private boolean isIndirectlyUsed ( ) { } public void tagAsNeedCheckCast ( ) { } public void tagAsUnnecessaryCast ( Scope scope , TypeBinding castType ) { } public void traverse ( ASTVisitor visitor , BlockScope blockScope ) { } }
public class DatabaseQuery { private final boolean returnsResultSet ; private final String preparationSQL ; private PreparedStatement preparedStatement ; private final String tableNameOfId ; public DatabaseQuery ( boolean returnsResultSet , String preparationSQL ) { } public DatabaseQuery ( boolean returnsResultSet , String preparationSQL , String tableNameOfId ) { } public ResultSet execute ( DatabaseQueryManager databaseQueryManager , DatabaseConnector databaseConnector , Object ... values ) throws DatabaseCriticalErrorException { if ( ( this . preparedStatement ) == null ) { try { this . preparedStatement = databaseConnector . createPreparedStatement ( preparationSQL ) ; } catch ( SQLException e ) { throw new DatabaseCriticalErrorException ( ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>create<seq2seq4repair_space>prepared<seq2seq4repair_space>statement:<seq2seq4repair_space>" + ( this . preparationSQL ) ) ) ; } } else { try { preparedStatement . clearParameters ( ) ; } catch ( SQLException e ) { throw new DatabaseCriticalErrorException ( "Unexpected<seq2seq4repair_space>error<seq2seq4repair_space>occured<seq2seq4repair_space>while<seq2seq4repair_space>clearing<seq2seq4repair_space>preparedStatement<seq2seq4repair_space>values!" ) ; } } if ( ( tableNameOfId ) == null ) { if ( values != null ) { try { for ( int i = 0 ; i < ( values . length ) ; i ++ ) { if ( ( values [ i ] ) instanceof String ) { preparedStatement . setString ( ( i + 1 ) , ( ( String ) ( values [ i ] ) ) ) ; } else if ( ( values [ i ] ) instanceof Integer ) { preparedStatement . setInt ( ( i + 1 ) , ( ( int ) ( values [ i ] ) ) ) ; } else if ( ( values [ i ] ) instanceof Double ) { preparedStatement . setDouble ( ( i + 1 ) , ( ( double ) ( values [ i ] ) ) ) ; } else if ( ( values [ i ] ) instanceof Boolean ) { preparedStatement . setBoolean ( ( i + 1 ) , ( ( boolean ) ( values [ i ] ) ) ) ; } else if ( ( values [ i ] ) instanceof Float ) { preparedStatement . setFloat ( ( i + 1 ) , ( ( float ) ( values [ i ] ) ) ) ; } else if ( ( values [ i ] ) instanceof Long ) { preparedStatement . setLong ( ( i + 1 ) , ( ( long ) ( values [ i ] ) ) ) ; } else if ( ( values [ i ] ) instanceof LocalDateTime ) { preparedStatement . setTimestamp ( ( i + 1 ) , Timestamp . valueOf ( ( ( LocalDateTime ) ( values [ i ] ) ) ) ) ; } else { throw new DatabaseCriticalErrorException ( "Type<seq2seq4repair_space>of<seq2seq4repair_space>request<seq2seq4repair_space>parameters<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>primitive!" ) ; } } } catch ( ArrayIndexOutOfBoundsException e1 ) { throw new DatabaseCriticalErrorException ( "Too<seq2seq4repair_space>many<seq2seq4repair_space>parameters<seq2seq4repair_space>for<seq2seq4repair_space>this<seq2seq4repair_space>type<seq2seq4repair_space>of<seq2seq4repair_space>request!" ) ; } catch ( SQLException e2 ) { throw new DatabaseCriticalErrorException ( "Unexpected<seq2seq4repair_space>error<seq2seq4repair_space>occured<seq2seq4repair_space>executing<seq2seq4repair_space>the<seq2seq4repair_space>prepared<seq2seq4repair_space>statement!" ) ; } } } else { try { databaseConnector . beginTransaction ( ) ; ResultSet resultSet = databaseQueryManager . executeQuery ( "getIdByTableName" , tableNameOfId ) ; resultSet . next ( ) ; int idValue = resultSet . getInt ( 1 ) ; databaseQueryManager . executeQuery ( "incrementId" , tableNameOfId ) ; preparedStatement . setInt ( 1 , idValue ) ; for ( int i = 0 ; i < ( values . length ) ; i ++ ) { if ( ( values [ i ] ) instanceof String ) { preparedStatement . setString ( ( i + 2 ) , ( ( String ) ( values [ i ] ) ) ) ; } else if ( ( values [ i ] ) instanceof Integer ) { preparedStatement . setInt ( ( i + 2 ) , ( ( int ) ( values [ i ] ) ) ) ; } else if ( ( values [ i ] ) instanceof Double ) { preparedStatement . setDouble ( ( i + 2 ) , ( ( double ) ( values [ i ] ) ) ) ; } else if ( ( values [ i ] ) instanceof Boolean ) { preparedStatement . setBoolean ( ( i + 2 ) , ( ( boolean ) ( values [ i ] ) ) ) ; } else if ( ( values [ i ] ) instanceof Float ) { preparedStatement . setFloat ( ( i + 2 ) , ( ( float ) ( values [ i ] ) ) ) ; } else if ( ( values [ i ] ) instanceof Long ) { preparedStatement . setLong ( ( i + 2 ) , ( ( long ) ( values [ i ] ) ) ) ; } else if ( ( values [ i ] ) instanceof LocalDateTime ) { preparedStatement . setTimestamp ( ( i + 2 ) , Timestamp . valueOf ( ( ( LocalDateTime ) ( values [ i ] ) ) ) ) ; } else { throw new DatabaseCriticalErrorException ( "Type<seq2seq4repair_space>of<seq2seq4repair_space>request<seq2seq4repair_space>parameters<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>primitive!" ) ; } } } catch ( ArrayIndexOutOfBoundsException e1 ) { throw new DatabaseCriticalErrorException ( "Too<seq2seq4repair_space>many<seq2seq4repair_space>parameters<seq2seq4repair_space>for<seq2seq4repair_space>this<seq2seq4repair_space>type<seq2seq4repair_space>of<seq2seq4repair_space>request!" ) ; } catch ( SQLException e2 ) { throw new DatabaseCriticalErrorException ( "Unexpected<seq2seq4repair_space>error<seq2seq4repair_space>occured<seq2seq4repair_space>executing<seq2seq4repair_space>the<seq2seq4repair_space>prepared<seq2seq4repair_space>statement!" ) ; } finally { try { databaseConnector . commitTransaction ( ) ; } catch ( SQLException e ) { try { databaseConnector . rollbackTransaction ( ) ; } catch ( SQLException e1 ) { throw new DatabaseCriticalErrorException ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>rollback<seq2seq4repair_space>transactions" ) ; } throw new DatabaseCriticalErrorException ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>commit<seq2seq4repair_space>transactions<seq2seq4repair_space>and<seq2seq4repair_space>activate<seq2seq4repair_space>auto<seq2seq4repair_space>commit!" ) ; } } } try { if ( returnsResultSet ) { return preparedStatement . executeQuery ( ) ; } else { preparedStatement . executeUpdate ( ) ; return null ; } } catch ( SQLException e ) { <START_BUG> throw new DatabaseCriticalErrorException ( "An<seq2seq4repair_space>error<seq2seq4repair_space>occured<seq2seq4repair_space>in<seq2seq4repair_space>the<seq2seq4repair_space>database<seq2seq4repair_space>or<seq2seq4repair_space>there<seq2seq4repair_space>are<seq2seq4repair_space>not<seq2seq4repair_space>enough<seq2seq4repair_space>parameteres<seq2seq4repair_space>for<seq2seq4repair_space>this<seq2seq4repair_space>type<seq2seq4repair_space>of<seq2seq4repair_space>request!" ) ; <END_BUG> } } No newline ; at end ; of file ; }
public class GerritChangeListPanel extends JPanel implements Consumer < List < ChangeInfo > > , TypeSafeDataProvider { private final ReviewCommentSink reviewCommentSink ; private final SelectedRevisions selectedRevisions ; private final GerritSelectRevisionInfoColumn selectRevisionInfoColumn ; private final List < ChangeInfo > changes ; private final TableView < ChangeInfo > table ; private GerritToolWindow gerritToolWindow ; @ Inject public GerritChangeListPanel ( ReviewCommentSink reviewCommentSink , final SelectedRevisions selectedRevisions , GerritSelectRevisionInfoColumn selectRevisionInfoColumn ) { } @ Override public void consume ( List < ChangeInfo > commits ) { } public void addListSelectionListener ( @ NotNull final Consumer < ChangeInfo > listener ) { } public void registerDiffAction ( @ NotNull AnAction diffAction ) { } @ Override public void calcData ( DataKey key , DataSink sink ) { } @ NotNull public JComponent getPreferredFocusComponent ( ) { } public TableView < ChangeInfo > getTable ( ) { } public void clearSelection ( ) { } public void setChanges ( @ NotNull List < ChangeInfo > changes ) { } public void registerChangeListPanel ( GerritToolWindow gerritToolWindow ) { } private void updateModel ( ) { } @ NotNull private ColumnInfo [ ] generateColumnsInfo ( @ NotNull List < ChangeInfo > changes ) { } private GerritChangeListPanel . ItemAndWidth getMax ( GerritChangeListPanel . ItemAndWidth current , String candidate ) { } private static class ItemAndWidth { private final String item ; private final int width ; private ItemAndWidth ( String item , int width ) { } } private static String getHash ( ChangeInfo change ) { } private static String getOwner ( ChangeInfo change ) { } private static String getProject ( ChangeInfo change ) { } private static String getBranch ( ChangeInfo change ) { } private static String getTime ( ChangeInfo change ) { } private static LabelInfo getCodeReview ( ChangeInfo change ) { } private static LabelInfo getVerified ( ChangeInfo change ) { } private static LabelInfo getLabel ( ChangeInfo change , String labelName ) { } private static abstract class GerritChangeColumnInfo extends ColumnInfo < ChangeInfo , String > { @ NotNull private final String maxString ; public GerritChangeColumnInfo ( @ NotNull String name , @ NotNull String maxString ) { } @ Override public String getMaxStringValue ( ) { } @ Override public int getAdditionalWidth ( ) { } } private static abstract class GerritChangeColumnIconLabelInfo extends ColumnInfo < ChangeInfo , LabelInfo > { public GerritChangeColumnIconLabelInfo ( String name ) { } @ Nullable @ Override public LabelInfo valueOf ( ChangeInfo changeInfo ) { } public abstract LabelInfo getLabelInfo ( ChangeInfo change ) { } @ Nullable @ Override public TableCellRenderer getRenderer ( final ChangeInfo changeInfo ) { } @ Override public int getWidth ( JTable table ) { } private static Icon getIconForLabel ( LabelInfo labelInfo ) { if ( labelInfo != null ) { if ( ( labelInfo . approved ) != null ) { return Checked ; } if ( ( labelInfo . recommended ) != null ) { return MoveUp ; } if ( ( labelInfo . disliked ) != null ) { return MoveDown ; } <START_BUG> if ( ( labelInfo . recommended ) != null ) { <END_BUG> return Cancel ; } } return null ; } private static String getToolTipForLabel ( LabelInfo labelInfo ) { } } private static class GerritChangeColumnStarredInfo extends ColumnInfo < ChangeInfo , Boolean > { public GerritChangeColumnStarredInfo ( ) { } @ Nullable @ Override public Boolean valueOf ( ChangeInfo changeInfo ) { } @ Nullable @ Override public TableCellRenderer getRenderer ( final ChangeInfo changeInfo ) { } @ Override public int getWidth ( JTable table ) { } } }
public class OF13MatchSerializerTest { private static final Logger LOG = LoggerFactory . getLogger ( OF13MatchSerializerTest . class ) ; private SerializerRegistry registry ; private OFSerializer < Match > matchSerializer ; @ Before public void startUp ( ) { } @ Test public void testIpv4Src ( ) { } @ Test public void testIpv6Various ( ) { } <START_BUG> @ Test ( expected = IllegalStateException . class ) <END_BUG> public void testIpv6Incorrect ( ) { MatchBuilder builder = new MatchBuilder ( ) ; builder . setType ( OxmMatchType . class ) ; List < MatchEntry > entries = new ArrayList < > ( ) ; MatchEntryBuilder entriesBuilder = new MatchEntryBuilder ( ) ; entriesBuilder . setOxmClass ( OpenflowBasicClass . class ) ; entriesBuilder . setOxmMatchField ( Ipv6Src . class ) ; entriesBuilder . setHasMask ( false ) ; Ipv6SrcCaseBuilder ipv6SrcCaseBuilder = new Ipv6SrcCaseBuilder ( ) ; Ipv6SrcBuilder ipv6SrcBuilder = new Ipv6SrcBuilder ( ) ; ipv6SrcBuilder . setIpv6Address ( new Ipv6Address ( "1:2::::8" ) ) ; ipv6SrcCaseBuilder . setIpv6Src ( ipv6SrcBuilder . build ( ) ) ; entriesBuilder . setMatchEntryValue ( ipv6SrcCaseBuilder . build ( ) ) ; entries . add ( entriesBuilder . build ( ) ) ; builder . setMatchEntry ( entries ) ; Match match = builder . build ( ) ; ByteBuf out = DEFAULT . buffer ( ) ; matchSerializer . serialize ( match , out ) ; } @ Test public void testIpv6Flabel ( ) { } @ Test public void testIpv6FlabelWithMask ( ) { } @ Test public void testIpv6FlabelWithMaskBad ( ) { } private static Match buildIpv6FLabelMatch ( long labelValue , boolean hasMask , byte [ ] mask ) { } @ Test public void testStandardMatchType ( ) { } @ Test ( expected = IllegalStateException . class ) public void testSerializeExperimenterMatchEntry ( ) { } private class OxmMatchFieldClass extends MatchField { } No newline ; at end ; of file ; }
public class GaiaInputController extends GestureDetector { public static final float WASD_MOVEMENT_SENSITIVITY = 0.5F ; public KeyMappings mappings ; public int rotateButton = Buttons . LEFT ; public float rotateAngle = 360.0F ; public int panButton = Buttons . RIGHT ; public final float translateUnits = 1000.0F ; public int movementButton = Buttons . MIDDLE ; public boolean alwaysScroll = true ; public float scrollFactor = - 0.1F ; public boolean autoUpdate = true ; public int rollKey = Keys . SHIFT_LEFT ; public int lookFocusKey = Keys . CONTROL_LEFT ; public boolean forwardTarget = true ; public boolean scrollTarget = false ; protected boolean rotateLeftPressed ; public CameraManager cam ; private IGui gui ; private Comparator < CelestialBody > comp ; private Set < Integer > pressedKeys = new HashSet < Integer > ( ) ; protected int button = - 1 ; private float startX ; private float startY ; private float MOVE_PX_DIST ; private int MAX_PX_DIST ; private Vector2 gesture = new Vector2 ( ) ; private Vector3d aux ; protected static class GaiaGestureListener extends GestureAdapter { public GaiaInputController controller ; private float previousZoom ; @ Override public boolean touchDown ( float x , float y , int pointer , int button ) { } @ Override public boolean tap ( float x , float y , int count , int button ) { } @ Override public boolean longPress ( float x , float y ) { } @ Override public boolean fling ( float velocityX , float velocityY , int button ) { } @ Override public boolean pan ( float x , float y , float deltaX , float deltaY ) { } @ Override public boolean zoom ( float initialDistance , float distance ) { } @ Override public boolean pinch ( Vector2 initialPointer1 , Vector2 initialPointer2 , Vector2 pointer1 , Vector2 pointer2 ) { } } protected final GaiaInputController . GaiaGestureListener gestureListener ; protected GaiaInputController ( final GaiaInputController . GaiaGestureListener gestureListener , final CameraManager camera , IGui gui ) { } public GaiaInputController ( final CameraManager camera , IGui gui ) { } private int touched ; private boolean multiTouch ; @ Override public boolean touchDown ( int screenX , int screenY , int pointer , int button ) { } @ Override public boolean touchUp ( int screenX , int screenY , int pointer , int button ) { } protected boolean process ( float deltaX , float deltaY , int button ) { } @ Override public boolean touchDragged ( int screenX , int screenY , int pointer ) { } @ Override public boolean scrolled ( int amount ) { } public boolean zoom ( float amount ) { } @ Override public boolean keyDown ( int keycode ) { } @ Override public boolean keyUp ( int keycode ) { EventManager . getInstance ( ) . post ( INPUT_EVENT , keycode ) ; if ( instance . INPUT_ENABLED ) { ProgramAction action = mappings . mappings . get ( pressedKeys ) ; if ( action != null ) { action . run ( ) ; } <START_BUG> pressedKeys . clear ( ) ; <END_BUG> return true ; } else if ( keycode == ( Keys . ESCAPE ) ) { if ( GlobalConf . OPENGL_GUI ) { app . exit ( ) ; } else { EventManager . getInstance ( ) . post ( FULLSCREEN_CMD , false ) ; } pressedKeys . remove ( keycode ) ; return true ; } pressedKeys . remove ( keycode ) ; return false ; } public boolean isKeyPressed ( int keycode ) { } }
public class ViewerActionBuilder extends PluginActionBuilder { private ISelectionProvider provider ; private IWorkbenchPart part ; public ViewerActionBuilder ( ) { } protected ActionDescriptor createActionDescriptor ( IConfigurationElement element ) { } protected BasicContribution createContribution ( ) { } public void dispose ( ) { } protected boolean readElement ( IConfigurationElement element ) { } public boolean readViewerContributions ( String id , ISelectionProvider prov , IWorkbenchPart part ) { Assert . isTrue ( ( ( part instanceof IViewPart ) || ( part instanceof IEditorPart ) ) ) ; provider = prov ; this . part = part ; <START_BUG> readContributions ( id , TAG_CONTRIBUTION_TYPE , PL_POPUP_MENU ) ; <END_BUG> return ( cache ) != null ; } private static class ViewerContribution extends BasicContribution implements ISelectionChangedListener { private ISelectionProvider selProvider ; private ActionExpression visibilityTest ; public ViewerContribution ( ISelectionProvider selProvider ) { } public void setVisibilityTest ( IConfigurationElement element ) { } public void contribute ( IMenuManager menu , boolean menuAppendIfMissing , IToolBarManager toolbar , boolean toolAppendIfMissing ) { } public void dispose ( ) { } public void selectionChanged ( SelectionChangedEvent event ) { } } }
public abstract class AdjacencySet < C extends Couple > implements Set < C > { protected AdjacencyMap < C , C > map = null ; @ Override public void clear ( ) { } public Set < Integer > getNext ( Integer i ) { } public Set < Integer > vertices ( ) { } @ Override public boolean add ( C e ) { } @ Override public boolean addAll ( Collection < ? extends C > cs ) { } @ Override public boolean contains ( Object o ) { } @ Override public boolean containsAll ( Collection < ? > cs ) { } @ Override public boolean isEmpty ( ) { } @ Override public Iterator < C > iterator ( ) { <START_BUG> return map . keyIterator ( ) ; <END_BUG> } @ Override public boolean remove ( Object o ) { } @ Override public boolean removeAll ( Collection < ? > cs ) { } @ Override public boolean retainAll ( Collection < ? > c ) { } @ Override public int size ( ) { } @ Override public Object [ ] toArray ( ) { } @ Override public < T > T [ ] toArray ( T [ ] a ) { } public static final class Links extends AdjacencySet < Link > implements LinkTrace . Handler { public Links ( ) { } @ Override public Listener < Link > linkListener ( ) { } @ Override public Listener < LinkEvent > linkEventListener ( ) { } } public static final class Edges extends AdjacencySet < Edge > implements EdgeTrace . Handler { public Edges ( ) { } @ Override public Listener < Edge > edgeListener ( ) { } @ Override public Listener < EdgeEvent > edgeEventListener ( ) { } } }
@ Singleton public class RepositoriesTypeManager { public static final CharSequenceTranslator ESCAPE_ISO8859_1 = new LookupTranslator ( EntityArrays . ISO8859_1_ESCAPE ( ) ) ; @ Inject private PdcImportExport pdcImportExport ; protected RepositoriesTypeManager ( ) { } public void processImport ( RepositoriesType repositoriesType , ImportSettings settings , ImportReportManager reportManager ) { } private PublicationDetail importFile ( final PublicationDetail previousSavedPublication , File file , ImportReportManager reportManager , MassiveReport massiveReport , GEDImportExport gedIE , PdcImportExport pdcIE , ImportSettings settings ) { } public static SimpleDocument handleFileToAttach ( UserDetail currentUser , String componentId , String resourceId , String oldSilverpeasId , final DocumentType documentType , File file , String contentLanguage , final Date creationDate , boolean hasToBeIndexed , boolean isComponentVersionActivated , boolean publicVersionRequired ) throws IOException { final String fileName = file . getName ( ) ; final long fileSize = file . length ( ) ; boolean publicVersion = isComponentVersionActivated && publicVersionRequired ; final String mimeType = FileUtil . getMimeType ( fileName ) ; final SimpleDocumentPK documentPK = new SimpleDocumentPK ( null , componentId ) ; if ( StringUtil . isDefined ( oldSilverpeasId ) ) { if ( StringUtil . isInteger ( oldSilverpeasId ) ) { documentPK . setOldSilverpeasId ( Long . parseLong ( oldSilverpeasId ) ) ; } else { documentPK . setId ( oldSilverpeasId ) ; } } SimpleDocument document = getAttachmentService ( ) . findExistingDocument ( documentPK , fileName , new ForeignPK ( resourceId , componentId ) , contentLanguage ) ; final boolean needCreation = ( document == null ) || ( ! ( document . isVersioned ( ) ) ) ; if ( needCreation ) { if ( isComponentVersionActivated ) { document = new org . silverpeas . core . contribution . attachment . model . HistorisedDocument ( documentPK , resourceId , 0 , currentUser . getId ( ) , new org . silverpeas . core . contribution . attachment . model . SimpleAttachment ( fileName , contentLanguage , fileName , "" , fileSize , mimeType , currentUser . getId ( ) , creationDate , null ) ) ; document . setPublicDocument ( publicVersion ) ; } else { document = new SimpleDocument ( new SimpleDocumentPK ( null , componentId ) , resourceId , 0 , false , new org . silverpeas . core . contribution . attachment . model . SimpleAttachment ( fileName , contentLanguage , null , null , fileSize , mimeType , currentUser . getId ( ) , creationDate , null ) ) ; } document . setDocumentType ( documentType ) ; RepositoriesTypeManager . setMetadata ( document , file ) ; } if ( needCreation ) { <START_BUG> boolean notifying = ( ! ( document . isVersioned ( ) ) ) || publicVersion ; <END_BUG> document = getAttachmentService ( ) . createAttachment ( document , file , hasToBeIndexed , notifying ) ; } else { document . setLanguage ( contentLanguage ) ; document . setPublicDocument ( publicVersion ) ; document . edit ( currentUser . getId ( ) ) ; getAttachmentService ( ) . updateAttachment ( document , file , hasToBeIndexed , publicVersion ) ; UnlockContext unlockContext = new UnlockContext ( document . getId ( ) , currentUser . getId ( ) , contentLanguage , "" ) ; unlockContext . addOption ( UPLOAD ) ; if ( ! publicVersion ) { unlockContext . addOption ( PRIVATE_VERSION ) ; } getAttachmentService ( ) . unlock ( unlockContext ) ; } ActifyDocumentProcessor . getProcessor ( ) . process ( document ) ; return document ; } private static void setMetadata ( SimpleDocument document , File file ) { } private void processMailContent ( PublicationDetail pubDetail , File file , ImportReportManager reportManager , UnitReport unitReport , GEDImportExport gedIE , boolean isVersioningUsed ) throws ImportExportException { } public void processImportRecursiveNoReplicate ( ImportReportManager reportManager , MassiveReport massiveReport , GEDImportExport gedIE , PdcImportExport pdcIE , ImportSettings settings ) { } public List < PublicationDetail > processImportRecursiveReplicate ( ImportReportManager reportManager , MassiveReport massiveReport , GEDImportExport gedIE , PdcImportExport pdcIE , ImportSettings settings ) throws ImportExportException { } private Iterator < File > getPathContent ( File path ) { } private List < File > convertListStringToListFile ( String [ ] listFileName , String path ) { } }
public class SchemaGrammar extends Grammar { private static final int CHUNK_SHIFT = 8 ; private static final int CHUNK_SIZE = 1 << ( SchemaGrammar . CHUNK_SHIFT ) ; private static final int CHUNK_MASK = ( SchemaGrammar . CHUNK_SIZE ) - 1 ; private static final int INITIAL_CHUNK_COUNT = 1 << ( 10 - ( SchemaGrammar . CHUNK_SHIFT ) ) ; private XMLContentSpec fTempContentSpecNode = new XMLContentSpec ( ) ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private int [ ] [ ] fScopeDefinedByElement = new int [ SchemaGrammar . INITIAL_CHUNK_COUNT ] [ ] ; private String [ ] [ ] fFromAnotherSchemaURI = new String [ SchemaGrammar . INITIAL_CHUNK_COUNT ] [ ] ; private ComplexTypeInfo [ ] [ ] fComplexTypeInfo = new TraverseSchema . ComplexTypeInfo [ SchemaGrammar . INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fElementDeclDefaultType = new int [ SchemaGrammar . INITIAL_CHUNK_COUNT ] [ ] ; private String [ ] [ ] fElementDeclDefaultValue = new String [ SchemaGrammar . INITIAL_CHUNK_COUNT ] [ ] ; private String [ ] [ ] fElementDeclSubstitutionGroupFullName = new String [ SchemaGrammar . INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fElementDeclBlockSet = new int [ SchemaGrammar . INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fElementDeclFinalSet = new int [ SchemaGrammar . INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fElementDeclMiscFlags = new int [ SchemaGrammar . INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fContentSpecMinOccurs = new int [ SchemaGrammar . INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fContentSpecMaxOccurs = new int [ SchemaGrammar . INITIAL_CHUNK_COUNT ] [ ] ; private Hashtable fComplexTypeRegistry = null ; private Hashtable fAttributeDeclRegistry = null ; private DatatypeValidatorFactoryImpl fDatatypeRegistry = null ; Hashtable topLevelGroupDecls = new Hashtable ( ) ; Hashtable topLevelNotationDecls = new Hashtable ( ) ; Hashtable topLevelAttrDecls = new Hashtable ( ) ; Hashtable topLevelAttrGrpDecls = new Hashtable ( ) ; Hashtable topLevelElemDecls = new Hashtable ( ) ; Hashtable topLevelTypeDecls = new Hashtable ( ) ; private NamespacesScope fNamespacesScope = null ; private String fTargetNamespaceURI = "" ; private boolean deferContentSpecExpansion = false ; private boolean checkUniqueParticleAttribution = false ; private boolean checkingUPA = false ; private int [ ] [ ] fContentSpecOrgUri = new int [ SchemaGrammar . INITIAL_CHUNK_COUNT ] [ ] ; public NamespacesScope getNamespacesScope ( ) { } public boolean getDeferContentSpecExpansion ( ) { } public boolean getCheckUniqueParticleAttribution ( ) { } public String getTargetNamespaceURI ( ) { } public Hashtable getAttributeDeclRegistry ( ) { } public Hashtable getComplexTypeRegistry ( ) { } public DatatypeValidatorFactoryImpl getDatatypeRegistry ( ) { } public int getElementDefinedScope ( int elementDeclIndex ) { } public int getElementDefaultTYpe ( int elementDeclIndex ) { } public int getElementDeclBlockSet ( int elementDeclIndex ) { } public int getElementDeclFinalSet ( int elementDeclIndex ) { } public int getElementDeclMiscFlags ( int elementDeclIndex ) { } public String getElementFromAnotherSchemaURI ( int elementDeclIndex ) { } public String getElementDefaultValue ( int elementDeclIndex ) { } public String getElementDeclSubstitutionGroupElementFullName ( int elementDeclIndex ) { } public ComplexTypeInfo getElementComplexTypeInfo ( int elementDeclIndex ) { } protected int convertContentSpecTree ( int contentSpecIndex ) { if ( ( ! ( deferContentSpecExpansion ) ) || ( contentSpecIndex < 0 ) ) { return contentSpecIndex ; } getContentSpec ( contentSpecIndex , fTempContentSpecNode ) ; int minOccurs = getContentSpecMinOccurs ( contentSpecIndex ) ; int maxOccurs = getContentSpecMaxOccurs ( contentSpecIndex ) ; <START_BUG> if ( ( ( ( ( ( fTempContentSpecNode . type ) & 15 ) == ( XMLContentSpec . CONTENTSPECNODE_ANY ) ) || ( ( ( fTempContentSpecNode . type ) & 15 ) == ( XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) ) ) || ( ( ( fTempContentSpecNode . type ) & 15 ) == ( XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) ) ) || ( ( fTempContentSpecNode . type ) == ( XMLContentSpec . CONTENTSPECNODE_LEAF ) ) ) { <END_BUG> if ( checkingUPA ) { contentSpecIndex = addContentSpecNode ( fTempContentSpecNode . type , fTempContentSpecNode . value , fTempContentSpecNode . otherValue , false ) ; setContentSpecOrgUri ( contentSpecIndex , fTempContentSpecNode . otherValue ) ; getContentSpec ( contentSpecIndex , fTempContentSpecNode ) ; fTempContentSpecNode . otherValue = contentSpecIndex ; setContentSpec ( contentSpecIndex , fTempContentSpecNode ) ; } return expandContentModel ( contentSpecIndex , minOccurs , maxOccurs ) ; } else if ( ( ( ( fTempContentSpecNode . type ) == ( XMLContentSpec . CONTENTSPECNODE_CHOICE ) ) || ( ( fTempContentSpecNode . type ) == ( XMLContentSpec . CONTENTSPECNODE_ALL ) ) ) || ( ( fTempContentSpecNode . type ) == ( XMLContentSpec . CONTENTSPECNODE_SEQ ) ) ) { int left = fTempContentSpecNode . value ; int right = fTempContentSpecNode . otherValue ; int type = fTempContentSpecNode . type ; left = convertContentSpecTree ( left ) ; if ( right == ( - 2 ) ) return expandContentModel ( left , minOccurs , maxOccurs ) ; right = convertContentSpecTree ( right ) ; if ( checkingUPA ) { contentSpecIndex = addContentSpecNode ( type , left , right , false ) ; } else { fTempContentSpecNode . type = type ; fTempContentSpecNode . value = left ; fTempContentSpecNode . otherValue = right ; setContentSpec ( contentSpecIndex , fTempContentSpecNode ) ; } return expandContentModel ( contentSpecIndex , minOccurs , maxOccurs ) ; } else return contentSpecIndex ; } public XMLContentModel getElementContentModel ( int elementDeclIndex , SubstitutionGroupComparator comparator ) throws CMException { } public void setContentSpecOrgUri ( int contentSpecIndex , int orgUri ) { } public int getContentSpecOrgUri ( int contentSpecIndex ) { } public void setDeferContentSpecExpansion ( ) { } public void setCheckUniqueParticleAttribution ( ) { } protected void setAttributeDeclRegistry ( Hashtable attrReg ) { } protected void setComplexTypeRegistry ( Hashtable cTypeReg ) { } protected void setDatatypeRegistry ( DatatypeValidatorFactoryImpl dTypeReg ) { } protected void setNamespacesScope ( NamespacesScope nsScope ) { } protected void setTargetNamespaceURI ( String targetNSUri ) { } protected int createElementDecl ( ) { }
public class Where < ModelClass extends Model > implements ModelQueriable < ModelClass > , Query { private final WhereBase < ModelClass > mWhereBase ; private final BaseDatabaseDefinition mManager ; private ConditionQueryBuilder < ModelClass > mConditionQueryBuilder ; private String mGroupBy ; private ConditionQueryBuilder < ModelClass > mHaving ; private String mOrderBy ; private String mLimit ; private String mOffset ; public Where ( WhereBase < ModelClass > whereBase ) { } public static < ModelClass extends Model > Where < ModelClass > with ( ConditionQueryBuilder < ModelClass > conditionQueryBuilder , String ... columns ) { } public Where < ModelClass > whereClause ( String whereClause , Object ... args ) { } public Where < ModelClass > whereQuery ( ConditionQueryBuilder < ModelClass > conditionQueryBuilder ) { } public Where < ModelClass > and ( String columnName , Object value ) { } public Where < ModelClass > and ( String columnName , String operator , Object value ) { } public Where < ModelClass > and ( Condition condition ) { <START_BUG> mConditionQueryBuilder . putCondition ( condition ) ; <END_BUG> return this ; } public Where < ModelClass > or ( Condition condition ) { } public Where < ModelClass > andThese ( List < Condition > conditions ) { } public Where < ModelClass > andThese ( Condition ... conditions ) { } public Where < ModelClass > groupBy ( QueryBuilder groupBy ) { } public Where < ModelClass > having ( Condition ... conditions ) { } public Where < ModelClass > orderBy ( boolean ascending , String ... columns ) { } public Where < ModelClass > orderBy ( String orderby ) { } public Where < ModelClass > limit ( Object limit ) { } public Where < ModelClass > offset ( Object offset ) { } public long count ( ) { } @ Override public String getQuery ( ) { } @ Override public Cursor query ( ) { } @ Override public void queryClose ( ) { } @ Override public List < ModelClass > queryList ( ) { } protected void checkSelect ( String methodName ) { } @ Override public ModelClass querySingle ( ) { } public void transact ( DBTransactionInfo transactionInfo ) { } public void transact ( DBTransactionInfo transactionInfo , TransactionManager transactionManager ) { } public void transactList ( TransactionListener < List < ModelClass > > listTransactionListener ) { } public void transactList ( TransactionManager transactionManager , TransactionListener < List < ModelClass > > listTransactionListener ) { } public void transactSingleModel ( TransactionListener < ModelClass > transactionListener ) { } public void transactSingleModel ( TransactionManager transactionManager , TransactionListener < ModelClass > transactionListener ) { } @ Override public FlowCursorList < ModelClass > queryCursorList ( ) { } @ Override public FlowTableList < ModelClass > queryTableList ( ) { } public boolean hasData ( ) { } @ Override public Class < ModelClass > getTable ( ) { } @ Override public String toString ( ) { } }
class AddFolderToIndex extends IndexRequest { IPath folderPath ; IProject project ; char [ ] [ ] inclusionPatterns ; char [ ] [ ] exclusionPatterns ; public AddFolderToIndex ( IPath folderPath , IProject project , char [ ] [ ] inclusionPatterns , char [ ] [ ] exclusionPatterns , IndexManager manager ) { } public boolean execute ( IProgressMonitor progressMonitor ) { if ( ( this . isCancelled ) || ( ( progressMonitor != null ) && ( progressMonitor . isCanceled ( ) ) ) ) return true ; if ( ! ( project . isAccessible ( ) ) ) return true ; IResource folder = this . project . getParent ( ) . findMember ( this . folderPath ) ; if ( ( folder == null ) || ( ( folder . getType ( ) ) == ( IResource . FILE ) ) ) return true ; <START_BUG> Index index = manager . getIndex ( this . containerPath , true , true ) ; <END_BUG> if ( index == null ) return true ; ReadWriteMonitor monitor = index . monitor ; if ( monitor == null ) return true ; try { monitor . enterRead ( ) ; final IPath container = this . containerPath ; final IndexManager indexManager = this . manager ; if ( ( ( this . exclusionPatterns ) == null ) && ( ( this . inclusionPatterns ) == null ) ) { folder . accept ( new IResourceProxyVisitor ( ) { public boolean visit ( IResourceProxy proxy ) { if ( ( proxy . getType ( ) ) == ( IResource . FILE ) ) { if ( Util . isJavaFileName ( proxy . getName ( ) ) ) indexManager . addSource ( ( ( IFile ) ( proxy . requestResource ( ) ) ) , container ) ; return false ; } return true ; } } , IResource . NONE ) ; } else { folder . accept ( new IResourceProxyVisitor ( ) { public boolean visit ( IResourceProxy proxy ) { switch ( proxy . getType ( ) ) { case IResource . FILE : if ( Util . isJavaFileName ( proxy . getName ( ) ) ) { IResource resource = proxy . requestResource ( ) ; if ( ! ( org . eclipse . jdt . internal . core . util . Util . isExcluded ( resource , inclusionPatterns , exclusionPatterns ) ) ) indexManager . addSource ( ( ( IFile ) ( resource ) ) , container ) ; } return false ; case IResource . FOLDER : if ( org . eclipse . jdt . internal . core . util . Util . isExcluded ( proxy . requestResource ( ) , inclusionPatterns , exclusionPatterns ) ) return false ; } return true ; } } , IResource . NONE ) ; } } catch ( CoreException e ) { if ( JobManager . VERBOSE ) { org . eclipse . jdt . internal . core . util . Util . verbose ( ( ( "-><seq2seq4repair_space>failed<seq2seq4repair_space>to<seq2seq4repair_space>add<seq2seq4repair_space>" + ( this . folderPath ) ) + "<seq2seq4repair_space>to<seq2seq4repair_space>index<seq2seq4repair_space>because<seq2seq4repair_space>of<seq2seq4repair_space>the<seq2seq4repair_space>following<seq2seq4repair_space>exception:" ) , System . err ) ; e . printStackTrace ( ) ; } return false ; } finally { monitor . exitRead ( ) ; } return true ; } public String toString ( ) { } }
public class BundleContextService implements Service < BundleContext > { public static final ServiceName SERVICE_NAME = JBOSS . append ( "osgi" , "context" ) ; private static final Logger log = Logger . getLogger ( "org.jboss.as.osgi" ) ; private final InjectedValue < BundleManager > injectedBundleManager = new InjectedValue < BundleManager > ( ) ; private final InjectedValue < Framework > injectedFramework = new InjectedValue < Framework > ( ) ; private BundleContext sysContext ; public static void addService ( final ServiceTarget target , Activation policy ) { } public static BundleContext getServiceValue ( ServiceContainer container ) { } public synchronized void start ( final StartContext context ) throws StartException { sysContext = injectedFramework . getValue ( ) . getBundleContext ( ) ; BundleListener bundleListener = new BundleListener ( ) { @ Override public void bundleChanged ( BundleEvent event ) { if ( ( event . getType ( ) ) == ( BundleEvent . INSTALLED ) ) { AbstractUserBundle userBundle ; try { userBundle = AbstractUserBundle . assertBundleState ( event . getBundle ( ) ) ; } catch ( RuntimeException ex ) { return ; } Deployment dep = userBundle . getDeployment ( ) ; String contextName = DeploymentHolderService . getContextName ( dep ) ; ServiceContainer container = context . getController ( ) . getServiceContainer ( ) ; ServiceName osgiDeploymentService = OSGiDeploymentService . getServiceName ( contextName ) ; <START_BUG> ServiceName deploymentService = JBOSS_DEPLOYMENT . append ( contextName ) ; <END_BUG> if ( ( ( container . getService ( deploymentService ) ) != null ) && ( ( container . getService ( osgiDeploymentService ) ) == null ) ) { ServiceName serviceName = ModuleRegistrationService . getServiceName ( contextName ) ; try { BundleContextService . log . tracef ( "Register<seq2seq4repair_space>service:<seq2seq4repair_space>%s" , serviceName ) ; BatchBuilder batchBuilder = container . batchBuilder ( ) ; ModuleRegistrationService . addService ( batchBuilder , dep , contextName ) ; batchBuilder . install ( ) ; } catch ( ServiceRegistryException ex ) { throw new IllegalStateException ( ( "Cannot<seq2seq4repair_space>register<seq2seq4repair_space>service:<seq2seq4repair_space>" + serviceName ) , ex ) ; } } } } } ; sysContext . addBundleListener ( bundleListener ) ; } public synchronized void stop ( StopContext context ) { } @ Override public BundleContext getValue ( ) throws IllegalStateException { } }
public class InputController implements ActionListener { private InputPanel inputPanel ; private BoardPanel boardPanel ; private Player player ; private MoveController moveController ; private LookController lookController ; private AttackController attackController ; private static final int mapWidth = 10 ; public InputController ( ) { } public InputController ( StatusPanel statusPanel , BoardPanel boardPanel ) { } public void setInputPanel ( InputPanel inputPanel ) { } public void setPlayer ( Player player ) { } public void setBoardPanel ( BoardPanel boardPanel ) { } @ Override public void actionPerformed ( ActionEvent e ) { } public void commandAction ( String action ) { String [ ] command = action . split ( "<seq2seq4repair_space>" ) ; if ( ( command [ 0 ] . equals ( "move" ) ) || ( command [ 0 ] . equals ( "m" ) ) ) { moveController . movePlayer ( command [ 1 ] , InputController . mapWidth ) ; } else if ( ( ( ( ( ( ( ( command [ 0 ] . equals ( "north" ) ) || ( command [ 0 ] . equals ( "west" ) ) ) || ( command [ 0 ] . equals ( "east" ) ) ) || ( command [ 0 ] . equals ( "south" ) ) ) || ( command [ 0 ] . equals ( "n" ) ) ) || ( command [ 0 ] . equals ( "e" ) ) ) || ( command [ 0 ] . equals ( "s" ) ) ) || ( command [ 0 ] . equals ( "w" ) ) ) { moveController . movePlayer ( command [ 0 ] , InputController . mapWidth ) ; } else if ( ( command [ 0 ] . equals ( "look" ) ) || ( command [ 0 ] . equals ( "l" ) ) ) { if ( ( command . length ) == 1 ) { lookController . look ( command [ 0 ] , player ) ; } else { lookController . look ( command [ 1 ] , player ) ; } } else if ( ( command [ 0 ] . equals ( "attack" ) ) || ( command [ 0 ] . equals ( "a" ) ) ) { attackController . attack ( command [ 1 ] ) ; } else if ( command [ 0 ] . equals ( "save" ) ) { boardPanel . save ( ) ; } else if ( command [ 0 ] . equals ( "load" ) ) { boardPanel . load ( ) ; } else if ( ( command [ 0 ] . equals ( "exit" ) ) || ( command [ 0 ] . equals ( "quit" ) ) ) { System . exit ( 0 ) ; } else if ( command [ 0 ] . equals ( "chat" ) ) { try { if ( ( command . length ) > 1 ) { new Chat ( command [ 1 ] , "234.235.236.237" , 9999 ) ; } else { new Chat ( ) ; } } catch ( IOException e ) { } } else if ( ( command [ 0 ] . equals ( "playmusic" ) ) || ( command [ 0 ] . equals ( "startmusic" ) ) ) { SoundPlayer . playMusic ( ) ; } else if ( command [ 0 ] . equals ( "stopmusic" ) ) { SoundPlayer . stopMusic ( ) ; } else { <START_BUG> new OutputController ( Utils . OutputPanelProvider . getOutputPanel ( ) ) . print ( "Felaktigt<seq2seq4repair_space>kommando" ) ; <END_BUG> } } No newline ; at end ; of file ; }
public abstract class AbstractPathService implements Service < String > { private static final ServiceName SERVICE_NAME_BASE = JBOSS . append ( "server" , "path" ) ; public static ServiceName pathNameOf ( String pathName ) { } private String path ; @ Override public void start ( StartContext context ) throws StartException { <START_BUG> this . path = resolvePath ( ) ; <END_BUG> } @ Override public void stop ( StopContext context ) { } @ Override public String getValue ( ) throws IllegalStateException { } protected abstract String resolvePath ( ) { } }
abstract class BaseMonitor implements BundleFinder , ModuleFactory { private HashMap serviceProviders = new HashMap ( ) ; private static final String LINE = "----------------------------------------------------------------" ; Vector [ ] implementationSets ; private Vector services ; Properties bootProperties ; Properties applicationProperties ; boolean inShutdown ; private InfoStreams systemStreams ; private ContextService contextService ; private UUIDFactory uuidFactory ; private TimerFactory timerFactory ; boolean reportOn ; private PrintStream logging ; ThreadGroup daemonGroup ; private InstanceGetter [ ] rc2 ; BaseMonitor ( ) { } public InfoStreams getSystemStreams ( ) { } public void shutdown ( ) { } public void shutdown ( Object serviceModule ) { } protected final void runWithState ( Properties properties , PrintStream log ) { } public Object findService ( String factoryInterface , String serviceName ) { } public Locale getLocale ( Object serviceModule ) { } public Locale getLocaleFromString ( String localeDescription ) throws StandardException { } public String getServiceName ( Object serviceModule ) { } public Locale setLocale ( Object serviceModule , String userDefinedLocale ) throws StandardException { } public Locale setLocale ( Properties serviceProperties , String userDefinedLocale ) throws StandardException { } public PersistentService getServiceType ( Object serviceModule ) { } public Object startModule ( boolean create , Object serviceModule , String factoryInterface , String identifier , Properties properties ) throws StandardException { } private synchronized TopService findTopService ( Object serviceModule ) { } public Object findModule ( Object serviceModule , String factoryInterface , String identifier ) { } public InstanceGetter classFromIdentifier ( int fmtId ) throws StandardException { } public Object newInstanceFromIdentifier ( int identifier ) throws StandardException { } private Boolean exceptionTrace ; protected Object loadInstance ( Class factoryInterface , Properties properties ) { } private Object loadInstance ( Vector implementations , Class factoryInterface , Properties properties ) { } private static int findImplementation ( Vector implementations , int startIndex , Class factoryInterface ) { } private Object newInstance ( String className ) { } private Object newInstance ( Class classObject ) { } public Properties getApplicationProperties ( ) { } public String [ ] getServiceList ( String protocol ) { } void dumpProperties ( String title , Properties props ) { } protected void report ( String message ) { } protected void reportException ( Throwable t ) { } private void addDebugFlags ( String flags , boolean set ) { } private static final String SERVICE = "derby.service." ; public void startServices ( Properties properties , boolean bootAll ) { } public final boolean startPersistentService ( String name , Properties properties ) throws StandardException { } public Object createPersistentService ( String factoryInterface , String name , Properties properties ) throws StandardException { } public void removePersistentService ( String name ) throws StandardException { } public Object startNonPersistentService ( String factoryInterface , String serviceName , Properties properties ) throws StandardException { } private Vector getImplementations ( Properties moduleList , boolean actualModuleList ) { } private boolean getPersistentServiceImplementation ( Class possibleModule ) { } private Vector getDefaultImplementations ( ) { } Properties getDefaultModuleProperties ( ) { Properties moduleList = new Properties ( ) ; boolean firstList = true ; ClassLoader cl = getClass ( ) . getClassLoader ( ) ; try { Enumeration e = ( cl == null ) ? ClassLoader . getSystemResources ( "org/apache/derby/modules.properties" ) : cl . getResources ( "org/apache/derby/modules.properties" ) ; while ( e . hasMoreElements ( ) ) { URL modulesPropertiesURL = ( ( URL ) ( e . nextElement ( ) ) ) ; InputStream is = null ; try { is = modulesPropertiesURL . openStream ( ) ; if ( firstList ) { moduleList . load ( is ) ; firstList = false ; } else { Properties otherList = new Properties ( ) ; otherList . load ( is ) ; for ( Enumeration newKeys = otherList . keys ( ) ; newKeys . hasMoreElements ( ) ; ) { String key = ( ( String ) ( newKeys . nextElement ( ) ) ) ; <START_BUG> if ( moduleList . contains ( key ) ) <END_BUG> report ( ( ( ( "Ignored<seq2seq4repair_space>duplicate<seq2seq4repair_space>property<seq2seq4repair_space>" + key ) + "<seq2seq4repair_space>in<seq2seq4repair_space>" ) + ( modulesPropertiesURL . toString ( ) ) ) ) ; else moduleList . setProperty ( key , otherList . getProperty ( key ) ) ; } } } catch ( IOException ioe ) { if ( SanityManager . DEBUG ) report ( ( ( ( "Can't<seq2seq4repair_space>load<seq2seq4repair_space>implementation<seq2seq4repair_space>list<seq2seq4repair_space>" + ( modulesPropertiesURL . toString ( ) ) ) + ":<seq2seq4repair_space>" ) + ( ioe . toString ( ) ) ) ) ; } finally { try { if ( is != null ) is . close ( ) ; } catch ( IOException ioe2 ) { } } } } catch ( IOException ioe ) { if ( SanityManager . DEBUG ) report ( ( "Can't<seq2seq4repair_space>load<seq2seq4repair_space>implementation<seq2seq4repair_space>list:<seq2seq4repair_space>" + ( ioe . toString ( ) ) ) ) ; } if ( SanityManager . DEBUG ) { if ( firstList ) report ( "Default<seq2seq4repair_space>implementation<seq2seq4repair_space>list<seq2seq4repair_space>not<seq2seq4repair_space>found" ) ; } return moduleList ; } protected static Properties removeRuntimeProperties ( Properties properties ) { } abstract InputStream applicationPropertiesStream ( ) throws IOException { } protected Properties readApplicationProperties ( ) { } private void determineSupportedServiceProviders ( ) { } private void bootPersistentServices ( ) { } protected void bootProviderServices ( PersistentService provider ) { } private boolean findProviderAndStartService ( String name , Properties properties , boolean bootTime ) throws StandardException { } protected PersistentService findProviderForCreate ( String name ) throws StandardException { } private PersistentService findProviderFromName ( String name , int colon ) throws StandardException { } public PersistentService getServiceProvider ( String subSubProtocol ) throws StandardException { } private PersistentService getPersistentService ( String subSubProtocol ) throws StandardException { } private PersistentService getPersistentService ( final String className , String subSubProtocol ) throws StandardException { } private String getStorageFactoryClassName ( String subSubProtocol ) { } private static final HashMap storageFactories = new HashMap ( ) ; protected void startProviderService ( PersistentService provider , String serviceName , Properties serviceProperties ) throws StandardException { }
public class Mouse extends MouseAdapter implements MouseMotionListener { private static final HashMap < Integer , Boolean > buttons ; private static final Point position ; private static final Mouse instance ; private Mouse ( ) { } public static Mouse getInstance ( ) { } public static Point getPosition ( ) { } public static boolean pressed ( int button ) { <START_BUG> return ( Mouse . buttons . containsKey ( button ) ) && ( Mouse . buttons . get ( Mouse . buttons ) ) ; <END_BUG> } @ Override public void mouseMoved ( MouseEvent e ) { } @ Override public void mousePressed ( MouseEvent e ) { } @ Override public void mouseReleased ( MouseEvent e ) { } }
public class Path extends Resource { public int handle ; PointF currentPoint = new PointF ( ) ; PointF startPoint = new PointF ( ) ; public Path ( Device device ) { } public void addArc ( float x , float y , float width , float height , float startAngle , float arcAngle ) { if ( isDisposed ( ) ) SWT . error ( ERROR_GRAPHIC_DISPOSED ) ; if ( width < 0 ) { x = x + width ; width = - width ; } if ( height < 0 ) { y = y + height ; height = - height ; } if ( ( ( width == 0 ) || ( height == 0 ) ) || ( arcAngle == 0 ) ) return ; if ( width == height ) { Gdip . GraphicsPath_AddArc ( handle , x , y , width , height , ( - startAngle ) , ( - arcAngle ) ) ; } else { int path = Gdip . GraphicsPath_new ( FillModeAlternate ) ; if ( path == 0 ) SWT . error ( ERROR_NO_HANDLES ) ; int matrix = Gdip . Matrix_new ( width , 0 , 0 , height , x , y ) ; if ( matrix == 0 ) SWT . error ( ERROR_NO_HANDLES ) ; Gdip . GraphicsPath_AddArc ( path , 0 , 0 , 1 , 1 , ( - startAngle ) , ( - arcAngle ) ) ; Gdip . GraphicsPath_Transform ( path , matrix ) ; <START_BUG> Gdip . GraphicsPath_AddPath ( handle , path , false ) ; <END_BUG> Gdip . Matrix_delete ( matrix ) ; Gdip . GraphicsPath_delete ( path ) ; } Gdip . GraphicsPath_GetLastPoint ( handle , currentPoint ) ; } public void addPath ( Path path ) { } public void addRectangle ( float x , float y , float width , float height ) { } public void addString ( String string , float x , float y , Font font ) { } public void close ( ) { } public boolean contains ( float x , float y , GC gc , boolean outline ) { } public void cubicTo ( float cx1 , float cy1 , float cx2 , float cy2 , float x , float y ) { } public void dispose ( ) { } public void getBounds ( float [ ] bounds ) { } public void getCurrentPoint ( float [ ] point ) { } public PathData getPathData ( ) { } public void lineTo ( float x , float y ) { } public boolean isDisposed ( ) { } public void moveTo ( float x , float y ) { } public void quadTo ( float cx , float cy , float x , float y ) { } public String toString ( ) { } }
public class CodeSnippetClassFile extends ClassFile { public CodeSnippetClassFile ( SourceTypeBinding aType , ClassFile enclosingClassFile , boolean creatingProblemType ) { } public static void createProblemType ( TypeDeclaration typeDeclaration , CompilationResult unitResult ) { SourceTypeBinding typeBinding = typeDeclaration . binding ; ClassFile classFile = new CodeSnippetClassFile ( typeBinding , null , true ) ; if ( typeBinding . isMemberType ( ) ) classFile . recordEnclosingTypeAttributes ( typeBinding ) ; FieldBinding [ ] fields = typeBinding . fields ; if ( ( fields != null ) && ( fields != ( NoFields ) ) ) { for ( int i = 0 , max = fields . length ; i < max ; i ++ ) { <START_BUG> if ( ( fields [ i ] . constant ) == null ) { <END_BUG> org . eclipse . jdt . internal . compiler . ast . FieldReference . getConstantFor ( fields [ i ] , null , false , null ) ; } } classFile . addFieldInfos ( ) ; } else { classFile . contents [ ( ( classFile . contentsOffset ) ++ ) ] = 0 ; classFile . contents [ ( ( classFile . contentsOffset ) ++ ) ] = 0 ; } classFile . setForMethodInfos ( ) ; MethodBinding [ ] methods = typeBinding . methods ; AbstractMethodDeclaration [ ] methodDeclarations = typeDeclaration . methods ; int maxMethodDecl = ( methodDeclarations == null ) ? 0 : methodDeclarations . length ; int problemsLength ; IProblem [ ] problems = unitResult . getErrors ( ) ; if ( problems == null ) { problems = new IProblem [ 0 ] ; } IProblem [ ] problemsCopy = new IProblem [ problemsLength = problems . length ] ; System . arraycopy ( problems , 0 , problemsCopy , 0 , problemsLength ) ; if ( methods != null ) { if ( typeBinding . isInterface ( ) ) { classFile . addProblemClinit ( problemsCopy ) ; for ( int i = 0 , max = methods . length ; i < max ; i ++ ) { MethodBinding methodBinding ; if ( ( methodBinding = methods [ i ] ) != null ) { for ( int j = 0 ; j < maxMethodDecl ; j ++ ) { if ( ( ( methodDeclarations [ j ] ) != null ) && ( ( methodDeclarations [ j ] . binding ) == ( methods [ i ] ) ) ) { if ( ! ( methodBinding . isConstructor ( ) ) ) { classFile . addAbstractMethod ( methodDeclarations [ j ] , methodBinding ) ; } break ; } } } } } else { for ( int i = 0 , max = methods . length ; i < max ; i ++ ) { MethodBinding methodBinding ; if ( ( methodBinding = methods [ i ] ) != null ) { for ( int j = 0 ; j < maxMethodDecl ; j ++ ) { if ( ( ( methodDeclarations [ j ] ) != null ) && ( ( methodDeclarations [ j ] . binding ) == ( methods [ i ] ) ) ) { AbstractMethodDeclaration methodDecl ; if ( ( methodDecl = methodDeclarations [ j ] ) . isConstructor ( ) ) { classFile . addProblemConstructor ( methodDecl , methodBinding , problemsCopy ) ; } else { classFile . addProblemMethod ( methodDecl , methodBinding , problemsCopy ) ; } break ; } } } } } classFile . addDefaultAbstractMethods ( ) ; } if ( ( typeDeclaration . memberTypes ) != null ) { for ( int i = 0 , max = typeDeclaration . memberTypes . length ; i < max ; i ++ ) { TypeDeclaration memberType = typeDeclaration . memberTypes [ i ] ; if ( ( memberType . binding ) != null ) { classFile . recordNestedMemberAttribute ( memberType . binding ) ; ClassFile . createProblemType ( memberType , unitResult ) ; } } } classFile . addAttributes ( ) ; unitResult . record ( typeBinding . constantPoolName ( ) , classFile ) ; } }
public class CommandProvider extends QuickAccessProvider { private Map idToElement ; private IEvaluationContext contextSnapshot ; private HandlerService realHandlerService ; public CommandProvider ( ) { } public String getId ( ) { } public QuickAccessElement getElementForId ( String id ) { } public QuickAccessElement [ ] getElements ( ) { } public ImageDescriptor getImageDescriptor ( ) { } public String getName ( ) { } private void saveApplicationContext ( ) { realHandlerService = ( ( HandlerService ) ( PlatformUI . getWorkbench ( ) . getService ( IHandlerService . class ) ) ) ; <START_BUG> contextSnapshot = realHandlerService . getContextSnapshot ( ) ; <END_BUG> } HandlerService getRealHandlerService ( ) { } IEvaluationContext getContextSnapshot ( ) { } }
public final class AllTests { private static transient Logger log = LoggingManager . getLoggerForClass ( ) ; private AllTests ( ) { } private static void logprop ( String prop , boolean show ) { } private static void logprop ( String prop ) { } public static void main ( String [ ] args ) { if ( ( args . length ) < 1 ) { System . out . println ( ( "You<seq2seq4repair_space>must<seq2seq4repair_space>specify<seq2seq4repair_space>a<seq2seq4repair_space>comma-delimited<seq2seq4repair_space>list<seq2seq4repair_space>of<seq2seq4repair_space>paths<seq2seq4repair_space>to<seq2seq4repair_space>search<seq2seq4repair_space>" + "for<seq2seq4repair_space>unit<seq2seq4repair_space>tests" ) ) ; System . exit ( 0 ) ; } AllTests . initializeLogging ( args ) ; AllTests . initializeManager ( args ) ; AllTests . logprop ( "java.version" , true ) ; AllTests . logprop ( "java.vendor" ) ; AllTests . logprop ( "java.home" , true ) ; AllTests . logprop ( "user.home" ) ; <START_BUG> AllTests . logprop ( "user.dir" ) ; <END_BUG> AllTests . logprop ( "os.name" ) ; AllTests . logprop ( "os.version" ) ; AllTests . logprop ( "os.arch" ) ; AllTests . logprop ( "java.class.version" ) ; String cp = System . getProperty ( "java.class.path" ) ; String [ ] cpe = JOrphanUtils . split ( cp , File . pathSeparator ) ; StringBuffer sb = new StringBuffer ( 3000 ) ; sb . append ( "java.class.path=" ) ; for ( int i = 0 ; i < ( cpe . length ) ; i ++ ) { sb . append ( "\n" ) ; sb . append ( cpe [ i ] ) ; if ( new File ( cpe [ i ] ) . exists ( ) ) { sb . append ( "<seq2seq4repair_space>-<seq2seq4repair_space>OK" ) ; } else { sb . append ( "<seq2seq4repair_space>-<seq2seq4repair_space>??" ) ; } } AllTests . log . info ( sb . toString ( ) ) ; System . out . println ( "+++++++++++" ) ; AllTests . logprop ( "java.awt.headless" , true ) ; AllTests . logprop ( "java.awt.graphicsenv" , true ) ; System . out . println ( "------------" ) ; System . out . println ( "Creating<seq2seq4repair_space>test<seq2seq4repair_space>suite" ) ; TestSuite suite = AllTests . suite ( args [ 0 ] ) ; System . out . println ( "Starting<seq2seq4repair_space>test<seq2seq4repair_space>run" ) ; TestRunner . run ( suite ) ; System . out . println ( "+++++++++++" ) ; System . out . println ( "------------" ) ; System . exit ( 0 ) ; } protected static void initializeLogging ( String [ ] args ) { } protected static void initializeManager ( String [ ] args ) { } public static TestSuite suite ( ) { } private static TestSuite suite ( String searchPaths ) { } }
public class Arena implements Comparable < Arena > { private File arenaFile ; private FileConfiguration arenaConfig ; private int arenaID ; private ArenaStatus status ; private int maxPlayers ; private int minPlayers ; private int maxRounds ; private int maxWaves ; private int round ; private int wave ; private int spawnRate ; private double saveRadius ; private int TaskId ; private World arenaWorld ; private Location minLoc ; private Location maxLoc ; private ArenaScore score ; private Random rand ; private ArrayList < ZvPPlayer > players ; public Arena ( int ID , int maxPlayers , String arenaPath , Location min , Location max , int rounds , int waves , int spawnRate , double saveRadius ) { } public Arena ( File arenaFile ) { } void save ( ) throws IOException { } void delete ( ) { } public void setStatus ( ArenaStatus status ) { } public void setRound ( int round ) { } public void setWave ( int wave ) { } public void setTaskID ( int ID ) { } public int getID ( ) { } public ArenaStatus getStatus ( ) { } public int getMaxPlayers ( ) { } public int getMinPlayers ( ) { } public int getMaxRounds ( ) { } public int getMaxWaves ( ) { } public int getRound ( ) { } public int getWave ( ) { } public int getSpawnRate ( ) { } public int getTaskId ( ) { } public double getSaveRadius ( ) { } public ArenaScore getScore ( ) { } public World getWorld ( ) { } public Location getMin ( ) { } public Location getMax ( ) { } public Location getNewRandomLocation ( ) { } public Location getNewSaveLocation ( ) { } public ZvPPlayer getRandomPlayer ( ) { } public ZvPPlayer [ ] getPlayers ( ) { } private Entity [ ] getEntities ( ) { } public int getLivingZombies ( ) { } public int getKilledZombies ( ) { } public boolean isOnline ( ) { } public boolean isRunning ( ) { } public boolean isWaiting ( ) { } public boolean isFull ( ) { } public boolean hasKit ( ) { } public boolean hasVoted ( ) { } public boolean containsPlayer ( Player player ) { } public boolean containsLocation ( Location location ) { } public void setPlayerBoards ( ) { } public void setPlayerLevel ( int level ) { } public void updatePlayerBoards ( ) { } public void removePlayerBoards ( ) { } public void sendMessage ( String message ) { } public boolean addPlayer ( final ZvPPlayer player ) { } public boolean removePlayer ( ZvPPlayer player ) { } private void customizeEntity ( Entity zombie ) { } public void spawnZombies ( int amount ) { } public void start ( int rounds , int waves ) { this . maxRounds = rounds ; this . maxWaves = waves ; this . round = 0 ; this . wave = 0 ; <START_BUG> this . score = new ArenaScore ( this , ZvPConfig . getSeperatePlayerScores ( ) ) ; <END_BUG> getWorld ( ) . setDifficulty ( NORMAL ) ; getWorld ( ) . setTime ( 15000L ) ; getWorld ( ) . setMonsterSpawnLimit ( 0 ) ; clearArena ( ) ; this . TaskId = new GameRunnable ( this , ZvPConfig . getStartDelay ( ) , getSpawnRate ( ) ) . runTaskTimer ( ZvP . getInstance ( ) , 0L , 20L ) . getTaskId ( ) ; ZvP . getPluginLogger ( ) . log ( Level . INFO , ( ( "Arena<seq2seq4repair_space>" + ( getID ( ) ) ) + "<seq2seq4repair_space>started<seq2seq4repair_space>a<seq2seq4repair_space>new<seq2seq4repair_space>Task!" ) , true ) ; } public void stop ( ) { } public boolean next ( ) { } public void clearArena ( ) { } @ Override public boolean equals ( Object obj ) { } @ Override public int compareTo ( Arena o ) { } }
public class ContentAdd extends AbstractAddStepHandler { protected final ContentRepository contentRepository ; private final DeploymentFileRepository remoteRepository ; public ContentAdd ( final ContentRepository contentRepository , final DeploymentFileRepository remoteRepository ) { } @ Override protected void populateModel ( final ModelNode operation , final ModelNode model ) throws OperationFailedException { } @ Override protected void performRuntime ( final OperationContext context , final ModelNode operation , final ModelNode model , final ServiceVerificationHandler verificationHandler , final List < ServiceController < ? > > newControllers ) throws OperationFailedException { } static void installServices ( final OperationContext context , final ServiceVerificationHandler verificationHandler , final List < ServiceController < ? > > newControllers , final String name , final String path , final byte [ ] content ) { final ServiceName serviceName = SERVICE_NAME . append ( name ) . append ( path ) ; final ContentService service = new ContentService ( path , content ) ; <START_BUG> ServiceBuilder < ContentService > builder = context . getServiceTarget ( ) . addService ( serviceName , service ) . addDependency ( DeploymentOverlayService . SERVICE_NAME . append ( name ) , DeploymentOverlayService . class , service . getContentServiceInjectedValue ( ) ) . addDependency ( ContentRepository . SERVICE_NAME , ContentRepository . class , service . getContentRepositoryInjectedValue ( ) ) ; <END_BUG> if ( verificationHandler != null ) { builder . addListener ( verificationHandler ) ; } final ServiceController < ContentService > controller = builder . install ( ) ; if ( newControllers != null ) { newControllers . add ( controller ) ; } } }
public final class LocalizedResource implements PrivilegedAction { private static final boolean SUPPORTS_BIG_DECIMAL_CALLS ; private ResourceBundle res ; private Locale locale ; private String encode ; private static final String MESSAGE_FILE = "org.apache.derby.loc.toolsmessages" ; private static final String ENV_CODESET = "derby.ui.codeset" ; private static final String ENV_LOCALE = "derby.ui.locale" ; private String messageFileName ; private String resourceKey ; private LocalizedOutput out ; private LocalizedInput in ; private boolean enableLocalized ; private boolean unicodeEscape ; private static LocalizedResource local ; private int dateSize ; private int timeSize ; private int timestampSize ; private DateFormat formatDate ; private DateFormat formatTime ; private DateFormat formatTimestamp ; private NumberFormat formatNumber ; private DecimalFormat formatDecimal ; public LocalizedResource ( ) { } public LocalizedResource ( String encStr , String locStr , String msgF ) { } public static LocalizedResource getInstance ( ) { } public void init ( ) { } public void init ( String encStr , String locStr , String msgF ) { } private void setResource ( ) { if ( ( res ) != null ) { return ; } if ( ( ( locale ) == null ) || ( locale . toString ( ) . equals ( "none" ) ) ) { <START_BUG> res = ResourceBundle . getBundle ( LocalizedResource . MESSAGE_FILE ) ; <END_BUG> } else try { res = ResourceBundle . getBundle ( messageFileName , locale ) ; } catch ( MissingResourceException e ) { res = ResourceBundle . getBundle ( messageFileName , Locale . ENGLISH ) ; } } private void initMaxSizes2 ( ) { } public LocalizedInput getNewInput ( InputStream i ) { } public LocalizedInput getNewEncodedInput ( InputStream i , String encoding ) { } public LocalizedOutput getNewOutput ( OutputStream o ) { } public LocalizedOutput getNewEncodedOutput ( OutputStream o , String encoding ) throws UnsupportedEncodingException { } public String getTextMessage ( String key ) { } public String getTextMessage ( String key , Object o ) { } public String getTextMessage ( String key , Object o1 , Object o2 ) { } public String getTextMessage ( String key , Object o1 , Object o2 , Object o3 ) { } public String getTextMessage ( String key , Object o1 , Object o2 , Object o3 , Object o4 ) { } private Locale getNewLocale ( String locStr ) { } public String getTextMessage ( String key , Object [ ] objectArr ) { } public String getLocalizedString ( ResultSet rs , ResultSetMetaData rsm , int columnNumber ) throws SQLException { } public String getDateAsString ( Date d ) { } public String getTimeAsString ( Date t ) { } public String getNumberAsString ( int o ) { } public String getNumberAsString ( long o ) { } public String getNumberAsString ( Object o ) { } public String getNumberAsString ( double o ) { } public String getTimestampAsString ( Timestamp t ) { } public int getColumnDisplaySize ( ResultSetMetaData rsm , int columnNumber ) throws SQLException { } public String getStringFromDate ( String dateStr ) throws ParseException { } public String getStringFromTime ( String timeStr ) throws ParseException { } public String getStringFromValue ( String val ) throws ParseException { } public String getStringFromTimestamp ( String timestampStr ) throws ParseException { } public Locale getLocale ( ) { } private final synchronized String getEnvProperty ( String key ) { } public final Object run ( ) { } public static boolean enableLocalization ( boolean mode ) { } public boolean isLocalized ( ) { } public static String getMessage ( String key ) { } public static String getMessage ( String key , Object o1 ) { } public static String getMessage ( String key , Object o1 , Object o2 ) { } public static String getMessage ( String key , Object o1 , Object o2 , Object o3 ) { } public static String getMessage ( String key , Object o1 , Object o2 , Object o3 , Object o4 ) { } public static LocalizedOutput OutputWriter ( ) { } public static LocalizedInput InputReader ( ) { } public static String getNumber ( long o ) { } public static String getNumber ( int o ) { } public static void setUnicodeEscape ( boolean u ) { } public static boolean getUnicodeEscape ( ) { } public String toString ( ) { } }
public abstract class Page extends MarkupContainer implements IRedirectListener { protected static final boolean ACCESS_ALLOWED = true ; protected static final boolean ACCESS_DENIED = false ; private static final Log log = LogFactory . getLog ( Page . class ) ; private int autoIndex ; private transient int changeCount ; private IFeedback feedback ; private FeedbackMessages feedbackMessages ; private int id = - 1 ; private transient Set renderedComponents ; private transient Session session = null ; private boolean trackChanges = false ; private IPageVersionManager versionManager ; protected Page ( ) { } protected Page ( final IModel model ) { } public int getAutoIndex ( ) { } public final int getCurrentVersionNumber ( ) { } public FeedbackMessages getFeedbackMessages ( ) { } public final int getId ( ) { } public final String getName ( ) { } public final Session getSession ( ) { } public Page getVersion ( final int versionNumber ) { } public PageState newPageState ( ) { } public final void onRedirect ( ) { <START_BUG> getRequestCycle ( ) . setPage ( this ) ; <END_BUG> } public final void removePersistedFormData ( final Class formClass , final boolean disablePersistence ) { } public void setFeedback ( final IFeedback feedback ) { } public String toString ( ) { } protected boolean checkAccess ( ) { } protected void configureResponse ( ) { } protected IModel initModel ( ) { } protected void internalOnModelChanged ( ) { } protected IPageVersionManager newVersionManager ( ) { } protected void onEndRequest ( ) { } protected final void onRender ( ) { } final void componentAdded ( final Component component ) { } final void componentModelChangeImpending ( final Component component ) { } final void componentRemoved ( final Component component ) { } final void componentRendered ( final Component component ) { } final void internalOnBeginRender ( ) { } final void internalOnEndRender ( ) { } final void internalOnEndRequest ( ) { } final void resetMarkupStreams ( ) { } final void setId ( final int id ) { } private final void checkRendering ( ) { } private void init ( ) { } private final void onChanged ( ) { } }
public class TestUmlNamespace extends GenericObjectTestFixture { public TestUmlNamespace ( String arg0 ) { } public void testNamespace ( ) { <START_BUG> Object o = getFactory ( ) . create ( NAMESPACE ) ; <END_BUG> assertNotNull ( "Didn't<seq2seq4repair_space>create<seq2seq4repair_space>object" , o ) ; assertTrue ( "Should<seq2seq4repair_space>be<seq2seq4repair_space>a<seq2seq4repair_space>base" , ModelFacade . isABase ( o ) ) ; assertTrue ( "Should<seq2seq4repair_space>be<seq2seq4repair_space>a<seq2seq4repair_space>namespace" , ModelFacade . isANamespace ( o ) ) ; runTruthTests ( o ) ; } protected void initializeTruth ( ) { } }
final class TermScorer extends Scorer { private Weight weight ; private DocsEnum docsEnum ; private byte [ ] norms ; private float weightValue ; private int doc = - 1 ; private int freq ; private int pointer ; private int pointerMax ; private static final int SCORE_CACHE_SIZE = 32 ; private float [ ] scoreCache = new float [ TermScorer . SCORE_CACHE_SIZE ] ; private int [ ] docs ; private int [ ] freqs ; private final BulkReadResult bulkResult ; TermScorer ( Weight weight , DocsEnum td , Similarity similarity , byte [ ] norms ) { } @ Override public void score ( Collector c ) throws IOException { } private final void refillBuffer ( ) throws IOException { } @ Override protected boolean score ( Collector c , int end , int firstDocID ) throws IOException { } @ Override public int docID ( ) { } @ Override public int nextDoc ( ) throws IOException { } @ Override public float score ( ) { } @ Override public int advance ( int target ) throws IOException { for ( ( pointer ) ++ ; ( pointer ) < ( pointerMax ) ; ( pointer ) ++ ) { if ( ( docs [ pointer ] ) >= target ) { freq = freqs [ pointer ] ; return doc = docs [ pointer ] ; } } int newDoc = docsEnum . advance ( target ) ; <START_BUG> if ( newDoc != ( DocsEnum . NO_MORE_DOCS ) ) { <END_BUG> doc = newDoc ; freq = docsEnum . freq ( ) ; } else { doc = NO_MORE_DOCS ; } return doc ; } @ Override public String toString ( ) { } }
@ Security . Authenticated ( FEMRAuthenticated . class ) @ AllowedRoles ( { Roles . PHYSICIAN , Roles . PHARMACIST , Roles . NURSE } ) public class TriageController extends Controller { private final Form < IndexViewModelPost > IndexViewModelForm = Form . form ( IndexViewModelPost . class ) ; private final IEncounterService encounterService ; private final IPatientService patientService ; private final ISessionService sessionService ; private final ISearchService searchService ; private final IPhotoService photoService ; private final IVitalService vitalService ; @ Inject public TriageController ( IEncounterService encounterService , ISessionService sessionService , ISearchService searchService , IPatientService patientService , IPhotoService photoService , IVitalService vitalService ) { } public Result indexGet ( ) { } public Result indexPopulatedGet ( int patientId ) { } public Result indexPost ( int id ) { IndexViewModelPost viewModel = IndexViewModelForm . bindFromRequest ( ) . get ( ) ; CurrentUser currentUser = sessionService . retrieveCurrentUserSession ( ) ; <START_BUG> ServiceResponse < SettingItem > settingItemServiceResponse = searchService . getSystemSettings ( ) ; <END_BUG> if ( settingItemServiceResponse . hasErrors ( ) ) { throw new RuntimeException ( ) ; } SettingItem settings = settingItemServiceResponse . getResponseObject ( ) ; ServiceResponse < PatientItem > patientServiceResponse ; PatientItem patientItem ; if ( id == 0 ) { patientItem = populatePatientItem ( viewModel , currentUser ) ; patientServiceResponse = patientService . createPatient ( patientItem ) ; } else { patientServiceResponse = patientService . updateSex ( id , viewModel . getSex ( ) ) ; } if ( patientServiceResponse . hasErrors ( ) ) { throw new RuntimeException ( ) ; } patientItem = patientServiceResponse . getResponseObject ( ) ; photoService . createPatientPhoto ( viewModel . getPatientPhotoCropped ( ) , patientItem . getId ( ) , viewModel . getDeletePhoto ( ) ) ; PatientEncounterItem patientEncounterItem = populatePatientEncounterItem ( viewModel . getChiefComplaint ( ) , viewModel . getChiefComplaintsJSON ( ) , viewModel . getWeeksPregnant ( ) , currentUser , patientServiceResponse . getResponseObject ( ) . getId ( ) , viewModel . getAgeClassification ( ) ) ; ServiceResponse < PatientEncounterItem > patientEncounterServiceResponse = encounterService . createPatientEncounter ( patientEncounterItem ) ; if ( patientEncounterServiceResponse . hasErrors ( ) ) { throw new RuntimeException ( ) ; } else { patientEncounterItem = patientEncounterServiceResponse . getResponseObject ( ) ; } Map < String , Float > newVitals = new HashMap < > ( ) ; if ( ( viewModel . getRespiratoryRate ( ) ) != null ) { newVitals . put ( "respiratoryRate" , viewModel . getRespiratoryRate ( ) . floatValue ( ) ) ; } if ( ( viewModel . getHeartRate ( ) ) != null ) { newVitals . put ( "heartRate" , viewModel . getHeartRate ( ) . floatValue ( ) ) ; } if ( ( viewModel . getTemperature ( ) ) != null ) { Float temperature = viewModel . getTemperature ( ) ; if ( settings . isMetric ( ) ) { temperature = LocaleUnitConverter . getFahrenheit ( temperature ) ; } newVitals . put ( "temperature" , temperature ) ; } if ( ( viewModel . getOxygenSaturation ( ) ) != null ) { newVitals . put ( "oxygenSaturation" , viewModel . getOxygenSaturation ( ) ) ; } if ( ( ( viewModel . getHeightFeet ( ) ) != null ) && ( ( viewModel . getHeightInches ( ) ) != null ) ) { Float heightFeet = viewModel . getHeightFeet ( ) . floatValue ( ) ; Float heightInches = viewModel . getHeightInches ( ) . floatValue ( ) ; if ( settings . isMetric ( ) ) { Float heightMetres = heightFeet ; Float heightCentimetres = heightInches ; heightFeet = LocaleUnitConverter . getFeet ( heightMetres , heightCentimetres ) ; heightInches = LocaleUnitConverter . getInches ( heightMetres , heightCentimetres ) ; } newVitals . put ( "heightFeet" , heightFeet ) ; newVitals . put ( "heightInches" , heightInches ) ; } if ( ( viewModel . getWeight ( ) ) != null ) { Float weight = viewModel . getWeight ( ) ; if ( settings . isMetric ( ) ) { weight = LocaleUnitConverter . getLbs ( weight ) ; } newVitals . put ( "weight" , weight ) ; } if ( ( viewModel . getBloodPressureSystolic ( ) ) != null ) { newVitals . put ( "bloodPressureSystolic" , viewModel . getBloodPressureSystolic ( ) . floatValue ( ) ) ; } if ( ( viewModel . getBloodPressureDiastolic ( ) ) != null ) { newVitals . put ( "bloodPressureDiastolic" , viewModel . getBloodPressureDiastolic ( ) . floatValue ( ) ) ; } if ( ( viewModel . getGlucose ( ) ) != null ) { newVitals . put ( "glucose" , viewModel . getGlucose ( ) . floatValue ( ) ) ; } ServiceResponse < List < VitalItem > > vitalServiceResponse = vitalService . createPatientEncounterVitalItems ( newVitals , currentUser . getId ( ) , patientEncounterItem . getId ( ) ) ; if ( vitalServiceResponse . hasErrors ( ) ) { throw new RuntimeException ( ) ; } return redirect ( HistoryController . indexPatientGet ( Integer . toString ( patientServiceResponse . getResponseObject ( ) . getId ( ) ) ) ) ; } private PatientItem populatePatientItem ( IndexViewModelPost viewModelPost , CurrentUser currentUser ) { } private PatientEncounterItem populatePatientEncounterItem ( String chiefComplaint , String chiefComplaintJSON , Integer weeksPregnant , CurrentUser currentUser , int patientId , String ageClassification ) { } }
public abstract class JDBCTask extends Task { private static Hashtable loaderMap = new Hashtable ( 3 ) ; private boolean caching = true ; private Path classpath ; private AntClassLoader loader ; private boolean autocommit = false ; private String driver = null ; private String url = null ; private String userId = null ; private String password = null ; private String rdbms = null ; private String version = null ; public void setClasspath ( Path classpath ) { } public void setCaching ( boolean enable ) { } public Path createClasspath ( ) { } public void setClasspathRef ( Reference r ) { } public void setDriver ( String driver ) { } public void setUrl ( String url ) { } public void setPassword ( String password ) { } public void setAutocommit ( boolean autocommit ) { } public void setRdbms ( String rdbms ) { } public void setVersion ( String version ) { } protected boolean isValidRdbms ( Connection conn ) { } protected static Hashtable getLoaderMap ( ) { } protected AntClassLoader getLoader ( ) { } protected Connection getConnection ( ) throws BuildException { } private Driver getDriver ( ) throws BuildException { if ( ( driver ) == null ) { throw new BuildException ( "Driver<seq2seq4repair_space>attribute<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>set!" , getLocation ( ) ) ; } Driver driverInstance = null ; try { Class dc ; if ( ( classpath ) != null ) { synchronized ( JDBCTask . loaderMap ) { if ( caching ) { loader = ( ( AntClassLoader ) ( JDBCTask . loaderMap . get ( driver ) ) ) ; } if ( ( loader ) == null ) { log ( ( ( ( "Loading<seq2seq4repair_space>" + ( driver ) ) + "<seq2seq4repair_space>using<seq2seq4repair_space>AntClassLoader<seq2seq4repair_space>with<seq2seq4repair_space>classpath<seq2seq4repair_space>" ) + ( classpath ) ) , MSG_VERBOSE ) ; <START_BUG> loader = new AntClassLoader ( getProject ( ) , classpath ) ; <END_BUG> if ( caching ) { JDBCTask . loaderMap . put ( driver , loader ) ; } } else { log ( ( ( "Loading<seq2seq4repair_space>" + ( driver ) ) + "<seq2seq4repair_space>using<seq2seq4repair_space>a<seq2seq4repair_space>cached<seq2seq4repair_space>AntClassLoader." ) , MSG_VERBOSE ) ; } } dc = loader . loadClass ( driver ) ; } else { log ( ( ( "Loading<seq2seq4repair_space>" + ( driver ) ) + "<seq2seq4repair_space>using<seq2seq4repair_space>system<seq2seq4repair_space>loader." ) , MSG_VERBOSE ) ; dc = Class . forName ( driver ) ; } driverInstance = ( ( Driver ) ( dc . newInstance ( ) ) ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( ( ( "Class<seq2seq4repair_space>Not<seq2seq4repair_space>Found:<seq2seq4repair_space>JDBC<seq2seq4repair_space>driver<seq2seq4repair_space>" + ( driver ) ) + "<seq2seq4repair_space>could<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>loaded" ) , getLocation ( ) ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( ( ( "Illegal<seq2seq4repair_space>Access:<seq2seq4repair_space>JDBC<seq2seq4repair_space>driver<seq2seq4repair_space>" + ( driver ) ) + "<seq2seq4repair_space>could<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>loaded" ) , getLocation ( ) ) ; } catch ( InstantiationException e ) { throw new BuildException ( ( ( "Instantiation<seq2seq4repair_space>Exception:<seq2seq4repair_space>JDBC<seq2seq4repair_space>driver<seq2seq4repair_space>" + ( driver ) ) + "<seq2seq4repair_space>could<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>loaded" ) , getLocation ( ) ) ; } return driverInstance ; } public void isCaching ( boolean value ) { } public Path getClasspath ( ) { } public boolean isAutocommit ( ) { } public String getUrl ( ) { } public String getUserId ( ) { } public void setUserid ( String userId ) { } public String getPassword ( ) { } public String getRdbms ( ) { } public String getVersion ( ) { } }
public class Eydis { private TaskCollection _tasks ; private List < Task > searchResult = new ArrayList < Task > ( ) ; private static Eydis _eydis ; private static final Logger log = Logger . getLogger ( Eydis . class . getName ( ) ) ; private Eydis ( String filename ) { } public static Eydis getEydisInstance ( String filename ) { } public void executeCommand ( InputParser parser ) { } public List < Task > getSearchResults ( ) { } public List < Task > getAllTasks ( ) { } private void printTasks ( ) { } private void add ( InputParser parser ) { } private void remove ( InputParser parser ) { } private void clear ( ) { } private void update ( InputParser parser ) { } private void search ( InputParser parser ) { PowerSearch ps = new PowerSearch ( _tasks . getList ( ) ) ; String keyword = parser . getDescription ( ) ; DateTime startTime = parser . getStartTime ( ) ; DateTime endTime = parser . getEndTime ( ) ; if ( ! ( keyword . equals ( "" ) ) ) { <START_BUG> ps . filter ( keyword ) ; <END_BUG> } if ( ( startTime != null ) || ( endTime != null ) ) { ps . filterStartEnd ( startTime , endTime ) ; } searchResult = ps . getResults ( ) ; } }
public abstract class AbstractStringResourceStream extends AbstractResourceStream implements IStringResourceStream { private static final long serialVersionUID = 1L ; public static final String DEFAULT_CONTENT_TYPE = "text" ; private String charsetName ; private final String contentType ; private Time lastModified = null ; public AbstractStringResourceStream ( ) { } public AbstractStringResourceStream ( final String contentType ) { } public String asString ( ) { } protected Charset getCharset ( ) { } public void setCharset ( final Charset charset ) { } public void close ( ) throws IOException { } @ Override public String getContentType ( ) { } public InputStream getInputStream ( ) throws ResourceStreamNotFoundException { } @ Override public Time lastModifiedTime ( ) { } <START_BUG> public void setLastModified ( Time lastModified ) { <END_BUG> this . lastModified = lastModified ; } protected abstract String getString ( ) { } @ Override public final Bytes length ( ) { } }
public class RandomString extends AbstractFunction { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final List < String > desc = new LinkedList < String > ( ) ; private static final String KEY = "__RandomString" ; private CompoundVariable [ ] values ; private static final int MAX_PARAM_COUNT = 3 ; private static final int MIN_PARAM_COUNT = 1 ; private static final int CHARS = 2 ; private static final int PARAM_NAME = 3 ; public RandomString ( ) { } @ Override public synchronized String execute ( SampleResult previousResult , Sampler currentSampler ) throws InvalidVariableException { <START_BUG> int length = Integer . valueOf ( values [ 0 ] . execute ( ) ) ; <END_BUG> String charsToUse = null ; if ( ( values . length ) >= ( RandomString . CHARS ) ) { charsToUse = values [ ( ( RandomString . CHARS ) - 1 ) ] . execute ( ) . trim ( ) ; if ( ( charsToUse . length ( ) ) <= 0 ) { charsToUse = null ; } } String myName = "" ; if ( ( values . length ) >= ( RandomString . PARAM_NAME ) ) { myName = values [ ( ( RandomString . PARAM_NAME ) - 1 ) ] . execute ( ) . trim ( ) ; } String myValue = null ; if ( StringUtils . isEmpty ( charsToUse ) ) { myValue = RandomStringUtils . random ( length ) ; } else { myValue = RandomStringUtils . random ( length , charsToUse ) ; } if ( ( myName . length ( ) ) > 0 ) { JMeterVariables vars = getVariables ( ) ; if ( vars != null ) { vars . put ( myName , myValue ) ; } } if ( RandomString . log . isDebugEnabled ( ) ) { String tn = Thread . currentThread ( ) . getName ( ) ; RandomString . log . debug ( ( ( ( ( tn + "<seq2seq4repair_space>name:" ) + myName ) + "<seq2seq4repair_space>value:" ) + myValue ) ) ; } return myValue ; } @ Override public synchronized void setParameters ( Collection < CompoundVariable > parameters ) throws InvalidVariableException { } @ Override public String getReferenceKey ( ) { } public List < String > getArgumentDesc ( ) { } }
public abstract class DefaultTransitionsBuilder < S extends StateType , C extends StateHolder < S > , X > implements TransitionsBuilder < S , C , X > { Transition < S , C , X > transition ; Multimap < S , Transition < S , C , X > > transitions = HashMultimap . create ( ) ; @ Override public TransitionsBuilder < S , C , X > from ( S state ) { } @ Override public TransitionsBuilder < S , C , X > to ( S state ) { } @ Override public TransitionsBuilder < S , C , X > check ( ConditionChecker < S , C > condition ) { } @ Override public TransitionsBuilder < S , C , X > permit ( String ... roles ) { } @ Override public TransitionsBuilder < S , C , X > validate ( BusinessValidator < S , C > businessValidator ) { } @ Override public TransitionsBuilder < S , C , X > execBefore ( ActionExecutor < S , C , X > executor ) { } @ Override public TransitionsBuilder < S , C , X > execAfter ( ActionExecutor < S , C , X > executor ) { <START_BUG> transition . setBeforeAction ( executor ) ; <END_BUG> return this ; } @ Override public TransitionsBuilder < S , C , X > validate ( Class < ? > ... validationGroups ) { } @ Override public TransitionsBuilder < S , C , X > commit ( ) { } @ Override public Multimap < S , Transition < S , C , X > > build ( ) { } }
public class TreeItem extends Item { Tree parent ; TreeItem parentItem ; TreeItem [ ] items ; int itemCount ; String [ ] strings ; Image [ ] images ; boolean checked ; boolean grayed ; boolean cached ; Color foreground ; Color background ; Color [ ] cellForeground ; Color [ ] cellBackground ; Font font ; Font [ ] cellFont ; int width = - 1 ; SWTTreeItem handle ; static final int IMAGETEXT_MARGIN = 2 ; public TreeItem ( Tree parent , int style ) { } public TreeItem ( Tree parent , int style , int index ) { } public TreeItem ( TreeItem parentItem , int style ) { } public TreeItem ( TreeItem parentItem , int style , int index ) { } TreeItem ( Tree parent , TreeItem parentItem , int style , int index , boolean create ) { } static TreeItem checkNull ( TreeItem item ) { } static Tree checkNull ( Tree parent ) { } static int checkIndex ( int index ) { } int calculateWidth ( int index , GC gc ) { } protected void checkSubclass ( ) { } void clear ( ) { } public void clear ( int index , boolean all ) { } public void clearAll ( boolean all ) { } void clearSelection ( ) { } NSObject createString ( int index ) { } void deregister ( ) { } void destroyWidget ( ) { } public Color getBackground ( ) { } public Color getBackground ( int index ) { } public Rectangle getBounds ( ) { } public Rectangle getBounds ( int index ) { } public boolean getChecked ( ) { } public boolean getExpanded ( ) { } public Font getFont ( ) { } public Font getFont ( int index ) { } public Color getForeground ( ) { } public Color getForeground ( int index ) { } public boolean getGrayed ( ) { } public Image getImage ( ) { } public Image getImage ( int index ) { } public Rectangle getImageBounds ( int index ) { } public TreeItem getItem ( int index ) { } public int getItemCount ( ) { } public TreeItem [ ] getItems ( ) { } String getNameText ( ) { } public Tree getParent ( ) { } public TreeItem getParentItem ( ) { } public String getText ( ) { } public String getText ( int index ) { } public Rectangle getTextBounds ( int index ) { } public int indexOf ( TreeItem item ) { } void redraw ( int columnIndex ) { <START_BUG> if ( ( parent . ignoreRedraw ) || ( ( parent . drawCount ) != 0 ) ) <END_BUG> return ; NSOutlineView outlineView = ( ( NSOutlineView ) ( parent . view ) ) ; NSRect rect ; if ( ( ( ( columnIndex == ( - 1 ) ) || ( parent . hooks ( MeasureItem ) ) ) || ( parent . hooks ( EraseItem ) ) ) || ( parent . hooks ( PaintItem ) ) ) { rect = outlineView . rectOfRow ( outlineView . rowForItem ( handle ) ) ; } else { int index ; if ( ( parent . columnCount ) == 0 ) { index = ( ( ( parent . style ) & ( SWT . CHECK ) ) != 0 ) ? 1 : 0 ; } else { TreeColumn column = parent . getColumn ( columnIndex ) ; index = ( ( int ) ( outlineView . columnWithIdentifier ( column . nsColumn ) ) ) ; } rect = outlineView . frameOfCellAtColumn ( index , outlineView . rowForItem ( handle ) ) ; } outlineView . setNeedsDisplayInRect ( rect ) ; } void register ( ) { } void release ( boolean destroy ) { } void releaseChildren ( boolean destroy ) { } void releaseHandle ( ) { } void releaseWidget ( ) { } public void removeAll ( ) { } public void setBackground ( Color color ) { } public void setBackground ( int index , Color color ) { } public void setChecked ( boolean checked ) { } public void setExpanded ( boolean expanded ) { } public void setFont ( Font font ) { } public void setFont ( int index , Font font ) { } public void setForeground ( Color color ) { } public void setForeground ( int index , Color color ) { } public void setGrayed ( boolean grayed ) { } public void setImage ( Image [ ] images ) { } public void setImage ( int index , Image image ) { } public void setImage ( Image image ) { } public void setItemCount ( int count ) { } public void setText ( String [ ] strings ) { } public void setText ( int index , String string ) { } public void setText ( String string ) { } }
public class PebbleRenderer implements Renderer { private static PebbleEngine build ( Directory root , StampoGlobalConfiguration configuration ) { <START_BUG> PebbleEngine e = new PebbleEngine ( new PebblePathLoader ( configuration . getContentDir ( ) , root ) ) ; <END_BUG> e . addExtension ( new PebbleExtension ( configuration ) ) ; return e ; } @ Override public void registerLayoutRenderer ( Directory root , StampoGlobalConfiguration configuration , Map < String , Function < LayoutParameters , LayoutProcessorOutput > > extensionProcessor ) { } @ Override public void registerResourceRenderer ( Directory root , StampoGlobalConfiguration configuration , Map < String , Function < FileResourceParameters , FileResourceProcessorOutput > > extensionProcessor , Map < String , String > extensionTransformMapping ) { } }
public class DeusNexContentParser { public DeusNexContentParser ( ) { } public DeusNexContentParser setEmbeddedItemElementHandler ( DeusNexEmbeddedItemElementHandler deusNexEmbeddedItemElementHandler ) { } public DeusNexContentParser setFieldElementHandler ( DeusNexFieldElementHandler fieldElementHandler ) { } public Map < String , String > parseContent ( Element documentElement ) throws DeusNexException { if ( ! ( "document" . equals ( documentElement . getTagName ( ) ) ) ) { throw new DeusNexSyntaxException ( "Invalid<seq2seq4repair_space>content<seq2seq4repair_space>document" ) ; } Map < String , String > contents = new HashMap < > ( ) ; Document ownerDocument = documentElement . getOwnerDocument ( ) ; try { List < Element > localeDocuments = DeusNexXmlUtils . getElementsByXPath ( documentElement , "fckdocument" ) ; for ( Element localeDocument : localeDocuments ) { String lang = localeDocument . getAttribute ( "lang" ) ; if ( StringUtils . isBlank ( lang ) ) { throw new DeusNexSyntaxException ( "Locale<seq2seq4repair_space>document<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>specify<seq2seq4repair_space>lang" ) ; } NodeList embeddedItemNodeList = localeDocument . getElementsByTagName ( "ix:embeddeditem" ) ; for ( int i = ( embeddedItemNodeList . getLength ( ) ) - 1 ; i >= 0 ; i -- ) { Element embeddedItemElement = ( ( Element ) ( embeddedItemNodeList . item ( i ) ) ) ; Node replacement = handleEmbeddedItem ( ownerDocument , embeddedItemElement ) ; replaceElement ( ownerDocument , embeddedItemElement , replacement ) ; } NodeList textFieldNodeList = localeDocument . getElementsByTagName ( "ixf:textfield" ) ; for ( int i = ( textFieldNodeList . getLength ( ) ) - 1 ; i >= 0 ; i -- ) { Element element = ( ( Element ) ( textFieldNodeList . item ( i ) ) ) ; Node replacement = handleTextField ( ownerDocument , element ) ; replaceElement ( ownerDocument , element , replacement ) ; } NodeList memoFieldNodeList = localeDocument . getElementsByTagName ( "ixf:memofield" ) ; for ( int i = ( memoFieldNodeList . getLength ( ) ) - 1 ; i >= 0 ; i -- ) { Element element = ( ( Element ) ( memoFieldNodeList . item ( i ) ) ) ; Node replacement = handleMemoField ( ownerDocument , element ) ; replaceElement ( ownerDocument , element , replacement ) ; } NodeList optionListNodeList = localeDocument . getElementsByTagName ( "ixf:optionlist" ) ; for ( int i = ( optionListNodeList . getLength ( ) ) - 1 ; i >= 0 ; i -- ) { Element element = ( ( Element ) ( optionListNodeList . item ( i ) ) ) ; Node replacement = handleOptionListField ( ownerDocument , element ) ; replaceElement ( ownerDocument , element , replacement ) ; } NodeList connectFieldNodeList = localeDocument . getElementsByTagName ( "ixf:connectfield" ) ; for ( int i = ( connectFieldNodeList . getLength ( ) ) - 1 ; i >= 0 ; i -- ) { Element element = ( ( Element ) ( connectFieldNodeList . item ( i ) ) ) ; Node replacement = handleConnectField ( ownerDocument , element ) ; replaceElement ( ownerDocument , element , replacement ) ; } NodeList fileFieldNodeList = localeDocument . getElementsByTagName ( "ixf:uploadfilefield" ) ; for ( int i = ( fileFieldNodeList . getLength ( ) ) - 1 ; i >= 0 ; i -- ) { Element element = ( ( Element ) ( fileFieldNodeList . item ( i ) ) ) ; Node replacement = handleFileField ( ownerDocument , element ) ; replaceElement ( ownerDocument , element , replacement ) ; } Element htmlElement = ownerDocument . createElement ( "html" ) ; Element bodyElement = ownerDocument . createElement ( "body" ) ; htmlElement . appendChild ( bodyElement ) ; NodeList childNodes = localeDocument . getChildNodes ( ) ; for ( int i = ( childNodes . getLength ( ) ) - 1 ; i >= 0 ; i -- ) { if ( ( bodyElement . getFirstChild ( ) ) != null ) { bodyElement . insertBefore ( childNodes . item ( i ) , bodyElement . getFirstChild ( ) ) ; } else { bodyElement . appendChild ( childNodes . item ( i ) ) ; } } <START_BUG> contents . put ( lang , DeusNexXmlUtils . serializeElement ( htmlElement , true , false , "html" , "5" ) ) ; <END_BUG> } } catch ( XPathExpressionException | TransformerException e ) { throw new DeusNexInternalException ( "Internal<seq2seq4repair_space>Error<seq2seq4repair_space>occurred<seq2seq4repair_space>while<seq2seq4repair_space>processing<seq2seq4repair_space>document" , e ) ; } return contents ; } private void replaceElement ( Document ownerDocument , Element element , Node replacement ) throws DeusNexInternalException , XPathExpressionException { } private Node handleEmbeddedItem ( Document ownerDocument , Element embeddedItemElement ) throws DeusNexInternalException , XPathExpressionException { } private Node handleEmbeddedItemHyperLink ( Document ownerDocument , Element embeddedItemElement ) throws XPathExpressionException { } private Node handleEmbeddedItemAudio ( Document ownerDocument , Element embeddedItemElement ) throws XPathExpressionException { } private Node handleEmbeddedItemDocument ( Document ownerDocument , Element embeddedItemElement ) throws XPathExpressionException { } private Node handleEmbeddedItemImage ( Document ownerDocument , Element embeddedItemElement ) throws XPathExpressionException { } private Node handleOptionListField ( Document ownerDocument , Element fieldElement ) throws DeusNexException , XPathExpressionException { } private Node handleCheckListField ( Document ownerDocument , Element fieldElement , String paramName ) throws XPathExpressionException { } private Node handleSingleOptionListField ( Document ownerDocument , Element fieldElement , String paramName , String type ) throws DeusNexException , XPathExpressionException { } private String hintOf ( Element fieldElement ) throws XPathExpressionException { } private String helpOf ( Element fieldElement ) throws XPathExpressionException { } private Node handleTextField ( Document ownerDocument , Element fieldElement ) throws DeusNexException , XPathExpressionException { } private Node handleMemoField ( Document ownerDocument , Element embeddedItemElement ) throws DeusNexException , XPathExpressionException { } private Node handleFileField ( Document ownerDocument , Element embeddedItemElement ) throws DeusNexException , XPathExpressionException { } private Node handleConnectField ( Document ownerDocument , Element fieldElement ) throws DeusNexException , XPathExpressionException { } private DeusNexEmbeddedItemElementHandler embeddedItemElementHandler ; private DeusNexFieldElementHandler fieldElementHandler ; }
public class MainActivity extends AppCompatActivity { ListView lv ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( activity_main ) ; <START_BUG> lv = ( ( ListView ) ( findViewById ( SinhVien ) ) ) ; <END_BUG> ArrayList < SinhVien > mangSinhVien = new ArrayList < SinhVien > ( ) ; mangSinhVien . add ( new SinhVien ( "Nguyen<seq2seq4repair_space>van<seq2seq4repair_space>a" , 1990 ) ) ; mangSinhVien . add ( new SinhVien ( "Nguyen<seq2seq4repair_space>van<seq2seq4repair_space>b" , 1991 ) ) ; mangSinhVien . add ( new SinhVien ( "Nguyen<seq2seq4repair_space>van<seq2seq4repair_space>c" , 1992 ) ) ; mangSinhVien . add ( new SinhVien ( "Nguyen<seq2seq4repair_space>van<seq2seq4repair_space>d" , 1993 ) ) ; mangSinhVien . add ( new SinhVien ( "Nguyen<seq2seq4repair_space>van<seq2seq4repair_space>e" , 1994 ) ) ; ListAdapter adapter = new ListAdapter ( this , layout . activity_dong_sinh_vien , mangSinhVien ) ; lv . setAdapter ( adapter ) ; } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } }
public class SQLStoreQuery extends AbstractStoreQuery { private static final Localizer _loc = Localizer . forPackage ( SQLStoreQuery . class ) ; private final transient JDBCStore _store ; public SQLStoreQuery ( JDBCStore store ) { } public JDBCStore getStore ( ) { } public boolean supportsParameterDeclarations ( ) { } public boolean supportsDataStoreExecution ( ) { } public Executor newDataStoreExecutor ( ClassMetaData meta , boolean subclasses ) { } public boolean requiresCandidateType ( ) { } public boolean requiresParameterDeclarations ( ) { } protected static class SQLExecutor extends AbstractExecutor { private final ClassMetaData _meta ; private final boolean _select ; private final boolean _call ; private final QueryResultMapping _resultMapping ; public SQLExecutor ( SQLStoreQuery q , ClassMetaData candidate ) { } public int getOperation ( StoreQuery q ) { } public Number executeUpdate ( StoreQuery q , Object [ ] params ) { JDBCStore store = ( ( SQLStoreQuery ) ( q ) ) . getStore ( ) ; DBDictionary dict = store . getDBDictionary ( ) ; String sql = q . getContext ( ) . getQueryString ( ) ; List paramList = new ArrayList ( Arrays . asList ( params ) ) ; SQLBuffer buf = new SQLBuffer ( dict ) . append ( sql ) ; store . getContext ( ) . beginStore ( ) ; Connection conn = store . getConnection ( ) ; JDBCFetchConfiguration fetch = ( ( JDBCFetchConfiguration ) ( q . getContext ( ) . getFetchConfiguration ( ) ) ) ; PreparedStatement stmnt = null ; try { if ( _call ) stmnt = prepareCall ( conn , buf ) ; else stmnt = prepareStatement ( conn , buf ) ; buf . setParameters ( paramList ) ; if ( stmnt != null ) buf . setParameters ( stmnt ) ; dict . setTimeouts ( stmnt , fetch , true ) ; int count = executeUpdate ( store , conn , stmnt , buf ) ; <START_BUG> return Numbers . valueOf ( count ) ; <END_BUG> } catch ( SQLException se ) { throw SQLExceptions . getStore ( se , dict ) ; } finally { if ( stmnt != null ) { try { stmnt . close ( ) ; } catch ( SQLException se ) { } finally { stmnt = null ; } } try { conn . close ( ) ; } catch ( SQLException se ) { } } } public ResultObjectProvider executeQuery ( StoreQuery q , Object [ ] params , Range range ) { } public String [ ] getDataStoreActions ( StoreQuery q , Object [ ] params , Range range ) { } public boolean isPacking ( StoreQuery q ) { } protected PreparedStatement prepareCall ( Connection conn , SQLBuffer buf ) throws SQLException { } protected int executeUpdate ( JDBCStore store , Connection conn , PreparedStatement stmnt , SQLBuffer buf ) throws SQLException { } protected PreparedStatement prepareCall ( Connection conn , SQLBuffer buf , JDBCFetchConfiguration fetch , int rsType , int rsConcur ) throws SQLException { } protected PreparedStatement prepareStatement ( Connection conn , SQLBuffer buf ) throws SQLException { } protected PreparedStatement prepareStatement ( Connection conn , SQLBuffer buf , JDBCFetchConfiguration fetch , int rsType , int rsConcur ) throws SQLException { } protected ResultSet executeQuery ( JDBCStore store , Connection conn , PreparedStatement stmnt , SQLBuffer buf , List paramList ) throws SQLException { } public Object [ ] toParameterArray ( StoreQuery q , Map userParams ) { } } public static String substituteParams ( String sql , List < Integer > paramOrder ) throws IOException { } }
public abstract class AnnotationPredictionBuilder { public static AnnotationPredictionTemplate predictFromAnnotation ( Annotation derivedFrom ) { } public static AnnotationPredictionTemplate predictFromSearch ( Property property ) { } private static class SimpleAnnotationPredictionTemplate implements AnnotationPredictionTemplate { private static final AnnotationSource zoomaSource = new SimpleDatabaseAnnotationSource ( URI . create ( "http://www.ebi.ac.uk/spot/zooma" ) , "zooma" ) ; private Collection < BiologicalEntity > biologicalEntities ; private Property searchedProperty ; private Collection < URI > semanticTags ; private AnnotationProvenance annotationProvenance ; private Annotation derivedFrom ; private Confidence confidence ; private SimpleAnnotationPredictionTemplate ( Annotation originalAnnotation ) { } public SimpleAnnotationPredictionTemplate ( Property property ) { } public void init ( ) { } @ Override public Annotation getDerivedFrom ( ) { } @ Override public Confidence getConfidence ( ) { } @ Override public Collection < BiologicalEntity > getAnnotatedBiologicalEntities ( ) { } @ Override public Property getAnnotatedProperty ( ) { } @ Override public Collection < URI > getSemanticTags ( ) { } @ Override public AnnotationProvenance getProvenance ( ) { } @ Override public Collection < URI > getReplacedBy ( ) { } @ Override public void setReplacedBy ( URI ... replacedBy ) { } @ Override public Collection < URI > getReplaces ( ) { } @ Override public void setReplaces ( URI ... replaces ) { } @ Override public URI getURI ( ) { } @ Override public AnnotationPredictionTemplate searchWas ( String propertyValue ) { } @ Override public AnnotationPredictionTemplate searchWas ( String propertyValue , String propertyType ) { <START_BUG> this . searchedProperty = new SimpleTypedProperty ( propertyValue , propertyType ) ; <END_BUG> return this ; } public AnnotationPredictionTemplate forBiologicalEntities ( Collection < BiologicalEntity > biologicalEntities ) { } @ Override public AnnotationPredictionTemplate derivedFrom ( Annotation originalAnnotation ) { } @ Override public AnnotationPredictionTemplate confidenceIs ( Confidence confidence ) { } public AnnotationPrediction build ( ) { } } }
public abstract class JDatabaseRecord2 < T extends JDatabaseRecord2 < ? > > implements Iterable < T > , JSONAware { private static Logger logger = LoggerFactory . getLogger ( JDatabaseRecord2 . class ) ; protected LocalResultSet rs ; protected final String table ; protected final String keyColumnName ; protected final String [ ] columns ; protected JDatabase db = null ; private int ccRow = 0 ; private final HashSet < String > changedColumns = new HashSet < > ( ) ; private boolean saveAlways = false ; private boolean useDefaults = true ; public JDatabaseRecord2 ( JDatabase database ) { } public JDatabaseRecord2 ( JDatabase database , JDROperation operation ) throws JDatabaseException { } public JDatabaseRecord2 ( LocalResultSet rs ) { } public abstract String getKeyColumn ( ) { } public abstract String [ ] getColumns ( ) { } public abstract String getTable ( ) { } public boolean useDefaults ( ) { } public T useDefaults ( boolean value ) { } private void columns ( ) { } protected void defaults ( ) { } public final void setResultSet ( LocalResultSet rs ) { } protected void set ( String column , Object value ) { } private void columnChange ( String changedColumn ) { } private void clearChanged ( ) { } public final T perform ( JDROperation operation ) throws JDatabaseException { } public boolean isSaveAlways ( ) { } public void setSaveAlways ( boolean saveAlways ) { } public JDatabase getDb ( ) { } public final < T extends JDatabaseRecord2 > T setDatabase ( JDatabase database ) { } public final T getById ( Object id ) throws JDatabaseException { } public final T getAll ( ) throws JDatabaseException { } public T getWhere ( String where , Object ... args ) throws JDatabaseException { } public final T getWhereSF ( String where , Object ... args ) throws JDatabaseException { } public T getSql ( String query , Object ... args ) throws JDatabaseException { } public T getSql ( String query , List < ? > args ) throws JDatabaseException { } public int count ( String where , Object ... args ) throws JDatabaseException { } public T save ( ) throws JDatabaseException { } public T delete ( JDatabase db ) throws JDatabaseException { } public T delete ( ) throws JDatabaseException { } public T insertWithoutId ( ) throws JDatabaseException { } public T insert ( ) throws JDatabaseException { if ( ( changedColumns . isEmpty ( ) ) && ( saveAlways ) ) { changedColumns . addAll ( rs . getColumnList ( ) ) ; } if ( changedColumns . isEmpty ( ) ) { return ( ( T ) ( this ) ) ; } if ( ( rs . getObject ( keyColumnName ) ) == null ) { return insertWithoutId ( ) ; } List < String > cols = new ArrayList < > ( changedColumns ) ; List < Object > values = cols . stream ( ) . map ( ( col ) -> rs . getObject ( col ) ) . collect ( Collectors . toList ( ) ) ; String sql = new StringBuilder ( "insert<seq2seq4repair_space>into<seq2seq4repair_space>" ) . append ( table ) . append ( "<seq2seq4repair_space>(" ) . append ( JDatabaseRecord2 . implode ( cols , "," ) ) . append ( ")<seq2seq4repair_space>values<seq2seq4repair_space>(" ) . append ( JDatabaseRecord2 . q ( cols ) ) . append ( ")" ) . toString ( ) ; <START_BUG> db . executeInsert ( sql , values ) ; <END_BUG> clearChanged ( ) ; return ( ( T ) ( this ) ) ; } public int update ( ) throws JDatabaseException { } public LocalResultSet getRs ( ) { } public Object id ( ) { } public T fromJSONObject ( JSONObject o ) throws ClassCastException { } public T fromJSONArray ( JSONArray a ) throws ClassCastException { } public JSONObject toJSONObject ( ) { } public JSONArray toJSONArray ( ) { } @ Override public String toJSONString ( ) { } public JSONObject exportJSON ( boolean map , String ... fields ) throws JDatabaseException { } public JSONObject customJSONMap ( String ... fields ) throws IllegalAccessException , NoSuchMethodException , InvocationTargetException { } public JSONObject customJSON ( String ... fields ) throws IllegalAccessException , NoSuchMethodException , InvocationTargetException { } public JSONArray fetchAll ( boolean map , String ... fields ) throws JDatabaseException { } @ Override public Iterator < T > iterator ( ) { } public Stream < T > stream ( ) { } @ Deprecated public JDatabaseRecord2 ( ) { } @ Deprecated public JDatabaseRecord2 ( JDatabase db , Object id ) throws JDatabaseException { } @ Deprecated public JDatabaseRecord2 ( JDatabase db , String where , Object ... params ) throws JDatabaseException { } @ Deprecated public int update ( JDatabase db ) throws JDatabaseException { } @ Deprecated public T insert ( JDatabase db ) throws JDatabaseException { } @ Deprecated public T insertWithoutId ( JDatabase db ) throws JDatabaseException { } @ Deprecated public final T getById ( JDatabase db , Object id ) throws JDatabaseException { } @ Deprecated public final T getAll ( JDatabase db ) throws JDatabaseException { } @ Deprecated public T getWhere ( JDatabase db , String where , Object ... args ) throws JDatabaseException { } @ Deprecated public final T getWhereSF ( JDatabase db , String where , Object ... args ) throws JDatabaseException { } @ Deprecated public T getSql ( JDatabase db , String query , Object ... args ) throws JDatabaseException { } @ Deprecated public T save ( JDatabase db ) throws JDatabaseException { } }
public final class ObjectInvokeHelper { private ObjectInvokeHelper ( ) { } public static Memory invokeParentMethod ( Memory object , String methodName , String methodLowerName , Environment env , TraceInfo trace , Memory [ ] args ) throws Throwable { Memory [ ] passed = null ; boolean doublePop = false ; if ( object . isNull ( ) ) { ClassEntity parent = env . __getParentClass ( trace ) ; return InvokeHelper . callStatic ( env , trace , parent . getLowerName ( ) , methodLowerName , parent . getName ( ) , methodName , args , null , 0 ) ; } IObject iObject = ( ( ObjectMemory ) ( object ) ) . value ; ClassEntity childClazz = iObject . getReflection ( ) ; <START_BUG> ClassEntity clazz = childClazz . getParent ( ) ; <END_BUG> MethodEntity method ; if ( clazz == null ) { env . error ( trace , "Cannot<seq2seq4repair_space>access<seq2seq4repair_space>parent::<seq2seq4repair_space>when<seq2seq4repair_space>current<seq2seq4repair_space>class<seq2seq4repair_space>scope<seq2seq4repair_space>has<seq2seq4repair_space>no<seq2seq4repair_space>parent" ) ; return Memory . NULL ; } if ( methodName == null ) { method = ( ( childClazz . methodMagicInvoke ) != null ) ? childClazz . methodMagicInvoke : clazz . methodMagicInvoke ; } else { method = clazz . findMethod ( methodLowerName ) ; if ( ( method == null ) && ( ( method = ( ( childClazz . methodMagicCall ) != null ) ? childClazz . methodMagicCall : clazz . methodMagicCall ) != null ) ) { passed = new Memory [ ] { new StringMemory ( methodName ) , new php . runtime . memory . ArrayMemory ( true , args ) } ; doublePop = true ; } } String className = clazz . getName ( ) ; if ( method == null ) { if ( methodName == null ) methodName = "__invoke" ; env . error ( trace , E_ERROR , ERR_CALL_TO_UNDEFINED_METHOD . fetch ( ( ( className + "::" ) + methodName ) ) ) ; } InvokeHelper . checkAccess ( env , trace , method ) ; if ( passed == null ) { passed = InvokeHelper . makeArguments ( env , args , method . getParameters ( ) , className , methodName , trace ) ; } Memory result = method . getImmutableResult ( ) ; if ( result != null ) return result ; try { if ( trace != null ) { env . pushCall ( trace , iObject , args , methodName , method . getClazz ( ) . getName ( ) , className ) ; if ( doublePop ) env . pushCall ( trace , iObject , passed , method . getName ( ) , method . getClazz ( ) . getName ( ) , className ) ; } result = method . invokeDynamic ( iObject , env , passed ) ; } finally { if ( trace != null ) { env . popCall ( ) ; if ( doublePop ) env . popCall ( ) ; } } return result ; } public static Memory invokeMethod ( Memory object , String methodName , Environment env , TraceInfo trace , Memory ... args ) throws Throwable { } public static Memory invokeMethod ( Memory object , String methodName , Environment env , Memory ... args ) throws Throwable { } public static Memory invokeMethod ( Memory object , String methodName , String methodLowerName , Environment env , TraceInfo trace , Memory [ ] args ) throws Throwable { } public static Memory invokeMethod ( IObject iObject , MethodEntity method , Environment env , TraceInfo trace , Memory [ ] args ) throws Throwable { } public static Memory invokeMethod ( IObject iObject , MethodEntity method , Environment env , TraceInfo trace , Memory [ ] args , boolean checkAccess ) throws Throwable { } public static Memory emptyProperty ( Memory object , String property , Environment env , TraceInfo trace ) throws Throwable { } public static Memory issetProperty ( Memory object , String property , Environment env , TraceInfo trace ) throws Throwable { } public static void unsetProperty ( Memory object , String property , Environment env , TraceInfo trace ) throws Throwable { } public static Memory getConstant ( String className , String lowerClassName , String constant , Environment env , TraceInfo trace ) { } public static Memory getProperty ( Memory object , String property , Environment env , TraceInfo trace ) throws Throwable { } public static Memory getRefProperty ( Memory object , String property , Environment env , TraceInfo trace ) throws Throwable { } public static Memory getStaticProperty ( String className , String lowerClassName , String property , Environment env , TraceInfo trace ) throws Throwable { } public static Memory issetStaticProperty ( String className , String lowerClassName , String property , Environment env , TraceInfo trace ) throws Throwable { } public static Memory unsetStaticProperty ( String className , String lowerClassName , String property , Environment env , TraceInfo trace ) throws Throwable { } private static IObject fetchObject ( Memory object , String property , Environment env , TraceInfo trace ) { } public static Memory incAndGetProperty ( Memory object , String property , Environment env , TraceInfo trace ) throws Throwable { } public static Memory GetAndIncProperty ( Memory object , String property , Environment env , TraceInfo trace ) throws Throwable { } public static Memory decAndGetProperty ( Memory object , String property , Environment env , TraceInfo trace ) throws Throwable { } public static Memory GetAndDecProperty ( Memory object , String property , Environment env , TraceInfo trace ) throws Throwable { } public static Memory assignProperty ( Memory object , Memory value , String property , Environment env , TraceInfo trace ) throws Throwable { } public static Memory assignPropertyRight ( Memory value , String property , Environment env , TraceInfo trace , Memory object ) throws Throwable { } public static Memory assignPlusProperty ( Memory object , Memory value , String property , Environment env , TraceInfo trace ) throws Throwable { }
public class ResultSearchDetailFragment extends Fragment { private Event event ; @ Nullable @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { } @ Override public void onViewCreated ( View view , @ Nullable Bundle savedInstanceState ) { } public void setEvent ( Event event ) { } public class MyAdapter extends FragmentPagerAdapter { public MyAdapter ( FragmentManager fm ) { } @ Override public int getCount ( ) { } @ Override public Fragment getItem ( int position ) { switch ( position ) { case 0 : EventDetailFragment fragment = new EventDetailFragment ( ) ; fragment . setEvent ( event ) ; return fragment ; case 1 : SupportMapFragment mapFragment = SupportMapFragment . newInstance ( ) ; mapFragment . getMapAsync ( new OnMapReadyCallback ( ) { @ Override public void onMapReady ( GoogleMap googleMap ) { googleMap . addMarker ( new MarkerOptions ( ) . position ( event . getLocationAsLatlng ( ) ) . title ( event . getName ( ) ) . snippet ( event . getDate ( ) ) ) ; googleMap . animateCamera ( CameraUpdateFactory . newLatLngZoom ( event . getLocationAsLatlng ( ) , 5 ) ) ; } } ) ; <START_BUG> return SupportMapFragment . newInstance ( ) ; <END_BUG> default : return null ; } } @ Override public CharSequence getPageTitle ( int position ) { } } }
public class LDAPConnectionUtils { private static Hashtable < String , String > env = null ; private static final String LDAP_URL_PREFIX = "ldap://" ; private static final String LDAPS_URL_PREFIX = "ldaps://" ; private static final String CONTEXT_FACTORY = "com.sun.jndi.ldap.LdapCtxFactory" ; private static InitialLdapContext ctx = null ; public static Object [ ] getAttributes ( SchemaOps schema , LDAPSchemaConnection talendLDAPConnection ) { } private static void featchAttributes ( Attribute oc , Set < String > attributeSet , SchemaOps schema ) { } public static List < String > fetchBaseDNs ( ) { } public static boolean checkParam ( LDAPSchemaConnection connection , boolean isStep1Check ) { String hostName = connection . getHost ( ) ; String port = connection . getPort ( ) ; String protocol = connection . getProtocol ( ) ; if ( isStep1Check ) { protocol = ANONYMOUS . getName ( ) ; } String encryptionMethod = connection . getEncryptionMethodName ( ) ; String userOrBindId = connection . getBindPrincipal ( ) ; String password = connection . getValue ( connection . getBindPassword ( ) , false ) ; String aliasesDereference = connection . getAliases ( ) ; String referral = connection . getReferrals ( ) ; boolean isAuthUsed = connection . isUseAuthen ( ) ; LDAPConnectionUtils . env = new Hashtable < String , String > ( ) ; LDAPConnectionUtils . env . put ( Context . INITIAL_CONTEXT_FACTORY , LDAPConnectionUtils . CONTEXT_FACTORY ) ; if ( protocol . equals ( SIMPLE . getName ( ) ) ) { LDAPConnectionUtils . env . put ( Context . SECURITY_AUTHENTICATION , "simple" ) ; } else { LDAPConnectionUtils . env . put ( Context . SECURITY_AUTHENTICATION , "none" ) ; } if ( ( isAuthUsed && ( userOrBindId != null ) ) && ( ( userOrBindId . length ( ) ) > 0 ) ) { LDAPConnectionUtils . env . put ( Context . SECURITY_PRINCIPAL , userOrBindId ) ; } if ( ( isAuthUsed && ( password != null ) ) && ( ( password . length ( ) ) > 0 ) ) { LDAPConnectionUtils . env . put ( Context . SECURITY_CREDENTIALS , password ) ; } if ( ( aliasesDereference != null ) && ( ( aliasesDereference . length ( ) ) > 0 ) ) { LDAPConnectionUtils . env . put ( "java.naming.ldap.derefAliases" , aliasesDereference ) ; } if ( ( referral != null ) && ( ( referral . length ( ) ) > 0 ) ) { LDAPConnectionUtils . env . put ( Context . REFERRAL , referral ) ; } String hostUrl = "" ; if ( ( encryptionMethod . equals ( SSL_ENCRYPTION_METHOD . getName ( ) ) ) || ( encryptionMethod . equals ( STARTTSL_EXTENSION_METHOD . getName ( ) ) ) ) { hostUrl = ( ( ( LDAPConnectionUtils . LDAPS_URL_PREFIX ) + hostName ) + ":" ) + port ; LDAPConnectionUtils . env . put ( Context . SECURITY_PROTOCOL , "ssl" ) ; <START_BUG> LDAPConnectionUtils . env . put ( "java.naming.ldap.factory.socket" , "org.talend.core.ldap.AdvancedSocketFactory" ) ; <END_BUG> } else if ( encryptionMethod . equals ( NO_ENCRYPTION_METHOD . getName ( ) ) ) { hostUrl = ( ( ( LDAPConnectionUtils . LDAP_URL_PREFIX ) + hostName ) + ":" ) + port ; LDAPConnectionUtils . env . remove ( Context . SECURITY_PROTOCOL ) ; } LDAPConnectionUtils . env . put ( Context . PROVIDER_URL , hostUrl ) ; try { LDAPConnectionUtils . ctx = new InitialLdapContext ( LDAPConnectionUtils . env , null ) ; if ( encryptionMethod . equals ( STARTTSL_EXTENSION_METHOD ) ) { StartTlsRequest tldsReq = new StartTlsRequest ( ) ; StartTlsResponse tls = ( ( StartTlsResponse ) ( LDAPConnectionUtils . ctx . extendedOperation ( tldsReq ) ) ) ; SSLSession session = tls . negotiate ( ( ( SSLSocketFactory ) ( AdvancedSocketFactory . getDefault ( ) ) ) ) ; } return true ; } catch ( Exception e ) { ExceptionHandler . process ( e ) ; return false ; } } }
public class TypeReferenceLocator extends PatternLocator { protected TypeReferencePattern pattern ; protected boolean isDeclarationOfReferencedTypesPattern ; public TypeReferenceLocator ( TypeReferencePattern pattern ) { } protected IJavaElement findElement ( IJavaElement element , int accuracy ) { } public int match ( Annotation node , MatchingNodeSet nodeSet ) { } public int match ( ASTNode node , MatchingNodeSet nodeSet ) { } public int match ( Reference node , MatchingNodeSet nodeSet ) { } public int match ( TypeReference node , MatchingNodeSet nodeSet ) { } protected int matchLevel ( ImportReference importRef ) { } protected void matchLevelAndReportImportRef ( ImportReference importRef , Binding binding , MatchLocator locator ) throws CoreException { } protected void matchReportImportRef ( ImportReference importRef , Binding binding , IJavaElement element , int accuracy , MatchLocator locator ) throws CoreException { } protected void matchReportReference ( ArrayTypeReference arrayRef , IJavaElement element , Binding elementBinding , int accuracy , MatchLocator locator ) throws CoreException { } protected void matchReportReference ( ASTNode reference , IJavaElement element , Binding elementBinding , int accuracy , MatchLocator locator ) throws CoreException { } protected void matchReportReference ( ASTNode reference , IJavaElement element , IJavaElement localElement , IJavaElement [ ] otherElements , Binding elementBinding , int accuracy , MatchLocator locator ) throws CoreException { } protected void matchReportReference ( ASTNode reference , IJavaElement element , Binding elementBinding , Scope scope , int accuracy , MatchLocator locator ) throws CoreException { } protected void matchReportReference ( QualifiedNameReference qNameRef , IJavaElement element , Binding elementBinding , int accuracy , MatchLocator locator ) throws CoreException { } protected void matchReportReference ( QualifiedTypeReference qTypeRef , IJavaElement element , Binding elementBinding , int accuracy , MatchLocator locator ) throws CoreException { } void matchReportReference ( Expression expr , int lastIndex , TypeBinding refBinding , MatchLocator locator ) throws CoreException { } protected int referenceType ( ) { } protected void reportDeclaration ( ASTNode reference , IJavaElement element , MatchLocator locator , SimpleSet knownTypes ) throws CoreException { } protected void reportDeclaration ( ReferenceBinding typeBinding , int maxType , MatchLocator locator , SimpleSet knownTypes ) throws CoreException { IType type = locator . lookupType ( typeBinding ) ; if ( type == null ) return ; IResource resource = type . getResource ( ) ; boolean isBinary = type . isBinary ( ) ; IBinaryType info = null ; if ( isBinary ) { if ( resource == null ) resource = type . getJavaProject ( ) . getProject ( ) ; info = locator . getBinaryInfo ( ( ( ClassFile ) ( type . getClassFile ( ) ) ) , resource ) ; } while ( ( maxType >= 0 ) && ( type != null ) ) { if ( ! ( knownTypes . includes ( type ) ) ) { if ( isBinary ) { locator . reportBinaryMemberDeclaration ( resource , type , typeBinding , info , SearchMatch . A_ACCURATE ) ; } else { if ( typeBinding instanceof ParameterizedTypeBinding ) <START_BUG> typeBinding = ( ( ParameterizedTypeBinding ) ( typeBinding ) ) . type ; <END_BUG> ClassScope scope = ( ( SourceTypeBinding ) ( typeBinding ) ) . scope ; if ( scope != null ) { TypeDeclaration typeDecl = scope . referenceContext ; int offset = typeDecl . sourceStart ; match = new TypeDeclarationMatch ( ( ( JavaElement ) ( type ) ) . resolved ( typeBinding ) , SearchMatch . A_ACCURATE , offset , ( ( ( typeDecl . sourceEnd ) - offset ) + 1 ) , locator . getParticipant ( ) , resource ) ; locator . report ( match ) ; } } knownTypes . add ( type ) ; } typeBinding = typeBinding . enclosingType ( ) ; IJavaElement parent = type . getParent ( ) ; if ( parent instanceof IType ) { type = ( ( IType ) ( parent ) ) ; } else { type = null ; } maxType -- ; } } public int resolveLevel ( ASTNode node ) { } public int resolveLevel ( Binding binding ) { } protected int resolveLevel ( NameReference nameRef ) { } protected int resolveLevel ( TypeReference typeRef ) { } protected int resolveLevelForType ( TypeBinding typeBinding ) { } protected int resolveLevelForTypeOrEnclosingTypes ( char [ ] simpleNamePattern , char [ ] qualificationPattern , TypeBinding binding ) { } public String toString ( ) { } }
public final class RawMarkup extends MarkupElement { private final CharSequence string ; public RawMarkup ( final CharSequence string ) { } @ Override public boolean equals ( final Object o ) { <START_BUG> if ( o instanceof String ) { <END_BUG> return string . equals ( o ) ; } if ( o instanceof RawMarkup ) { return string . equals ( ( ( RawMarkup ) ( o ) ) . string ) ; } return false ; } @ Override public boolean equalTo ( final MarkupElement element ) { } @ Override public int hashCode ( ) { } @ Override public CharSequence toCharSequence ( ) { } @ Override public String toString ( ) { } @ Override public String toUserDebugString ( ) { } }
public class PersistenceContextInjectionSource extends InjectionSource { private final PersistenceContextType type ; private final PersistenceContextInjectionSource . PersistenceContextJndiInjectable injectable ; private final ServiceName puServiceName ; public PersistenceContextInjectionSource ( final PersistenceContextType type , final SynchronizationType synchronizationType , final Map properties , final ServiceName puServiceName , final ServiceRegistry serviceRegistry , final String scopedPuName , final String injectionTypeName , final PersistenceUnitMetadata pu , final JPADeploymentSettings jpaDeploymentSettings ) { } public void getResourceValue ( final ResolutionContext resolutionContext , final ServiceBuilder < ? > serviceBuilder , final DeploymentPhaseContext phaseContext , final Injector < ManagedReferenceFactory > injector ) throws DeploymentUnitProcessingException { } public boolean equals ( Object other ) { } public int hashCode ( ) { } private static final class PersistenceContextJndiInjectable implements ManagedReferenceFactory { private final ServiceName puServiceName ; private final ServiceRegistry serviceRegistry ; private final PersistenceContextType type ; private final SynchronizationType synchronizationType ; private final Map properties ; private final String unitName ; private final String injectionTypeName ; private final PersistenceUnitMetadata pu ; private final JPADeploymentSettings jpaDeploymentSettings ; private static final String ENTITY_MANAGER_CLASS = "javax.persistence.EntityManager" ; public PersistenceContextJndiInjectable ( final ServiceName puServiceName , final ServiceRegistry serviceRegistry , final PersistenceContextType type , SynchronizationType synchronizationType , final Map properties , final String unitName , final String injectionTypeName , final PersistenceUnitMetadata pu , final JPADeploymentSettings jpaDeploymentSettings ) { } @ Override public ManagedReference getReference ( ) { PersistenceUnitServiceImpl service = ( ( PersistenceUnitServiceImpl ) ( serviceRegistry . getRequiredService ( puServiceName ) . getValue ( ) ) ) ; EntityManagerFactory emf = service . getEntityManagerFactory ( ) ; EntityManager entityManager ; boolean standardEntityManager = PersistenceContextInjectionSource . PersistenceContextJndiInjectable . ENTITY_MANAGER_CLASS . equals ( injectionTypeName ) ; if ( type . equals ( TRANSACTION ) ) { entityManager = new org . jboss . as . jpa . container . TransactionScopedEntityManager ( unitName , properties , emf , synchronizationType ) ; if ( JPA_LOGGER . isDebugEnabled ( ) ) JPA_LOGGER . debugf ( "created<seq2seq4repair_space>new<seq2seq4repair_space>TransactionScopedEntityManager<seq2seq4repair_space>for<seq2seq4repair_space>unit<seq2seq4repair_space>name=%s" , unitName ) ; } else { boolean useDeepInheritance = ! ( SHALLOW . equals ( JPAService . getDefaultExtendedPersistenceInheritance ( ) ) ) ; if ( ( jpaDeploymentSettings ) != null ) { useDeepInheritance = DEEP . equals ( jpaDeploymentSettings . getExtendedPersistenceInheritanceType ( ) ) ; } boolean createdNewExtendedPersistence = false ; ExtendedEntityManager entityManager1 ; if ( useDeepInheritance ) { entityManager1 = INSTANCE . findExtendedPersistenceContext ( unitName ) ; } else { entityManager1 = ExtendedPersistenceShallowInheritance . INSTANCE . findExtendedPersistenceContext ( unitName ) ; } if ( entityManager1 == null ) { <START_BUG> entityManager1 = new ExtendedEntityManager ( unitName , emf . createEntityManager ( properties ) , synchronizationType ) ; <END_BUG> createdNewExtendedPersistence = true ; if ( JPA_LOGGER . isDebugEnabled ( ) ) JPA_LOGGER . debugf ( "created<seq2seq4repair_space>new<seq2seq4repair_space>ExtendedEntityManager<seq2seq4repair_space>for<seq2seq4repair_space>unit<seq2seq4repair_space>name=%s,<seq2seq4repair_space>useDeepInheritance<seq2seq4repair_space>=<seq2seq4repair_space>%b" , unitName , useDeepInheritance ) ; } else { entityManager1 . increaseReferenceCount ( ) ; if ( JPA_LOGGER . isDebugEnabled ( ) ) JPA_LOGGER . debugf ( ( "inherited<seq2seq4repair_space>existing<seq2seq4repair_space>ExtendedEntityManager<seq2seq4repair_space>from<seq2seq4repair_space>SFSB<seq2seq4repair_space>invocation<seq2seq4repair_space>stack,<seq2seq4repair_space>unit<seq2seq4repair_space>name=%s,<seq2seq4repair_space>" + "%d<seq2seq4repair_space>beans<seq2seq4repair_space>sharing<seq2seq4repair_space>ExtendedEntityManager,<seq2seq4repair_space>useDeepInheritance<seq2seq4repair_space>=<seq2seq4repair_space>%b" ) , unitName , entityManager1 . getReferenceCount ( ) , useDeepInheritance ) ; } entityManager = entityManager1 ; CreatedEntityManagers . registerPersistenceContext ( entityManager1 ) ; if ( createdNewExtendedPersistence ) { if ( useDeepInheritance ) { INSTANCE . registerExtendedPersistenceContext ( unitName , entityManager1 ) ; } else { ExtendedPersistenceShallowInheritance . INSTANCE . registerExtendedPersistenceContext ( unitName , entityManager1 ) ; } } } if ( ! standardEntityManager ) { Class extensionClass ; try { extensionClass = pu . getClassLoader ( ) . loadClass ( injectionTypeName ) ; } catch ( ClassNotFoundException e ) { throw MESSAGES . cannotLoadFromJpa ( e , injectionTypeName ) ; } Object targetValueToInject = entityManager . unwrap ( extensionClass ) ; Class [ ] targetInterfaces = targetValueToInject . getClass ( ) . getInterfaces ( ) ; Class [ ] proxyInterfaces = new Class [ ( targetInterfaces . length ) + 1 ] ; boolean alreadyHasInterfaceClass = false ; for ( int interfaceIndex = 0 ; interfaceIndex < ( targetInterfaces . length ) ; interfaceIndex ++ ) { Class interfaceClass = targetInterfaces [ interfaceIndex ] ; if ( interfaceClass . equals ( extensionClass ) ) { proxyInterfaces = targetInterfaces ; alreadyHasInterfaceClass = true ; break ; } proxyInterfaces [ ( 1 + interfaceIndex ) ] = interfaceClass ; } if ( ! alreadyHasInterfaceClass ) { proxyInterfaces [ 0 ] = extensionClass ; } EntityManagerUnwrappedTargetInvocationHandler entityManagerUnwrappedTargetInvocationHandler = new EntityManagerUnwrappedTargetInvocationHandler ( entityManager , extensionClass ) ; Object proxyForUnwrappedObject = Proxy . newProxyInstance ( extensionClass . getClassLoader ( ) , proxyInterfaces , entityManagerUnwrappedTargetInvocationHandler ) ; if ( JPA_LOGGER . isDebugEnabled ( ) ) JPA_LOGGER . debugf ( "injecting<seq2seq4repair_space>entity<seq2seq4repair_space>manager<seq2seq4repair_space>into<seq2seq4repair_space>a<seq2seq4repair_space>'%s'<seq2seq4repair_space>(unit<seq2seq4repair_space>name=%s)" , extensionClass . getName ( ) , unitName ) ; return new ValueManagedReference ( new org . jboss . msc . value . ImmediateValue < Object > ( proxyForUnwrappedObject ) ) ; } return new ValueManagedReference ( new org . jboss . msc . value . ImmediateValue < Object > ( entityManager ) ) ; } } }
public final class FeedbackMessages { private static Log log = LogFactory . getLog ( FeedbackMessages . class ) ; private static final ThreadLocal current = new ThreadLocal ( ) ; private List messages = null ; public static final class LevelComparator implements Comparator { private static final int ASCENDING = 1 ; private static final int DESCENDING = - 1 ; private final int sign ; public LevelComparator ( boolean ascending ) { } public int compare ( Object o1 , Object o2 ) { } } private static class UIMessagesModel implements IModel { private int level = FeedbackMessage . UNDEFINED ; public UIMessagesModel ( ) { } public UIMessagesModel ( final int level ) { } public Object getObject ( ) { } public void setObject ( Object object ) { FeedbackMessages messages = FeedbackMessages . get ( ) ; if ( object instanceof List ) { messages . setMessages ( ( ( List ) ( object ) ) ) ; } else if ( object instanceof FeedbackMessage [ ] ) { if ( object != null ) { messages . setMessages ( Arrays . asList ( ( ( FeedbackMessage [ ] ) ( object ) ) ) ) ; } else { messages . setMessages ( null ) ; } } else { <START_BUG> throw new RuntimeException ( "Invalid<seq2seq4repair_space>model<seq2seq4repair_space>type<seq2seq4repair_space>for<seq2seq4repair_space>FeedbackMessages" ) ; <END_BUG> } } } private FeedbackMessages ( ) { } public static FeedbackMessages get ( ) { } static void set ( FeedbackMessages messages ) { } static void release ( ) { } static void remove ( ) { } public static IModel model ( ) { } public static IModel model ( int level ) { } public static void debug ( Component reporter , String message ) { } public static void info ( Component reporter , String message ) { } public static void warn ( Component reporter , String message ) { } public static void error ( Component reporter , String message ) { } public static void fatal ( Component reporter , String message ) { } public FeedbackMessages add ( FeedbackMessage message ) { } public boolean hasMessages ( ) { } public boolean hasErrorMessages ( ) { } public boolean hasMessages ( final int level ) { } public List getMessages ( ) { } public List getMessagesAscending ( ) { } public List getMessagesDescending ( ) { } private List getMessagesSorted ( boolean ascending ) { } public Iterator iterator ( ) { } public FeedbackMessage getMessageFor ( Component component ) { } public boolean hasMessageFor ( Component component ) { } public boolean hasErrorMessageFor ( Component component ) { } public boolean hasMessageFor ( Component component , int level ) { } public FeedbackMessages getErrorMessages ( ) { } public FeedbackMessages getMessages ( int level ) { } private FeedbackMessages setMessages ( List messages ) { } public Set getErrorReporters ( ) { } public Set getReporters ( final int level ) { } public String toString ( ) { } }
public class Loading extends AppCompatActivity { @ Bind ( id . gambarbesar ) ImageView gambarbesar ; private Handler mHandler ; Runnable splash = new Runnable ( ) { @ Override public void run ( ) { } } ; private Parseran mParseran ; private CekGPSNet mCekGPSNet ; private String jsonkomoditas = "" ; private Realm mRealm ; private RealmQuery < RMJsonData > mRealmQueryJson ; private RealmResults < RMJsonData > mRealmResultsJson ; private RealmQuery < RMLogin > mRealmQueryLogin ; private RealmResults < RMLogin > mRealmResultsLogin ; private boolean isAktivitasJalan = false ; private boolean isRealmUpdate = false ; private boolean isInternetAda = false ; private long mLongWaktuSekarang = 0 ; private String strwaktudb = "0" ; private Calendar mCalendar ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( loadings ) ; ButterKnife . bind ( this ) ; <START_BUG> Glide . with ( this ) . load ( web_hi_res_512 ) . into ( gambarbesar ) ; <END_BUG> RealmConfiguration realmConfiguration = new RealmConfiguration . Builder ( this ) . build ( ) ; try { mRealm = Realm . getInstance ( realmConfiguration ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; isRealmUpdate = Realm . deleteRealm ( realmConfiguration ) ; } if ( isRealmUpdate ) { mRealm = Realm . getInstance ( realmConfiguration ) ; } isAktivitasJalan = true ; mCalendar = Calendar . getInstance ( ) ; mLongWaktuSekarang = mCalendar . getTimeInMillis ( ) ; mParseran = new Parseran ( this ) ; mCekGPSNet = new CekGPSNet ( this ) ; ambilDataDatabase ( ) ; } @ Override protected void onDestroy ( ) { } private void ambilDataDatabase ( ) { } private void ambilAsetJson ( ) { } private void ambilDataServerKomoditas ( ) { } private void cekSimpanData ( String strjsonserver ) { } private void pindahHalaman ( ) { } private void munculSnackbar ( int resPesan ) { } OnClickListener listenersnackbar = new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { } } ; }
public class MainActivity extends ActionBarActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( activity_main ) ; Button btn = ( ( Button ) ( findViewById ( button ) ) ) ; btn . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { ArrowPopWindows arrowPopWindows = new ArrowPopWindows ( MainActivity . this , layout . layout , new ArrowPopWindows . OnViewCreateListener ( ) { @ Override public void onViewCreate ( ViewGroup viewGroup ) { } } ) ; <START_BUG> arrowPopWindows . show ( view , SHOW_BLOW ) ; <END_BUG> } } ) ; } }
public class PackageMapper extends AbstractBookmarkableMapper { private final String mountPath ; private final PackageName packageName ; private final IPageParametersEncoder pageParametersEncoder ; public PackageMapper ( final String mountPath , final PackageName packageName ) { } public PackageMapper ( final String mountPath , final PackageName packageName , final IPageParametersEncoder pageParametersEncoder ) { } @ Override protected Url buildUrl ( UrlInfo info ) { Class < ? extends IRequestablePage > pageClass = info . getPageClass ( ) ; <START_BUG> if ( pageClass . getName ( ) . startsWith ( packageName . getName ( ) ) ) { <END_BUG> Url url = new Url ( ) ; url . getSegments ( ) . add ( mountPath ) ; url . getSegments ( ) . add ( pageClass . getSimpleName ( ) ) ; encodePageComponentInfo ( url , info . getPageComponentInfo ( ) ) ; return encodePageParameters ( url , info . getPageParameters ( ) , pageParametersEncoder ) ; } return null ; } @ Override protected UrlInfo parseRequest ( Request request ) { } @ Override protected boolean pageMustHaveBeenCreatedBookmarkable ( ) { } @ Override public int getCompatibilityScore ( Request request ) { } }
public class Lexer implements Scanner { private ArrayList < Symbol > tokens = new ArrayList < Symbol > ( ) ; private ArrayList < Object [ ] > errorLog ; private boolean done = false ; int lineNumber = 0 ; int readerLineNumber = 0 ; private BufferedReader bufferToRead ; private int tokenIndex = 0 ; public boolean useLineNumbers = false ; public Symbol next_token ( ) { } public Lexer ( BufferedReader bufferToRead ) throws IOException { } private Symbol symbol ( int type ) { } private Symbol symbol ( int type , Object value ) { } public ArrayList < Symbol > getTokens ( ) { } private static int EOF = - 1 ; private boolean isKeyword ( StringBuffer str ) { } private boolean isKeySymbol ( StringBuffer str ) { } private boolean isAdditiveOp ( StringBuffer str ) { } private boolean isRelationalOp ( StringBuffer str ) { } private boolean isMultiplicativeOp ( StringBuffer str ) { } private boolean isIdentifier ( StringBuffer str ) { } private boolean isType ( StringBuffer str ) { } private boolean isBooleanLiteral ( StringBuffer str ) { boolean out = true ; if ( str . toString ( ) . equals ( "true" ) ) { tokens . add ( symbol ( BOOLEAN_LITERAL , new Boolean ( true ) ) ) ; } else if ( str . toString ( ) . equals ( "false" ) ) { <START_BUG> tokens . add ( symbol ( BOOLEAN_LITERAL , new Boolean ( true ) ) ) ; <END_BUG> } else { out = false ; } return out ; } private boolean isIntegerLiteral ( StringBuffer str ) { } private boolean isRealLiteral ( StringBuffer str ) { } private boolean isCharLiteral ( StringBuffer str ) { } private boolean isStringLiteral ( StringBuffer str ) { } private boolean isUnitLiteral ( StringBuffer str ) { } private ArrayList < Symbol > lexIt ( ) throws IOException { } private boolean process ( String strIn ) { } private StringBuilder getWord ( ) throws IOException { } private int dumpWhiteSpace ( ) throws IOException { } private int dumpUntilNewLine ( ) throws IOException { } private boolean isNewLine ( char c ) { } private boolean isWhiteSpace ( char c ) { } public int errorsCount ( ) { } private void errorLogger ( String str , int lineNumber ) { } private void dumpErrors ( ) { } No newline ; at end ; of file ; }
public class P4Counter extends P4Base { public String counter = null ; public String property = null ; public boolean shouldSetValue = false ; public boolean shouldSetProperty = false ; public int value = 0 ; public void setName ( String counter ) { } public void setProperty ( String property ) { } public void setValue ( int value ) { } public void execute ( ) throws TaskException { if ( ( ( counter ) == null ) || ( ( counter . length ( ) ) == 0 ) ) { throw new TaskException ( "No<seq2seq4repair_space>counter<seq2seq4repair_space>specified<seq2seq4repair_space>to<seq2seq4repair_space>retrieve" ) ; } if ( ( shouldSetValue ) && ( shouldSetProperty ) ) { throw new TaskException ( "Cannot<seq2seq4repair_space>both<seq2seq4repair_space>set<seq2seq4repair_space>the<seq2seq4repair_space>value<seq2seq4repair_space>of<seq2seq4repair_space>the<seq2seq4repair_space>property<seq2seq4repair_space>and<seq2seq4repair_space>retrieve<seq2seq4repair_space>the<seq2seq4repair_space>value<seq2seq4repair_space>of<seq2seq4repair_space>the<seq2seq4repair_space>property." ) ; } String command = ( ( "counter<seq2seq4repair_space>" + ( P4CmdOpts ) ) + "<seq2seq4repair_space>" ) + ( counter ) ; if ( ! ( shouldSetProperty ) ) { command = "-s<seq2seq4repair_space>" + command ; } if ( shouldSetValue ) { command += "<seq2seq4repair_space>" + ( value ) ; } if ( shouldSetProperty ) { <START_BUG> final Project myProj = project ; <END_BUG> P4Handler handler = new P4HandlerAdapter ( ) { public void process ( String line ) { log ( ( ( "P4Counter<seq2seq4repair_space>retrieved<seq2seq4repair_space>line<seq2seq4repair_space>\"" + line ) + "\"" ) , MSG_VERBOSE ) ; try { value = Integer . parseInt ( line ) ; setProperty ( property , ( "" + ( value ) ) ) ; } catch ( NumberFormatException nfe ) { throw new TaskException ( "Perforce<seq2seq4repair_space>error.<seq2seq4repair_space>Could<seq2seq4repair_space>not<seq2seq4repair_space>retrieve<seq2seq4repair_space>counter<seq2seq4repair_space>value." ) ; } } } ; execP4Command ( command , handler ) ; } else { execP4Command ( command , new SimpleP4OutputHandler ( this ) ) ; } } }
public class Gcj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { } protected Commandline setupGCJCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = new Path ( project ) ; if ( ( bootclasspath ) != null ) { classpath . append ( bootclasspath ) ; } <START_BUG> addExtdirsToClasspath ( classpath ) ; <END_BUG> if ( ( ( bootclasspath ) == null ) || ( ( bootclasspath . size ( ) ) == 0 ) ) { includeJavaRuntime = true ; } classpath . append ( getCompileClasspath ( ) ) ; classpath . append ( src ) ; cmd . setExecutable ( "gcj" ) ; if ( ( destDir ) != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; if ( destDir . mkdirs ( ) ) { throw new BuildException ( "Can't<seq2seq4repair_space>make<seq2seq4repair_space>output<seq2seq4repair_space>directories.<seq2seq4repair_space>Maybe<seq2seq4repair_space>permission<seq2seq4repair_space>is<seq2seq4repair_space>wrong.<seq2seq4repair_space>" ) ; } } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( ( encoding ) != null ) { cmd . createArgument ( ) . setValue ( ( "--encoding=" + ( encoding ) ) ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g1" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } cmd . createArgument ( ) . setValue ( "-C" ) ; addCurrentCompilerArgs ( cmd ) ; return cmd ; } }
public class PerformanceTest { private final int max = 10 ; private static final File BIG_FILE = new File ( System . getProperty ( "java.io.tmpdir" ) , "worldcitiespop.txt" ) ; @ BeforeClass public static void setUpClass ( ) throws FileNotFoundException , IOException { } private BufferedReader getBufferedReader ( ) throws IOException { } private long parse ( final Reader in , boolean traverseColumns ) throws IOException { <START_BUG> final CSVFormat format = CSVFormat . defaults ( ) . withIgnoreSurroundingSpaces ( false ) . build ( ) ; <END_BUG> long recordCount = 0 ; for ( final CSVRecord record : format . parse ( in ) ) { recordCount ++ ; if ( traverseColumns ) { for ( String value : record ) { } } } return recordCount ; } private void println ( final String s ) { } private long readAll ( final BufferedReader in ) throws IOException { } public long testParseBigFile ( boolean traverseColumns ) throws Exception { } @ Test public void testParseBigFileRepeat ( ) throws Exception { } @ Test public void testReadBigFile ( ) throws Exception { } }
public class VariableAndFunctionTests extends ExpressionTestCase { @ Test public void testVariableAccess01 ( ) { } @ Test public void testVariableAccess_WellKnownVariables ( ) { } @ Test public void testFunctionAccess01 ( ) { } @ Test public void testFunctionAccess02 ( ) { } @ Test public void testCallVarargsFunction ( ) { } @ Test public void testCallingIllegalFunctions ( ) throws Exception { SpelExpressionParser parser = new SpelExpressionParser ( ) ; StandardEvaluationContext ctx = new StandardEvaluationContext ( ) ; ctx . setVariable ( "notStatic" , this . getClass ( ) . getMethod ( "nonStatic" ) ) ; try { @ SuppressWarnings ( "unused" ) <START_BUG> Object v = parser . parseExpression ( "#notStatic()" ) . getValue ( ctx ) ; <END_BUG> Assert . fail ( "Should<seq2seq4repair_space>have<seq2seq4repair_space>failed<seq2seq4repair_space>with<seq2seq4repair_space>exception<seq2seq4repair_space>-<seq2seq4repair_space>cannot<seq2seq4repair_space>call<seq2seq4repair_space>non<seq2seq4repair_space>static<seq2seq4repair_space>method<seq2seq4repair_space>that<seq2seq4repair_space>way" ) ; } catch ( SpelEvaluationException se ) { if ( ( se . getMessageCode ( ) ) != ( SpelMessage . FUNCTION_MUST_BE_STATIC ) ) { se . printStackTrace ( ) ; Assert . fail ( ( "Should<seq2seq4repair_space>have<seq2seq4repair_space>failed<seq2seq4repair_space>a<seq2seq4repair_space>message<seq2seq4repair_space>about<seq2seq4repair_space>the<seq2seq4repair_space>function<seq2seq4repair_space>needing<seq2seq4repair_space>to<seq2seq4repair_space>be<seq2seq4repair_space>static,<seq2seq4repair_space>not:<seq2seq4repair_space>" + ( se . getMessageCode ( ) ) ) ) ; } } } public void nonStatic ( ) { } }
public class Generator extends AbstractExpressionsUsingWorkflowComponent { private static final String COMPONENT_NAME = "Xpand<seq2seq4repair_space>Generator" ; private String genPath = null ; private String srcPath = null ; private String prSrcPaths = null ; private String prExcludes = null ; private boolean prDefaultExcludes = true ; private String expand = null ; private String fileEncoding = System . getProperty ( "file.encoding" ) ; private List < ? > beautifier = new ArrayList < Object > ( ) ; private final List < String > advices = new ArrayList < String > ( ) ; private final List < String > extensionAdvices = new ArrayList < String > ( ) ; private boolean automaticHyphens = false ; private String collectProfileSummary = null ; private String verboseProfileFilename = null ; private Output output = null ; public void setCollectProfileSummary ( final String summary ) { } public void setVerboseProfileFilename ( final String fileName ) { } public void setAutomaticHyphens ( final boolean automaticHyphens ) { } @ Override public String getLogMessage ( ) { } @ Override public void addAdvice ( final String advice ) { } @ Override public void addExtensionAdvice ( final String extensionAdvice ) { } public List < ? > getBeautifier ( ) { } public void setBeautifier ( final List < ? > beautifiers ) { } public void setFileEncoding ( final String fileEncoding ) { } public String getFileEncoding ( ) { } @ Deprecated public void setGenPath ( final String genPath ) { } public void setExpand ( final String invoke ) { } public void setPrDefaultExcludes ( final boolean prDefaultExcludes ) { } public void setPrExcludes ( final String prExcludes ) { } public void setPrSrcPaths ( final String prSrcPathes ) { } @ Override public String getComponentName ( ) { } @ Deprecated public void setSrcPath ( final String srcPath ) { } private String fixPath ( final String p ) { } @ Override protected void invokeInternal2 ( final WorkflowContext ctx , final ProgressMonitor monitor , final Issues issues ) { OutputStream verboseProfileOutputStream = null ; if ( ( verboseProfileFilename ) != null ) { try { verboseProfileOutputStream = new BufferedOutputStream ( new FileOutputStream ( verboseProfileFilename ) ) ; ProfileCollector . getInstance ( ) . setDetailedLoggingWriter ( verboseProfileOutputStream ) ; } catch ( final IOException exc ) { log . warn ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>open<seq2seq4repair_space>profiling<seq2seq4repair_space>log<seq2seq4repair_space>file" , exc ) ; } } final Output out = getOutput ( ) ; final List < Outlet > outlets = getInitializedOutlets ( ) ; for ( final Outlet outlet : outlets ) { out . addOutlet ( outlet ) ; } ProtectedRegionResolverImpl prs = null ; if ( ( prSrcPaths ) != null ) { prs = new ProtectedRegionResolverImpl ( ) ; prs . setDefaultExcludes ( prDefaultExcludes ) ; prs . setIgnoreList ( prExcludes ) ; prs . setSrcPathes ( prSrcPaths ) ; prs . setFileEncoding ( fileEncoding ) ; } XpandExecutionContextImpl executionContext = new XpandExecutionContextImpl ( out , prs , getGlobalVars ( ctx ) , exceptionHandler , getNullEvaluationHandler ( ) ) ; if ( monitor != null ) { executionContext . setMonitor ( monitor ) ; } executionContext . setResourceManager ( getResourceManager ( ) ) ; if ( ( callback ) != null ) { <START_BUG> executionContext . setCallBack ( callback ) ; <END_BUG> } if ( ( fileEncoding ) != null ) { executionContext . setFileEncoding ( fileEncoding ) ; } for ( final MetaModel mm : metaModels ) { executionContext . registerMetaModel ( mm ) ; } final ExpandStatement es = getStatement ( ) ; if ( es == null ) throw new ConfigurationException ( "property<seq2seq4repair_space>'expand'<seq2seq4repair_space>has<seq2seq4repair_space>wrong<seq2seq4repair_space>syntax!" ) ; final String [ ] names = ctx . getSlotNames ( ) ; for ( final String name : names ) { executionContext = ( ( XpandExecutionContextImpl ) ( executionContext . cloneWithVariable ( new org . eclipse . xtend . expression . Variable ( name , ctx . get ( name ) ) ) ) ) ; } for ( final String advice : advices ) { final String [ ] allAdvices = advice . split ( "," ) ; for ( final String string : allAdvices ) { executionContext . registerAdvices ( string . trim ( ) ) ; } } for ( final String advice : extensionAdvices ) { final String [ ] allAdvices = advice . split ( "," ) ; for ( final String string : allAdvices ) { executionContext . registerExtensionAdvices ( string . trim ( ) ) ; } } es . evaluate ( executionContext ) ; for ( final Outlet element : outlets ) { final String name = ( ( ( ( element . getName ( ) ) == null ? "[default]" : element . getName ( ) ) + "(" ) + ( element . getPath ( ) ) ) + ")" ; if ( ( element . getFilesWrittenAndClosed ( ) ) > 0 ) { log . info ( ( ( ( "Written<seq2seq4repair_space>" + ( element . getFilesWrittenAndClosed ( ) ) ) + "<seq2seq4repair_space>files<seq2seq4repair_space>to<seq2seq4repair_space>outlet<seq2seq4repair_space>" ) + name ) ) ; } if ( ( element . getFilesCreated ( ) ) > ( element . getFilesWrittenAndClosed ( ) ) ) { log . info ( ( ( ( "Skipped<seq2seq4repair_space>writing<seq2seq4repair_space>of<seq2seq4repair_space>" + ( ( element . getFilesCreated ( ) ) - ( element . getFilesWrittenAndClosed ( ) ) ) ) + "<seq2seq4repair_space>files<seq2seq4repair_space>to<seq2seq4repair_space>outlet<seq2seq4repair_space>" ) + name ) ) ; } } ProfileCollector . getInstance ( ) . finish ( ) ; if ( "true" . equalsIgnoreCase ( this . collectProfileSummary ) ) { log . info ( ( "profiling<seq2seq4repair_space>info:<seq2seq4repair_space>\n" + ( ProfileCollector . getInstance ( ) . toString ( ) ) ) ) ; } if ( verboseProfileOutputStream != null ) { try { verboseProfileOutputStream . close ( ) ; } catch ( final IOException exc ) { log . warn ( "problem<seq2seq4repair_space>closing<seq2seq4repair_space>profile<seq2seq4repair_space>log<seq2seq4repair_space>file" , exc ) ; } } } private final List < Outlet > outlets = new ArrayList < Outlet > ( ) ;
public class GLSMultipleLinearRegressionTest extends MultipleLinearRegressionAbstractTest { private double [ ] y ; private double [ ] [ ] x ; private double [ ] [ ] omega ; @ Before public void setUp ( ) { } @ Test ( expected = IllegalArgumentException . class ) public void cannotAddXSampleData ( ) { } @ Test ( expected = IllegalArgumentException . class ) public void cannotAddNullYSampleData ( ) { } @ Test ( expected = IllegalArgumentException . class ) public void cannotAddSampleDataWithSizeMismatch ( ) { } <START_BUG> @ Test ( expected = IllegalArgumentException . class ) <END_BUG> public void cannotAddNullCovarianceData ( ) { createRegression ( ) . newSampleData ( new double [ ] { } , new double [ ] [ ] { } , null ) ; } @ Test ( expected = IllegalArgumentException . class ) public void cannotAddCovarianceDataWithSampleSizeMismatch ( ) { } @ Test ( expected = IllegalArgumentException . class ) public void cannotAddCovarianceDataThatIsNotSquare ( ) { } protected GLSMultipleLinearRegression createRegression ( ) { } protected int getNumberOfRegressors ( ) { } protected int getSampleSize ( ) { } }
public final class ChallengeParser { public static final String FLL_NAMESPACE = "http://www.hightechkids.org" ; private static final Logger LOG = LogUtils . getLogger ( ) ; public static void main ( final String [ ] args ) { LogUtils . initializeLogging ( ) ; if ( ( args . length ) < 1 ) { ChallengeParser . LOG . fatal ( "Usage:<seq2seq4repair_space>ChallengeParser<seq2seq4repair_space><xml<seq2seq4repair_space>file>" ) ; System . exit ( 1 ) ; } final File challengeFile = new File ( args [ 0 ] ) ; if ( ! ( challengeFile . exists ( ) ) ) { ChallengeParser . LOG . fatal ( ( ( challengeFile . getAbsolutePath ( ) ) + "<seq2seq4repair_space>doesn't<seq2seq4repair_space>exist" ) ) ; System . exit ( 1 ) ; } if ( ! ( challengeFile . canRead ( ) ) ) { ChallengeParser . LOG . fatal ( ( ( challengeFile . getAbsolutePath ( ) ) + "<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>readable" ) ) ; System . exit ( 1 ) ; } if ( ! ( challengeFile . isFile ( ) ) ) { ChallengeParser . LOG . fatal ( ( ( challengeFile . getAbsolutePath ( ) ) + "<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>a<seq2seq4repair_space>file" ) ) ; System . exit ( 1 ) ; } try { final Reader input = new InputStreamReader ( new FileInputStream ( challengeFile ) , Utilities . DEFAULT_CHARSET ) ; final Document challengeDocument = ChallengeParser . parse ( input ) ; final ChallengeDescription description = new ChallengeDescription ( challengeDocument . getDocumentElement ( ) ) ; ChallengeParser . LOG . info ( ( "Title:<seq2seq4repair_space>" + ( description . getTitle ( ) ) ) ) ; <START_BUG> } catch ( final Exception e ) { <END_BUG> ChallengeParser . LOG . fatal ( e , e ) ; System . exit ( 1 ) ; } } public static final double INITIAL_VALUE_TOLERANCE = 1.0E-4 ; public static final int CURRENT_SCHEMA_VERSION = 2 ; private ChallengeParser ( ) { } public static Document parse ( final Reader stream ) throws ChallengeXMLException { } private static String applyTransform ( final String content , final InputStream transform ) { } private static String transform0To1 ( final String content ) { } private static String transform1To2 ( final String content ) { } private static int determineSchemaVersion ( final String content ) throws IOException , SAXException { } private static void validateDocument ( final Document document ) throws ParseException { } private static void checkForCircularDependencies ( final Map < String , Element > computedGoals ) { } private static Set < String > getImmediateComputedGoalDependencies ( final Element computedGoalElement ) { } public static String compareStructure ( final Document curDoc , final Document newDoc ) { } public static String compareStructure ( final ChallengeDescription curDoc , final ChallengeDescription newDoc ) { } private static String compareGoalDefinitions ( final String category , final Map < String , String > curGoals , final Map < String , String > newGoals ) { } private static Map < String , String > gatherColumnDefinitions ( final ScoreCategory element ) { } private static Document parseXMLDocument ( final Reader xmlDocStream ) throws IOException , SAXException { } }
public class JaxrsSpringProcessor implements DeploymentUnitProcessor { private static final String VERSION_KEY = "resteasy.version" ; private static final String SPRING_INT_JAR_BASE = "resteasy-spring" ; private static final String JAR_LOCATION = "resteasy-spring-jar" ; private static final ModuleIdentifier MODULE = ModuleIdentifier . create ( "org.jboss.resteasy.resteasy-spring" ) ; public static final String SPRING_LISTENER = "org.jboss.resteasy.plugins.spring.SpringContextLoaderListener" ; public static final String SPRING_SERVLET = "org.springframework.web.servlet.DispatcherServlet" ; @ Deprecated public static final String DISABLE_PROPERTY = "org.jboss.as.jaxrs.disableSpringIntegration" ; public static final String ENABLE_PROPERTY = "org.jboss.as.jaxrs.enableSpringIntegration" ; public static final String SERVICE_NAME = "resteasy-spring-integration-resource-root" ; private final ServiceTarget serviceTarget ; private VirtualFile resourceRoot ; public JaxrsSpringProcessor ( ServiceTarget serviceTarget ) { } protected synchronized VirtualFile getResteasySpringVirtualFile ( ) throws DeploymentUnitProcessingException { try { Module module = Module . getBootModuleLoader ( ) . loadModule ( JaxrsSpringProcessor . MODULE ) ; URL fileUrl = module . getClassLoader ( ) . getResource ( JaxrsSpringProcessor . JAR_LOCATION ) ; if ( fileUrl == null ) { throw JAXRS_LOGGER . noSpringIntegrationJar ( ) ; } <START_BUG> File dir = new File ( fileUrl . getFile ( ) ) ; <END_BUG> File file = null ; for ( String jar : dir . list ( ) ) { if ( jar . endsWith ( ".jar" ) ) { file = new File ( dir , jar ) ; break ; } } if ( file == null ) { throw JAXRS_LOGGER . noSpringIntegrationJar ( ) ; } VirtualFile vf = VFS . getChild ( file . toURI ( ) ) ; final Closeable mountHandle = VFS . mountZip ( file , vf , TempFileProviderService . provider ( ) ) ; Service < Closeable > mountHandleService = new Service < Closeable > ( ) { public void start ( StartContext startContext ) throws StartException { } public void stop ( StopContext stopContext ) { VFSUtils . safeClose ( mountHandle ) ; } public Closeable getValue ( ) throws IllegalArgumentException , IllegalStateException { return mountHandle ; } } ; ServiceBuilder < Closeable > builder = serviceTarget . addService ( JBOSS . append ( JaxrsSpringProcessor . SERVICE_NAME ) , mountHandleService ) ; builder . setInitialMode ( ACTIVE ) . install ( ) ; resourceRoot = vf ; return resourceRoot ; } catch ( Exception e ) { throw new DeploymentUnitProcessingException ( e ) ; } } public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { } public void undeploy ( DeploymentUnit context ) { } }
class AddCompilationUnitToIndex extends IndexRequest { IFile resource ; IndexManager manager ; IPath indexedContainer ; char [ ] contents ; public AddCompilationUnitToIndex ( IFile resource , IndexManager manager , IPath indexedContainer ) { } public boolean belongsTo ( String jobFamily ) { } public boolean execute ( IProgressMonitor progressMonitor ) { if ( ( progressMonitor != null ) && ( progressMonitor . isCanceled ( ) ) ) return IJob . COMPLETE ; try { <START_BUG> IIndex index = manager . getIndex ( this . indexedContainer ) ; <END_BUG> if ( index == null ) return IJob . COMPLETE ; ReadWriteMonitor monitor = manager . getMonitorFor ( index ) ; if ( monitor == null ) return IJob . COMPLETE ; try { monitor . enterWrite ( ) ; char [ ] contents = this . getContents ( ) ; if ( contents == null ) return IJob . FAILED ; index . add ( new IFileDocument ( resource , contents ) , new SourceIndexer ( ) ) ; } finally { monitor . exitWrite ( ) ; } } catch ( IOException e ) { if ( JobManager . VERBOSE ) { JobManager . verbose ( ( ( "-><seq2seq4repair_space>failed<seq2seq4repair_space>to<seq2seq4repair_space>index<seq2seq4repair_space>" + ( this . resource ) ) + "<seq2seq4repair_space>because<seq2seq4repair_space>of<seq2seq4repair_space>the<seq2seq4repair_space>following<seq2seq4repair_space>exception:" ) ) ; e . printStackTrace ( ) ; } return IJob . FAILED ; } return IJob . COMPLETE ; } private char [ ] getContents ( ) { } public void initializeContents ( ) { } public String toString ( ) { } }
public class Table extends Composite { TableItem [ ] items ; int [ ] keys ; TableColumn [ ] columns ; int columnCount ; int customCount ; int keyCount ; ImageList imageList ; ImageList headerImageList ; TableItem currentItem ; TableColumn sortColumn ; RECT focusRect ; int headerToolTipHandle ; boolean ignoreCustomDraw ; boolean ignoreDrawForeground ; boolean ignoreDrawBackground ; boolean ignoreDrawFocus ; boolean ignoreDrawSelection ; boolean ignoreDrawHot ; boolean customDraw ; boolean dragStarted ; boolean explorerTheme ; boolean firstColumnImage ; boolean fixScrollWidth ; boolean tipRequested ; boolean wasSelected ; boolean wasResized ; boolean painted ; boolean ignoreActivate ; boolean ignoreSelect ; boolean ignoreShrink ; boolean ignoreResize ; boolean ignoreColumnMove ; boolean ignoreColumnResize ; boolean fullRowSelect ; int itemHeight ; int lastIndexOf ; int lastWidth ; int sortDirection ; int resizeCount ; int selectionForeground ; int hotIndex ; static int HeaderProc ; static final int INSET = 4 ; static final int GRID_WIDTH = 1 ; static final int SORT_WIDTH = 10 ; static final int HEADER_MARGIN = 12 ; static final int HEADER_EXTRA = 3 ; static final int VISTA_EXTRA = 2 ; static final int EXPLORER_EXTRA = 2 ; static final int H_SCROLL_LIMIT = 32 ; static final int V_SCROLL_LIMIT = 16 ; static final int DRAG_IMAGE_SIZE = 301 ; static final boolean EXPLORER_THEME = true ; static boolean COMPRESS_ITEMS = true ; static final int TableProc ; static final TCHAR TableClass = new TCHAR ( 0 , OS . WC_LISTVIEW , true ) ; public Table ( Composite parent , int style ) { } void _addListener ( int eventType , Listener listener ) { } boolean _checkGrow ( int count ) { } void _checkShrink ( ) { } void _clearItems ( ) { } TableItem _getItem ( int index ) { } TableItem _getItem ( int index , boolean create ) { } TableItem _getItem ( int index , boolean create , int count ) { } void _getItems ( TableItem [ ] result , int count ) { if ( ( keys ) == null ) { System . arraycopy ( items , 0 , result , 0 , count ) ; } else { for ( int i = 0 ; i < ( keyCount ) ; i ++ ) { if ( ( keys [ i ] ) >= count ) break ; <START_BUG> result [ keys [ i ] ] = items [ i ] ; <END_BUG> } } } boolean _hasItems ( ) { } void _initItems ( ) { } void _insertItem ( int index , TableItem item , int count ) { } void _removeItem ( int index , int count ) { } void _removeItems ( int start , int index , int count ) { } void _setItemCount ( int count , int itemCount ) { } int binarySearch ( int [ ] indices , int start , int end , int index ) { } public void addSelectionListener ( SelectionListener listener ) { } int callWindowProc ( int hwnd , int msg , int wParam , int lParam ) { } int callWindowProc ( int hwnd , int msg , int wParam , int lParam , boolean forceSelect ) { } static int checkStyle ( int style ) { } LRESULT CDDS_ITEMPOSTPAINT ( NMLVCUSTOMDRAW nmcd , int wParam , int lParam ) { } LRESULT CDDS_ITEMPREPAINT ( NMLVCUSTOMDRAW nmcd , int wParam , int lParam ) { } LRESULT CDDS_POSTPAINT ( NMLVCUSTOMDRAW nmcd , int wParam , int lParam ) { } LRESULT CDDS_PREPAINT ( NMLVCUSTOMDRAW nmcd , int wParam , int lParam ) { } LRESULT CDDS_SUBITEMPOSTPAINT ( NMLVCUSTOMDRAW nmcd , int wParam , int lParam ) { } LRESULT CDDS_SUBITEMPREPAINT ( NMLVCUSTOMDRAW nmcd , int wParam , int lParam ) { } void checkBuffered ( ) { } boolean checkData ( TableItem item , boolean redraw ) { } boolean checkData ( TableItem item , int index , boolean redraw ) { } boolean checkHandle ( int hwnd ) { } protected void checkSubclass ( ) { } public void clear ( int index ) { } public void clear ( int start , int end ) { } public void clear ( int [ ] indices ) { } public void clearAll ( ) { } public Point computeSize ( int wHint , int hHint , boolean changed ) { } void createHandle ( ) { } void createHeaderToolTips ( ) { } void createItem ( TableColumn column , int index ) { } void createItem ( TableItem item , int index ) { } void createWidget ( ) { } int defaultBackground ( ) { } void deregister ( ) { } public void deselect ( int [ ] indices ) { } public void deselect ( int index ) { } public void deselect ( int start , int end ) { } public void deselectAll ( ) { } void destroyItem ( TableColumn column ) { } void destroyItem ( TableItem item ) { } void fixCheckboxImageList ( boolean fixScroll ) { } void fixCheckboxImageListColor ( boolean fixScroll ) { } void fixItemHeight ( boolean fixScroll ) { } public TableColumn getColumn ( int index ) { } public int getColumnCount ( ) { } public int [ ] getColumnOrder ( ) { } public TableColumn [ ] getColumns ( ) { } int getFocusIndex ( ) { } public int getGridLineWidth ( ) { } public int getHeaderHeight ( ) { } public boolean getHeaderVisible ( ) { } public TableItem getItem ( int index ) { } public TableItem getItem ( Point point ) { } public int getItemCount ( ) { } public int getItemHeight ( ) { } public TableItem [ ] getItems ( ) { } public boolean getLinesVisible ( ) { } public TableItem [ ] getSelection ( ) { } public int getSelectionCount ( ) { } public int getSelectionIndex ( ) { } public int [ ] getSelectionIndices ( ) { }
public class CreateVFolderOnMessageCommand extends FolderCommand { private static final Logger LOG = Logger . getLogger ( "org.columba.mail.folder.command" ) ; public static final String VFOLDER_ON_SUBJECT = "Subject" ; public static final String VFOLDER_ON_FROM = "From" ; public static final String VFOLDER_ON_TO = "To" ; private String vfolderType ; private MessageFolder parentFolder = null ; private VirtualFolder vfolder = null ; public CreateVFolderOnMessageCommand ( FrameMediator frameController , DefaultCommandReference [ ] references , String vfolderType ) { } public void updateGUI ( ) throws Exception { treeModel . nodeStructureChanged ( parentFolder ) ; if ( ( vfolder ) != null ) { <START_BUG> new org . columba . mail . gui . config . filter . ConfigFrame ( getFrameMediator ( ) . getView ( ) . getFrame ( ) , vfolder ) ; <END_BUG> } } public void execute ( WorkerStatusController worker ) throws Exception { } public VirtualFolder createVirtualFolder ( String folderName , String headerField , String pattern , MessageFolder parent ) { } }
final class NewOperationContextImpl implements NewOperationContext { private static final Logger log = Logger . getLogger ( "org.jboss.as.controller" ) ; private final NewModelControllerImpl modelController ; private final Type contextType ; private final EnumSet < NewOperationContextImpl . ContextFlag > contextFlags ; private final OperationMessageHandler messageHandler ; private final Thread initiatingThread ; private final EnumMap < Stage , Deque < NewOperationContextImpl . Step > > steps ; private final OperationTransactionControl transactionControl ; private final ServiceTarget serviceTarget ; private final Map < ServiceName , ServiceController < ? > > realRemovingControllers = new HashMap < ServiceName , ServiceController < ? > > ( ) ; private final boolean booting ; private final OperationAttachments attachments ; private final ControlledProcessState processState ; private final Set < PathAddress > affectsModel ; private boolean affectsResourceRegistration ; private boolean respectInterruption = true ; private PathAddress modelAddress ; private Stage currentStage = Stage . MODEL ; private ModelNode response ; private ModelNode operation ; private Resource model ; private Resource readOnlyModel ; private ResultAction resultAction ; private boolean affectsRuntime ; private boolean cancelled ; private int depth ; private int lockDepth ; private int containerMonitorDepth ; private NewOperationContextImpl . StampHolder restartStampHolder ; enum ContextFlag { ROLLBACK_ON_FAIL ; } NewOperationContextImpl ( final NewModelControllerImpl modelController , final Type contextType , final EnumSet < NewOperationContextImpl . ContextFlag > contextFlags , final OperationMessageHandler messageHandler , final OperationAttachments attachments , final Resource model , final NewModelController . OperationTransactionControl transactionControl , final ControlledProcessState processState , final boolean booting ) { } public InputStream getAttachmentStream ( final int index ) { } public int getAttachmentStreamCount ( ) { } public void addStep ( final NewStepHandler step , final Stage stage ) throws IllegalArgumentException { } public void addStep ( final ModelNode operation , final NewStepHandler step , final Stage stage ) throws IllegalArgumentException { } public void addStep ( final ModelNode response , final ModelNode operation , final NewStepHandler step , final Stage stage ) throws IllegalArgumentException { } public ModelNode getFailureDescription ( ) { } public boolean hasFailureDescription ( ) { } public ResultAction completeStep ( ) { } private ResultAction doCompleteStep ( ) { assert ( Thread . currentThread ( ) ) == ( initiatingThread ) ; if ( ( currentStage ) == null ) { throw new IllegalStateException ( "Operation<seq2seq4repair_space>already<seq2seq4repair_space>complete" ) ; } if ( Thread . currentThread ( ) . isInterrupted ( ) ) { cancelled = true ; } ModelNode response = this . response ; if ( cancelled ) { response . get ( OUTCOME ) . set ( CANCELLED ) ; response . get ( FAILURE_DESCRIPTION ) . set ( "Operation<seq2seq4repair_space>cancelled" ) ; response . get ( ROLLED_BACK ) . set ( true ) ; resultAction = ResultAction . ROLLBACK ; return resultAction ; } if ( ( response . hasDefined ( FAILURE_DESCRIPTION ) ) && ( ( contextFlags . contains ( NewOperationContextImpl . ContextFlag . ROLLBACK_ON_FAIL ) ) || ( ( currentStage ) == ( Stage . MODEL ) ) ) ) { response . get ( OUTCOME ) . set ( FAILED ) ; response . get ( ROLLED_BACK ) . set ( true ) ; resultAction = ResultAction . ROLLBACK ; return resultAction ; } if ( ( resultAction ) == ( ResultAction . ROLLBACK ) ) { return ResultAction . ROLLBACK ; } NewOperationContextImpl . Step step = null ; do { step = steps . get ( currentStage ) . pollFirst ( ) ; if ( step == null ) { if ( currentStage . hasNext ( ) ) { currentStage = currentStage . next ( ) ; if ( ( ( contextType ) == ( Type . MANAGEMENT ) ) && ( ( currentStage ) == ( MODEL . next ( ) ) ) ) { <START_BUG> currentStage = null ; <END_BUG> } else if ( ( affectsRuntime ) && ( ( currentStage ) == ( Stage . VERIFY ) ) ) { try { modelController . awaitContainerMonitor ( true , 1 ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; cancelled = true ; response . get ( OUTCOME ) . set ( CANCELLED ) ; response . get ( FAILURE_DESCRIPTION ) . set ( "Operation<seq2seq4repair_space>cancelled" ) ; response . get ( ROLLED_BACK ) . set ( true ) ; return ResultAction . ROLLBACK ; } } } } else { return executeStep ( step ) ; } } while ( ( currentStage ) != ( Stage . DONE ) ) ; final AtomicReference < ResultAction > ref = new AtomicReference < ResultAction > ( ( ( transactionControl ) == null ? ResultAction . KEEP : ResultAction . ROLLBACK ) ) ; ConfigurationPersister . PersistenceResource persistenceResource = null ; if ( ( isModelAffected ( ) ) && ( ( resultAction ) != ( ResultAction . ROLLBACK ) ) ) try { persistenceResource = modelController . writeModel ( model , affectsModel ) ; } catch ( ConfigurationPersistenceException e ) { response . get ( OUTCOME ) . set ( FAILED ) ; response . get ( FAILURE_DESCRIPTION ) . set ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>persist<seq2seq4repair_space>configuration<seq2seq4repair_space>change:<seq2seq4repair_space>" + e ) ) ; return resultAction = ResultAction . ROLLBACK ; } if ( ( transactionControl ) != null ) { if ( NewOperationContextImpl . log . isTraceEnabled ( ) ) { NewOperationContextImpl . log . trace ( ( "Prepared<seq2seq4repair_space>response<seq2seq4repair_space>is<seq2seq4repair_space>" + response ) ) ; } transactionControl . operationPrepared ( new NewModelController . OperationTransaction ( ) { public void commit ( ) { ref . set ( KEEP ) ; } public void rollback ( ) { ref . set ( ROLLBACK ) ; } } , response ) ; } resultAction = ref . get ( ) ; if ( persistenceResource != null ) { if ( ( resultAction ) == ( ResultAction . ROLLBACK ) ) { persistenceResource . rollback ( ) ; } else { persistenceResource . commit ( ) ; } } return resultAction ; }
public final class StatisticalSummaryValuesTest extends TestCase { public StatisticalSummaryValuesTest ( String name ) { } public void setUp ( ) { } public static Test suite ( ) { } public void testSerialization ( ) { } public void testEqualsAndHashCode ( ) { StatisticalSummaryValues u = new StatisticalSummaryValues ( 1 , 2 , 3 , 4 , 5 , 6 ) ; StatisticalSummaryValues t = null ; assertTrue ( "reflexive" , u . equals ( u ) ) ; assertFalse ( "non-null<seq2seq4repair_space>compared<seq2seq4repair_space>to<seq2seq4repair_space>null" , u . equals ( t ) ) ; <START_BUG> assertFalse ( "wrong<seq2seq4repair_space>type" , u . equals ( Double . valueOf ( 0 ) ) ) ; <END_BUG> t = new StatisticalSummaryValues ( 1 , 2 , 3 , 4 , 5 , 6 ) ; assertTrue ( "instances<seq2seq4repair_space>with<seq2seq4repair_space>same<seq2seq4repair_space>data<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>equal" , t . equals ( u ) ) ; assertEquals ( "hash<seq2seq4repair_space>code" , u . hashCode ( ) , t . hashCode ( ) ) ; u = new StatisticalSummaryValues ( Double . NaN , 2 , 3 , 4 , 5 , 6 ) ; t = new StatisticalSummaryValues ( 1 , Double . NaN , 3 , 4 , 5 , 6 ) ; assertFalse ( "instances<seq2seq4repair_space>based<seq2seq4repair_space>on<seq2seq4repair_space>different<seq2seq4repair_space>data<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>different" , ( ( u . equals ( t ) ) || ( t . equals ( u ) ) ) ) ; } private void verifyEquality ( StatisticalSummaryValues s , StatisticalSummaryValues u ) { } }
public class Composite extends Scrollable { Layout layout ; Control [ ] tabList ; int layoutCount ; int backgroundMode ; boolean keyInputHappened ; Composite ( ) { } public Composite ( Composite parent , int style ) { } Control [ ] _getChildren ( ) { } Control [ ] _getTabList ( ) { } boolean acceptsFirstResponder ( int id , int sel ) { } int accessibilityAttributeNames ( int id , int sel ) { } boolean accessibilityIsIgnored ( int id , int sel ) { } public void changed ( Control [ ] changed ) { } public Point computeSize ( int wHint , int hHint , boolean changed ) { } protected void checkSubclass ( ) { } Control [ ] computeTabList ( ) { } void setBounds ( int x , int y , int width , int height , boolean move , boolean resize ) { } void createHandle ( ) { state |= CANVAS ; boolean scrolled = ( ( style ) & ( ( SWT . V_SCROLL ) | ( SWT . H_SCROLL ) ) ) != 0 ; if ( ! scrolled ) state |= THEME_BACKGROUND ; NSRect rect = new NSRect ( ) ; if ( scrolled || ( hasBorder ( ) ) ) { NSScrollView scrollWidget = ( ( NSScrollView ) ( new SWTScrollView ( ) . alloc ( ) ) ) ; scrollWidget . initWithFrame ( rect ) ; scrollWidget . setDrawsBackground ( false ) ; if ( ( ( style ) & ( SWT . H_SCROLL ) ) != 0 ) scrollWidget . setHasHorizontalScroller ( true ) ; if ( ( ( style ) & ( SWT . V_SCROLL ) ) != 0 ) scrollWidget . setHasVerticalScroller ( true ) ; scrollWidget . setBorderType ( ( hasBorder ( ) ? OS . NSBezelBorder : OS . NSNoBorder ) ) ; scrollView = scrollWidget ; } <START_BUG> NSView widget = ( ( NSView ) ( new SWTView ( ) . alloc ( ) ) ) ; <END_BUG> widget . initWithFrame ( rect ) ; view = widget ; } void doCommandBySelector ( int id , int sel , int selector ) { } void drawWidget ( int id , NSGraphicsContext context , NSRect rect , boolean sendPaint ) { } void flagsChanged ( int id , int sel , int theEvent ) { } Composite findDeferredControl ( ) { } Menu [ ] findMenus ( Control control ) { } void fixChildren ( Shell newShell , Shell oldShell , Decorations newDecorations , Decorations oldDecorations , Menu [ ] menus ) { } void fixTabList ( Control control ) { } public int getBackgroundMode ( ) { } public Control [ ] getChildren ( ) { } int getChildrenCount ( ) { } public Layout getLayout ( ) { } public boolean getLayoutDeferred ( ) { } public Control [ ] getTabList ( ) { } boolean hooksKeys ( ) { } boolean insertText ( int id , int sel , int string ) { } public boolean isLayoutDeferred ( ) { } boolean isOpaque ( int id , int sel ) { } boolean isTabGroup ( ) { } void keyDown ( int id , int sel , int theEvent ) { } public void layout ( ) { } public void layout ( boolean changed ) { } public void layout ( boolean changed , boolean all ) { } public void layout ( Control [ ] changed ) { } void markLayout ( boolean changed , boolean all ) { } Point minimumSize ( int wHint , int Hint , boolean changed ) { } void pageDown ( int id , int sel , int sender ) { } void pageUp ( int id , int sel , int sender ) { } void reflectScrolledClipView ( int id , int sel , int aClipView ) { } void releaseChildren ( boolean destroy ) { } void releaseWidget ( ) { } void removeControl ( Control control ) { } void resized ( ) { } void scrollWheel ( int id , int sel , int theEvent ) { } public void setBackgroundMode ( int mode ) { } public boolean setFocus ( ) { } public void setLayout ( Layout layout ) { } public void setLayoutDeferred ( boolean defer ) { } boolean setMarkedText_selectedRange ( int id , int sel , int string , int range ) { } boolean setScrollBarVisible ( ScrollBar bar , boolean visible ) { } boolean setTabGroupFocus ( ) { } public void setTabList ( Control [ ] tabList ) { } int traversalCode ( int key , NSEvent theEvent ) { } void updateBackgroundMode ( ) { } void updateLayout ( boolean all ) { } }
public class BinaryType extends BinaryMember implements IType { private static final IField [ ] NO_FIELDS = new IField [ 0 ] ; private static final IMethod [ ] NO_METHODS = new IMethod [ 0 ] ; private static final IType [ ] NO_TYPES = new IType [ 0 ] ; private static final IInitializer [ ] NO_INITIALIZERS = new IInitializer [ 0 ] ; private static final String [ ] NO_STRINGS = new String [ 0 ] ; protected BinaryType ( IJavaElement parent , String name ) { } public void close ( ) throws JavaModelException { } protected void closing ( Object info ) throws JavaModelException { } public IField createField ( String contents , IJavaElement sibling , boolean force , IProgressMonitor monitor ) throws JavaModelException { } public IInitializer createInitializer ( String contents , IJavaElement sibling , IProgressMonitor monitor ) throws JavaModelException { } public IMethod createMethod ( String contents , IJavaElement sibling , boolean force , IProgressMonitor monitor ) throws JavaModelException { } public IType createType ( String contents , IJavaElement sibling , boolean force , IProgressMonitor monitor ) throws JavaModelException { } public IJavaElement [ ] getChildren ( ) throws JavaModelException { } protected ClassFileInfo getClassFileInfo ( ) throws JavaModelException { } public IType getDeclaringType ( ) { } public IField getField ( String name ) { } public IField [ ] getFields ( ) throws JavaModelException { } public int getFlags ( ) throws JavaModelException { } public String getFullyQualifiedName ( ) { } public IInitializer getInitializer ( int occurrenceCount ) { } public IInitializer [ ] getInitializers ( ) { } public IMethod getMethod ( String name , String [ ] parameterTypeSignatures ) { } public IMethod [ ] getMethods ( ) throws JavaModelException { } public IPackageFragment getPackageFragment ( ) { } public String getSuperclassName ( ) throws JavaModelException { } public String [ ] getSuperInterfaceNames ( ) throws JavaModelException { } public IType getType ( String name ) { } public String getTypeQualifiedName ( ) { } public IType [ ] getTypes ( ) throws JavaModelException { } public boolean hasChildren ( ) throws JavaModelException { } public boolean isClass ( ) throws JavaModelException { } public boolean isInterface ( ) throws JavaModelException { } public ITypeHierarchy newSupertypeHierarchy ( IProgressMonitor monitor ) throws JavaModelException { } public ITypeHierarchy newTypeHierarchy ( IProgressMonitor monitor ) throws JavaModelException { } public ITypeHierarchy newTypeHierarchy ( IJavaProject project , IProgressMonitor monitor ) throws JavaModelException { if ( project == null ) { throw new IllegalArgumentException ( Util . bind ( "hierarchy.nullProject" ) ) ; } <START_BUG> CreateTypeHierarchyOperation op = new CreateTypeHierarchyOperation ( this , SearchEngine . createJavaSearchScope ( new IResource [ ] { project . getProject ( ) } ) , true ) ; <END_BUG> runOperation ( op , monitor ) ; return op . getResult ( ) ; } protected void removeInfo ( ) { } public String [ ] [ ] resolveType ( String typeName ) throws JavaModelException { } }
public class NativeUtils { public enum KVType { TEXT , BYTES , OTHER ; public static NativeUtils . KVType getType ( Class < ? > clazz ) { } } public static boolean equals ( byte [ ] a , byte [ ] b ) { } public static byte [ ] toBytes ( String str ) { } public static String fromBytes ( byte [ ] data ) { } @ SuppressWarnings ( "unchecked" ) public static < T > byte [ ] serialize ( JobConf conf , Object obj ) throws IOException { SerializationFactory factory = new SerializationFactory ( conf ) ; <START_BUG> Serializer < T > serializer = ( ( Serializer < T > ) ( factory . getDeserializer ( obj . getClass ( ) ) ) ) ; <END_BUG> DataOutputBuffer out = new DataOutputBuffer ( 1024 ) ; serializer . open ( out ) ; serializer . serialize ( ( ( T ) ( obj ) ) ) ; byte [ ] ret = new byte [ out . getLength ( ) ] ; System . arraycopy ( out . getData ( ) , 0 , ret , 0 , out . getLength ( ) ) ; return ret ; } @ SuppressWarnings ( "unchecked" ) public static < T > NativeUtils . NativeSerializer < T > createSerializer ( Class < T > clazz ) throws IOException { } @ SuppressWarnings ( "unchecked" ) public static < T > NativeUtils . NativeDeserializer < T > createDeserializer ( Class < T > clazz ) throws IOException { } public static abstract class NativeSerializer < T > { NativeUtils . SerializeDest dest ; ByteBuffer buffer ; public void setDest ( NativeUtils . SerializeDest dest ) { } public abstract int getSerialLength ( T obj ) throws IOException { } public abstract void serializeRaw ( T obj , int len ) throws IOException { } public void serialize ( T obj ) throws IOException { } } public static interface SerializeDest { ByteBuffer getBuffer ( ) { } void flush ( ) throws IOException { } } public static class NullWritableSerializer extends NativeUtils . NativeSerializer < NullWritable > { @ Override public int getSerialLength ( NullWritable obj ) throws IOException { } @ Override public void serializeRaw ( NullWritable obj , int len ) throws IOException { } } public static class LongWritableSerializer extends NativeUtils . NativeSerializer < LongWritable > { @ Override public int getSerialLength ( LongWritable obj ) throws IOException { } @ Override public void serializeRaw ( LongWritable obj , int len ) throws IOException { } } public static class BinarySerializer < T > extends NativeUtils . NativeSerializer < T > { @ Override public int getSerialLength ( T obj ) throws IOException { } @ Override public void serializeRaw ( T obj , int len ) throws IOException { } } public static class WritableSerializer < T > extends NativeUtils . NativeSerializer < T > { private DataOutputBuffer tempOutput = new DataOutputBuffer ( ) ; @ Override public int getSerialLength ( T robj ) throws IOException { } @ Override public void serializeRaw ( T obj , int len ) throws IOException { } } public static interface NativeDeserializer < T > { T deserialize ( T src , ByteBuffer buffer ) throws IOException { } } public static class NullWritableDeserializer implements NativeUtils . NativeDeserializer < NullWritable > { @ Override public NullWritable deserialize ( NullWritable src , ByteBuffer buffer ) throws IOException { } } public static class LongWritableDeserializer implements NativeUtils . NativeDeserializer < LongWritable > { byte [ ] tempBuff = new byte [ 8 ] ; @ Override public LongWritable deserialize ( LongWritable src , ByteBuffer buffer ) throws IOException { } } public static class TextDeserializer implements NativeUtils . NativeDeserializer < Text > { int len = - 1 ; int need ; @ Override public Text deserialize ( Text src , ByteBuffer buffer ) throws IOException { } } public static class BytesWritableDeserializer implements NativeUtils . NativeDeserializer < BytesWritable > { int len = - 1 ; int need ; @ Override public BytesWritable deserialize ( BytesWritable src , ByteBuffer buffer ) { } } public static class WritableDeserializer < T > implements NativeUtils . NativeDeserializer < T > { int len = - 1 ; int need ; byte [ ] tempBuffer = new byte [ 256 ] ; DataInputBuffer serialInput = new DataInputBuffer ( ) ; @ Override public T deserialize ( T src , ByteBuffer buffer ) throws IOException { } } }
public class SadlServerImpl implements ISadlServer { protected final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; protected IConfigurationManager configurationMgr = null ; protected IReasoner reasoner = null ; private boolean collectTimingInformation = false ; protected String modelName = null ; private String serviceVersion = "$Revision:<seq2seq4repair_space>1.16<seq2seq4repair_space>$" ; protected String kbaseRoot = null ; protected String defaultInstanceDataNS = null ; protected Map < String , String [ ] > serviceNameMap = null ; private String modelFolder = null ; public SadlServerImpl ( ) { } public SadlServerImpl ( String _kbaseRoot ) throws ConfigurationException { } public String getClassName ( ) throws SessionNotFoundException { } public String getServiceVersion ( ) throws SessionNotFoundException { <START_BUG> return ( ( this . getClass ( ) . getSimpleName ( ) ) + "<seq2seq4repair_space>version<seq2seq4repair_space>" ) + ( serviceVersion ) ; <END_BUG> } public ResultSet query ( String sparql ) throws QueryCancelledException , QueryParseException , ReasonerNotFoundException { } public ReasonerTiming [ ] getTimingInformation ( ) { } public DataSource construct ( String sparql ) throws QueryCancelledException , QueryParseException { } public ResultSet ask ( String subjName , String propName , Object objValue ) throws ReasonerNotFoundException , TripleNotFoundException { } public boolean loadData ( String serverDataLocator ) throws ConfigurationException , ReasonerNotFoundException , IOException { } public boolean loadCsvData ( String serverCsvDataLocator , boolean includesHeader , String csvTemplate ) throws TemplateException , ConfigurationException , InvalidNameException , IOException { } public String selectServiceModel ( String serviceName ) throws ConfigurationException , ReasonerNotFoundException { } public String selectServiceModel ( String serviceName , List < ConfigurationItem > preferences ) throws ConfigurationException , ReasonerNotFoundException , NamedServiceNotFoundException { } public String selectServiceModel ( String knowledgeBaseIdentifier , String modelName ) throws ConfigurationException , ReasonerNotFoundException { } public String selectServiceModel ( String knowledgeBaseIdentifier , String modelName , List < ConfigurationItem > preferences ) throws ConfigurationException , ReasonerNotFoundException { } protected void setModelFolder ( String knowledgeBaseIdentifier ) throws MalformedURLException { } protected String getModelFolder ( ) { } protected void setConfigurationManagerModelGetter ( ) throws ConfigurationException , MalformedURLException { } protected String getRepoType ( String tdbFolder ) throws MalformedURLException { } public boolean sendData ( DataSource dataSrc ) throws ConfigurationException , ReasonerNotFoundException , IOException { } public boolean sendData ( DataSource dataSrc , String inputFormat ) throws ConfigurationException , ReasonerNotFoundException , IOException { } public boolean sendCsvData ( DataSource csvDataSrc , boolean includesHeader , String csvTemplate ) throws TemplateException , ConfigurationException , InvalidNameException , IOException { } public boolean addTriple ( String subjName , String predName , Object objValue ) throws ConfigurationException , ReasonerNotFoundException , TripleNotFoundException { } public boolean deleteTriple ( String subjName , String predName , Object objValue ) throws ConfigurationException , ReasonerNotFoundException , TripleNotFoundException { } public boolean reset ( ) throws ReasonerNotFoundException { } public String prepareQuery ( String query ) throws ConfigurationException , InvalidNameException , ReasonerNotFoundException { } private String getModelNameByServiceName ( String serviceName ) { } private String getKbIdentifierByServiceName ( String serviceName ) { } public void setOwlFileOutputFormat ( String outputFormat ) { } public String getKBaseIdentifier ( ) throws ConfigurationException { } public String getModelName ( ) throws IOException { } public String getReasonerVersion ( ) throws ConfigurationException { } protected IReasoner getReasoner ( ) throws ConfigurationException , MalformedURLException { } public DataSource getDerivations ( ) throws ConfigurationException , InvalidDerivationException { } public void setServiceNameMap ( Map < String , String [ ] > serviceNameMap ) { } public Map < String , String [ ] > getServiceNameMap ( ) { } public void collectTimingInformation ( boolean bCollect ) { } public void setKbaseRoot ( String _kbaseRoot ) throws ConfigurationException { } public String getKbaseRoot ( ) { } private Map [ ] scanFolderForServices ( File folder , Map < String , String [ ] > map , Map < String , File > sources ) throws ConfigurationException { } private List < Object [ ] > getServicesFromConfigFile ( File file ) throws ConfigurationException , IOException { } public ResultSet [ ] atomicQuery ( String serviceName , DataSource dataSrc , String inputFormat , String [ ] sparql ) throws ConfigurationException , InvalidNameException , QueryCancelledException , QueryParseException , ReasonerNotFoundException , NamedServiceNotFoundException , SessionNotFoundException , IOException { } public ResultSet [ ] atomicQueryCsvData ( String serviceName , DataSource csvDataSrc , boolean includesHeader , String csvTemplate , String [ ] sparql ) throws TemplateException , ConfigurationException , InvalidNameException , QueryCancelledException , QueryParseException , ReasonerNotFoundException , NamedServiceNotFoundException , SessionNotFoundException , IOException { } public String setInstanceDataNamespace ( String namespace ) throws InvalidNameException { } public String getInstanceDataNamespace ( ) { } @ Override public String getInstanceModelName ( ) { } public String createInstance ( String name , String className ) throws ConfigurationException , InvalidNameException , IOException { } private String convertDataSourceToString ( DataSource ds ) throws IOException { } public void setQueryTimeout ( long timeout ) throws ReasonerNotFoundException , SessionNotFoundException { } protected IConfigurationManager getConfigurationMgr ( ) throws ConfigurationException , MalformedURLException { } protected void setConfigurationMgr ( IConfigurationManager configurationMgr ) { } protected String getModelNamespace ( String modelName ) { } @ Override public boolean clearCache ( ) throws InvalidNameException , SessionNotFoundException { } private Object [ ] scanTemplateForImports ( String rawTemplate ) throws TemplateException { } private String scanTemplateForUri ( String rawTemplate ) throws TemplateException { } }
class Substring extends AbstractVal implements Val { private final Val _val1 ; private final Val _val2 ; private Joins _joins = null ; private ClassMetaData _meta = null ; public Substring ( Val val1 , Val val2 ) { } public ClassMetaData getMetaData ( ) { } public void setMetaData ( ClassMetaData meta ) { } public boolean isVariable ( ) { } public Class getType ( ) { } public void setImplicitType ( Class type ) { } public void initialize ( Select sel , JDBCStore store , boolean nullTest ) { } public Joins getJoins ( ) { } public Object toDataStoreValue ( Object val , JDBCStore store ) { } public void select ( Select sel , JDBCStore store , Object [ ] params , boolean pks , JDBCFetchConfiguration fetch ) { } public void selectColumns ( Select sel , JDBCStore store , Object [ ] params , boolean pks , JDBCFetchConfiguration fetch ) { } public void groupBy ( Select sel , JDBCStore store , Object [ ] params , JDBCFetchConfiguration fetch ) { <START_BUG> sel . groupBy ( newSQLBuffer ( sel , store , params , fetch ) , false ) ; <END_BUG> } public void orderBy ( Select sel , JDBCStore store , Object [ ] params , boolean asc , JDBCFetchConfiguration fetch ) { } private SQLBuffer newSQLBuffer ( Select sel , JDBCStore store , Object [ ] params , JDBCFetchConfiguration fetch ) { } public Object load ( Result res , JDBCStore store , JDBCFetchConfiguration fetch ) throws SQLException { } public boolean hasVariable ( Variable var ) { } public void calculateValue ( Select sel , JDBCStore store , Object [ ] params , Val other , JDBCFetchConfiguration fetch ) { } public void clearParameters ( ) { } public int length ( ) { } public void appendTo ( SQLBuffer sql , int index , Select sel , JDBCStore store , Object [ ] params , JDBCFetchConfiguration fetch ) { } }
public class LoggerLevelChange extends AbstractModelUpdateHandler { static final String OPERATION_NAME = "change-log-level" ; static final LoggerLevelChange INSTANCE = new LoggerLevelChange ( ) ; @ Override protected void updateModel ( final ModelNode operation , final ModelNode model ) throws OperationFailedException { } @ Override protected void performRuntime ( final OperationContext context , final ModelNode operation , final ModelNode model , final ServiceVerificationHandler verificationHandler , final List < ServiceController < ? > > newControllers ) throws OperationFailedException { final PathAddress address = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) ; final String name = address . getLastElement ( ) . getValue ( ) ; final ModelNode level = CommonAttributes . LEVEL . validateResolvedOperation ( model ) ; <START_BUG> final ServiceRegistry serviceRegistry = context . getServiceRegistry ( false ) ; <END_BUG> final ServiceController < Logger > controller = ( ( ServiceController < Logger > ) ( serviceRegistry . getService ( LogServices . loggerName ( name ) ) ) ) ; if ( ( controller != null ) && ( level . isDefined ( ) ) ) { controller . getValue ( ) . setLevel ( Level . parse ( level . asString ( ) ) ) ; } } }
public class PackageFragment extends Openable implements IPackageFragment , SuffixConstants { protected static final IClassFile [ ] NO_CLASSFILES = new IClassFile [ ] { } ; protected static final ICompilationUnit [ ] NO_COMPILATION_UNITS = new ICompilationUnit [ ] { } ; protected PackageFragment ( PackageFragmentRoot root , String name ) { } protected boolean buildStructure ( OpenableElementInfo info , IProgressMonitor pm , Map newElements , IResource underlyingResource ) throws JavaModelException { } public boolean containsJavaResources ( ) throws JavaModelException { } public void copy ( IJavaElement container , IJavaElement sibling , String rename , boolean force , IProgressMonitor monitor ) throws JavaModelException { } public ICompilationUnit createCompilationUnit ( String cuName , String contents , boolean force , IProgressMonitor monitor ) throws JavaModelException { } protected Object createElementInfo ( ) { } public void delete ( boolean force , IProgressMonitor monitor ) throws JavaModelException { } public boolean equals ( Object o ) { } public IClassFile getClassFile ( String classFileName ) { } public IClassFile [ ] getClassFiles ( ) throws JavaModelException { } public ICompilationUnit getCompilationUnit ( String cuName ) { } public ICompilationUnit [ ] getCompilationUnits ( ) throws JavaModelException { } public ICompilationUnit [ ] getCompilationUnits ( WorkingCopyOwner owner ) { ICompilationUnit [ ] workingCopies = JavaModelManager . getJavaModelManager ( ) . getWorkingCopies ( owner , false ) ; if ( workingCopies == null ) <START_BUG> return NoWorkingCopy ; <END_BUG> int length = workingCopies . length ; ICompilationUnit [ ] result = new ICompilationUnit [ length ] ; int index = 0 ; for ( int i = 0 ; i < length ; i ++ ) { ICompilationUnit wc = workingCopies [ i ] ; if ( equals ( wc . getParent ( ) ) ) { result [ ( index ++ ) ] = wc ; } } if ( index != length ) { System . arraycopy ( result , 0 , ( result = new ICompilationUnit [ index ] ) , 0 , index ) ; } return result ; } public int getElementType ( ) { } public IJavaElement getHandleFromMemento ( String token , StringTokenizer memento , WorkingCopyOwner owner ) { } protected char getHandleMementoDelimiter ( ) { } public int getKind ( ) throws JavaModelException { } public Object [ ] getNonJavaResources ( ) throws JavaModelException { } public IPath getPath ( ) { } public IResource getResource ( ) { } public IResource getUnderlyingResource ( ) throws JavaModelException { } public boolean hasChildren ( ) throws JavaModelException { } public boolean hasSubpackages ( ) throws JavaModelException { } public boolean isDefaultPackage ( ) { } public void move ( IJavaElement container , IJavaElement sibling , String rename , boolean force , IProgressMonitor monitor ) throws JavaModelException { } public void rename ( String newName , boolean force , IProgressMonitor monitor ) throws JavaModelException { } protected void toStringChildren ( int tab , StringBuffer buffer , Object info ) { } protected void toStringInfo ( int tab , StringBuffer buffer , Object info ) { } }
public class PlatformLoggingMXBeanGetLoggerLevelHandler implements OperationStepHandler , DescriptionProvider { public static final PlatformLoggingMXBeanGetLoggerLevelHandler INSTANCE = new PlatformLoggingMXBeanGetLoggerLevelHandler ( ) ; private static final String [ ] SIGNATURE = new String [ ] { String . class . getName ( ) } ; private final ParametersValidator parametersValidator = new ParametersValidator ( ) ; private PlatformLoggingMXBeanGetLoggerLevelHandler ( ) { } @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { parametersValidator . validate ( operation ) ; final String loggerName = operation . require ( LOGGER_NAME ) . asString ( ) ; try { Object level = ManagementFactory . getPlatformMBeanServer ( ) . invoke ( PLATFORM_LOGGING_OBJECT_NAME , "getLoggerLevel" , new String [ ] { loggerName } , PlatformLoggingMXBeanGetLoggerLevelHandler . SIGNATURE ) ; final ModelNode result = context . getResult ( ) ; if ( level != null ) { result . set ( level . toString ( ) ) ; } } catch ( JMRuntimeException e ) { throw e ; } catch ( JMException e ) { throw new RuntimeException ( e ) ; } <START_BUG> context . completeStep ( ) ; <END_BUG> } @ Override public ModelNode getModelDescription ( Locale locale ) { } }
public class HcfsFileSystemTest { static FileSystem fs ; @ Test public void testEncodedPaths ( ) throws Exception { FileSystem fs2 = HcfsFileSystemTest . fs ; Path encodedFiles = new Path ( ( "/tmp/encodedTest" + ( System . currentTimeMillis ( ) ) ) ) ; fs2 . mkdirs ( encodedFiles ) ; fs2 . create ( new Path ( encodedFiles , "a" ) ) ; fs2 . create ( new Path ( encodedFiles , "a%2" ) ) ; fs2 . create ( new Path ( encodedFiles , "a%2a" ) ) ; fs2 . create ( new Path ( encodedFiles , "a%3a" ) ) ; fs2 . create ( new Path ( encodedFiles , "a%4a" ) ) ; Assert . assertEquals ( 5 , fs2 . listStatus ( encodedFiles ) . length ) ; <START_BUG> fs2 . delete ( encodedFiles ) ; <END_BUG> } @ BeforeClass public static void setup ( ) throws Exception { } @ AfterClass public static void after ( ) throws IOException { } @ After public void tearDown ( ) throws Exception { } @ Test public void testTolerantMkdirs ( ) throws Exception { } @ Test public void testOwner ( ) throws Exception { } @ Test public void testTextWriteAndRead ( ) throws Exception { } @ Test public void testPermissions ( ) throws Exception { } @ Test public void testZDirs ( ) throws Exception { } @ Test public void testFiles ( ) throws Exception { } public void testFileIO ( ) throws Exception { } @ Test public void testPermissionsChanging ( ) throws Exception { } }
public class ForStatement extends Statement { private ASTNode . NodeList initializers = new ASTNode . NodeList ( true , Expression . class ) ; private Expression optionalConditionExpression = null ; private ASTNode . NodeList updaters = new ASTNode . NodeList ( true , Expression . class ) ; private Statement body = null ; ForStatement ( AST ast ) { } public int getNodeType ( ) { } ASTNode clone ( AST target ) { ForStatement result = new ForStatement ( target ) ; result . setSourceRange ( this . getStartPosition ( ) , this . getLength ( ) ) ; <START_BUG> result . setLeadingComment ( getLeadingComment ( ) ) ; <END_BUG> result . initializers ( ) . addAll ( ASTNode . copySubtrees ( target , initializers ( ) ) ) ; result . setExpression ( ( ( Expression ) ( ASTNode . copySubtree ( target , getExpression ( ) ) ) ) ) ; result . updaters ( ) . addAll ( ASTNode . copySubtrees ( target , updaters ( ) ) ) ; result . setBody ( ( ( Statement ) ( ASTNode . copySubtree ( target , getBody ( ) ) ) ) ) ; return result ; } public boolean subtreeMatch ( ASTMatcher matcher , Object other ) { } void accept0 ( ASTVisitor visitor ) { } public List initializers ( ) { } public Expression getExpression ( ) { } public void setExpression ( Expression expression ) { } public List updaters ( ) { } public Statement getBody ( ) { } public void setBody ( Statement statement ) { } int memSize ( ) { } int treeSize ( ) { } }
public class AnnotProxyFieldValueFactory implements IFieldValueFactory { private final ISpringContextLocator contextLocator ; private final ConcurrentHashMap < SpringBeanLocator , Object > cache = Generics . newConcurrentHashMap ( ) ; private final ConcurrentHashMap < Class < ? > , String > beanNameCache = Generics . newConcurrentHashMap ( ) ; private final boolean wrapInProxies ; public AnnotProxyFieldValueFactory ( ISpringContextLocator contextLocator ) { } public AnnotProxyFieldValueFactory ( ISpringContextLocator contextLocator , boolean wrapInProxies ) { } public Object getFieldValue ( Field field , Object fieldOwner ) { <START_BUG> if ( field . isAnnotationPresent ( SpringBean . class ) ) { <END_BUG> SpringBeanLocator locator = new SpringBeanLocator ( getBeanName ( field ) , field . getType ( ) , contextLocator ) ; Object cachedValue = cache . get ( locator ) ; if ( cachedValue != null ) { return cachedValue ; } final Object target ; if ( wrapInProxies ) { target = LazyInitProxyFactory . createProxy ( field . getType ( ) , locator ) ; } else { target = locator . locateProxyTarget ( ) ; } if ( locator . isSingletonBean ( ) ) { cache . put ( locator , target ) ; } return target ; } return null ; } private String getBeanName ( final Field field ) { } private final String getBeanNameOfClass ( ApplicationContext ctx , Class < ? > clazz ) { } public boolean supportsField ( Field field ) { } }
@ SuppressCodecs ( "Lucene3x" ) public class TestDocValuesIndexing extends LuceneTestCase { public void testDocValuesSimple ( ) throws IOException { } public void testIndexBytesNoDeletes ( ) throws IOException { } public void testIndexBytesDeletes ( ) throws IOException { } public void testIndexNumericsNoDeletes ( ) throws IOException { } public void testIndexNumericsDeletes ( ) throws IOException { } public void testAddIndexes ( ) throws IOException { } public void testAddIndexesRandom ( ) throws IOException { } private IndexWriterConfig writerConfig ( boolean useCompoundFile ) { } @ SuppressWarnings ( "fallthrough" ) public void runTestNumerics ( IndexWriterConfig cfg , boolean withDeletions ) throws IOException { } public void runTestIndexBytes ( IndexWriterConfig cfg , boolean withDeletions ) throws IOException { } public void testGetArrayNumerics ( ) throws IOException { } public void testGetArrayBytes ( ) throws IOException { } private DocValues getDocValues ( IndexReader reader , String field ) throws IOException { } @ SuppressWarnings ( "fallthrough" ) private Source getSource ( DocValues values ) throws IOException { } private static EnumSet < Type > BYTES = EnumSet . of ( BYTES_FIXED_DEREF , BYTES_FIXED_STRAIGHT , BYTES_VAR_DEREF , BYTES_VAR_STRAIGHT , BYTES_FIXED_SORTED , BYTES_VAR_SORTED ) ; private static EnumSet < Type > NUMERICS = EnumSet . of ( VAR_INTS , FIXED_INTS_16 , FIXED_INTS_32 , FIXED_INTS_64 , FIXED_INTS_8 , FLOAT_32 , FLOAT_64 ) ; private FixedBitSet indexValues ( IndexWriter w , int numValues , Type valueType , List < Type > valueVarList , boolean withDeletions , int bytesSize ) throws IOException { } public void testMultiValuedDocValuesField ( ) throws Exception { } public void testDifferentTypedDocValuesField ( ) throws Exception { } public void testSortedBytes ( ) throws IOException { } public int docId ( AtomicReader reader , Term term ) throws IOException { int docFreq = reader . docFreq ( term ) ; assertEquals ( 1 , docFreq ) ; <START_BUG> DocsEnum termDocsEnum = reader . termDocsEnum ( null , term . field , term . bytes , false ) ; <END_BUG> int nextDoc = termDocsEnum . nextDoc ( ) ; assertEquals ( NO_MORE_DOCS , termDocsEnum . nextDoc ( ) ) ; return nextDoc ; } public void testWithThreads ( ) throws Exception { } public void testLengthPrefixAcrossTwoPages ( ) throws Exception { } }
public final class RuntimeTypeAdapterFactory < T > implements TypeAdapterFactory { private final Class < ? > baseType ; private final String typeFieldName ; private final Map < String , Class < ? > > labelToSubtype = new LinkedHashMap < String , Class < ? > > ( ) ; private final Map < Class < ? > , String > subtypeToLabel = new LinkedHashMap < Class < ? > , String > ( ) ; private RuntimeTypeAdapterFactory ( Class < ? > baseType , String typeFieldName ) { } public static < T > RuntimeTypeAdapterFactory < T > of ( Class < T > baseType , String typeFieldName ) { } public static < T > RuntimeTypeAdapterFactory < T > of ( Class < T > baseType ) { } public RuntimeTypeAdapterFactory < T > registerSubtype ( Class < ? extends T > type , String label ) { } public RuntimeTypeAdapterFactory < T > registerSubtype ( Class < ? extends T > type ) { } public < R > TypeAdapter < R > create ( Gson gson , TypeToken < R > type ) { if ( ( type . getRawType ( ) ) != ( baseType ) ) { return null ; } final Map < String , TypeAdapter < ? > > labelToDelegate = new LinkedHashMap < String , TypeAdapter < ? > > ( ) ; final Map < Class < ? > , TypeAdapter < ? > > subtypeToDelegate = new LinkedHashMap < Class < ? > , TypeAdapter < ? > > ( ) ; for ( Map . Entry < String , Class < ? > > entry : labelToSubtype . entrySet ( ) ) { TypeAdapter < ? > delegate = gson . getDelegateAdapter ( this , TypeToken . get ( entry . getValue ( ) ) ) ; labelToDelegate . put ( entry . getKey ( ) , delegate ) ; subtypeToDelegate . put ( entry . getValue ( ) , delegate ) ; } return new TypeAdapter < R > ( ) { @ Override public R read ( JsonReader in ) throws IOException { JsonElement jsonElement = Streams . parse ( in ) ; <START_BUG> JsonElement labelJsonElement = jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; <END_BUG> if ( labelJsonElement == null ) { throw new JsonParseException ( ( ( ( "cannot<seq2seq4repair_space>deserialize<seq2seq4repair_space>" + ( baseType ) ) + "<seq2seq4repair_space>because<seq2seq4repair_space>it<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>define<seq2seq4repair_space>a<seq2seq4repair_space>field<seq2seq4repair_space>named<seq2seq4repair_space>" ) + ( typeFieldName ) ) ) ; } String label = labelJsonElement . getAsString ( ) ; @ SuppressWarnings ( "unchecked" ) TypeAdapter < R > delegate = ( ( TypeAdapter < R > ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate == null ) { delegate = ( ( TypeAdapter < R > ) ( labelToDelegate . get ( "default_value_mapping" ) ) ) ; } if ( delegate == null ) { throw new JsonParseException ( ( ( ( ( "cannot<seq2seq4repair_space>deserialize<seq2seq4repair_space>" + ( baseType ) ) + "<seq2seq4repair_space>subtype<seq2seq4repair_space>named<seq2seq4repair_space>" ) + label ) + ";<seq2seq4repair_space>did<seq2seq4repair_space>you<seq2seq4repair_space>forget<seq2seq4repair_space>to<seq2seq4repair_space>register<seq2seq4repair_space>a<seq2seq4repair_space>subtype?" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } @ Override public void write ( JsonWriter out , R value ) throws IOException { Class < ? > srcType = value . getClass ( ) ; String label = subtypeToLabel . get ( srcType ) ; @ SuppressWarnings ( "unchecked" ) TypeAdapter < R > delegate = ( ( TypeAdapter < R > ) ( subtypeToDelegate . get ( srcType ) ) ) ; if ( delegate == null ) { throw new JsonParseException ( ( ( "cannot<seq2seq4repair_space>serialize<seq2seq4repair_space>" + ( srcType . getName ( ) ) ) + ";<seq2seq4repair_space>did<seq2seq4repair_space>you<seq2seq4repair_space>forget<seq2seq4repair_space>to<seq2seq4repair_space>register<seq2seq4repair_space>a<seq2seq4repair_space>subtype?" ) ) ; } JsonObject jsonObject = delegate . toJsonTree ( value ) . getAsJsonObject ( ) ; if ( jsonObject . has ( typeFieldName ) ) { throw new JsonParseException ( ( ( ( "cannot<seq2seq4repair_space>serialize<seq2seq4repair_space>" + ( srcType . getName ( ) ) ) + "<seq2seq4repair_space>because<seq2seq4repair_space>it<seq2seq4repair_space>already<seq2seq4repair_space>defines<seq2seq4repair_space>a<seq2seq4repair_space>field<seq2seq4repair_space>named<seq2seq4repair_space>" ) + ( typeFieldName ) ) ) ; } JsonObject clone = new JsonObject ( ) ; clone . add ( typeFieldName , new JsonPrimitive ( label ) ) ; for ( Map . Entry < String , JsonElement > e : jsonObject . entrySet ( ) ) { clone . add ( e . getKey ( ) , e . getValue ( ) ) ; } Streams . write ( clone , out ) ; } } ; } No newline ; at end ; of file ; }
public class FreeTextSuggester extends Lookup { public static final String CODEC_NAME = "freetextsuggest" ; public static final int VERSION_START = 0 ; public static final int VERSION_CURRENT = FreeTextSuggester . VERSION_START ; public static final int DEFAULT_GRAMS = 2 ; public static final double ALPHA = 0.4 ; private FST < Long > fst ; private final Analyzer indexAnalyzer ; private long totTokens ; private final Analyzer queryAnalyzer ; private final int grams ; private final byte separator ; public static final byte DEFAULT_SEPARATOR = 30 ; public FreeTextSuggester ( Analyzer analyzer ) { } public FreeTextSuggester ( Analyzer indexAnalyzer , Analyzer queryAnalyzer ) { } public FreeTextSuggester ( Analyzer indexAnalyzer , Analyzer queryAnalyzer , int grams ) { } public FreeTextSuggester ( Analyzer indexAnalyzer , Analyzer queryAnalyzer , int grams , byte separator ) { } @ Override public long sizeInBytes ( ) { } private static class AnalyzingComparator implements Comparator < BytesRef > { private final ByteArrayDataInput readerA = new ByteArrayDataInput ( ) ; private final ByteArrayDataInput readerB = new ByteArrayDataInput ( ) ; private final BytesRef scratchA = new BytesRef ( ) ; private final BytesRef scratchB = new BytesRef ( ) ; @ Override public int compare ( BytesRef a , BytesRef b ) { } } private Analyzer addShingles ( final Analyzer other ) { } @ Override public void build ( InputIterator iterator ) throws IOException { } public void build ( InputIterator iterator , double ramBufferSizeMB ) throws IOException { if ( iterator . hasPayloads ( ) ) { throw new IllegalArgumentException ( "payloads<seq2seq4repair_space>are<seq2seq4repair_space>not<seq2seq4repair_space>supported" ) ; } String prefix = getClass ( ) . getSimpleName ( ) ; File directory = Sort . defaultTempDir ( ) ; File tempIndexPath = null ; Random random = new Random ( ) ; while ( true ) { tempIndexPath = new File ( directory , ( ( prefix + ".index." ) + ( random . nextInt ( Integer . MAX_VALUE ) ) ) ) ; if ( tempIndexPath . mkdir ( ) ) { break ; } } Directory dir = FSDirectory . open ( tempIndexPath ) ; <START_BUG> IndexWriterConfig iwc = new IndexWriterConfig ( Version . LUCENE_46 , indexAnalyzer ) ; <END_BUG> iwc . setOpenMode ( CREATE ) ; iwc . setRAMBufferSizeMB ( ramBufferSizeMB ) ; IndexWriter writer = new IndexWriter ( dir , iwc ) ; FieldType ft = new FieldType ( TextField . TYPE_NOT_STORED ) ; ft . setIndexOptions ( DOCS_AND_FREQS ) ; ft . setOmitNorms ( true ) ; ft . freeze ( ) ; Document doc = new Document ( ) ; Field field = new Field ( "body" , "" , ft ) ; doc . add ( field ) ; totTokens = 0 ; IndexReader reader = null ; boolean success = false ; try { while ( true ) { BytesRef surfaceForm = iterator . next ( ) ; if ( surfaceForm == null ) { break ; } field . setStringValue ( surfaceForm . utf8ToString ( ) ) ; writer . addDocument ( doc ) ; } reader = DirectoryReader . open ( writer , false ) ; Terms terms = MultiFields . getTerms ( reader , "body" ) ; if ( terms == null ) { throw new IllegalArgumentException ( "need<seq2seq4repair_space>at<seq2seq4repair_space>least<seq2seq4repair_space>one<seq2seq4repair_space>suggestion" ) ; } TermsEnum termsEnum = terms . iterator ( null ) ; Outputs < Long > outputs = PositiveIntOutputs . getSingleton ( ) ; Builder < Long > builder = new Builder < Long > ( INPUT_TYPE . BYTE1 , outputs ) ; IntsRef scratchInts = new IntsRef ( ) ; while ( true ) { BytesRef term = termsEnum . next ( ) ; if ( term == null ) { break ; } int ngramCount = countGrams ( term ) ; if ( ngramCount > ( grams ) ) { throw new IllegalArgumentException ( ( ( ( ( ( "tokens<seq2seq4repair_space>must<seq2seq4repair_space>not<seq2seq4repair_space>contain<seq2seq4repair_space>separator<seq2seq4repair_space>byte;<seq2seq4repair_space>got<seq2seq4repair_space>token=" + term ) + "<seq2seq4repair_space>but<seq2seq4repair_space>gramCount=" ) + ngramCount ) + ",<seq2seq4repair_space>which<seq2seq4repair_space>is<seq2seq4repair_space>greater<seq2seq4repair_space>than<seq2seq4repair_space>expected<seq2seq4repair_space>max<seq2seq4repair_space>ngram<seq2seq4repair_space>size=" ) + ( grams ) ) ) ; } if ( ngramCount == 1 ) { totTokens += termsEnum . totalTermFreq ( ) ; } builder . add ( Util . toIntsRef ( term , scratchInts ) , encodeWeight ( termsEnum . totalTermFreq ( ) ) ) ; } fst = builder . finish ( ) ; if ( ( fst ) == null ) { throw new IllegalArgumentException ( "need<seq2seq4repair_space>at<seq2seq4repair_space>least<seq2seq4repair_space>one<seq2seq4repair_space>suggestion" ) ; } success = true ; } finally { try { if ( success ) { IOUtils . close ( writer , reader ) ; } else { IOUtils . closeWhileHandlingException ( writer , reader ) ; } } finally { for ( String file : dir . listAll ( ) ) { File path = new File ( tempIndexPath , file ) ; if ( ( path . delete ( ) ) == false ) { throw new IllegalStateException ( ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>remove<seq2seq4repair_space>" + path ) ) ; } } if ( ( tempIndexPath . delete ( ) ) == false ) { throw new IllegalStateException ( ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>remove<seq2seq4repair_space>" + tempIndexPath ) ) ; } dir . close ( ) ; } } } @ Override public boolean store ( OutputStream output ) throws IOException { } @ Override public boolean load ( InputStream input ) throws IOException { } @ Override public List < LookupResult > lookup ( final CharSequence key , boolean onlyMorePopular , int num ) { } private int countGrams ( BytesRef token ) { } public List < LookupResult > lookup ( final CharSequence key , int num ) throws IOException { } private long encodeWeight ( long ngramCount ) { } private long decodeWeight ( Long output ) { } private Long lookupPrefix ( FST < Long > fst , FST . BytesReader bytesReader , BytesRef scratch , Arc < Long > arc ) throws IOException { }
public class DocumentationChecker { public static String ASSERTION_ID_WSDL_DOC = "CA6-WSDL-Documentation-Validation" ; public static String ASSERTION_ID_XSD_DOC = "CA17-XSD-Documentation-Validation" ; private static int TEXT_LENGTH_MAX = 700 ; private static int TEXT_LENGTH_MIN = 5 ; private static boolean isAscii ( String text ) { } private static boolean isDanish ( int ch ) { } private static String removeDanish ( String text ) { } private static void checkText ( String text , String element , int maxLength , int minLength , AnalysisInformationCollector collector , String assertion ) { } public static void checkWsdlDocumentation ( String wsdl , AnalysisInformationCollector collector ) { } public static void checkConceptSchemaDocumentation ( String xsd , AnalysisInformationCollector collector ) { try { String tns = XsdUtil . getTargetNamespace ( xsd ) ; if ( tns . startsWith ( "http://concept." ) ) { String elementsDoc = XQuery . runXQuery ( Paths . get ( "xsd" ) , "documentation.xq" , xsd ) ; List < Map < String , String > > elements = XQuery . mapResult ( elementsDoc , "name" , "documentation" ) ; for ( Map < String , String > element : elements ) { String elementName = element . get ( "name" ) ; String elementDoc = element . get ( "documentation" ) ; String elem = ( "'" + elementName ) + "'" ; <START_BUG> DocumentationChecker . checkText ( elementDoc , elem , DocumentationChecker . TEXT_LENGTH_MAX , DocumentationChecker . TEXT_LENGTH_MIN , collector , DocumentationChecker . ASSERTION_ID_WSDL_DOC ) ; <END_BUG> } } } catch ( Exception e ) { DocumentationChecker . collectException ( e , collector , DocumentationChecker . ASSERTION_ID_XSD_DOC ) ; } } private static void collectException ( Exception e , AnalysisInformationCollector collector , String assertion ) { } No newline ; at end ; of file ; }
public class SingleNameReference extends NameReference implements OperatorIds { public char [ ] token ; public MethodBinding [ ] syntheticAccessors ; public static final int READ = 0 ; public static final int WRITE = 1 ; public SingleNameReference ( char [ ] source , long pos ) { } public FlowInfo analyseAssignment ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , Assignment assignment , boolean isCompound ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , boolean valueRequired ) { } public TypeBinding checkFieldAccess ( BlockScope scope ) { FieldBinding fieldBinding = ( ( FieldBinding ) ( binding ) ) ; bits &= ~ ( ASTNode . RestrictiveFlagMASK ) ; bits |= FIELD ; if ( ! ( ( ( FieldBinding ) ( binding ) ) . isStatic ( ) ) ) { if ( scope . methodScope ( ) . isStatic ) { scope . problemReporter ( ) . staticFieldAccessToNonStaticVariable ( this , fieldBinding ) ; constant = NotAConstant ; return null ; } } constant = FieldReference . getConstantFor ( fieldBinding , true , this , scope , 0 ) ; if ( isFieldUseDeprecated ( fieldBinding , scope ) ) scope . problemReporter ( ) . deprecatedField ( fieldBinding , this ) ; MethodScope ms = scope . methodScope ( ) ; <START_BUG> if ( ( ( ( ms . enclosingSourceType ( ) ) == ( fieldBinding . declaringClass ) ) && ( ( ms . fieldDeclarationIndex ) != ( ms . NotInFieldDecl ) ) ) && ( ( fieldBinding . id ) >= ( ms . fieldDeclarationIndex ) ) ) { <END_BUG> if ( ( ! ( fieldBinding . isStatic ( ) ) ) || ( ms . isStatic ) ) scope . problemReporter ( ) . forwardReference ( this , 0 , scope . enclosingSourceType ( ) ) ; } return fieldBinding . type ; } public void generateAssignment ( BlockScope currentScope , CodeStream codeStream , Assignment assignment , boolean valueRequired ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public void generateCompoundAssignment ( BlockScope currentScope , CodeStream codeStream , Expression expression , int operator , int assignmentImplicitConversion , boolean valueRequired ) { } public void generateCompoundAssignment ( BlockScope currentScope , CodeStream codeStream , MethodBinding writeAccessor , Expression expression , int operator , int assignmentImplicitConversion , boolean valueRequired ) { } public void generatePostIncrement ( BlockScope currentScope , CodeStream codeStream , CompoundAssignment postIncrement , boolean valueRequired ) { } public void generateReceiver ( CodeStream codeStream ) { } public void manageEnclosingInstanceAccessIfNecessary ( BlockScope currentScope ) { } public void manageSyntheticReadAccessIfNecessary ( BlockScope currentScope ) { } public void manageSyntheticWriteAccessIfNecessary ( BlockScope currentScope ) { } public TypeBinding reportError ( BlockScope scope ) { } public TypeBinding resolveType ( BlockScope scope ) { } public String toStringExpression ( ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope scope ) { } public String unboundReferenceErrorName ( ) { } }
public class WeblogicDeploymentTool extends GenericDeploymentTool { public static final String PUBLICID_EJB11 = "-//Sun<seq2seq4repair_space>Microsystems,<seq2seq4repair_space>Inc.//DTD<seq2seq4repair_space>Enterprise<seq2seq4repair_space>JavaBeans<seq2seq4repair_space>1.1//EN" ; public static final String PUBLICID_EJB20 = "-//Sun<seq2seq4repair_space>Microsystems,<seq2seq4repair_space>Inc.//DTD<seq2seq4repair_space>Enterprise<seq2seq4repair_space>JavaBeans<seq2seq4repair_space>2.0//EN" ; public static final String PUBLICID_WEBLOGIC_EJB510 = "-//BEA<seq2seq4repair_space>Systems,<seq2seq4repair_space>Inc.//DTD<seq2seq4repair_space>WebLogic<seq2seq4repair_space>5.1.0<seq2seq4repair_space>EJB//EN" ; public static final String PUBLICID_WEBLOGIC_EJB600 = "-//BEA<seq2seq4repair_space>Systems,<seq2seq4repair_space>Inc.//DTD<seq2seq4repair_space>WebLogic<seq2seq4repair_space>6.0.0<seq2seq4repair_space>EJB//EN" ; public static final String PUBLICID_WEBLOGIC_EJB700 = "-//BEA<seq2seq4repair_space>Systems,<seq2seq4repair_space>Inc.//DTD<seq2seq4repair_space>WebLogic<seq2seq4repair_space>7.0.0<seq2seq4repair_space>EJB//EN" ; protected static final String DEFAULT_WL51_EJB11_DTD_LOCATION = "/weblogic/ejb/deployment/xml/ejb-jar.dtd" ; protected static final String DEFAULT_WL60_EJB11_DTD_LOCATION = "/weblogic/ejb20/dd/xml/ejb11-jar.dtd" ; protected static final String DEFAULT_WL60_EJB20_DTD_LOCATION = "/weblogic/ejb20/dd/xml/ejb20-jar.dtd" ; protected static final String DEFAULT_WL51_DTD_LOCATION = "/weblogic/ejb/deployment/xml/weblogic-ejb-jar.dtd" ; protected static final String DEFAULT_WL60_51_DTD_LOCATION = "/weblogic/ejb20/dd/xml/weblogic510-ejb-jar.dtd" ; protected static final String DEFAULT_WL60_DTD_LOCATION = "/weblogic/ejb20/dd/xml/weblogic600-ejb-jar.dtd" ; protected static final String DEFAULT_WL70_DTD_LOCATION = "/weblogic/ejb20/dd/xml/weblogic700-ejb-jar.dtd" ; protected static final String DEFAULT_COMPILER = "default" ; protected static final String WL_DD = "weblogic-ejb-jar.xml" ; protected static final String WL_CMP_DD = "weblogic-cmp-rdbms-jar.xml" ; protected static final String COMPILER_EJB11 = "weblogic.ejbc" ; protected static final String COMPILER_EJB20 = "weblogic.ejbc20" ; private String jarSuffix = ".jar" ; private String weblogicDTD ; private String ejb11DTD ; private boolean keepgenerated = false ; private String ejbcClass = null ; private String additionalArgs = "" ; private String additionalJvmArgs = "" ; private boolean keepGeneric = false ; private String compiler = null ; private boolean alwaysRebuild = true ; private boolean noEJBC = false ; private boolean newCMP = false ; private Path wlClasspath = null ; private Vector sysprops = new Vector ( ) ; private Integer jvmDebugLevel = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private File outputDir ; public void addSysproperty ( Environment . Variable sysp ) { } public Path createWLClasspath ( ) { } public void setOutputDir ( File outputDir ) { } public void setWLClasspath ( Path wlClasspath ) { } public void setCompiler ( String compiler ) { } public void setRebuild ( boolean rebuild ) { } public void setJvmDebugLevel ( Integer jvmDebugLevel ) { } public Integer getJvmDebugLevel ( ) { } public void setSuffix ( String inString ) { } public void setKeepgeneric ( boolean inValue ) { } public void setKeepgenerated ( String inValue ) { } public void setArgs ( String args ) { } public void setJvmargs ( String args ) { } public void setEjbcClass ( String ejbcClass ) { } public String getEjbcClass ( ) { } public void setWeblogicdtd ( String inString ) { } public void setWLdtd ( String inString ) { } public void setEJBdtd ( String inString ) { } public void setOldCMP ( boolean oldCMP ) { } public void setNewCMP ( boolean newCMP ) { } public void setNoEJBC ( boolean noEJBC ) { } protected void registerKnownDTDs ( DescriptorHandler handler ) { } protected DescriptorHandler getWeblogicDescriptorHandler ( final File srcDir ) { } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { } File getVendorOutputJarFile ( String baseName ) { } private void buildWeblogicJar ( File sourceJar , File destJar , String publicId ) { } protected void writeJar ( String baseName , File jarFile , Hashtable files , String publicId ) throws BuildException { } public void validateConfigured ( ) throws BuildException { } protected boolean isRebuildRequired ( File genericJarFile , File weblogicJarFile ) { } protected ClassLoader getClassLoaderFromJar ( File classjar ) throws IOException { Path lookupPath = new Path ( getTask ( ) . getProject ( ) ) ; lookupPath . setLocation ( classjar ) ; Path classpath = getCombinedClasspath ( ) ; if ( classpath != null ) { lookupPath . append ( classpath ) ; } <START_BUG> return new org . apache . tools . ant . AntClassLoader ( getTask ( ) . getProject ( ) , lookupPath ) ; <END_BUG> } }
public class GameConfiguratorEx implements AgentGenerator < Site > , GameInstanceGenerator < Site , Aggregator > { private final int current = 800 ; private final int min = 500 ; private final int max = 1000 ; private MersenneTwister twister = new MersenneTwister ( 2412 ) ; @ Override public Site getAgent ( ) { } @ Override public GameInstance < Site , Aggregator > generateInstance ( ) { <START_BUG> return new ExpGameInstance ( twister . nextInt ( ) , 2 , 2 ) ; <END_BUG> } }
public class MenuSeparatorContribution extends CommonMenuAddition { public MenuSeparatorContribution ( IConfigurationElement element ) { } public boolean isVisible ( ) { String val = element . getAttribute ( ATT_VISIBLE ) ; <START_BUG> return Boolean . parseBoolean ( val ) ; <END_BUG> } public void fill ( Menu parent , int index ) { } public void fill ( ToolBar parent , int index ) { } public String toString ( ) { } }
public class Copy extends Task { protected File file = null ; protected File destFile = null ; protected File destDir = null ; protected Vector filesets = new Vector ( ) ; protected boolean filtering = false ; protected boolean forceOverwrite = false ; protected boolean flatten = false ; protected int verbosity = Project . MSG_VERBOSE ; protected boolean includeEmpty = true ; protected Hashtable fileCopyMap = new Hashtable ( ) ; protected Hashtable dirCopyMap = new Hashtable ( ) ; public void setFile ( File file ) { } public void setTofile ( File destFile ) { } public void setTodir ( File destDir ) { } public void setFiltering ( boolean filtering ) { } public void setOverwrite ( boolean overwrite ) { } public void setFlatten ( boolean flatten ) { } public void setVerbose ( boolean verbose ) { } public void setIncludeEmptyDirs ( boolean includeEmpty ) { } public void addFileset ( FileSet set ) { } public void execute ( ) throws BuildException { } protected void validateAttributes ( ) throws BuildException { } protected void scan ( File fromDir , File toDir , String [ ] files , String [ ] dirs ) { } protected void buildMap ( File fromDir , File toDir , String [ ] names , FileNameMapper mapper , Hashtable map ) { String [ ] toCopy = null ; if ( forceOverwrite ) { toCopy = names ; } else { <START_BUG> SourceFileScanner ds = new SourceFileScanner ( ) ; <END_BUG> toCopy = ds . restrict ( names , fromDir , toDir , mapper ) ; } for ( int i = 0 ; i < ( toCopy . length ) ; i ++ ) { File src = new File ( fromDir , toCopy [ i ] ) ; File dest = new File ( toDir , mapper . mapFileName ( toCopy [ i ] ) [ 0 ] ) ; map . put ( src . getAbsolutePath ( ) , dest . getAbsolutePath ( ) ) ; } } protected void doFileOperations ( ) { } }
public class CTermUtil { public static boolean isList ( CTerm term ) { } public static void checkFlags ( int flags ) { } public static CTerm [ ] listAsArray ( CTerm term ) { } public static Vector < CTerm > listAsVector ( CTerm term ) { } public static Map < String , CTerm > listAsMap ( CTerm term ) { } public static CTerm createCTerm ( Object input ) { } public static String renderTerm ( CTerm term ) { } private static void renderTerm ( CTerm term , StringBuffer sb ) { } public static String renderSignature ( CTerm sig , String defaultModule ) { } public static CTerm parseNonCanonicalTerm ( String query ) throws IOException , PrologInterfaceException { } public static CTerm parseNonCanonicalTerm ( String term , PrologInterface pif ) throws PrologInterfaceException { <START_BUG> PrologSession session = pif . getSession ( CTERMS ) ; <END_BUG> String query = QueryUtils . bT ( "atom_to_term" , Util . quoteAtom ( term ) , "Term" , "D" ) ; Map < String , Object > result = session . queryOnce ( query ) ; session . dispose ( ) ; CTerm cTerm = ( ( CTerm ) ( result . get ( "Term" ) ) ) ; cTerm . toString ( ) ; Map < String , CTerm > map = CTermUtil . listAsMap ( ( ( CTerm ) ( result . get ( "D" ) ) ) ) ; Map < String , String > dictionary = CTermUtil . transformDictionary ( map ) ; cTerm . rename ( dictionary ) ; return cTerm ; } private static Map < String , String > transformDictionary ( Map < String , CTerm > map ) { } }
@ Component public class HueCommandHandler implements GroupCommandHandler { private static final Logger LOG = getLogger ( HueCommandHandler . class ) ; @ Autowired private List < HueCommandAction > actions ; private ConcurrentMap < String , HueCommandAction < Command > > actionMap = new ConcurrentHashMap < > ( ) ; @ PostConstruct public void prepareActions ( ) { } private void processAction ( HueCommandAction < Command > actionInstance ) { } private void addAction ( HueCommandAction < Command > actionInstance , Method method ) { } @ Override public void receive ( GroupItem groupItem , List < DeviceItem > items , Command command ) { } @ Override public void receive ( DeviceItem item , Command command ) { } private Optional < HueCommandAction < Command > > getAction ( Command command ) { HueCommandHandler . LOG . debug ( "Received<seq2seq4repair_space>a<seq2seq4repair_space>command,<seq2seq4repair_space>finding<seq2seq4repair_space>action<seq2seq4repair_space>handler<seq2seq4repair_space>for<seq2seq4repair_space>Command:<seq2seq4repair_space>{}" , command ) ; final Set < String > actionsExecuted = new HashSet < > ( ) ; for ( TypeToken t : TypeToken . of ( command . getClass ( ) ) . getTypes ( ) ) { String typeName = t . getRawType ( ) . getName ( ) ; HueCommandHandler . LOG . debug ( "Checking<seq2seq4repair_space>an<seq2seq4repair_space>action<seq2seq4repair_space>for<seq2seq4repair_space>type:<seq2seq4repair_space>{}" , typeName ) ; if ( ! ( actionsExecuted . contains ( typeName ) ) ) { actionsExecuted . add ( typeName ) ; Optional < HueCommandAction < Command > > action = Optional . ofNullable ( actionMap . get ( typeName ) ) ; if ( action . isPresent ( ) ) { HueCommandHandler . LOG . debug ( "Found<seq2seq4repair_space>handler:<seq2seq4repair_space>{}<seq2seq4repair_space>for<seq2seq4repair_space>command:<seq2seq4repair_space>{}" , action . get ( ) , command ) ; return action ; } else { <START_BUG> HueCommandHandler . LOG . warn ( "Unsupported<seq2seq4repair_space>command:<seq2seq4repair_space>{}<seq2seq4repair_space>for<seq2seq4repair_space>HUE<seq2seq4repair_space>plugin<seq2seq4repair_space>type:<seq2seq4repair_space>{}" , command , typeName ) ; <END_BUG> } } else { HueCommandHandler . LOG . debug ( "Type<seq2seq4repair_space>already<seq2seq4repair_space>executed,<seq2seq4repair_space>skipping:<seq2seq4repair_space>{}" , typeName ) ; } } return Optional . empty ( ) ; } }
public class ColumnIndexer { public static void serialize ( ColumnFamily columnFamily , DataOutput dos ) { } private static BloomFilter createColumnBloomFilter ( Collection < IColumn > columns ) { int columnCount = 0 ; for ( IColumn column : columns ) { columnCount += column . getObjectCount ( ) ; } <START_BUG> BloomFilter bf = new BloomFilter ( columnCount , 4 ) ; <END_BUG> for ( IColumn column : columns ) { bf . add ( column . name ( ) ) ; if ( column instanceof SuperColumn ) { Collection < IColumn > subColumns = column . getSubColumns ( ) ; for ( IColumn subColumn : subColumns ) { bf . add ( subColumn . name ( ) ) ; } } } return bf ; } private static void doIndexing ( AbstractType comparator , Collection < IColumn > columns , DataOutput dos ) throws IOException { } }
public class StructuredSyslogServerEvent extends SyslogServerEvent { private static final long serialVersionUID = 1676499796406044315L ; protected String applicationName = SyslogConstants . STRUCTURED_DATA_APP_NAME_DEFAULT_VALUE ; protected String processId = null ; protected DateTime dateTime = null ; protected DateTimeFormatter dateTimeFormatter = null ; public StructuredSyslogServerEvent ( final byte [ ] message , int length , InetAddress inetAddress ) { } public StructuredSyslogServerEvent ( final String message , InetAddress inetAddress ) { } public DateTimeFormatter getDateTimeFormatter ( ) { } public void setDateTimeFormatter ( Object dateTimeFormatter ) { } protected void parseApplicationName ( ) { } protected void parseProcessId ( ) { } protected void parseDate ( ) { } protected void parseHost ( ) { } public String getApplicationName ( ) { } public String getProcessId ( ) { } public DateTime getDateTime ( ) { } public StructuredSyslogMessage getStructuredMessage ( ) { try { return StructuredSyslogMessage . fromString ( getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { <START_BUG> return new StructuredSyslogMessage ( null , null , getMessage ( ) ) ; <END_BUG> } } }
public abstract class ClassOrInterfaceView < M extends ClassOrInterface > implements CodeView < M > { protected static final String CLASS_STRING = "class<seq2seq4repair_space>" ; protected static final String INTERFACE_STRING = "interface<seq2seq4repair_space>" ; protected static final String ENUM_STRING = "enum<seq2seq4repair_space>" ; protected static final String IMPLEMENTS_STRING = "implements<seq2seq4repair_space>" ; protected static final String EXTENDS_STRING = "extends<seq2seq4repair_space>" ; protected static final String PACKAGE_STRING = "package<seq2seq4repair_space>" ; private String renderPackage ( M model ) { } protected String onBeforeFields ( CodeGenerator cg , M model ) { } protected Object wrapField ( Field field ) { } protected Object wrapMethod ( Method method ) { } private < In , C extends Collection < In > > Collection < Object > wrap ( C models , Function < In , Object > wrapper ) { } protected abstract String classOrInterfaceLabel ( ) { } protected abstract String extendsOrImplementsLabel ( ) { } protected abstract String onSuperType ( CodeGenerator cg , M model ) { } @ Override public Optional < String > render ( CodeGenerator cg , M model ) { Optional < String > packageName = packageName ( model . getName ( ) ) ; final DependencyManager mgr = cg . getDependencyMgr ( ) ; mgr . clearDependencies ( ) ; if ( packageName . isPresent ( ) ) { if ( mgr . isIgnored ( packageName . get ( ) ) ) { packageName = Optional . empty ( ) ; } else { mgr . ignorePackage ( packageName . get ( ) ) ; } } <START_BUG> final Optional < String > view = Optional . of ( ( ( ( ( ( ( ( ( ( ( renderPackage ( model ) ) + ( cg . onEach ( model . getDependencies ( ) ) . collect ( CodeCombiner . joinIfNotEmpty ( ClassOrInterfaceView . nl ( ) , EMPTY , ClassOrInterfaceView . dnl ( ) ) ) ) ) + ( ifelse ( cg . on ( model . getJavadoc ( ) ) , ( s ) -> s + ( nl ( ) ) , EMPTY ) ) ) + ( cg . onEach ( model . getModifiers ( ) ) . collect ( CodeCombiner . joinIfNotEmpty ( SPACE , EMPTY , SPACE ) ) ) ) + ( classOrInterfaceLabel ( ) ) ) + ( shortName ( model . getName ( ) ) ) ) + ( SPACE ) ) + ( onSuperType ( cg , model ) ) ) + ( cg . onEach ( model . getInterfaces ( ) ) . collect ( CodeCombiner . joinIfNotEmpty ( SPACE , extendsOrImplementsLabel ( ) , SPACE ) ) ) ) + ( block ( ( ( ( onBeforeFields ( cg , model ) ) + ( cg . onEach ( wrap ( model . getFields ( ) , ( Field f ) -> wrapField ( f ) ) ) . collect ( CodeCombiner . joinIfNotEmpty ( ClassOrInterfaceView . scnl ( ) , EMPTY , ClassOrInterfaceView . scdnl ( ) ) ) ) ) + ( cg . onEach ( wrap ( model . getMethods ( ) , ( Method m ) -> wrapMethod ( m ) ) ) . collect ( CodeCombiner . joinIfNotEmpty ( ClassOrInterfaceView . dnl ( ) ) ) ) ) ) ) ) ) ; <END_BUG> if ( packageName . isPresent ( ) ) { mgr . acceptPackage ( packageName . get ( ) ) ; } return view ; } No newline ; at end ; of file ; }
public abstract class AbstractFilter implements Filter { private MailFrameMediator mediator ; private Rfc822MessageViewer messageController ; public AbstractFilter ( MailFrameMediator mediator , Rfc822MessageViewer messageViewer ) { } public IMailFolderCommandReference filter ( IMailbox folder , Object uid , IColumbaMessage message ) throws Exception { TempFolder tempFolder = FolderTreeModel . getInstance ( ) . getTempFolder ( ) ; uid = tempFolder . addMessage ( message ) ; MailFolderCommandReference local = new MailFolderCommandReference ( tempFolder , new Object [ ] { uid } ) ; <START_BUG> TableSelectionHandler h1 = ( ( TableSelectionHandler ) ( mediator . getSelectionManager ( ) . getHandler ( "mail.table" ) ) ) ; <END_BUG> h1 . setLocalReference ( local ) ; messageController . setAttachmentSelectionReference ( local ) ; return local ; } public IFrameMediator getMediator ( ) { } }
public class JavadocArgumentExpression extends Expression { public char [ ] token ; public Argument argument ; public JavadocArgumentExpression ( char [ ] name , int startPos , int endPos , TypeReference typeRef ) { } private TypeBinding internalResolveType ( Scope scope ) { this . constant = Constant . NotAConstant ; if ( ( this . resolvedType ) != null ) return this . resolvedType . isValidBinding ( ) ? this . resolvedType : null ; if ( ( this . argument ) != null ) { TypeReference typeRef = this . argument . type ; if ( typeRef != null ) { this . resolvedType = typeRef . getTypeBinding ( scope ) ; typeRef . resolvedType = this . resolvedType ; if ( ( ( typeRef instanceof SingleTypeReference ) && ( ( this . resolvedType . leafComponentType ( ) . enclosingType ( ) ) != null ) ) && ( ( scope . compilerOptions ( ) . complianceLevel ) <= ( ClassFileConstants . JDK1_4 ) ) ) { scope . problemReporter ( ) . javadocInvalidMemberTypeQualification ( this . sourceStart , this . sourceEnd , scope . getDeclarationModifiers ( ) ) ; return null ; } if ( ! ( this . resolvedType . isValidBinding ( ) ) ) { scope . problemReporter ( ) . javadocInvalidType ( typeRef , this . resolvedType , scope . getDeclarationModifiers ( ) ) ; return null ; } if ( isTypeUseDeprecated ( this . resolvedType , scope ) ) { scope . problemReporter ( ) . javadocDeprecatedType ( this . resolvedType , typeRef , scope . getDeclarationModifiers ( ) ) ; } <START_BUG> return this . resolvedType = scope . environment ( ) . convertToRawType ( this . resolvedType ) ; <END_BUG> } } return null ; } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public void resolve ( BlockScope scope ) { } public TypeBinding resolveType ( BlockScope scope ) { } public TypeBinding resolveType ( ClassScope scope ) { } public void traverse ( ASTVisitor visitor , BlockScope blockScope ) { } public void traverse ( ASTVisitor visitor , ClassScope blockScope ) { } }
public class ReportPlan extends AbstractTestElement implements Serializable , TestListener { private static final long serialVersionUID = 233L ; private static final Logger log = LoggingManager . getLoggerForClass ( ) ; public static final String REPORT_PAGE = "ReportPlan.report_page" ; public static final String USER_DEFINED_VARIABLES = "ReportPlan.user_defined_variables" ; public static final String REPORT_COMMENTS = "ReportPlan.comments" ; public static final String BASEDIR = "ReportPlan.basedir" ; private transient List < AbstractThreadGroup > reportPages = new LinkedList < AbstractThreadGroup > ( ) ; private transient List < ConfigElement > configs = new LinkedList < ConfigElement > ( ) ; private static final List < String > itemsCanAdd = new LinkedList < String > ( ) ; private static ReportPlan plan ; private static volatile boolean functionalMode = false ; public ReportPlan ( ) { } public ReportPlan ( String name ) { } public void setUserDefinedVariables ( Arguments vars ) { } public String getBasedir ( ) { } public void setBasedir ( String b ) { } public Map < String , String > getUserDefinedVariables ( ) { } private Arguments getVariables ( ) { } public static boolean getFunctionalMode ( ) { } public void addParameter ( String name , String value ) { } public static ReportPlan createReportPlan ( String name ) { } @ Override public void addTestElement ( TestElement tg ) { } public void addJMeterComponent ( TestElement child ) { } public Collection < AbstractThreadGroup > getReportPages ( ) { } public void addConfigElement ( ConfigElement c ) { } public void addReportPage ( AbstractThreadGroup group ) { } public void testEnded ( ) { } public void testEnded ( String host ) { } public void testIterationStart ( LoopIterationEvent event ) { } public void testStarted ( ) { if ( ( ( getBasedir ( ) ) != null ) && ( ( getBasedir ( ) . length ( ) ) > 0 ) ) { try { org . apache . jmeter . services . FileServer . getFileServer ( ) . setBasedir ( ( ( org . apache . jmeter . services . FileServer . getFileServer ( ) . getBaseDir ( ) ) + ( getBasedir ( ) ) ) ) ; <START_BUG> } catch ( IOException e ) { <END_BUG> ReportPlan . log . error ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>set<seq2seq4repair_space>file<seq2seq4repair_space>server<seq2seq4repair_space>base<seq2seq4repair_space>dir<seq2seq4repair_space>with<seq2seq4repair_space>" + ( getBasedir ( ) ) ) , e ) ; } } } public void testStarted ( String host ) { } }
public class MinpackTest { @ Test public void testMinpackLinearFullRank ( ) { } @ Test public void testMinpackLinearRank1 ( ) { } @ Test public void testMinpackLinearRank1ZeroColsAndRows ( ) { } @ Test public void testMinpackRosenbrok ( ) { } @ Test public void testMinpackHelicalValley ( ) { } @ Test public void testMinpackPowellSingular ( ) { } @ Test public void testMinpackFreudensteinRoth ( ) { } @ Test public void testMinpackBard ( ) { } @ Test public void testMinpackKowalikOsborne ( ) { } @ Test public void testMinpackMeyer ( ) { } @ Test public void testMinpackWatson ( ) { } @ Test public void testMinpackBox3Dimensional ( ) { } @ Test public void testMinpackJennrichSampson ( ) { } @ Test public void testMinpackBrownDennis ( ) { } @ Test public void testMinpackChebyquad ( ) { } @ Test public void testMinpackBrownAlmostLinear ( ) { } @ Test public void testMinpackOsborne1 ( ) { } @ Test public void testMinpackOsborne2 ( ) { } private void minpackTest ( MinpackTest . MinpackFunction function , boolean exceptionExpected ) { final double tol = 2.22044604926E-16 ; final double sqrtTol = FastMath . sqrt ( tol ) ; LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer ( ) . withCostRelativeTolerance ( sqrtTol ) . withParameterRelativeTolerance ( sqrtTol ) . withOrthoTolerance ( tol ) ; LeastSquaresProblem problem = new LeastSquaresBuilder ( ) . maxEvaluations ( ( 400 * ( ( function . getN ( ) ) + 1 ) ) ) . maxIterations ( 2000 ) . model ( function . getModelFunction ( ) ) . jacobian ( function . getModelFunctionJacobian ( ) ) . target ( function . getTarget ( ) ) . weight ( new DiagonalMatrix ( function . getWeight ( ) ) ) . start ( function . getStartPoint ( ) ) . build ( ) ; try { final Optimum optimum = optimizer . optimize ( problem ) ; Assert . assertFalse ( exceptionExpected ) ; function . checkTheoreticalMinCost ( optimum . computeRMS ( ) ) ; <START_BUG> function . checkTheoreticalMinParams ( optimum . getPoint ( ) ) ; <END_BUG> } catch ( TooManyEvaluationsException e ) { Assert . assertTrue ( exceptionExpected ) ; } } private abstract static class MinpackFunction { protected int n ; protected int m ; protected double [ ] startParams ; protected double theoreticalMinCost ; protected double [ ] theoreticalMinParams ; protected double costAccuracy ; protected double paramsAccuracy ; protected MinpackFunction ( int m , double [ ] startParams , double theoreticalMinCost , double [ ] theoreticalMinParams ) { } protected static double [ ] buildArray ( int n , double x ) { } public double [ ] getTarget ( ) { } public double [ ] getWeight ( ) { } public double [ ] getStartPoint ( ) { } protected void setCostAccuracy ( double costAccuracy ) { } protected void setParamsAccuracy ( double paramsAccuracy ) { } public int getN ( ) { } public void checkTheoreticalMinCost ( double rms ) { } public void checkTheoreticalMinParams ( double [ ] params ) { } public MultivariateVectorFunction getModelFunction ( ) { } public MultivariateMatrixFunction getModelFunctionJacobian ( ) { } public abstract double [ ] [ ] computeJacobian ( double [ ] variables ) { } public abstract double [ ] computeValue ( double [ ] variables ) { } } private static class LinearFullRankFunction extends MinpackTest . MinpackFunction { private static final long serialVersionUID = - 9030323226268039536L ; public LinearFullRankFunction ( int m , int n , double x0 , double theoreticalStartCost , double theoreticalMinCost ) { } @ Override public double [ ] [ ] computeJacobian ( double [ ] variables ) { } @ Override public double [ ] computeValue ( double [ ] variables ) { } } private static class LinearRank1Function extends MinpackTest . MinpackFunction { private static final long serialVersionUID = 8494863245104608300L ; public LinearRank1Function ( int m , int n , double x0 , double theoreticalStartCost , double theoreticalMinCost ) { } @ Override public double [ ] [ ] computeJacobian ( double [ ] variables ) { } @ Override public double [ ] computeValue ( double [ ] variables ) { } } private static class LinearRank1ZeroColsAndRowsFunction extends MinpackTest . MinpackFunction { private static final long serialVersionUID = - 3316653043091995018L ; public LinearRank1ZeroColsAndRowsFunction ( int m , int n , double x0 ) { } @ Override public double [ ] [ ] computeJacobian ( double [ ] variables ) { } @ Override public double [ ] computeValue ( double [ ] variables ) { } } private static class RosenbrockFunction extends MinpackTest . MinpackFunction { private static final long serialVersionUID = 2893438180956569134L ; public RosenbrockFunction ( double [ ] startParams , double theoreticalStartCost ) { } @ Override public double [ ] [ ] computeJacobian ( double [ ] variables ) { } @ Override public double [ ] computeValue ( double [ ] variables ) { } } private static class HelicalValleyFunction extends MinpackTest . MinpackFunction { private static final long serialVersionUID = 220613787843200102L ; public HelicalValleyFunction ( double [ ] startParams , double theoreticalStartCost ) { } @ Override public double [ ] [ ] computeJacobian ( double [ ] variables ) { } @ Override public double [ ] computeValue ( double [ ] variables ) { } private static final double twoPi = 2.0 * ( FastMath . PI ) ; } private static class PowellSingularFunction extends MinpackTest . MinpackFunction { private static final long serialVersionUID = 7298364171208142405L ; public PowellSingularFunction ( double [ ] startParams , double theoreticalStartCost ) { } @ Override public double [ ] [ ] computeJacobian ( double [ ] variables ) { } @ Override public double [ ] computeValue ( double [ ] variables ) { } private static final double sqrt5 = FastMath . sqrt ( 5.0 ) ; private static final double sqrt10 = FastMath . sqrt ( 10.0 ) ; }
public class AndPattern extends IntersectingPattern { protected SearchPattern [ ] patterns ; int current ; private static int combinedMatchRule ( int matchRule , int matchRule2 ) { int combined = matchRule & matchRule2 ; int compatibility = combined & ( JavaSearchPattern . MATCH_COMPATIBILITY_MASK ) ; if ( compatibility == 0 ) { if ( ( matchRule & ( JavaSearchPattern . MATCH_COMPATIBILITY_MASK ) ) == ( SearchPattern . R_FULL_MATCH ) ) { compatibility = matchRule2 ; } else if ( ( matchRule2 & ( JavaSearchPattern . MATCH_COMPATIBILITY_MASK ) ) == ( SearchPattern . R_FULL_MATCH ) ) { compatibility = matchRule ; } else { compatibility = Math . min ( ( matchRule & ( JavaSearchPattern . MATCH_COMPATIBILITY_MASK ) ) , ( matchRule2 & ( JavaSearchPattern . MATCH_COMPATIBILITY_MASK ) ) ) ; } } <START_BUG> return ( ( ( combined & ( ( ( ( SearchPattern . R_EXACT_MATCH ) | ( SearchPattern . R_PREFIX_MATCH ) ) | ( SearchPattern . R_PATTERN_MATCH ) ) | ( SearchPattern . R_REGEXP_MATCH ) ) ) | ( combined & ( SearchPattern . R_CASE_SENSITIVE ) ) ) | compatibility ) | ( combined & ( R_CAMEL_CASE_MATCH ) ) ; <END_BUG> } public AndPattern ( SearchPattern leftPattern , SearchPattern rightPattern ) { } SearchPattern currentPattern ( ) { } protected boolean hasNextQuery ( ) { } protected void resetQuery ( ) { } }
public class ThrowStatement extends Statement { public Expression exception ; public TypeBinding exceptionType ; public ThrowStatement ( Expression exception , int startPosition ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { exception . analyseCode ( currentScope , flowContext , flowInfo ) ; flowContext . checkExceptionHandlers ( exceptionType , this , flowInfo , currentScope ) ; <START_BUG> return DeadEnd ; <END_BUG> } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public void resolve ( BlockScope scope ) { } public String toString ( int tab ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope blockScope ) { } }
public class BrettflanWorldBorder extends WorldBorder { World world ; BorderData border ; public BrettflanWorldBorder ( World world ) { } @ Override public void init ( ) { } @ Override public World getWorld ( ) { } @ Override public double getDiameter ( ) { <START_BUG> return border . getRadiusX ( ) ; <END_BUG> } @ Override public void setDiameter ( double diameter ) { } @ Override public void setDiameter ( double diameter , long time ) { } @ Override public Location getCenter ( ) { } @ Override public void setCenter ( double x , double z ) { } @ Override public void setCenter ( Location center ) { } @ Override public double getDamageBuffer ( ) { } @ Override public void setDamageBuffer ( double distance ) { } @ Override public double getDamageAmount ( ) { } @ Override public void setDamageAmount ( double damageAmount ) { } @ Override public int getWarningTime ( ) { } @ Override public void setWarningTime ( int seconds ) { } @ Override public int getWarningDistance ( ) { } @ Override public void setWarningDistance ( int blocks ) { } @ Override public MapShape getShape ( ) { } @ Override public void setShape ( MapShape shape ) { } }
public class SiadapEvaluationUniverse extends SiadapEvaluationUniverse_Base { private static final int PRECISION = 3 ; private static final int ROUND_MODE = BigDecimal . ROUND_HALF_EVEN ; public SiadapEvaluationUniverse ( Siadap siadap , SiadapUniverse siadapUniverse , CompetenceType competenceType , boolean defaultUniverse ) { } public boolean isCurriculumPonderation ( ) { } public boolean hasRelevantEvaluation ( ) { } public boolean isInadequate ( ) { } public SiadapGlobalEvaluation getSiadapGlobalEvaluationEnum ( boolean considerValidation , boolean getLatestGrade ) { } public boolean getCurrentExcellencyAward ( ) { } public BigDecimal getCurrentGrade ( ) { } private boolean hasCcaAfterValidationAssignedGrade ( ) { } public SiadapGlobalEvaluation getSiadapGlobalEvaluationEnumAfterValidation ( ) { } public SiadapGlobalEvaluation getSiadapGlobalEvaluationEnum ( ) { } public SiadapGlobalEvaluation getLatestSiadapGlobalEvaluationEnum ( ) { } public BigDecimal getTotalEvaluationScoring ( ) { } public BigDecimal getPonderatedCompetencesScoring ( ) { } public List < CompetenceEvaluation > getCompetenceEvaluations ( ) { } protected boolean hasCompleteValidationAssessment ( ) { } protected boolean hasValidationAssessment ( ) { } public BigDecimal getPonderatedObjectivesScoring ( ) { } public BigDecimal getObjectivesScoring ( ) { } public List < ObjectiveEvaluation > getObjectiveEvaluations ( ) { } public int getObjectivesPonderation ( ) { } public int getCompetencesPonderation ( ) { } public BigDecimal getCompetencesScoring ( ) { } private boolean isEvaluationScoringComplete ( List < ? extends SiadapEvaluationItem > evaluations ) { } private BigDecimal getEvaluationScoring ( List < ? extends SiadapEvaluationItem > evaluations ) { if ( ! ( isEvaluationScoringComplete ( evaluations ) ) ) { return BigDecimal . ZERO ; } BigDecimal result = new BigDecimal ( 0 ) ; for ( SiadapEvaluationItem evaluation : evaluations ) { IScoring itemEvaluation = evaluation . getItemEvaluation ( ) ; if ( itemEvaluation == null ) { <START_BUG> throw new SiadapException ( "resources/SiadapResources" , "error.siadapEvaluation.mustFillAllItems" ) ; <END_BUG> } result = result . add ( itemEvaluation . getPoints ( ) ) ; } if ( ( evaluations . size ( ) ) == 0 ) { return BigDecimal . ZERO ; } return result . divide ( new BigDecimal ( evaluations . size ( ) ) , SiadapEvaluationUniverse . PRECISION , SiadapEvaluationUniverse . ROUND_MODE ) ; } private BigDecimal getPonderationResult ( BigDecimal scoring , int usedPercentage ) { } protected < T extends SiadapEvaluationItem > List < T > getEvaluations ( Class < T > clazz , Predicate predicate , Comparator < T > comparator ) { } public boolean hasExcellencyAwardedFromEvaluator ( ) { } public boolean hasExcellencyAwarded ( ) { } public boolean isEvaluationDone ( ) { } @ Atomic public void setHarmonizationAssessments ( Boolean harmonizationAssessment , Boolean excellencyHarmonizationAssessment ) { } private boolean isWithFullAssessments ( Boolean newHarmonizationAssessment , Boolean newExcellencyHarmonizationAssessment ) { } @ Deprecated @ Override public void setHarmonizationAssessment ( Boolean harmonizationAssessment ) { } public boolean isWithSkippedEvaluation ( ) { } @ Override public void setHarmonizationDate ( LocalDate harmonizationDate ) { } @ Atomic public void removeHarmonizationAssessments ( ) { } public void delete ( ) { } @ Deprecated public Set < module . siadap . domain . SiadapEvaluationItem > getSiadapEvaluationItems ( ) { } }
public class WildcardType extends Type { public static final ChildPropertyDescriptor BOUND_PROPERTY = new ChildPropertyDescriptor ( WildcardType . class , "bound" , Type . class , ASTNode . OPTIONAL , ASTNode . CYCLE_RISK ) ; public static final SimplePropertyDescriptor UPPER_BOUND_PROPERTY = new SimplePropertyDescriptor ( WildcardType . class , "upperBound" , boolean . class , ASTNode . MANDATORY ) ; private static final List PROPERTY_DESCRIPTORS ; public static List propertyDescriptors ( int apiLevel ) { } private Type optionalBound = null ; private boolean isUpperBound = true ; WildcardType ( AST ast ) { } final List internalStructuralPropertiesForType ( int apiLevel ) { } final boolean internalGetSetBooleanProperty ( SimplePropertyDescriptor property , boolean get , boolean value ) { } final ASTNode internalGetSetChildProperty ( ChildPropertyDescriptor property , boolean get , ASTNode child ) { } final int getNodeType0 ( ) { } ASTNode clone0 ( AST target ) { WildcardType result = new WildcardType ( target ) ; <START_BUG> result . setSourceRange ( this . getStartPosition ( ) , this . getLength ( ) ) ; <END_BUG> result . setBound ( ( ( Type ) ( ASTNode . copySubtree ( target , getBound ( ) ) ) ) , isUpperBound ( ) ) ; return result ; } final boolean subtreeMatch0 ( ASTMatcher matcher , Object other ) { } void accept0 ( ASTVisitor visitor ) { } public boolean isUpperBound ( ) { } public Type getBound ( ) { } public void setBound ( Type type , boolean isUpperBound ) { } public void setBound ( Type type ) { } public void setUpperBound ( boolean isUpperBound ) { } int memSize ( ) { } int treeSize ( ) { } }
class SubTaskInfo extends JobTreeElement { protected String taskName ; JobInfo jobInfo ; SubTaskInfo ( JobInfo parentJob , String name ) { } Object [ ] getChildren ( ) { } String getDisplayString ( ) { if ( ( taskName ) == null ) <START_BUG> return ProgressMessages . getString ( "SubTaskInfo.UndefinedTaskName" ) ; <END_BUG> return taskName ; } boolean hasChildren ( ) { } void setTaskName ( String name ) { } String getTaskName ( ) { } Object getParent ( ) { } boolean isJobInfo ( ) { } boolean isActive ( ) { } }
class ProcessDestroyer implements Runnable { private Vector processes = new Vector ( ) ; private Method addShutdownHookMethod ; private Method removeShutdownHookMethod ; private ProcessDestroyer . ProcessDestroyerImpl destroyProcessThread = null ; private boolean added = false ; private class ProcessDestroyerImpl extends Thread { private boolean shouldDestroy = true ; public ProcessDestroyerImpl ( ) { } public void run ( ) { } public void setShouldDestroy ( boolean shouldDestroy ) { } } public ProcessDestroyer ( ) { } private void addShutdownHook ( ) { } private void removeShutdownHook ( ) { } public boolean isAddedAsShutdownHook ( ) { } public boolean add ( Process process ) { } public boolean remove ( Process process ) { synchronized ( processes ) { boolean processRemoved = processes . removeElement ( process ) ; if ( ( processes . size ( ) ) == 0 ) { <START_BUG> processes . notify ( ) ; <END_BUG> removeShutdownHook ( ) ; } return processRemoved ; } } public void run ( ) { } }
public class QuickVerificationCommand extends AbstractHandler { private String signatureId ; private boolean preferencesComplete = false ; private ExecutionEvent event ; private IFile file = null ; public Object execute ( ExecutionEvent event ) throws ExecutionException { } private void createVerification ( ) throws Exception { VerifySignature verify = new VerifySignature ( ) ; ArrayList < VerificationResult > results = new ArrayList < VerificationResult > ( ) ; if ( ( HandlerUtil . getActivePart ( event ) ) instanceof IEditorPart ) { final IEditorPart editorPart = ( ( IEditorPart ) ( HandlerUtil . getActivePart ( event ) ) ) ; if ( editorPart . isDirty ( ) ) { if ( ( null != ( editorPart . getTitle ( ) ) ) && ( ( editorPart . getTitle ( ) . length ( ) ) > 0 ) ) { IRunnableWithProgress op = new IRunnableWithProgress ( ) { public void run ( final IProgressMonitor monitor ) { editorPart . doSave ( monitor ) ; } } ; try { PlatformUI . getWorkbench ( ) . getProgressService ( ) . runInUI ( XSTUIPlugin . getActiveWorkbenchWindow ( ) , op , ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ) ; } catch ( InvocationTargetException ite ) { Utils . log ( "Error<seq2seq4repair_space>while<seq2seq4repair_space>saving<seq2seq4repair_space>editor<seq2seq4repair_space>content" , ite ) ; } catch ( InterruptedException ie ) { Utils . log ( "Error<seq2seq4repair_space>while<seq2seq4repair_space>saving<seq2seq4repair_space>editor<seq2seq4repair_space>content" , ie ) ; } } else { editorPart . doSaveAs ( ) ; } } file = ( ( IFile ) ( editorPart . getEditorInput ( ) . getAdapter ( IFile . class ) ) ) ; } else { ISelection selection = HandlerUtil . getCurrentSelection ( event ) ; if ( selection instanceof IStructuredSelection ) { file = ( ( IFile ) ( ( ( IStructuredSelection ) ( selection ) ) . getFirstElement ( ) ) ) ; } } if ( ( ( file ) != null ) && ( file . isAccessible ( ) ) ) { results = verify . verify ( file . getLocation ( ) . toString ( ) , signatureId ) ; } else { MessageDialog . openInformation ( HandlerUtil . getActiveShell ( event ) , QuickVerificationCommand_0 , NLS . bind ( RemoveReadOnlyFlag , QuickVerificationCommand_5 ) ) ; } if ( ( results . size ( ) ) == 1 ) { VerificationResult result = ( ( VerificationResult ) ( results . get ( 0 ) ) ) ; if ( ( result . getSignature ( ) ) != null ) { <START_BUG> Verification . showVerificationResult ( result , HandlerUtil . getActiveShell ( event ) ) ; <END_BUG> } else { MessageDialog . openError ( HandlerUtil . getActiveShell ( event ) , QuickVerificationCommand_0 , NLS . bind ( QuickVerificationCommand_4 , signatureId ) ) ; } } else { MessageDialog . openError ( HandlerUtil . getActiveShell ( event ) , QuickVerificationCommand_0 , NLS . bind ( QuickVerificationCommand_4 , signatureId ) ) ; } } private void getPreferenceValues ( ) { } private boolean checkPreferences ( ) { } }
public class Application { @ SuppressWarnings ( "FieldCanBeLocal" ) private static RabbitMQConnector notToBeGcedMQConnector ; public static void main ( String [ ] args ) throws IOException , InterruptedException { } private static InputStream configurationPropertiesStream ( String fileName ) throws IOException { if ( Strings . isNullOrEmpty ( fileName ) ) { Application . consoleLog ( "Configuration<seq2seq4repair_space>properties<seq2seq4repair_space>file<seq2seq4repair_space>not<seq2seq4repair_space>provided,<seq2seq4repair_space>using<seq2seq4repair_space>default<seq2seq4repair_space>application.properties<seq2seq4repair_space>file" ) ; <START_BUG> return Application . class . getResource ( "application.properties" ) . openStream ( ) ; <END_BUG> } else { Application . consoleLog ( ( "Loading<seq2seq4repair_space>properties<seq2seq4repair_space>file:<seq2seq4repair_space>" + fileName ) ) ; return new FileInputStream ( new File ( fileName ) ) ; } } private static Map < String , String > createConfigurationMap ( String [ ] args ) { } private static void consoleLog ( String logMessage ) { } }
public class SSTableReader extends SSTable implements Comparable < SSTableReader > { private static final Logger logger = LoggerFactory . getLogger ( SSTableReader . class ) ; private static final int INDEX_FILE_BUFFER_BYTES = 16 * ( IndexSummary . INDEX_INTERVAL ) ; private static final Set < Reference < SSTableReader > > finalizers = new HashSet < Reference < SSTableReader > > ( ) ; private static final ReferenceQueue < SSTableReader > finalizerQueue = new ReferenceQueue < SSTableReader > ( ) { } ; public final long maxDataAge ; private SegmentedFile ifile ; private SegmentedFile dfile ; private IndexSummary indexSummary ; private BloomFilter bf ; private InstrumentedCache < Pair < Descriptor , DecoratedKey > , Long > keyCache ; private BloomFilterTracker bloomFilterTracker = new BloomFilterTracker ( ) ; private volatile SSTableDeletingReference phantomReference ; public static int indexInterval ( ) { } public static long getApproximateKeyCount ( Iterable < SSTableReader > sstables ) { } public static SSTableReader open ( String dataFileName ) throws IOException { } public static SSTableReader open ( Descriptor desc ) throws IOException { } public static SSTableReader open ( String dataFileName , IPartitioner partitioner ) throws IOException { } public static SSTableReader open ( Descriptor descriptor , IPartitioner partitioner ) throws IOException { } static SSTableReader internalOpen ( Descriptor desc , IPartitioner partitioner ) throws IOException { } static SSTableReader internalOpen ( Descriptor desc , IPartitioner partitioner , SegmentedFile ifile , SegmentedFile dfile , IndexSummary isummary , BloomFilter bf , long maxDataAge ) throws IOException { } SSTableReader ( Descriptor desc , IPartitioner partitioner , SegmentedFile ifile , SegmentedFile dfile , IndexSummary indexSummary , BloomFilter bloomFilter , long maxDataAge ) throws IOException { } public void setTrackedBy ( SSTableTracker tracker ) { } void loadBloomFilter ( ) throws IOException { } private void load ( boolean recreatebloom ) throws IOException { } private KeyPosition getIndexScanPosition ( DecoratedKey decoratedKey ) { } public void forceFilterFailures ( ) { } public InstrumentedCache getKeyCache ( ) { } public long estimatedKeys ( ) { } public Collection < DecoratedKey > getKeySamples ( ) { } public List < Pair < Long , Long > > getPositionsForRanges ( Collection < Range > ranges ) { } public long getPosition ( DecoratedKey decoratedKey , SSTableReader . Operator op ) { <START_BUG> if ( ( op == ( SSTableReader . Operator . EQ ) ) && ( ! ( bf . isPresent ( partitioner . convertToDiskFormat ( decoratedKey ) ) ) ) ) <END_BUG> return - 1 ; Pair < Descriptor , DecoratedKey > unifiedKey = new Pair < Descriptor , DecoratedKey > ( desc , decoratedKey ) ; if ( ( ( keyCache ) != null ) && ( ( keyCache . getCapacity ( ) ) > 0 ) ) { Long cachedPosition = keyCache . get ( unifiedKey ) ; if ( cachedPosition != null ) { return cachedPosition ; } } IndexSummary . KeyPosition sampledPosition = getIndexScanPosition ( decoratedKey ) ; if ( sampledPosition == null ) { if ( op == ( SSTableReader . Operator . EQ ) ) bloomFilterTracker . addFalsePositive ( ) ; return ( op . apply ( 1 ) ) >= 0 ? 0 : - 1 ; } Iterator < FileDataInput > segments = ifile . iterator ( sampledPosition . indexPosition , SSTableReader . INDEX_FILE_BUFFER_BYTES ) ; while ( segments . hasNext ( ) ) { FileDataInput input = segments . next ( ) ; try { while ( ! ( input . isEOF ( ) ) ) { DecoratedKey indexDecoratedKey = partitioner . convertFromDiskFormat ( FBUtilities . readShortByteArray ( input ) ) ; long dataPosition = input . readLong ( ) ; int comparison = indexDecoratedKey . compareTo ( decoratedKey ) ; int v = op . apply ( comparison ) ; if ( v == 0 ) { if ( ( ( comparison == 0 ) && ( ( keyCache ) != null ) ) && ( ( keyCache . getCapacity ( ) ) > 0 ) ) { if ( op == ( SSTableReader . Operator . EQ ) ) bloomFilterTracker . addTruePositive ( ) ; keyCache . put ( unifiedKey , Long . valueOf ( dataPosition ) ) ; } return dataPosition ; } if ( v < 0 ) { if ( op == ( SSTableReader . Operator . EQ ) ) bloomFilterTracker . addFalsePositive ( ) ; return - 1 ; } } } catch ( IOException e ) { throw new IOError ( e ) ; } finally { try { input . close ( ) ; } catch ( IOException e ) { SSTableReader . logger . error ( "error<seq2seq4repair_space>closing<seq2seq4repair_space>file" , e ) ; } } } if ( op == ( SSTableReader . Operator . EQ ) ) bloomFilterTracker . addFalsePositive ( ) ; return - 1 ; } public long length ( ) { } public void markCompacted ( ) { } public SSTableScanner getScanner ( int bufferSize ) { } public SSTableScanner getScanner ( int bufferSize , QueryFilter filter ) { } public FileDataInput getFileDataInput ( DecoratedKey decoratedKey , int bufferSize ) { } public int compareTo ( SSTableReader o ) { } public AbstractType getColumnComparator ( ) { } public ColumnFamily makeColumnFamily ( ) { } public ICompactSerializer2 < IColumn > getColumnSerializer ( ) { } public boolean newSince ( long age ) { } public static long readRowSize ( DataInput in , Descriptor d ) throws IOException { } public abstract static class Operator { public static final SSTableReader . Operator EQ = new SSTableReader . Operator . Equals ( ) ; public static final SSTableReader . Operator GE = new SSTableReader . Operator . GreaterThanOrEqualTo ( ) ; public static final SSTableReader . Operator GT = new SSTableReader . Operator . GreaterThan ( ) ; public abstract int apply ( int comparison ) { } static final class Equals extends SSTableReader . Operator { public int apply ( int comparison ) { } }
public class ModifiedSelector extends BaseExtendSelector implements BuildListener , ResourceSelector { private ModifiedSelector . CacheName cacheName = null ; private String cacheClass ; private ModifiedSelector . AlgorithmName algoName = null ; private String algorithmClass ; private ModifiedSelector . ComparatorName compName = null ; private String comparatorClass ; private boolean update = true ; private boolean selectDirectories = true ; private boolean selectResourcesWithoutInputStream = true ; private boolean delayUpdate = true ; private Comparator comparator = null ; private Algorithm algorithm = null ; private Cache cache = null ; private int modified = 0 ; private boolean isConfigured = false ; private Vector configParameter = new Vector ( ) ; private Vector specialParameter = new Vector ( ) ; private ClassLoader myClassLoader = null ; private Path classpath = null ; public ModifiedSelector ( ) { } public void verifySettings ( ) { } public void configure ( ) { } protected Object loadClass ( String classname , String msg , Class type ) { } public boolean isSelected ( Resource resource ) { if ( resource . isFilesystemOnly ( ) ) { FileResource fileResource = ( ( FileResource ) ( resource ) ) ; File file = fileResource . getFile ( ) ; String filename = fileResource . getName ( ) ; File basedir = fileResource . getBaseDir ( ) ; return isSelected ( basedir , filename , file ) ; } else { try { FileUtils fu = FileUtils . getFileUtils ( ) ; <START_BUG> File tmpFile = fu . createTempFile ( "modified-" , ".tmp" , null ) ; <END_BUG> Resource tmpResource = new FileResource ( tmpFile ) ; ResourceUtils . copyResource ( resource , tmpResource ) ; boolean isSelected = isSelected ( tmpFile . getParentFile ( ) , tmpFile . getName ( ) , resource . toLongString ( ) ) ; tmpFile . delete ( ) ; return isSelected ; } catch ( UnsupportedOperationException uoe ) { log ( ( ( ( ( ( "The<seq2seq4repair_space>resource<seq2seq4repair_space>'" + ( resource . getName ( ) ) ) + "'<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>provide<seq2seq4repair_space>an<seq2seq4repair_space>InputStream,<seq2seq4repair_space>so<seq2seq4repair_space>it<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>checked.<seq2seq4repair_space>" ) + "Akkording<seq2seq4repair_space>to<seq2seq4repair_space>'selres'<seq2seq4repair_space>attribute<seq2seq4repair_space>value<seq2seq4repair_space>it<seq2seq4repair_space>is<seq2seq4repair_space>" ) + ( selectResourcesWithoutInputStream ? "" : "<seq2seq4repair_space>not" ) ) + "selected." ) , MSG_INFO ) ; return selectResourcesWithoutInputStream ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } } public boolean isSelected ( File basedir , String filename , File file ) { } private boolean isSelected ( File basedir , String filename , String cacheKey ) { } protected void saveCache ( ) { } public void setAlgorithmClass ( String classname ) { } public void setComparatorClass ( String classname ) { } public void setCacheClass ( String classname ) { } public void setUpdate ( boolean update ) { } public void setSeldirs ( boolean seldirs ) { } public void setSelres ( boolean newValue ) { } public int getModified ( ) { } public void setModified ( int modified ) { } public boolean getDelayUpdate ( ) { } public void setDelayUpdate ( boolean delayUpdate ) { } public void addClasspath ( Path path ) { } public ClassLoader getClassLoader ( ) { } public void setClassLoader ( ClassLoader loader ) { } public void addParam ( String key , Object value ) { } public void addParam ( Parameter parameter ) { } public void setParameters ( Parameter [ ] parameters ) { } public void useParameter ( Parameter parameter ) { } protected void tryToSetAParameter ( Object obj , String name , String value ) { } public String toString ( ) { } public void buildFinished ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void buildStarted ( BuildEvent event ) { } public void targetStarted ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } public Cache getCache ( ) { } public void setCache ( ModifiedSelector . CacheName name ) { } public static class CacheName extends EnumeratedAttribute { public String [ ] getValues ( ) { } } public Algorithm getAlgorithm ( ) { } public void setAlgorithm ( ModifiedSelector . AlgorithmName name ) { } public static class AlgorithmName extends EnumeratedAttribute { public String [ ] getValues ( ) { } } public Comparator getComparator ( ) { } public void setComparator ( ModifiedSelector . ComparatorName name ) { } public static class ComparatorName extends EnumeratedAttribute { public String [ ] getValues ( ) { } } }
public class OutputAttribute extends ProjectComponent { public static final String STDOUT = "stdout" ; public static final String STDERR = "stderr" ; protected String value ; public OutputAttribute ( String value ) { } public OutputStream getOutputStream ( ) { if ( OutputAttribute . STDOUT . equals ( value ) ) { return new KeepAliveOutputStream ( System . out ) ; } else if ( OutputAttribute . STDERR . equals ( value ) ) { return new KeepAliveOutputStream ( System . err ) ; } <START_BUG> File f = project . resolveFile ( value ) ; <END_BUG> try { return new FileOutputStream ( f ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } }
public class LookAndFeelCommand implements Command { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final String JMETER_LAF = "jmeter.laf" ; private static final Set < String > commands = new HashSet < String > ( ) ; private static String getJMeterLaf ( ) { } private static String checkLafName ( String laf ) { } public LookAndFeelCommand ( ) { } public void doAction ( ActionEvent ev ) { try { <START_BUG> String className = ev . getActionCommand ( ) . substring ( 4 ) . replace ( '/' , '.' ) ; <END_BUG> UIManager . setLookAndFeel ( className ) ; SwingUtilities . updateComponentTreeUI ( GuiPackage . getInstance ( ) . getMainFrame ( ) ) ; } catch ( UnsupportedLookAndFeelException e ) { JMeterUtils . reportErrorToUser ( ( "Look<seq2seq4repair_space>and<seq2seq4repair_space>Feel<seq2seq4repair_space>unavailable:" + ( e . toString ( ) ) ) ) ; } catch ( InstantiationException e ) { JMeterUtils . reportErrorToUser ( ( "Look<seq2seq4repair_space>and<seq2seq4repair_space>Feel<seq2seq4repair_space>unavailable:" + ( e . toString ( ) ) ) ) ; } catch ( ClassNotFoundException e ) { JMeterUtils . reportErrorToUser ( ( "Look<seq2seq4repair_space>and<seq2seq4repair_space>Feel<seq2seq4repair_space>unavailable:" + ( e . toString ( ) ) ) ) ; } catch ( IllegalAccessException e ) { JMeterUtils . reportErrorToUser ( ( "Look<seq2seq4repair_space>and<seq2seq4repair_space>Feel<seq2seq4repair_space>unavailable:" + ( e . toString ( ) ) ) ) ; } } public Set < String > getActionNames ( ) { } }
public final class TagTypeHandler extends AbstractMarkupFilter { private final ArrayListStack < ComponentTag > stack = new ArrayListStack < ComponentTag > ( ) ; private static final Map < String , Boolean > requireOpenBodyCloseTag = new HashMap < String , Boolean > ( ) ; public TagTypeHandler ( final IMarkupFilter parent ) { } public MarkupElement nextTag ( ) throws ParseException { while ( ( stack . size ( ) ) > 0 ) { final ComponentTag top = stack . pop ( ) ; return top ; } final ComponentTag tag = nextComponentTag ( ) ; if ( tag == null ) { return tag ; } if ( tag . isOpenClose ( ) ) { String name = tag . getName ( ) ; if ( ( tag . getNamespace ( ) ) != null ) { name = ( ( tag . getNamespace ( ) ) + ":" ) + ( tag . getName ( ) ) ; } if ( TagTypeHandler . requiresOpenBodyCloseTag ( name ) ) { tag . setType ( OPEN ) ; <START_BUG> XmlTag closeTag = new XmlTag ( ) ; <END_BUG> closeTag . setType ( CLOSE ) ; closeTag . setName ( tag . getName ( ) ) ; closeTag . setNamespace ( tag . getNamespace ( ) ) ; closeTag . closes ( tag ) ; stack . push ( new ComponentTag ( closeTag ) ) ; } } return tag ; } public static boolean requiresOpenBodyCloseTag ( final String name ) { } }
public class SuffixValidator extends ModelTypeValidator { private final boolean denySeconds ; public SuffixValidator ( ) { } public SuffixValidator ( final boolean nullable , final boolean denySeconds ) { } @ Override public void validateParameter ( String parameterName , ModelNode value ) throws OperationFailedException { super . validateParameter ( parameterName , value ) ; if ( value . isDefined ( ) ) { final String suffix = value . asString ( ) ; try { if ( ( denySeconds ) && ( ( suffix . contains ( "s" ) ) || ( suffix . contains ( "S" ) ) ) ) { <START_BUG> throw Logging . createOperationFailure ( ROOT_LOGGER . invalidSuffix ( suffix ) ) ; <END_BUG> } new SimpleDateFormat ( suffix ) ; } catch ( IllegalArgumentException e ) { throw Logging . createOperationFailure ( ROOT_LOGGER . invalidSuffix ( suffix ) ) ; } } } }
public class PingAsyncTask extends AsyncTask < Object , Void , Integer > { private static final String TAG = PingAsyncTask . class . getSimpleName ( ) ; private static final String USER_AGENT = "User-Agent" ; public static final int OK = 0 ; public static final int MALFORMED_URL = - 1 ; public static final int IO_ERROR = - 2 ; public static final int NO_OK = - 3 ; private Context context ; public PingAsyncTask ( Context context ) { } @ Override protected Integer doInBackground ( Object ... parameters ) { } private boolean checkParameters ( Object ... parameters ) { if ( ( ( parameters == null ) || ( ( parameters . length ) != 1 ) ) || ( ! ( ( parameters [ 0 ] ) instanceof URL ) ) ) { return false ; } URL url = ( ( URL ) ( parameters [ 0 ] ) ) ; <START_BUG> if ( ( ( ( TextUtils . isEmpty ( url . getProtocol ( ) ) ) || ( TextUtils . isEmpty ( url . getHost ( ) ) ) ) || ( ( url . getPort ( ) ) != ( - 1 ) ) ) || ( TextUtils . isEmpty ( url . getFile ( ) ) ) ) { <END_BUG> return false ; } return true ; } private boolean isAvailableServer ( URL url ) throws IOException { } No newline ; at end ; of file ; }
public class BCodec extends RFC1522Codec implements StringDecoder , StringEncoder { private final String charset ; public BCodec ( ) { } public BCodec ( final String charset ) { } protected String getEncoding ( ) { } protected byte [ ] doEncoding ( byte [ ] bytes ) { } protected byte [ ] doDecoding ( byte [ ] bytes ) { } public String encode ( final String value , final String charset ) throws EncoderException { if ( value == null ) { return null ; } try { return encodeText ( value , charset ) ; } catch ( UnsupportedEncodingException e ) { <START_BUG> throw new EncoderException ( e . getMessage ( ) ) ; <END_BUG> } } public String encode ( String value ) throws EncoderException { } public String decode ( String value ) throws DecoderException { } public Object encode ( Object value ) throws EncoderException { } public Object decode ( Object value ) throws DecoderException { } public String getDefaultCharset ( ) { } }
public class GUILOSDataEditor extends LOSDataEditor { public static final Color VALLEY2_COLOR = new Color ( 88 , 110 , 50 ) ; public static final Color VALLEY1_COLOR = new Color ( 119 , 146 , 74 ) ; public static final Color LEVEL1_COLOR = new Color ( 176 , 147 , 70 ) ; public static final Color LEVEL2_COLOR = new Color ( 147 , 111 , 31 ) ; public static final Color LEVEL3_COLOR = new Color ( 118 , 80 , 0 ) ; public static final Color LEVEL4_COLOR = new Color ( 94 , 57 , 0 ) ; public static final Color LEVEL5_COLOR = new Color ( 74 , 45 , 0 ) ; public static final Color LEVEL6_COLOR = new Color ( 56 , 34 , 0 ) ; public static final Color LEVEL7_COLOR = new Color ( 60 , 25 , 0 ) ; public static final Color LEVEL8_COLOR = new Color ( 50 , 20 , 0 ) ; public static final Color LEVEL9_COLOR = new Color ( 40 , 15 , 0 ) ; public static final Color LEVEL10_COLOR = new Color ( 30 , 10 , 0 ) ; public GUILOSDataEditor ( String boardName , String boardDirectory , SharedBoardMetadata sharedBoardMetadata ) throws IOException { } @ SuppressWarnings ( "UnusedDeclaration" ) public void paintMapArea ( int x , int y , int width , int height , BufferedImage mapImage , BufferedImage [ ] imageList , Image singleHexWoodenBridgeImage , Image singleHexStoneBridgeImage ) { } public void paintMapContours ( int x , int y , int width , int height , BufferedImage img ) { } public void paintMapShadows ( int x , int y , int width , int height , BufferedImage img ) { } public void paintAncillaryHexTerrain ( BufferedImage img ) { } public void paintMapHexes ( Image img ) { } private void paintMapHexes ( Image img , Color c ) { } private void paintMapHex ( Image img , Hex h , boolean paintName , Color c ) { } public void saveLOSData ( ) { } public String getArchiveName ( ) { } public HashMap < String , String > getTerrainNames ( ) { HashMap < String , String > terrainNames = new HashMap < String , String > ( boardArchive . getTerrainTypes ( ) . size ( ) ) ; <START_BUG> for ( String key : boardArchive . getTerrainTypes ( ) . keySet ( ) ) { <END_BUG> terrainNames . put ( key , boardArchive . getTerrainTypes ( ) . get ( key ) . getLOSCategory ( ) . toString ( ) ) ; } return terrainNames ; } public SharedBoardMetadata getSharedBoardMetadata ( ) { } public void setHexGroundLevel ( Shape s , Terrain terr , int newLevel ) { } public boolean changeAllTerrain ( Terrain fromTerrain , Terrain toTerrain ) { } public boolean changeAllGroundLevel ( int fromElevation , int toElevation ) { } public boolean insertMap ( Map insertMap , Hex upperLeft ) { } public void setHexTerrain ( Shape s , Terrain terr ) { } public void setGridTerrain ( Rectangle rect , Terrain terr ) { } }
public class ModuleContextProcessor implements DeploymentUnitProcessor { public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; if ( DeploymentTypeMarker . isType ( EAR , deploymentUnit ) ) { return ; } EEModuleDescription moduleDescription = deploymentUnit . getAttachment ( EE_MODULE_DESCRIPTION ) ; final ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; final ServiceName appContextServiceName = ContextNames . contextServiceNameOfApplication ( moduleDescription . getApplicationName ( ) ) ; final ServiceName moduleContextServiceName = ContextNames . contextServiceNameOfModule ( moduleDescription . getApplicationName ( ) , moduleDescription . getModuleName ( ) ) ; final NamingStoreService contextService = new NamingStoreService ( ) ; serviceTarget . addService ( moduleContextServiceName , contextService ) . install ( ) ; final BinderService moduleNameBinder = new BinderService ( "ModuleName" ) ; serviceTarget . addService ( moduleContextServiceName . append ( "ModuleName" ) , moduleNameBinder ) . addInjection ( moduleNameBinder . getManagedObjectInjector ( ) , new org . jboss . as . naming . ValueManagedReferenceFactory ( Values . immediateValue ( moduleDescription . getModuleName ( ) ) ) ) . addDependency ( moduleContextServiceName , ServiceBasedNamingStore . class , moduleNameBinder . getNamingStoreInjector ( ) ) . install ( ) ; deploymentUnit . putAttachment ( Attachments . MODULE_CONTEXT_CONFIG , moduleContextServiceName ) ; final InjectedEENamespaceContextSelector selector = new InjectedEENamespaceContextSelector ( ) ; phaseContext . addDependency ( appContextServiceName , NamingStore . class , selector . getAppContextInjector ( ) ) ; phaseContext . addDependency ( moduleContextServiceName , NamingStore . class , selector . getModuleContextInjector ( ) ) ; phaseContext . addDependency ( moduleContextServiceName , NamingStore . class , selector . getCompContextInjector ( ) ) ; phaseContext . addDependency ( JBOSS_CONTEXT_SERVICE_NAME , NamingStore . class , selector . getJbossContextInjector ( ) ) ; phaseContext . addDependency ( GLOBAL_CONTEXT_SERVICE_NAME , NamingStore . class , selector . getGlobalContextInjector ( ) ) ; moduleDescription . setNamespaceContextSelector ( selector ) ; final Set < ServiceName > serviceNames = new HashSet < ServiceName > ( ) ; serviceNames . add ( appContextServiceName ) ; serviceNames . add ( moduleContextServiceName ) ; serviceNames . add ( JBOSS_CONTEXT_SERVICE_NAME ) ; serviceNames . add ( GLOBAL_CONTEXT_SERVICE_NAME ) ; final JavaNamespaceSetup setupAction = new JavaNamespaceSetup ( selector , serviceTarget ) ; deploymentUnit . addToAttachmentList ( org . jboss . as . server . deployment . Attachments . SETUP_ACTIONS , setupAction ) ; <START_BUG> deploymentUnit . addToAttachmentList ( EE_SETUP_ACTIONS , setupAction ) ; <END_BUG> } public void undeploy ( DeploymentUnit context ) { } }
public class ObjStor { private static ObjStor ourInstance = new ObjStor ( ) ; public static ObjStor getInstance ( ) { } public static ObjStor newInstance ( ) { } public static NumberPicker teleNumStacks ; public static NumberPicker teleNumTotes ; public static NumberPicker teleNumContainers ; public static NumberPicker teleMaxStackHeight ; public static CheckBox teleisDisabled ; public static CheckBox autoisDisabled ; public static CheckBox autoZone ; public static CheckBox autoToteSet ; public static CheckBox autoToteStack ; public static CheckBox autoContainerSet ; public static EditText teamNumber ; public static EditText matchNumber ; public static EditText notes ; static ArrayList < Container > arrayContainers = new ArrayList < Container > ( 7 ) ; public static String getCSV ( ) { } private static String getContainerData ( ) { <START_BUG> String data = null ; <END_BUG> for ( Container c : ObjStor . arrayContainers ) { data . concat ( ( "," + ( c . toString ( ) ) ) ) ; } return data ; } private static int readNumPick ( NumberPicker numberPicker ) { } private static String readCheckBox ( CheckBox checkBox ) { } private static String readEditText ( EditText editText ) { } private ObjStor ( ) { } }
public class ProductActivity extends AppCompatActivity implements View . OnClickListener { private Toolbar toolbar ; private ViewPager mViewPager ; private ProductViewPagerAdapter adapter ; private SlidingTabLayout mSlidingTabLayout ; private Product prod ; private CharSequence title ; private TextView prodName ; private TextView prodCategorie ; private TextView prodShortDesc ; private ImageView prodPicture ; private Button geoloc ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( activity_product ) ; prodName = ( ( TextView ) ( findViewById ( product_name ) ) ) ; prodPicture = ( ( ImageView ) ( findViewById ( product_picture ) ) ) ; geoloc = ( ( Button ) ( findViewById ( R . id . geoloc ) ) ) ; geoloc . setOnClickListener ( this ) ; prod = getIntent ( ) . getExtras ( ) . getParcelable ( "listprod" ) ; title = new String ( prod . getName ( ) ) ; prodName . setText ( prod . getName ( ) ) ; CharSequence [ ] Tab = new CharSequence [ ] { getString ( commentary ) , getString ( social ) , getString ( options ) } ; toolbar = ( ( Toolbar ) ( findViewById ( app_bar ) ) ) ; toolbar . setTitle ( title ) ; setSupportActionBar ( toolbar ) ; mViewPager = ( ( ViewPager ) ( findViewById ( viewpager ) ) ) ; adapter = new ProductViewPagerAdapter ( getSupportFragmentManager ( ) , Tab , 3 , prod ) ; mViewPager . setAdapter ( adapter ) ; mSlidingTabLayout = ( ( SlidingTabLayout ) ( findViewById ( sliding_tab ) ) ) ; mSlidingTabLayout . setDistributeEvenly ( true ) ; mSlidingTabLayout . setCustomTabColorizer ( new SlidingTabLayout . TabColorizer ( ) { @ Override public int getIndicatorColor ( int position ) { <START_BUG> return getResources ( ) . getColor ( ColorTabs ) ; <END_BUG> } } ) ; mSlidingTabLayout . setViewPager ( mViewPager ) ; new ProductActivity . RetrievePicture ( ) . execute ( ) ; } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } @ Override public void onClick ( View v ) { } class RetrievePicture extends AsyncTask < Void , Void , String > { @ Override protected String doInBackground ( Void ... params ) { } @ Override protected void onPostExecute ( String path ) { } } @ Override protected void onResume ( ) { } No newline ; at end ; of file ; }
public class SaveAttachmentCommand extends FolderCommand { File tempFile = null ; MimePart part ; static File lastDir = null ; public SaveAttachmentCommand ( DefaultCommandReference [ ] references ) { } public void updateGUI ( ) throws Exception { } public void execute ( Worker worker ) throws Exception { FolderCommandReference [ ] r = ( ( FolderCommandReference [ ] ) ( getReferences ( ) ) ) ; Folder folder = ( ( Folder ) ( r [ 0 ] . getFolder ( ) ) ) ; Object [ ] uids = r [ 0 ] . getUids ( ) ; Integer [ ] address = r [ 0 ] . getAddress ( ) ; <START_BUG> part = folder . getMimePart ( uids [ 0 ] , address , worker ) ; <END_BUG> String fileName = part . getHeader ( ) . getContentParameter ( "name" ) ; if ( fileName == null ) fileName = part . getHeader ( ) . getDispositionParameter ( "filename" ) ; cFileChooser fileChooser ; if ( ( SaveAttachmentCommand . lastDir ) == null ) fileChooser = new cFileChooser ( ) ; else fileChooser = new cFileChooser ( SaveAttachmentCommand . lastDir ) ; cFileFilter fileFilter = new cFileFilter ( ) ; fileFilter . acceptFilesWithProperty ( FILEPROPERTY_FILE ) ; fileChooser . setDialogTitle ( "Save<seq2seq4repair_space>Attachment<seq2seq4repair_space>as<seq2seq4repair_space>..." ) ; if ( fileName != null ) fileChooser . forceSelectedFile ( new File ( fileName ) ) ; fileChooser . setSelectFilter ( fileFilter ) ; while ( true ) { if ( ( fileChooser . showSaveDialog ( null ) ) != ( JFileChooser . APPROVE_OPTION ) ) { return ; } tempFile = fileChooser . getSelectedFile ( ) ; SaveAttachmentCommand . lastDir = tempFile . getParentFile ( ) ; if ( tempFile . exists ( ) ) { if ( ( JOptionPane . showConfirmDialog ( null , "Overwrite<seq2seq4repair_space>File?" , "Warning" , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ) == ( JOptionPane . YES_OPTION ) ) { break ; } } else { break ; } } Decoder decoder ; MimeHeader header ; header = part . getHeader ( ) ; try { decoder = CoderRouter . getDecoder ( header . contentTransferEncoding ) ; decoder . decode ( new ByteArrayInputStream ( part . getBody ( ) . getBytes ( "ISO_8859_1" ) ) , new FileOutputStream ( tempFile ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } }
public class MainActivity extends SherlockFragmentActivity { private DrawerLayout mDrawerLayout ; private LinearLayout mDrawer ; private ActionBarDrawerToggle mDrawerToggle ; private NonSwipeableViewPager viewPager ; private TabsPagerAdapter mAdapter ; private ActionBar actionBar ; private ExpandableListView elv ; private static WebSocketClient mWebSocketClient ; Manager manager ; private Button btnEditSave ; private Button btnWebCode ; private Button addQuestionBut ; private String [ ] tabsTitles = new String [ ] { "Profile" , "Questions" , "Survey" } ; private int [ ] tabDrawable = new int [ ] { drawable . ic_profile , drawable . ic_question , drawable . ic_survey } ; List < Map < String , Question > > qlist ; List < Map < String , String > > group ; List < List < Map < String , Question > > > child ; MainActivity . ExpandableAdapter adapter ; List < Map < String , String > > groups ; Map < String , String > group_unSloved ; Map < String , String > group_sloved ; List < Survey > slist ; MainActivity . MyAdapter adapt ; List < Survey > surveyList ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } @ Override protected void onStart ( ) { } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { } public void updateInfo ( ) { } public void updateSurveylist ( ) { } public void updateQuestionlist ( boolean group0 , boolean group1 ) { List < Map < String , Question > > child_unSloved = new ArrayList < Map < String , Question > > ( ) ; Hashtable < Integer , Question > unSolvedTable = manager . getEvent ( manager . getJoinEventID ( ) ) . getQuestionManager ( ) . getUnSolvedTable ( ) ; Enumeration < Integer > enumKey = unSolvedTable . keys ( ) ; while ( enumKey . hasMoreElements ( ) ) { Map < String , Question > data = new HashMap < String , Question > ( ) ; Integer key = enumKey . nextElement ( ) ; Question question = unSolvedTable . get ( key ) ; data . put ( "child" , question ) ; child_unSloved . add ( data ) ; } List < Map < String , Question > > child_sloved = new ArrayList < Map < String , Question > > ( ) ; Hashtable < Integer , Question > solvedTable = manager . getEvent ( manager . getJoinEventID ( ) ) . getQuestionManager ( ) . getSolvedTable ( ) ; enumKey = solvedTable . keys ( ) ; while ( enumKey . hasMoreElements ( ) ) { Map < String , Question > data = new HashMap < String , Question > ( ) ; Integer key = enumKey . nextElement ( ) ; Question question = solvedTable . get ( key ) ; data . put ( "child" , question ) ; <START_BUG> child_unSloved . add ( data ) ; <END_BUG> } ArrayList < List < Map < String , Question > > > childs = new ArrayList < List < Map < String , Question > > > ( ) ; childs . add ( child_unSloved ) ; childs . add ( child_sloved ) ; adapter = new MainActivity . ExpandableAdapter ( this , groups , childs ) ; elv = ( ( ExpandableListView ) ( findViewById ( mExpandableListView ) ) ) ; elv . setAdapter ( adapter ) ; if ( group0 ) elv . expandGroup ( 0 ) ; if ( group1 ) elv . expandGroup ( 1 ) ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } @ Override protected void onPostCreate ( Bundle savedInstanceState ) { } @ Override public void onConfigurationChanged ( Configuration newConfig ) { } public void EditProfile ( View v ) { } public void WebCode ( View v ) { } public void addQuestionNow ( View v ) { } public void addSurveyNow ( View v ) { } public void SolveQuestion ( View view ) { } public void onClickLike ( View view ) { } public void sendSurveyResult ( View view ) { } class ExpandableAdapter extends BaseExpandableListAdapter { private Context context ; List < Map < String , String > > groups ; List < List < Map < String , Question > > > childs ; public ExpandableAdapter ( Context context , List < Map < String , String > > groups , List < List < Map < String , Question > > > childs ) { } public Object getChild ( int groupPosition , int childPosition ) { } public long getChildId ( int groupPosition , int childPosition ) { } public View getChildView ( int groupPosition , int childPosition , boolean isLastChild , View convertView , ViewGroup parent ) { } public int getChildrenCount ( int groupPosition ) { } public Object getGroup ( int groupPosition ) { } public int getGroupCount ( ) { } public long getGroupId ( int groupPosition ) { } public View getGroupView ( int groupPosition , boolean isExpanded , View convertView , ViewGroup parent ) { } public boolean hasStableIds ( ) { } public boolean isChildSelectable ( int groupPosition , int childPosition ) { } } private class MyAdapter extends ArrayAdapter < Survey > { Context context ; List < Survey > surveyList = new ArrayList < Survey > ( ) ; int layoutResourceId ; public MyAdapter ( Context context , int layoutResourceId , List < Survey > objects ) { } @ Override public View getView ( int position , View convertView , ViewGroup parent ) { } } private void connectWebSocket ( ) { } public void sendMessage ( String sendMessage ) { } public boolean joinEvent ( int eventID ) { } public boolean replySurvey ( int eventID , int surveyID , String answer ) { } public boolean askQuestion ( int eventID , String topic ) { } public boolean increasePopu ( int eventID , int questionID ) { }
public class ContactGenerator { private static ContactGenerator instance = new ContactGenerator ( ) ; private static long nextId = 1 ; public static ContactGenerator getInstance ( ) { } private final String [ ] firstNames = new String [ ] { "Jacob" , "Emily" , "Michael" , "Sarah" , "Matthew" , "Brianna" , "Nicholas" , "Samantha" , "Christopher" , "Hailey" , "Abner" , "Abby" , "Joshua" , "Douglas" , "Jack" , "Keith" , "Gerald" , "Samuel" , "Willie" , "Larry" , "Jose" , "Timothy" , "Sandra" , "Kathleen" , "Pamela" , "Virginia" , "Debra" , "Maria" , "Linda" } ; private final String [ ] lastNames = new String [ ] { "Smiith" , "Johnson" , "Williams" , "Jones" , "Brown" , "Donahue" , "Bailey" , "Rose" , "Allen" , "Black" , "Davis" , "Clark" , "Hall" , "Lee" , "Baker" , "Gonzalez" , "Nelson" , "Moore" , "Wilson" , "Graham" , "Fisher" , "Cruz" , "Ortiz" , "Gomez" , "Murray" } ; private ContactGenerator ( ) { } public synchronized long generateId ( ) { } public Contact generate ( ) { } public void generate ( Collection < Contact > collection , int count ) { } private String generatePhoneNumber ( ) { <START_BUG> return new StringBuffer ( ) . append ( rint ( 2 , 9 ) ) . append ( rint ( 0 , 9 ) ) . append ( rint ( 0 , 9 ) ) . append ( "-555-" ) . append ( rint ( 1 , 9 ) ) . append ( rint ( 0 , 9 ) ) . append ( rint ( 0 , 9 ) ) . append ( rint ( 0 , 9 ) ) . toString ( ) ; <END_BUG> } private int rint ( int min , int max ) { } private String randomString ( String [ ] choices ) { } }
public class TypeInstanceTask extends AbstractContainerTask implements Configurable { private static final Resources REZ = ResourceManager . getPackageResources ( TypeInstanceTask . class ) ; private String m_id ; private Object m_value ; private boolean m_localScope = true ; public void configure ( final Configuration configuration ) throws ConfigurationException { final DefaultConfiguration newConfiguration = new DefaultConfiguration ( configuration . getName ( ) , configuration . getLocation ( ) ) ; final String [ ] attributes = configuration . getAttributeNames ( ) ; for ( int i = 0 ; i < ( attributes . length ) ; i ++ ) { final String name = attributes [ i ] ; final String value = configuration . getAttribute ( name ) ; if ( ( name . equals ( "id" ) ) || ( name . equals ( "local-scope" ) ) ) { configure ( this , name , value ) ; } else { newConfiguration . setAttribute ( name , value ) ; } } final Configuration [ ] children = configuration . getChildren ( ) ; for ( int i = 0 ; i < ( children . length ) ; i ++ ) { newConfiguration . addChild ( children [ i ] ) ; } try { <START_BUG> final TypeFactory typeFactory = getTypeFactory ( ROLE ) ; <END_BUG> m_value = typeFactory . create ( configuration . getName ( ) ) ; } catch ( final Exception e ) { final String message = TypeInstanceTask . REZ . getString ( "type.no-create.error" ) ; throw new ConfigurationException ( message , e ) ; } configure ( m_value , newConfiguration ) ; } public void setId ( final String id ) { } public void setLocalScope ( final boolean localScope ) { } public void execute ( ) throws TaskException { } }
public class ServiceManagerIndexRdf extends SparqlGraphStoreManager implements ServiceManager { private static final Logger log = LoggerFactory . getLogger ( ServiceManagerIndexRdf . class ) ; private static final String SERVICES_URL_PATH = "id/services/" ; private final URI servicesUri ; private ConcurrentMap < URI , Set < URI > > svcOpMap ; private ConcurrentMap < URI , Set < URI > > opInputMap ; private ConcurrentMap < URI , Set < URI > > messageMandatoryPartsMap ; private ConcurrentMap < URI , Set < URI > > messageOptionalPartsMap ; private ConcurrentMap < URI , Set < URI > > opOutputMap ; private ConcurrentMap < URI , Set < URI > > modelReferencesMap ; @ Inject ServiceManagerIndexRdf ( EventBus eventBus , @ Named ( SystemConfiguration . ISERVE_URL_PROP ) String iServeUri , @ Named ( SystemConfiguration . SERVICES_REPOSITORY_SPARQL_PROP ) String sparqlQueryEndpoint , @ Named ( SystemConfiguration . SERVICES_REPOSITORY_SPARQL_UPDATE_PROP ) String sparqlUpdateEndpoint , @ Named ( SystemConfiguration . SERVICES_REPOSITORY_SPARQL_SERVICE_PROP ) String sparqlServiceEndpoint ) throws SalException { } @ Override public Set < URI > listServices ( ) { } private Set < URI > loadListServices ( ) { } @ Override public Set < URI > listOperations ( URI serviceUri ) { } private Set < URI > loadListOperations ( URI serviceUri ) { } @ Override public Set < URI > listInputs ( URI operationUri ) { } private Set < URI > loadListInputs ( URI operationUri ) { } @ Override public Set < URI > listOutputs ( URI operationUri ) { } private Set < URI > loadListOutputs ( URI operationUri ) { } @ Override public Set < URI > listMandatoryParts ( URI messageContent ) { } @ Override public Set < URI > listOptionalParts ( URI messageContent ) { } private Set < URI > loadOptionalParts ( URI messageContent ) { } private Set < URI > loadListMandatoryParts ( URI messageContent ) { } private Set < URI > listResourcesByQuery ( String queryStr , String variableName ) { } @ Override public Service getService ( URI serviceUri ) throws ServiceException { } @ Override public Set < Service > getServices ( Set < URI > serviceUris ) throws ServiceException { } @ Override public Set < URI > listDocumentsForService ( URI serviceUri ) throws ServiceException { } private Set < URI > loadListDocumentsForService ( URI serviceUri ) throws ServiceException { } public URI addService ( Service service ) throws ServiceException { } @ Override public boolean addRelatedDocumentToService ( URI serviceUri , URI relatedDocument ) throws ServiceException { } private URI generateUniqueServiceUri ( ) { } private void replaceUris ( Resource resource , URI newUriBase ) throws URISyntaxException { } private URI getServiceBaseUri ( String serviceId ) { } @ Override public boolean deleteService ( URI serviceUri ) throws ServiceException { } @ Override public boolean deleteService ( Service service ) throws ServiceException { } @ Override public boolean clearServices ( ) throws ServiceException { } @ Override public boolean serviceExists ( URI serviceUri ) throws ServiceException { } @ Override public Set < URI > listModelReferences ( URI elementUri ) { } private Set < URI > loadListModelReferences ( URI uri ) { } @ Override public void initialise ( ) { } private void initialiseCache ( ) { } private void populateCache ( ) { } private void indexService ( Service service ) { } private void indexModelReferences ( AnnotableResource annotableResource ) { } private void indexOperation ( Operation operation ) { Set < URI > partsUris ; Set < URI > messagesUris ; messagesUris = new HashSet < URI > ( ) ; List < MessageContent > inputs = operation . getInputs ( ) ; for ( MessageContent input : inputs ) { messagesUris . add ( input . getUri ( ) ) ; indexModelReferences ( input ) ; indexMandatoryParts ( input ) ; indexOptionalParts ( input ) ; } this . opInputMap . put ( operation . getUri ( ) , messagesUris ) ; messagesUris = new HashSet < URI > ( ) ; <START_BUG> List < MessageContent > outputs = operation . getInputs ( ) ; <END_BUG> for ( MessageContent output : outputs ) { messagesUris . add ( output . getUri ( ) ) ; indexModelReferences ( output ) ; indexMandatoryParts ( output ) ; indexOptionalParts ( output ) ; } this . opOutputMap . put ( operation . getUri ( ) , messagesUris ) ; indexModelReferences ( operation ) ; } private void indexOptionalParts ( MessageContent messageContent ) { } private void indexMandatoryParts ( MessageContent messageContent ) { } private void removeServiceFromCache ( URI serviceUri ) { } private void removeOperationFromCache ( URI operation ) { } @ Override public void shutdown ( ) { } }
public class Display extends JPanel { private ArrayList < Trial > trials ; private int currentIndex ; private JPanel southPanel ; private JTextArea directions ; private Image img1 ; private Image img2 ; public Display ( ) throws LineUnavailableException { } public void readFile ( String text ) { } public void setComponents ( ) { } private void createButtons ( ) { } private void createDirections ( ) { } private void createTitle ( ) { <START_BUG> ImageIcon img4 = new ImageIcon ( "./images/prison.png" ) ; <END_BUG> JPanel northPanel = new JPanel ( ) { protected void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; img2 = img4 . getImage ( ) ; g . drawImage ( img2 , 0 , 0 , null ) ; } } ; JLabel title = new JLabel ( "The<seq2seq4repair_space>Tiger<seq2seq4repair_space>Puzzle" ) ; title . setFont ( new Font ( "Sans-serif" , Font . BOLD , 30 ) ) ; title . setForeground ( Color . getHSBColor ( 50 , 54 , 54 ) ) ; northPanel . add ( title ) ; add ( northPanel , BorderLayout . NORTH ) ; } private void playSound ( String soundFile ) throws LineUnavailableException { } }
public class GammaTest extends TestCase { public GammaTest ( String name ) { } private void testRegularizedGamma ( double expected , double a , double x ) { } private void testLogGamma ( double expected , double x ) { <START_BUG> double actual = Gamma . logGamma ( x , 1.0E-4 , Integer . MAX_VALUE ) ; <END_BUG> TestUtils . assertEquals ( expected , actual , 1.0E-4 ) ; } public void testRegularizedGammaNanPositive ( ) { } public void testRegularizedGammaPositiveNan ( ) { } public void testRegularizedGammaNegativePositive ( ) { } public void testRegularizedGammaPositiveNegative ( ) { } public void testRegularizedGammaZeroPositive ( ) { } public void testRegularizedGammaPositiveZero ( ) { } public void testRegularizedGammaPositivePositive ( ) { } public void testLogGammaNan ( ) { } public void testLogGammaNegative ( ) { } public void testLogGammaZero ( ) { } public void testLogGammaPositive ( ) { } }
public abstract class ParentNode extends NodeImpl { static final long serialVersionUID = 2815829867152120872L ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected int changes = 0 ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ParentNode ( DocumentImpl ownerDocument ) { } public ParentNode ( ) { } public Node cloneNode ( boolean deep ) { } public Document getOwnerDocument ( ) { } DocumentImpl ownerDocument ( ) { } void setOwnerDocument ( DocumentImpl doc ) { } public boolean hasChildNodes ( ) { } public NodeList getChildNodes ( ) { } public Node getFirstChild ( ) { } public Node getLastChild ( ) { } final ChildNode lastChild ( ) { } final void lastChild ( ChildNode node ) { } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { } public Node removeChild ( Node oldChild ) throws DOMException { } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { } public int getLength ( ) { } public Node item ( int index ) { } public void normalize ( ) { } public void setReadOnly ( boolean readOnly , boolean deep ) { } protected void changed ( ) { } protected int changes ( ) { } protected void synchronizeChildren ( ) { } protected final void synchronizeChildren ( int nodeIndex ) { } private void writeObject ( ObjectOutputStream out ) throws IOException { <START_BUG> if ( syncChildren ( ) ) { <END_BUG> synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws IOException , ClassNotFoundException { } }
public abstract class QueryNodeImpl implements Cloneable , QueryNode { public static final String PLAINTEXT_FIELD_NAME = "_plain" ; private boolean isLeaf = true ; private Hashtable < String , Object > tags = new Hashtable < String , Object > ( ) ; private List < QueryNode > clauses = null ; protected void allocate ( ) { } public final void add ( QueryNode child ) { } public final void add ( List < QueryNode > children ) { } public boolean isLeaf ( ) { } public final void set ( List < QueryNode > children ) { } public QueryNode cloneTree ( ) throws CloneNotSupportedException { } @ Override public Object clone ( ) throws CloneNotSupportedException { } protected void setLeaf ( boolean isLeaf ) { } public final List < QueryNode > getChildren ( ) { } public void setTag ( String tagName , Object value ) { } public void unsetTag ( String tagName ) { } public boolean containsTag ( String tagName ) { <START_BUG> return this . tags . containsKey ( tagName ) ; <END_BUG> } public Object getTag ( String tagName ) { } private QueryNode parent = null ; private void setParent ( QueryNode parent ) { } public QueryNode getParent ( ) { } protected boolean isRoot ( ) { } protected boolean toQueryStringIgnoreFields = false ; protected boolean isDefaultField ( CharSequence fld ) { } @ Override public String toString ( ) { } @ SuppressWarnings ( "unchecked" ) public Map < String , Object > getTagMap ( ) { } }
public class PageProviderTest extends WicketTestCase { @ Test public void testStalePageException ( ) { } public void testStalePageExceptionOnAjaxRequest ( ) throws IOException , ParseException , ResourceStreamNotFoundException { } private void executeAjaxUrlWithLastBaseUrl ( Url url ) throws IOException , ParseException , ResourceStreamNotFoundException { tester . getRequest ( ) . setUrl ( url ) ; <START_BUG> tester . getRequest ( ) . addHeader ( "Wicket-Ajax-BaseURL" , tester . getWicketAjaxBaserUrlFromLastRequest ( ) ) ; <END_BUG> tester . getRequest ( ) . addHeader ( "Wicket-Ajax" , "true" ) ; tester . processRequest ( ) ; } public static class TestPage extends WebPage implements IMarkupResourceStreamProvider { Link < Void > link ; AjaxLink < Void > ajaxLink ; public TestPage ( ) { } public IResourceStream getMarkupResourceStream ( MarkupContainer container , Class < ? > containerClass ) { } } }
public class UMLAction extends AbstractAction { protected static Category cat = Category . getInstance ( UMLAction . class ) ; public static boolean HAS_ICON = true ; public static boolean NO_ICON = false ; public UMLAction ( String name ) { } public UMLAction ( String name , boolean hasIcon ) { } public UMLAction ( String name , boolean global , boolean hasIcon ) { } public void actionPerformed ( ActionEvent e ) { } public void markNeedsSave ( ) { if ( ( ProjectBrowser . TheInstance ) != null ) { <START_BUG> Project p = TheInstance . getProject ( ) ; <END_BUG> if ( p != null ) { p . setNeedsSave ( true ) ; } } } public void updateEnabled ( Object target ) { } public void updateEnabled ( ) { } public boolean shouldBeEnabled ( ) { } protected static String stripJunk ( String s ) { } public static final KeyStroke getShortcut ( String key ) { } public static final String getMnemonic ( String key ) { } public boolean isEnabled ( ) { } }
public final class GeofenceHardwareImpl { private static final String TAG = "GeofenceHardwareImpl" ; private static final boolean DEBUG = Log . isLoggable ( GeofenceHardwareImpl . TAG , Log . DEBUG ) ; private final Context mContext ; private static GeofenceHardwareImpl sInstance ; private WakeLock mWakeLock ; private final SparseArray < IGeofenceHardwareCallback > mGeofences = new SparseArray < IGeofenceHardwareCallback > ( ) ; private final ArrayList < IGeofenceHardwareMonitorCallback > [ ] mCallbacks = new ArrayList [ GeofenceHardware . NUM_MONITORS ] ; private final ArrayList < GeofenceHardwareImpl . Reaper > mReapers = new ArrayList < GeofenceHardwareImpl . Reaper > ( ) ; private IFusedGeofenceHardware mFusedService ; private IGpsGeofenceHardware mGpsService ; private int [ ] mSupportedMonitorTypes = new int [ GeofenceHardware . NUM_MONITORS ] ; private static final int GEOFENCE_TRANSITION_CALLBACK = 1 ; private static final int ADD_GEOFENCE_CALLBACK = 2 ; private static final int REMOVE_GEOFENCE_CALLBACK = 3 ; private static final int PAUSE_GEOFENCE_CALLBACK = 4 ; private static final int RESUME_GEOFENCE_CALLBACK = 5 ; private static final int GEOFENCE_CALLBACK_BINDER_DIED = 6 ; private static final int GEOFENCE_STATUS = 1 ; private static final int CALLBACK_ADD = 2 ; private static final int CALLBACK_REMOVE = 3 ; private static final int MONITOR_CALLBACK_BINDER_DIED = 4 ; private static final int REAPER_GEOFENCE_ADDED = 1 ; private static final int REAPER_MONITOR_CALLBACK_ADDED = 2 ; private static final int REAPER_REMOVED = 3 ; private static final int LOCATION_INVALID = 0 ; private static final int LOCATION_HAS_LAT_LONG = 1 ; private static final int LOCATION_HAS_ALTITUDE = 2 ; private static final int LOCATION_HAS_SPEED = 4 ; private static final int LOCATION_HAS_BEARING = 8 ; private static final int LOCATION_HAS_ACCURACY = 16 ; private static final int RESOLUTION_LEVEL_NONE = 1 ; private static final int RESOLUTION_LEVEL_COARSE = 2 ; private static final int RESOLUTION_LEVEL_FINE = 3 ; public static synchronized GeofenceHardwareImpl getInstance ( Context context ) { } private GeofenceHardwareImpl ( Context context ) { } private void acquireWakeLock ( ) { } private void releaseWakeLock ( ) { } private void updateGpsHardwareAvailability ( ) { } private void updateFusedHardwareAvailability ( ) { } public void setGpsHardwareGeofence ( IGpsGeofenceHardware service ) { } public void setFusedGeofenceHardware ( IFusedGeofenceHardware service ) { } public int [ ] getMonitoringTypes ( ) { } public int getStatusOfMonitoringType ( int monitoringType ) { } public boolean addCircularFence ( int monitoringType , GeofenceHardwareRequestParcelable request , IGeofenceHardwareCallback callback ) { } public boolean removeGeofence ( int geofenceId , int monitoringType ) { } public boolean pauseGeofence ( int geofenceId , int monitoringType ) { } public boolean resumeGeofence ( int geofenceId , int monitoringType , int monitorTransition ) { } public boolean registerForMonitorStateChangeCallback ( int monitoringType , IGeofenceHardwareMonitorCallback callback ) { } public boolean unregisterForMonitorStateChangeCallback ( int monitoringType , IGeofenceHardwareMonitorCallback callback ) { } public void reportGeofenceTransition ( int geofenceId , Location location , int transition , long transitionTimestamp , int monitoringType , int sourcesUsed ) { if ( location == null ) { <START_BUG> Log . e ( GeofenceHardwareImpl . TAG , String . format ( "Invalid<seq2seq4repair_space>Geofence<seq2seq4repair_space>Transition:<seq2seq4repair_space>location=%p" , location ) ) ; <END_BUG> return ; } if ( GeofenceHardwareImpl . DEBUG ) { Log . d ( GeofenceHardwareImpl . TAG , ( ( ( ( ( ( ( ( ( "GeofenceTransition|<seq2seq4repair_space>" + location ) + ",<seq2seq4repair_space>transition:" ) + transition ) + ",<seq2seq4repair_space>transitionTimestamp:" ) + transitionTimestamp ) + ",<seq2seq4repair_space>monitoringType:" ) + monitoringType ) + ",<seq2seq4repair_space>sourcesUsed:" ) + sourcesUsed ) ) ; } GeofenceHardwareImpl . GeofenceTransition geofenceTransition = new GeofenceHardwareImpl . GeofenceTransition ( geofenceId , transition , transitionTimestamp , location , monitoringType , sourcesUsed ) ; acquireWakeLock ( ) ; Message message = mGeofenceHandler . obtainMessage ( GeofenceHardwareImpl . GEOFENCE_TRANSITION_CALLBACK , geofenceTransition ) ; message . sendToTarget ( ) ; } public void reportGeofenceMonitorStatus ( int monitoringType , int monitoringStatus , Location location , int source ) { } private void reportGeofenceOperationStatus ( int operation , int geofenceId , int operationStatus ) { } public void reportGeofenceAddStatus ( int geofenceId , int status ) { } public void reportGeofenceRemoveStatus ( int geofenceId , int status ) { } public void reportGeofencePauseStatus ( int geofenceId , int status ) { } public void reportGeofenceResumeStatus ( int geofenceId , int status ) { } private Handler mGeofenceHandler = new Handler ( ) { @ Override public void handleMessage ( Message msg ) { } } ; private Handler mCallbacksHandler = new Handler ( ) { @ Override public void handleMessage ( Message msg ) { } } ; private Handler mReaperHandler = new Handler ( ) { @ Override public void handleMessage ( Message msg ) { } } ; private class GeofenceTransition { private int mGeofenceId ; private int mTransition ; private long mTimestamp ; private Location mLocation ; private int mMonitoringType ; private int mSourcesUsed ; GeofenceTransition ( int geofenceId , int transition , long timestamp , Location location , int monitoringType , int sourcesUsed ) { } } private void setMonitorAvailability ( int monitor , int val ) { } int getMonitoringResolutionLevel ( int monitoringType ) { } class Reaper implements IBinder . DeathRecipient { private IGeofenceHardwareMonitorCallback mMonitorCallback ; private IGeofenceHardwareCallback mCallback ; private int mMonitoringType ; Reaper ( IGeofenceHardwareCallback c , int monitoringType ) { } Reaper ( IGeofenceHardwareMonitorCallback c , int monitoringType ) { } @ Override public void binderDied ( ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( Object obj ) { } } int getAllowedResolutionLevel ( int pid , int uid ) { } }
final class Persistence { static final String PACKAGE_BASE = "activities" ; static final String PACKAGE_FULL = "org.eclipse.ui." + ( Persistence . PACKAGE_BASE ) ; static final String TAG_ACTIVITY_BINDING = "activityBinding" ; static final String TAG_ACTIVITY_ID = "activityId" ; static final String TAG_DESCRIPTION = "description" ; static final String TAG_ID = "id" ; static final String TAG_NAME = "name" ; static final String TAG_PARENT_ID = "parentId" ; static final String TAG_PATTERN = "pattern" ; static final String TAG_PLUGIN_ID = "pluginId" ; static final String TAG_ACTIVITY = "activity" ; static IActivityPatternBindingDefinition readActivityBindingDefinition ( IMemento memento , String pluginIdOverride ) { if ( memento == null ) throw new NullPointerException ( ) ; String activityId = memento . getString ( Persistence . TAG_ACTIVITY_ID ) ; String pluginId = ( pluginIdOverride != null ) ? pluginIdOverride : memento . getString ( Persistence . TAG_PLUGIN_ID ) ; String pattern = memento . getString ( Persistence . TAG_PATTERN ) ; <START_BUG> return new ActivityPatternBindingDefinition ( activityId , pluginId , activityId ) ; <END_BUG> } static List readActivityBindingDefinitions ( IMemento memento , String name , String pluginIdOverride ) { } static IActivityDefinition readActivityDefinition ( IMemento memento , String pluginIdOverride ) { } static List readActivityDefinitions ( IMemento memento , String name , String pluginIdOverride ) { } static void writeActivityBindingDefinition ( IMemento memento , IActivityPatternBindingDefinition activityBindingDefinition ) { } static void writeActivityBindingDefinitions ( IMemento memento , String name , List activityBindingDefinitions ) { } static void writeActivityDefinition ( IMemento memento , IActivityDefinition activityDefinition ) { } static void writeActivityDefinitions ( IMemento memento , String name , List activityDefinitions ) { } private Persistence ( ) { } }
public class FileUploadFieldTest extends WicketTestCase { public FileUploadFieldTest ( ) { } public void testInternalDetach ( ) throws Exception { final MockPageWithFormAndUploadField page = new MockPageWithFormAndUploadField ( ) ; FileUploadField field = new FileUploadField ( page . getForm ( ) , "upload" ) ; tester . startPage ( new ITestPageSource ( ) { private static final long serialVersionUID = 1L ; public Page getTestPage ( ) { return page ; } } ) ; RequestCycle requestCycle = tester . createRequestCycle ( ) ; MockHttpServletRequest servletRequest = tester . getServletRequest ( ) ; servletRequest . setMethod ( "POST" ) ; servletRequest . setParameter ( "form2:hf:fs" , "" ) ; servletRequest . setParameter ( "wicketState" , "" ) ; servletRequest . addFile ( "upload" , new File ( "pom.xml" ) , "text/xml" ) ; requestCycle . setRequest ( new wicket . protocol . http . servlet . MultipartServletWebRequest ( servletRequest , Bytes . MAX ) ) ; FileUpload fileUpload = field . getFileUpload ( ) ; assertNotNull ( fileUpload ) ; InputStream is = fileUpload . getInputStream ( ) ; assertTrue ( ( ( is . read ( ) ) != ( - 1 ) ) ) ; <START_BUG> field . internalOnDetach ( ) ; <END_BUG> try { is . read ( ) ; fail ( ) ; } catch ( IOException e ) { } catch ( Exception e ) { fail ( ) ; } } }
public class CLIWrapper { private final CommandContext ctx ; private ByteArrayOutputStream consoleOut ; public CLIWrapper ( ) throws Exception { } public CLIWrapper ( boolean connect ) throws Exception { } public CLIWrapper ( boolean connect , String cliAddress ) throws CliInitializationException { } protected InputStream createConsoleInput ( ) { } public boolean isConnected ( ) { } public boolean sendConnect ( ) { } public boolean sendConnect ( String cliAddress ) { String addr = ( cliAddress != null ) ? cliAddress : TestSuiteEnvironment . getServerAddress ( ) ; try { <START_BUG> ctx . connectController ( addr , TestSuiteEnvironment . getServerPort ( ) ) ; <END_BUG> return true ; } catch ( CommandLineException e ) { e . printStackTrace ( ) ; return false ; } } public boolean sendLine ( String line , boolean ignoreError ) { } public void sendLine ( String line ) { } public String readOutput ( ) { } public CLIOpResult readAllAsOpResult ( ) throws IOException { } public synchronized void quit ( ) { } public boolean hasQuit ( ) { } protected String getUsername ( ) { } protected String getPassword ( ) { } }
class XSDAttributeGroupTraverser extends XSDAbstractTraverser { XSDAttributeGroupTraverser ( XSDHandler handler , XSAttributeChecker gAttrCheck ) { } XSAttributeGroupDecl traverseLocal ( Element elmNode , XSDocumentInfo schemaDoc , SchemaGrammar grammar ) { } XSAttributeGroupDecl traverseGlobal ( Element elmNode , XSDocumentInfo schemaDoc , SchemaGrammar grammar ) { XSAttributeGroupDecl attrGrp = new XSAttributeGroupDecl ( ) ; Object [ ] attrValues = fAttrChecker . checkAttributes ( elmNode , true , schemaDoc ) ; String nameAttr = ( ( String ) ( attrValues [ XSAttributeChecker . ATTIDX_NAME ] ) ) ; if ( nameAttr == null ) { reportSchemaError ( "s4s-att-must-appear" , new Object [ ] { "attributeGroup<seq2seq4repair_space>(global)" , "name" } , elmNode ) ; nameAttr = "no<seq2seq4repair_space>name" ; } attrGrp . fName = nameAttr ; attrGrp . fTargetNamespace = schemaDoc . fTargetNamespace ; Element child = DOMUtil . getFirstChildElement ( elmNode ) ; XSAnnotationImpl annotation = null ; if ( ( child != null ) && ( DOMUtil . getLocalName ( child ) . equals ( ELT_ANNOTATION ) ) ) { annotation = traverseAnnotationDecl ( child , attrValues , false , schemaDoc ) ; child = DOMUtil . getNextSiblingElement ( child ) ; } else { String text = DOMUtil . getSyntheticAnnotation ( elmNode ) ; if ( text != null ) { annotation = traverseSyntheticAnnotation ( elmNode , text , attrValues , false , schemaDoc ) ; } } Element nextNode = traverseAttrsAndAttrGrps ( child , attrGrp , schemaDoc , grammar , null ) ; if ( nextNode != null ) { Object [ ] args = new Object [ ] { nameAttr , "(annotation?,<seq2seq4repair_space>((attribute<seq2seq4repair_space>|<seq2seq4repair_space>attributeGroup)*,<seq2seq4repair_space>anyAttribute?))" , DOMUtil . getLocalName ( nextNode ) } ; reportSchemaError ( "s4s-elt-must-match.1" , args , nextNode ) ; } attrGrp . removeProhibitedAttrs ( ) ; XSAttributeGroupDecl redefinedAttrGrp = ( ( XSAttributeGroupDecl ) ( fSchemaHandler . getGrpOrAttrGrpRedefinedByRestriction ( ATTRIBUTEGROUP_TYPE , new org . apache . xerces . xni . QName ( XMLSymbols . EMPTY_STRING , nameAttr , nameAttr , schemaDoc . fTargetNamespace ) , schemaDoc , elmNode ) ) ) ; if ( redefinedAttrGrp != null ) { Object [ ] errArgs = attrGrp . validRestrictionOf ( nameAttr , redefinedAttrGrp ) ; if ( errArgs != null ) { reportSchemaError ( ( ( String ) ( errArgs [ ( ( errArgs . length ) - 1 ) ] ) ) , errArgs , child ) ; reportSchemaError ( "src-redefine.7.2.2" , new Object [ ] { nameAttr , errArgs [ ( ( errArgs . length ) - 1 ) ] } , child ) ; } } XSObjectList annotations ; if ( annotation != null ) { annotations = new XSObjectListImpl ( ) ; <START_BUG> ( ( XSObjectListImpl ) ( annotations ) ) . add ( annotation ) ; <END_BUG> } else { annotations = XSObjectListImpl . EMPTY_LIST ; } attrGrp . fAnnotations = annotations ; grammar . addGlobalAttributeGroupDecl ( attrGrp ) ; fAttrChecker . returnAttrArray ( attrValues , schemaDoc ) ; return attrGrp ; } }
public class WebMvcConfigurationSupportTests { @ Test public void requestMappingHandlerMapping ( ) throws Exception { } @ Test public void emptyViewControllerHandlerMapping ( ) { } @ Test public void beanNameHandlerMapping ( ) throws Exception { } @ Test public void emptyResourceHandlerMapping ( ) { } @ Test public void emptyDefaultServletHandlerMapping ( ) { } @ Test public void requestMappingHandlerAdapter ( ) throws Exception { ApplicationContext context = initContext ( WebMvcConfigurationSupportTests . WebConfig . class ) ; RequestMappingHandlerAdapter adapter = context . getBean ( RequestMappingHandlerAdapter . class ) ; List < HttpMessageConverter < ? > > converters = adapter . getMessageConverters ( ) ; assertEquals ( 9 , converters . size ( ) ) ; for ( HttpMessageConverter < ? > converter : converters ) { if ( converter instanceof AbstractJackson2HttpMessageConverter ) { ObjectMapper objectMapper = ( ( AbstractJackson2HttpMessageConverter ) ( converter ) ) . getObjectMapper ( ) ; assertTrue ( objectMapper . getDeserializationConfig ( ) . isEnabled ( MapperFeature . DEFAULT_VIEW_INCLUSION ) ) ; assertTrue ( objectMapper . getSerializationConfig ( ) . isEnabled ( MapperFeature . DEFAULT_VIEW_INCLUSION ) ) ; <START_BUG> assertTrue ( objectMapper . getDeserializationConfig ( ) . isEnabled ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES ) ) ; <END_BUG> if ( converter instanceof MappingJackson2XmlHttpMessageConverter ) { assertEquals ( XmlMapper . class , objectMapper . getClass ( ) ) ; } } } ConfigurableWebBindingInitializer initializer = ( ( ConfigurableWebBindingInitializer ) ( adapter . getWebBindingInitializer ( ) ) ) ; assertNotNull ( initializer ) ; ConversionService conversionService = initializer . getConversionService ( ) ; assertNotNull ( conversionService ) ; assertTrue ( ( conversionService instanceof FormattingConversionService ) ) ; Validator validator = initializer . getValidator ( ) ; assertNotNull ( validator ) ; assertTrue ( ( validator instanceof LocalValidatorFactoryBean ) ) ; DirectFieldAccessor fieldAccessor = new DirectFieldAccessor ( adapter ) ; List < Object > interceptors = ( ( List < Object > ) ( fieldAccessor . getPropertyValue ( "responseBodyAdvice" ) ) ) ; assertEquals ( 1 , interceptors . size ( ) ) ; assertEquals ( JsonViewResponseBodyAdvice . class , interceptors . get ( 0 ) . getClass ( ) ) ; } @ Test public void uriComponentsContributor ( ) throws Exception { } @ Test public void handlerExceptionResolver ( ) throws Exception { } @ Test public void mvcViewResolver ( ) { } @ Test public void mvcViewResolverWithExistingResolver ( ) throws Exception { } @ Test public void defaultPathMatchConfiguration ( ) throws Exception { } private ApplicationContext initContext ( Class ... configClasses ) { } @ EnableWebMvc @ Configuration public static class WebConfig { @ Bean ( name = "/testController" ) public WebMvcConfigurationSupportTests . TestController testController ( ) { } } @ Configuration public static class ViewResolverConfig { @ Bean public ViewResolver beanNameViewResolver ( ) { } } @ Controller public static class TestController { @ RequestMapping ( "/" ) public void handle ( ) { } @ RequestMapping ( "/foo/{id}/bar/{date}" ) public HttpEntity < Void > methodWithTwoPathVariables ( @ PathVariable Integer id , @ DateTimeFormat ( iso = ISO . DATE ) @ PathVariable DateTime date ) { } } @ Controller @ Scope ( "prototype" ) public static class ScopedController { @ RequestMapping ( "/scoped" ) public void handle ( ) { } } @ Controller @ Scope ( value = "prototype" , proxyMode = ScopedProxyMode . TARGET_CLASS ) public static class ScopedProxyController { @ RequestMapping ( "/scopedProxy" ) public void handle ( ) { } } }
public class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '.' ; public static final String PACKAGE_SEPARATOR = String . valueOf ( ClassUtils . PACKAGE_SEPARATOR_CHAR ) ; public static final char INNER_CLASS_SEPARATOR_CHAR = '$' ; public static final String INNER_CLASS_SEPARATOR = String . valueOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) ; private static final Map < Class < ? > , Class < ? > > primitiveWrapperMap = new HashMap < Class < ? > , Class < ? > > ( ) ; private static final Map < Class < ? > , Class < ? > > wrapperPrimitiveMap = new HashMap < Class < ? > , Class < ? > > ( ) ; private static final Map < String , String > abbreviationMap = new HashMap < String , String > ( ) ; private static final Map < String , String > reverseAbbreviationMap = new HashMap < String , String > ( ) ; private static void addAbbreviation ( String primitive , String abbreviation ) { } public ClassUtils ( ) { } public static String getShortClassName ( Object object , String valueIfNull ) { } public static String getShortClassName ( Class < ? > cls ) { } public static String getShortClassName ( String className ) { } public static String getPackageName ( Object object , String valueIfNull ) { } public static String getPackageName ( Class < ? > cls ) { if ( cls == null ) { return StringUtils . EMPTY ; } <START_BUG> return ClassUtils . getPackageName ( cls . getName ( ) ) ; <END_BUG> } public static String getPackageName ( String className ) { } public static List < Class < ? > > getAllSuperclasses ( Class < ? > cls ) { } public static List < Class < ? > > getAllInterfaces ( Class < ? > cls ) { } public static List < Class < ? > > convertClassNamesToClasses ( List < String > classNames ) { } public static List < String > convertClassesToClassNames ( List < Class < ? > > classes ) { } public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray ) { } public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { } public static boolean isAssignable ( Class < ? > cls , Class < ? > toClass ) { } public static boolean isAssignable ( Class < ? > cls , Class < ? > toClass , boolean autoboxing ) { } public static Class < ? > primitiveToWrapper ( Class < ? > cls ) { } public static Class < ? > [ ] primitivesToWrappers ( Class < ? > [ ] classes ) { } public static Class < ? > wrapperToPrimitive ( Class < ? > cls ) { } public static Class < ? > [ ] wrappersToPrimitives ( Class < ? > [ ] classes ) { } public static boolean isInnerClass ( Class < ? > cls ) { } public static Class < ? > getClass ( ClassLoader classLoader , String className , boolean initialize ) throws ClassNotFoundException { } public static Class < ? > getClass ( ClassLoader classLoader , String className ) throws ClassNotFoundException { } public static Class < ? > getClass ( String className ) throws ClassNotFoundException { } public static Class < ? > getClass ( String className , boolean initialize ) throws ClassNotFoundException { } public static Method getPublicMethod ( Class < ? > cls , String methodName , Class < ? > [ ] parameterTypes ) throws NoSuchMethodException , SecurityException { } private static String toCanonicalName ( String className ) { } public static Class < ? > [ ] toClass ( Object [ ] array ) { } public static String getShortCanonicalName ( Object object , String valueIfNull ) { } public static String getShortCanonicalName ( Class < ? > cls ) { } public static String getShortCanonicalName ( String canonicalName ) { } public static String getPackageCanonicalName ( Object object , String valueIfNull ) { } public static String getPackageCanonicalName ( Class < ? > cls ) { } public static String getPackageCanonicalName ( String canonicalName ) { } private static String getCanonicalName ( String className ) { } }
public class ViewDescriptor implements IPluginContribution , IViewDescriptor { private String id ; private ImageDescriptor imageDescriptor ; private IConfigurationElement configElement ; private String [ ] categoryPath ; private float fastViewWidthRatio ; private IPartDescriptor viewInfo = new IPartDescriptor ( ) { public String getId ( ) { } public String getLabel ( ) { } public ImageDescriptor getImage ( ) { } } ; private IHandlerActivation handlerActivation ; public ViewDescriptor ( IConfigurationElement e ) throws CoreException { } public IPartDescriptor getPartDescriptor ( ) { } public IViewPart createView ( ) throws CoreException { } public String [ ] getCategoryPath ( ) { } public IConfigurationElement getConfigurationElement ( ) { } public String getDescription ( ) { } public String getId ( ) { } public ImageDescriptor getImageDescriptor ( ) { } public String getLabel ( ) { } public String getAccelerator ( ) { } public float getFastViewWidthRatio ( ) { } private void loadFromExtension ( ) throws CoreException { id = configElement . getAttribute ( ATT_ID ) ; String category = configElement . getAttribute ( TAG_CATEGORY ) ; if ( ( ( configElement . getAttribute ( ATT_NAME ) ) == null ) || ( ( RegistryReader . getClassValue ( configElement , ATT_CLASS ) ) == null ) ) { <START_BUG> throw new CoreException ( new Status ( IStatus . ERROR , configElement . getDeclaringExtension ( ) . getNamespace ( ) , 0 , ( "Invalid<seq2seq4repair_space>extension<seq2seq4repair_space>(missing<seq2seq4repair_space>label<seq2seq4repair_space>or<seq2seq4repair_space>class<seq2seq4repair_space>name):<seq2seq4repair_space>" + ( id ) ) , null ) ) ; <END_BUG> } if ( category != null ) { StringTokenizer stok = new StringTokenizer ( category , "/" ) ; categoryPath = new String [ stok . countTokens ( ) ] ; for ( int i = 0 ; stok . hasMoreTokens ( ) ; i ++ ) { categoryPath [ i ] = stok . nextToken ( ) ; } } String ratio = configElement . getAttribute ( ATT_RATIO ) ; if ( ratio != null ) { try { fastViewWidthRatio = new Float ( ratio ) . floatValue ( ) ; if ( ( fastViewWidthRatio ) > ( IPageLayout . RATIO_MAX ) ) fastViewWidthRatio = IPageLayout . RATIO_MAX ; if ( ( fastViewWidthRatio ) < ( IPageLayout . RATIO_MIN ) ) fastViewWidthRatio = IPageLayout . RATIO_MIN ; } catch ( NumberFormatException e ) { fastViewWidthRatio = IPageLayout . DEFAULT_FASTVIEW_RATIO ; } } else { fastViewWidthRatio = IPageLayout . DEFAULT_FASTVIEW_RATIO ; } } public String toString ( ) { } public String getPluginId ( ) { } public String getLocalId ( ) { } public boolean getAllowMultiple ( ) { } public Object getAdapter ( Class adapter ) { } public final void activateHandler ( ) { } public final void deactivateHandler ( ) { } }
public class PageCreateKey extends WizardPage implements Listener { public static final String PAGE_NAME = "SignPageCreateKey" ; private String keystoreName ; private String project ; private boolean generated = false ; private Button bOpen = null ; private Button bGenerate = null ; private Button bEchoKeystorePassword = null ; private Button bEchoKeyPassword = null ; private Combo cAlgorithm = null ; private Label lPreview = null ; private Label lResult = null ; private Text tCommonName = null ; private Text tOrganizationalUnit = null ; private Text tOrganization = null ; private Text tLocation = null ; private Text tState = null ; private Text tCountry = null ; private Text tKeyName = null ; private Text tKeystore = null ; private Text tKeystorePassword = null ; private Text tKeyPassword = null ; private static final int LABELWIDTH = 160 ; private static final int TEXTHEIGHT = 40 ; private Signature signature = null ; private Keystore keystore = null ; public PageCreateKey ( final Signature signature , final String project ) { } public void createControl ( final Composite parent ) { } private void createPageContent ( final Composite parent ) { } private void addListeners ( ) { } private void dialogChanged ( ) { } private void updateStatus ( final String message , final int status ) { } public void handleEvent ( final Event e ) { } private void echoPassword ( final Event e ) { } private void openKeystore ( ) { } private void generateCertificate ( ) throws Exception { } public void onEnterPage ( ) { } public IWizardPage getNextPage ( ) { } private void saveDataToModel ( ) { signature . setKeystore ( keystore ) ; signature . setKeystorePassword ( tKeystorePassword . getText ( ) . toCharArray ( ) ) ; signature . setKeyPassword ( tKeyPassword . getText ( ) . toCharArray ( ) ) ; <START_BUG> signature . setKeyAlias ( tKeyName . getText ( ) ) ; <END_BUG> if ( cAlgorithm . getText ( ) . equals ( "DSA" ) ) { signature . setKeyAlgorithm ( "SHA1withDSA" ) ; } else if ( cAlgorithm . getText ( ) . equals ( "EC" ) ) { signature . setKeyAlgorithm ( "SHA1withECDSA" ) ; } else if ( cAlgorithm . getText ( ) . equals ( "RSA" ) ) { signature . setKeyAlgorithm ( "SHA1withRSA" ) ; } } }
public final class XMLSerializer extends BaseMarkupSerializer { public XMLSerializer ( ) { } public XMLSerializer ( OutputFormat format ) { } public XMLSerializer ( Writer writer , OutputFormat format ) { } public XMLSerializer ( OutputStream output , OutputFormat format ) { } public void setOutputFormat ( OutputFormat format ) { } public void startElement ( String namespaceURI , String localName , String rawName , Attributes attrs ) { } public void endElement ( String namespaceURI , String localName , String rawName ) { } public void startElement ( String tagName , AttributeList attrs ) { } public void endElement ( String tagName ) { } protected void startDocument ( String rootTagName ) { } protected void serializeElement ( Element elem ) { } <START_BUG> protected String getEntityRef ( char ch ) { <END_BUG> switch ( ch ) { case '<' : return "lt" ; case '>' : return "gt" ; case '"' : return "quot" ; case '\'' : return "apos" ; case '&' : return "amp" ; } return null ; } }
public class IntegerRangeTest { @ Test public void testNoRange ( ) { } @ Test ( expected = IllegalArgumentException . class ) public void testIncorrectRange ( ) { } @ Test public void simpleRange ( ) { } @ Test public void oneNumberRange ( ) { } @ Test public void twoRanges ( ) { } @ Test public void twoRangesAddedInReverseOrder ( ) { } @ Test public void twoRangesOneWithinAnother ( ) { } @ Test public void twoRangesOverlapping ( ) { } @ Test public void twoRangesAtTheMaxInt ( ) { } private void validateRange ( IntegerRange range , Integer ... numbers ) { <START_BUG> Iterator < Integer > iterator = range . createIterator ( ) ; <END_BUG> for ( Integer number : numbers ) { assertTrue ( iterator . hasNext ( ) ) ; assertEquals ( number , iterator . next ( ) ) ; } assertFalse ( iterator . hasNext ( ) ) ; } }
public abstract class AbstractDistributionTest extends ContainerAbstractTestCase implements RemoteServicePublication , IDistributionConstants { protected IRemoteServiceContainerAdapter [ ] adapters = null ; protected abstract String getClientContainerName ( ) { } protected void tearDown ( ) throws Exception { } protected void setClientCount ( int count ) { } protected void setupRemoteServiceAdapters ( ) throws Exception { } protected BundleContext getContext ( ) { } protected IRemoteServiceContainerAdapter [ ] getRemoteServiceAdapters ( ) { } protected IRemoteServiceListener createRemoteServiceListener ( final boolean server ) { } protected void addRemoteServiceListeners ( ) { } protected IRemoteServiceRegistration registerRemoteService ( IRemoteServiceContainerAdapter adapter , String serviceInterface , Object service , Dictionary serviceProperties , int sleepTime ) { } protected IRemoteServiceReference [ ] getRemoteServiceReferences ( IRemoteServiceContainerAdapter adapter , String clazz , String filter ) { } protected IRemoteService getRemoteService ( IRemoteServiceContainerAdapter adapter , String clazz , String filter ) { } protected String getFilterFromServiceProperties ( Dictionary serviceProperties ) { } protected String [ ] getDefaultServiceClasses ( ) { } protected Object getDefaultService ( ) { } protected ServiceRegistration registerService ( String [ ] clazzes , Object service , Properties props ) throws Exception { } protected ServiceRegistration registerService ( String clazz , Object service , Properties props ) throws Exception { } protected ServiceRegistration registerDefaultService ( Properties props ) throws Exception { } public ServiceReference getReference ( ) { } protected void assertReferenceHasCorrectType ( ServiceReference sr , String classname ) { } protected void assertReferencesValidAndFirstHasCorrectType ( ServiceReference [ ] references , String classname ) { } protected void assertReferencesValid ( ServiceReference [ ] references ) { } protected void assertStringResultValid ( Object result , String compare ) { } protected void assertProxyValid ( Object proxy ) { } protected ServiceTracker createProxyServiceTracker ( String clazz ) throws InvalidSyntaxException { ServiceTracker st = new ServiceTracker ( getContext ( ) , getContext ( ) . createFilter ( ( ( ( ( ( ( "(&(" + ( Constants . OBJECTCLASS ) ) + "=" ) + clazz ) + ")(" ) + ( SERVICE_IMPORTED ) ) + "=*))" ) ) , new ServiceTrackerCustomizer ( ) { public Object addingService ( ServiceReference reference ) { Trace . trace ( PLUGIN_ID , ( "addingService=" + reference ) ) ; return getContext ( ) . getService ( reference ) ; } public void modifiedService ( ServiceReference reference , Object service ) { Trace . trace ( PLUGIN_ID , ( "modifiedService=" + reference ) ) ; } public void removedService ( ServiceReference reference , Object service ) { Trace . trace ( PLUGIN_ID , ( ( ( "removedService=" + reference ) + ",svc=" ) + service ) ) ; } } ) ; <START_BUG> st . open ( ) ; <END_BUG> return st ; } protected IRemoteService getRemoteServiceFromProxy ( Object proxy ) { } }
@ Repository public class DataExportDAOImpl extends JDBCBaseDAO implements DataExportDAO { @ Override public String exportToCSV ( String userName , String tableName ) throws IOException , SQLException { User user = ( ( User ) ( getJdbcTemplate ( ) . queryForObject ( GET_USER_BY_USERNAME . getValue ( ) , new Object [ ] { userName } , new UserRowMapper ( ) ) ) ) ; String userTable = ( ( ( tableName + "_" ) + userName ) + "_" ) + ( user . getUserId ( ) ) ; String query = "SELECT<seq2seq4repair_space>*<seq2seq4repair_space>FROM<seq2seq4repair_space>" + userTable ; PreparedStatement statement = getConnection ( ) . prepareStatement ( query ) ; ResultSet resultSet = statement . executeQuery ( ) ; ResultSetMetaData resultSetMetaData = resultSet . getMetaData ( ) ; <START_BUG> FileWriter writer = new FileWriter ( ( userTable + ".csv" ) ) ; <END_BUG> for ( int i = 1 ; i <= ( resultSetMetaData . getColumnCount ( ) ) ; i ++ ) { writer . append ( resultSetMetaData . getColumnName ( i ) ) ; writer . append ( "," ) ; } writer . append ( "\n" ) ; while ( resultSet . next ( ) ) { for ( int i = 1 ; i <= ( resultSetMetaData . getColumnCount ( ) ) ; i ++ ) { writer . append ( resultSet . getString ( i ) . replaceAll ( "," , "." ) ) ; writer . append ( "," ) ; } writer . append ( "\n" ) ; } writer . flush ( ) ; writer . close ( ) ; return userTable + ".csv" ; } }
public class GameActivity extends Activity { private GameEngine _gameEngine = null ; private GameHUD _gameHUD = null ; private List < ABlock > _blocks = null ; private SharedPreferences _sharedPreferences = null ; @ Override protected void onCreate ( Bundle savedInstanceState ) { <START_BUG> _sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; <END_BUG> super . onCreate ( savedInstanceState ) ; _gameHUD = new GameHUD ( this ) ; setContentView ( _gameHUD ) ; _gameEngine = new GameEngine ( this ) ; int ballSpeedValue = _sharedPreferences . getInt ( "ball_speed" , 0 ) ; Ball ball = new Ball ( ) ; try { ball . setMaxSpeed ( ballSpeedValue ) ; } catch ( IllegalArgumentException e ) { } _gameHUD . setBall ( ball ) ; _gameEngine . setBall ( ball ) ; _blocks = _gameEngine . buildGame ( ) ; _gameHUD . setBlocks ( _blocks ) ; } @ Override protected void onResume ( ) { } @ Override protected void onPause ( ) { } @ Override public Dialog onCreateDialog ( int id ) { } @ Override public void onPrepareDialog ( int id , Dialog box ) { } }
public class NamePatternParserTestCase extends TestCase { public NamePatternParserTestCase ( String name ) { } public void testMatch ( ) { } private void checkMatch ( String [ ] patterns ) { for ( int i = 0 , len = patterns . length ; i < len ; i ++ ) { String pattern = patterns [ i ] ; <START_BUG> ITokenSource tokenSource = BasicTokenSource . makeTokenSource ( pattern ) ; <END_BUG> NamePattern p1 = new PatternParser ( tokenSource ) . parseNamePattern ( ) ; NamePattern p2 = new NamePattern ( pattern ) ; assertEquals ( ( "pattern:<seq2seq4repair_space>" + pattern ) , p2 , p1 ) ; assertEquals ( "eof" , EOF , tokenSource . next ( ) ) ; } } }
public final class LootRandom extends Random { public LootRandom ( ) { } public LootRandom ( long seed ) { } @ Override public double nextDouble ( ) { } public int nextIntRange ( int i1 , int i2 ) { int min = Math . min ( i1 , i2 ) ; int max = Math . max ( i1 , i2 ) ; int diff = Math . abs ( ( max - min ) ) ; <START_BUG> return min + ( nextInt ( diff ) ) ; <END_BUG> } }
public class Inserter extends Operation { public Inserter ( int index ) { } public void run ( Cassandra . Client client ) throws IOException { List < ByteBuffer > values = generateValues ( ) ; List < Column > columns = new ArrayList < Column > ( ) ; List < SuperColumn > superColumns = new ArrayList < SuperColumn > ( ) ; String format = ( "%0" + ( session . getTotalKeysLength ( ) ) ) + "d" ; for ( int i = 0 ; i < ( session . getColumnsPerKey ( ) ) ; i ++ ) { String columnName = "C" + ( Integer . toString ( i ) ) ; ByteBuffer columnValue = values . get ( ( i % ( values . size ( ) ) ) ) ; columns . add ( new Column ( ByteBufferUtil . bytes ( columnName ) , columnValue , System . currentTimeMillis ( ) ) ) ; } if ( ( session . getColumnFamilyType ( ) ) == ( ColumnFamilyType . Super ) ) { for ( int i = 0 ; i < ( session . getSuperColumns ( ) ) ; i ++ ) { String superColumnName = "S" + ( Integer . toString ( i ) ) ; <START_BUG> superColumns . add ( new SuperColumn ( ByteBuffer . wrap ( superColumnName . getBytes ( ) ) , columns ) ) ; <END_BUG> } } String rawKey = String . format ( format , index ) ; Map < ByteBuffer , Map < String , List < Mutation > > > record = new HashMap < ByteBuffer , Map < String , List < Mutation > > > ( ) ; record . put ( ByteBufferUtil . bytes ( rawKey ) , ( ( session . getColumnFamilyType ( ) ) == ( ColumnFamilyType . Super ) ? getSuperColumnsMutationMap ( superColumns ) : getColumnsMutationMap ( columns ) ) ) ; long start = System . currentTimeMillis ( ) ; boolean success = false ; String exceptionMessage = null ; for ( int t = 0 ; t < ( session . getRetryTimes ( ) ) ; t ++ ) { if ( success ) break ; try { client . batch_mutate ( record , session . getConsistencyLevel ( ) ) ; success = true ; } catch ( Exception e ) { exceptionMessage = getExceptionMessage ( e ) ; success = false ; } } if ( ! success ) { error ( String . format ( "Operation<seq2seq4repair_space>[%d]<seq2seq4repair_space>retried<seq2seq4repair_space>%d<seq2seq4repair_space>times<seq2seq4repair_space>-<seq2seq4repair_space>error<seq2seq4repair_space>inserting<seq2seq4repair_space>key<seq2seq4repair_space>%s<seq2seq4repair_space>%s%n" , index , session . getRetryTimes ( ) , rawKey , ( exceptionMessage == null ? "" : ( "(" + exceptionMessage ) + ")" ) ) ) ; } operations . getAndIncrement ( ) ; keys . getAndIncrement ( ) ; latency . getAndAdd ( ( ( System . currentTimeMillis ( ) ) - start ) ) ; } private Map < String , List < Mutation > > getSuperColumnsMutationMap ( List < SuperColumn > superColumns ) { } private Map < String , List < Mutation > > getColumnsMutationMap ( List < Column > columns ) { } }
public class UserList { private static Map < User , String > userNames = new HashMap < > ( ) ; private static Set < User > users = new HashSet < > ( ) ; public UserList ( ) { } public boolean userExists ( User user ) { } public void addUser ( User user ) { } public void updateUser ( User user ) { } public static boolean isUserValid ( String username ) { <START_BUG> return ! ( UserList . userNames . containsValue ( username ) ) ; <END_BUG> } public static User getUserByUsername ( String username ) throws NoSuchElementException { } public static User getUserByEmail ( String email ) throws NoSuchElementException { } No newline ; at end ; of file ; }
public class UrlConfigGui extends JPanel implements ChangeListener { private static final long serialVersionUID = 240L ; private static final int TAB_PARAMETERS = 0 ; private static final int TAB_RAW_BODY = 1 ; private HTTPArgumentsPanel argsPanel ; private JTextField domain ; private JTextField port ; private JTextField proxyHost ; private JTextField proxyPort ; private JTextField proxyUser ; private JPasswordField proxyPass ; private JTextField connectTimeOut ; private JTextField responseTimeOut ; private JTextField protocol ; private JTextField contentEncoding ; private JTextField path ; private JCheckBox followRedirects ; private JCheckBox autoRedirects ; private JCheckBox useKeepAlive ; private JCheckBox useMultipartForPost ; private JCheckBox useBrowserCompatibleMultipartMode ; private JLabeledChoice method ; private JLabeledChoice httpImplementation ; private final boolean notConfigOnly ; private final boolean showImplementation ; private JLabeledTextArea postBodyContent ; private UrlConfigGui . ValidationTabbedPane postContentTabbedPane ; private boolean showRawBodyPane ; public UrlConfigGui ( ) { } public UrlConfigGui ( boolean showSamplerFields ) { } public UrlConfigGui ( boolean showSamplerFields , boolean showImplementation , boolean showRawBodyPane ) { } public void clear ( ) { } public TestElement createTestElement ( ) { } public void modifyTestElement ( TestElement element ) { boolean useRaw = ( postContentTabbedPane . getSelectedIndex ( ) ) == ( UrlConfigGui . TAB_RAW_BODY ) ; Arguments args ; if ( useRaw ) { args = new Arguments ( ) ; String text = postBodyContent . getText ( ) ; <START_BUG> HTTPArgument arg = new HTTPArgument ( "" , text . replaceAll ( "\n" , "\r\n" ) , true ) ; <END_BUG> arg . setAlwaysEncoded ( false ) ; args . addArgument ( arg ) ; } else { args = ( ( Arguments ) ( argsPanel . createTestElement ( ) ) ) ; HTTPArgument . convertArgumentsToHTTP ( args ) ; } element . setProperty ( POST_BODY_RAW , useRaw , POST_BODY_RAW_DEFAULT ) ; element . setProperty ( new org . apache . jmeter . testelement . property . TestElementProperty ( HTTPSamplerBase . ARGUMENTS , args ) ) ; element . setProperty ( DOMAIN , domain . getText ( ) ) ; element . setProperty ( PORT , port . getText ( ) ) ; element . setProperty ( PROXYHOST , proxyHost . getText ( ) , "" ) ; element . setProperty ( PROXYPORT , proxyPort . getText ( ) , "" ) ; element . setProperty ( PROXYUSER , proxyUser . getText ( ) , "" ) ; element . setProperty ( PROXYPASS , String . valueOf ( proxyPass . getPassword ( ) ) , "" ) ; element . setProperty ( CONNECT_TIMEOUT , connectTimeOut . getText ( ) ) ; element . setProperty ( RESPONSE_TIMEOUT , responseTimeOut . getText ( ) ) ; element . setProperty ( PROTOCOL , protocol . getText ( ) ) ; element . setProperty ( CONTENT_ENCODING , contentEncoding . getText ( ) ) ; element . setProperty ( PATH , path . getText ( ) ) ; if ( notConfigOnly ) { element . setProperty ( METHOD , method . getText ( ) ) ; element . setProperty ( new org . apache . jmeter . testelement . property . BooleanProperty ( HTTPSamplerBase . FOLLOW_REDIRECTS , followRedirects . isSelected ( ) ) ) ; element . setProperty ( new org . apache . jmeter . testelement . property . BooleanProperty ( HTTPSamplerBase . AUTO_REDIRECTS , autoRedirects . isSelected ( ) ) ) ; element . setProperty ( new org . apache . jmeter . testelement . property . BooleanProperty ( HTTPSamplerBase . USE_KEEPALIVE , useKeepAlive . isSelected ( ) ) ) ; element . setProperty ( new org . apache . jmeter . testelement . property . BooleanProperty ( HTTPSamplerBase . DO_MULTIPART_POST , useMultipartForPost . isSelected ( ) ) ) ; element . setProperty ( BROWSER_COMPATIBLE_MULTIPART , useBrowserCompatibleMultipartMode . isSelected ( ) , BROWSER_COMPATIBLE_MULTIPART_MODE_DEFAULT ) ; } if ( showImplementation ) { element . setProperty ( IMPLEMENTATION , httpImplementation . getText ( ) , "" ) ; } } private static final String computePostBody ( Arguments arguments ) { } private static final String computePostBody ( Arguments arguments , boolean crlfToLF ) { } public void configure ( TestElement el ) { } private void init ( ) { } protected final JPanel getWebServerTimeoutPanel ( ) { } protected final JPanel getProxyServerPanel ( ) { } private JPanel getPortPanel ( ) { } private JPanel getProxyPortPanel ( ) { } private JPanel getConnectTimeOutPanel ( ) { } private JPanel getResponseTimeOutPanel ( ) { } private JPanel getDomainPanel ( ) { } private JPanel getProxyHostPanel ( ) { } private JPanel getProxyUserPanel ( ) { } private JPanel getProxyPassPanel ( ) { } protected Component getPathPanel ( ) { } protected JPanel getProtocolAndMethodPanel ( ) { } protected JTabbedPane getParameterPanel ( ) { } class ValidationTabbedPane extends JTabbedPane { private static final long serialVersionUID = 7014311238367882880L ; @ Override public void setSelectedIndex ( int index ) { } public void setSelectedIndex ( int index , boolean check ) { } } public void stateChanged ( ChangeEvent e ) { } void convertParametersToRaw ( ) { } boolean canConvertParameters ( ) { } boolean noData ( int oldSelectedIndex ) { } }
public class ChannelMetricsHandler extends AbstractRuntimeOnlyHandler { @ Override protected void executeRuntimeStep ( OperationContext context , ModelNode operation ) throws OperationFailedException { <START_BUG> String channelName = context . getCurrentAddressValue ( ) ; <END_BUG> String name = Operations . getAttributeName ( operation ) ; ChannelMetric metric = ChannelMetric . forName ( name ) ; if ( metric == null ) { context . getFailureDescription ( ) . set ( ROOT_LOGGER . unknownMetric ( name ) ) ; } else { JChannel channel = ServiceContainerHelper . findValue ( context . getServiceRegistry ( false ) , CHANNEL . getServiceName ( channelName ) ) ; if ( channel != null ) { context . getResult ( ) . set ( metric . getValue ( channel ) ) ; } } context . completeStep ( NOOP_RESULT_HANDLER ) ; } }
public class RepositoryValidationDecorator extends CrudRepositoryDecorator { private final EntityAttributesValidator entityAttributesValidator ; private final DataService dataService ; public RepositoryValidationDecorator ( DataService dataService , CrudRepository repository , EntityAttributesValidator entityAttributesValidator ) { } @ Override public void update ( Entity entity ) { } @ Override public void update ( Iterable < ? extends Entity > entities ) { } @ Override public void delete ( Entity entity ) { } @ Override public void add ( Entity entity ) { } @ Override public Integer add ( Iterable < ? extends Entity > entities ) { } private void validate ( Iterable < ? extends Entity > entities , boolean forUpdate ) { } protected Set < ConstraintViolation > checkNillable ( Iterable < ? extends Entity > entities ) { } protected Set < ConstraintViolation > checkReadonlyByUpdate ( Iterable < ? extends Entity > entities ) { } protected Set < ConstraintViolation > checkRefValues ( Iterable < ? extends Entity > entities , AttributeMetaData attr ) { Set < ConstraintViolation > violations = Sets . newHashSet ( ) ; HugeSet < Object > refEntityIdValues = new HugeSet < Object > ( ) ; try { for ( Entity refEntity : dataService . findAll ( attr . getRefEntity ( ) . getName ( ) ) ) { refEntityIdValues . add ( refEntity . getIdValue ( ) ) ; } if ( attr . getRefEntity ( ) . getName ( ) . equalsIgnoreCase ( attr . getName ( ) ) ) { for ( Entity entity : entities ) { if ( ( entity . getIdValue ( ) ) != null ) { refEntityIdValues . add ( entity . getIdValue ( ) ) ; } } } long rownr = 0 ; for ( Entity entity : entities ) { rownr ++ ; if ( ( attr . getDataType ( ) ) instanceof XrefField ) { Entity refEntity = entity . getEntity ( attr . getName ( ) ) ; if ( ( ( refEntity != null ) && ( ( refEntity . getIdValue ( ) ) != null ) ) && ( ! ( refEntityIdValues . contains ( refEntity . getIdValue ( ) ) ) ) ) { String message = String . format ( "Unknown<seq2seq4repair_space>xref<seq2seq4repair_space>value<seq2seq4repair_space>'%s'<seq2seq4repair_space>for<seq2seq4repair_space>attribute<seq2seq4repair_space>'%s'<seq2seq4repair_space>of<seq2seq4repair_space>entity<seq2seq4repair_space>'%s'." , DataConverter . toString ( refEntity . getIdValue ( ) ) , attr . getName ( ) , getEntityMetaData ( ) . getLabel ( ) ) ; violations . add ( new ConstraintViolation ( message , attr , rownr ) ) ; if ( ( violations . size ( ) ) > 4 ) break ; } } else if ( ( attr . getDataType ( ) ) instanceof MrefField ) { <START_BUG> Iterable < Entity > refEntities = entity . getEntities ( attr . getName ( ) ) ; <END_BUG> if ( refEntities != null ) { for ( Entity refEntity : refEntities ) { if ( ( ( refEntity . getIdValue ( ) ) != null ) && ( ! ( refEntityIdValues . contains ( refEntity . getIdValue ( ) ) ) ) ) { String message = String . format ( "Unknown<seq2seq4repair_space>mref<seq2seq4repair_space>value<seq2seq4repair_space>'%s'<seq2seq4repair_space>for<seq2seq4repair_space>attribute<seq2seq4repair_space>'%s'<seq2seq4repair_space>of<seq2seq4repair_space>entity<seq2seq4repair_space>'%s'." , DataConverter . toString ( refEntity . getIdValue ( ) ) , attr . getName ( ) , getEntityMetaData ( ) . getLabel ( ) ) ; violations . add ( new ConstraintViolation ( message , attr , rownr ) ) ; if ( ( violations . size ( ) ) > 4 ) break ; } } } } } return violations ; } finally { IOUtils . closeQuietly ( refEntityIdValues ) ; } } protected Set < ConstraintViolation > checkUniques ( Iterable < ? extends Entity > entities , AttributeMetaData attr , boolean forUpdate ) { } private boolean entityHasId ( Entity entity , Object id ) { } }
public class CrusherRecipeRegistry { private final List < ICrusherRecipe > recipes = new ArrayList < > ( ) ; private final Map < CrusherRecipeRegistry . ItemLookupReference , ICrusherRecipe > recipeByInputCache = new HashMap < > ( ) ; private final Map < CrusherRecipeRegistry . ItemLookupReference , List < ICrusherRecipe > > recipeByOutputCache = new HashMap < > ( ) ; private static final Lock initLock = new ReentrantLock ( ) ; private static CrusherRecipeRegistry instance = null ; public static CrusherRecipeRegistry getInstance ( ) { } public static void addNewCrusherRecipe ( final String oreDictionaryName , final ItemStack output ) { } public static void addNewCrusherRecipe ( final ItemStack input , final ItemStack output ) { } public static void addNewCrusherRecipe ( final Item input , final ItemStack output ) { } public static void addNewCrusherRecipe ( final Block input , final ItemStack output ) { } public void clearCache ( ) { } public void addRecipe ( ICrusherRecipe crusherRecipe ) { } public List < ICrusherRecipe > getRecipesForOutputItem ( ItemStack output ) { CrusherRecipeRegistry . ItemLookupReference ref = new CrusherRecipeRegistry . ItemLookupReference ( output ) ; if ( recipeByOutputCache . containsKey ( ref ) ) { List < ICrusherRecipe > recipeCache = recipeByOutputCache . get ( ref ) ; if ( recipeCache . isEmpty ( ) ) return null ; return recipeCache ; } else { List < ICrusherRecipe > recipeCache = new ArrayList < > ( ) ; for ( ICrusherRecipe r : recipes ) { <START_BUG> if ( ItemStack . areItemStacksEqual ( r . getOutput ( ) , output ) ) { <END_BUG> recipeCache . add ( r ) ; } } recipeByOutputCache . put ( ref , recipeCache ) ; if ( recipeCache . isEmpty ( ) ) return null ; return recipeCache ; } } public ICrusherRecipe getRecipeForInputItem ( ItemStack input ) { } private static final class ItemLookupReference { final Item item ; final int metaData ; final int hashCache ; public ItemLookupReference ( ItemStack inputItem ) { } @ Override public boolean equals ( Object other ) { } @ Override public int hashCode ( ) { } } public Collection < ICrusherRecipe > getAllRecipes ( ) { } }
public class ThisJoinPointVisitor extends ASTVisitor { boolean needsDynamic = false ; boolean needsStatic = false ; boolean needsStaticEnclosing = false ; boolean hasEffectivelyStaticRef = false ; LocalVariableBinding thisJoinPointDec ; LocalVariableBinding thisJoinPointStaticPartDec ; LocalVariableBinding thisEnclosingJoinPointStaticPartDec ; LocalVariableBinding thisJoinPointDecLocal ; LocalVariableBinding thisJoinPointStaticPartDecLocal ; LocalVariableBinding thisEnclosingJoinPointStaticPartDecLocal ; boolean replaceEffectivelyStaticRefs = false ; AbstractMethodDeclaration method ; ThisJoinPointVisitor ( AbstractMethodDeclaration method ) { } public void computeJoinPointParams ( ) { } boolean isRef ( NameReference ref , Binding binding ) { } boolean isRef ( Expression expr , Binding binding ) { } public void endVisit ( SingleNameReference ref , BlockScope scope ) { } boolean canTreatAsStatic ( String id ) { } boolean inBlockThatCantRun = false ; public boolean visit ( MessageSend call , BlockScope scope ) { } private void replaceEffectivelyStaticRef ( MessageSend call ) { NameReference receiver = ( ( NameReference ) ( call . receiver ) ) ; if ( ( call . binding ) == null ) return ; receiver . binding = thisJoinPointStaticPartDecLocal ; receiver . codegenBinding = thisJoinPointStaticPartDecLocal ; ReferenceBinding thisJoinPointStaticPartType = ( ( ReferenceBinding ) ( thisJoinPointStaticPartDec . type ) ) ; <START_BUG> receiver . receiverType = receiver . actualReceiverType = receiver . resolvedType = thisJoinPointStaticPartType ; <END_BUG> call . setActualReceiverType ( thisJoinPointStaticPartType ) ; AstUtil . replaceMethodBinding ( call , getEquivalentStaticBinding ( call . binding ) ) ; } private MethodBinding getEquivalentStaticBinding ( MethodBinding template ) { } public int removeUnusedExtraArguments ( ) { } private void removeParameter ( int indexToRemove ) { } private static TypeBinding [ ] removeParameter ( int index , TypeBinding [ ] bindings ) { } private static LocalVariableBinding [ ] removeLocalBinding ( int index , LocalVariableBinding [ ] bindings ) { } }
public class TableController implements TreeSelectionListener , FolderListener , FocusOwner { private TableView view ; private AddressbookFrameMediator mediator ; private AddressbookTableModel addressbookModel ; private SortDecorator sortDecorator ; private FilterDecorator filterDecorator ; private AddressbookTreeNode selectedFolder ; public TableController ( AddressbookFrameMediator mediator ) { } protected void addMouseListenerToHeaderInTable ( ) { } public AddressbookFrameMediator getMediator ( ) { } public TableView getView ( ) { } public void valueChanged ( TreeSelectionEvent e ) { AddressbookTreeNode node = ( ( AddressbookTreeNode ) ( e . getPath ( ) . getLastPathComponent ( ) ) ) ; if ( node == null ) { return ; } if ( node instanceof IContactStorage ) { try { ( ( org . columba . addressbook . folder . AbstractFolder ) ( node ) ) . removeFolderListener ( this ) ; selectedFolder = node ; ( ( org . columba . addressbook . folder . AbstractFolder ) ( node ) ) . addFolderListener ( this ) ; filterDecorator . setContactItemMap ( ( ( org . columba . addressbook . folder . AbstractFolder ) ( selectedFolder ) ) . getContactItemMap ( ) ) ; } catch ( Exception e1 ) { if ( Logging . DEBUG ) e1 . printStackTrace ( ) ; <START_BUG> new ErrorDialog ( e1 . getMessage ( ) , e1 ) ; <END_BUG> } } else { filterDecorator . setContactItemMap ( null ) ; } } public Object [ ] getUids ( ) { } public AddressbookTableModel getAddressbookModel ( ) { } public IContactItem getSelectedItem ( ) { } public void itemAdded ( IFolderEvent e ) { } public void itemChanged ( IFolderEvent e ) { } public void itemRemoved ( IFolderEvent e ) { } public void copy ( ) { } public void cut ( ) { } public void delete ( ) { } public JComponent getComponent ( ) { } public boolean isCopyActionEnabled ( ) { } public boolean isCutActionEnabled ( ) { } public boolean isDeleteActionEnabled ( ) { } public boolean isPasteActionEnabled ( ) { } public boolean isRedoActionEnabled ( ) { } public boolean isSelectAllActionEnabled ( ) { } public boolean isUndoActionEnabled ( ) { } public void paste ( ) { } public void redo ( ) { } public void selectAll ( ) { } public void undo ( ) { } public SortDecorator getSortDecorator ( ) { } public FilterDecorator getFilterDecorator ( ) { } }
public class RosterWorkbenchAdapterFactory implements IAdapterFactory { protected ImageDescriptor getImageDescriptor ( String iconFile ) { } protected String getRosterLabel ( IRoster roster ) { } protected ImageDescriptor getRosterImageDescriptor ( IRoster roster ) { IUser user = roster . getUser ( ) ; if ( user == null ) return getImageDescriptor ( IMG_USER_UNAVAILABLE ) ; else <START_BUG> return getImageDescriptor ( IMG_USER_AVAILABLE ) ; <END_BUG> } private IWorkbenchAdapter rosterAdapter = new IWorkbenchAdapter ( ) { public Object [ ] getChildren ( Object o ) { } public ImageDescriptor getImageDescriptor ( Object object ) { } public String getLabel ( Object o ) { } public Object getParent ( Object o ) { } } ; protected int getEntriesAvailableCount ( Collection entries ) { } protected int getEntriesTotalCount ( Collection entries ) { } protected String getRosterGroupLabel ( IRosterGroup group ) { } protected ImageDescriptor getRosterGroupImageDescriptor ( IRosterGroup group ) { } private IWorkbenchAdapter rosterGroupAdapter = new IWorkbenchAdapter ( ) { public Object [ ] getChildren ( Object o ) { } public ImageDescriptor getImageDescriptor ( Object object ) { } public String getLabel ( Object o ) { } public Object getParent ( Object o ) { } } ; protected String getRosterItemLabel ( IRosterItem item ) { } protected ImageDescriptor getRosterItemImageDescriptor ( IRosterItem item ) { } private IWorkbenchAdapter rosterItemAdapter = new IWorkbenchAdapter ( ) { public Object [ ] getChildren ( Object o ) { } public ImageDescriptor getImageDescriptor ( Object object ) { } public String getLabel ( Object o ) { } public Object getParent ( Object o ) { } } ; protected String getRosterEntryLabel ( IRosterEntry entry ) { } protected ImageDescriptor getRosterEntryImageDescriptor ( IRosterEntry entry ) { } private IWorkbenchAdapter rosterEntryAdapter = new IWorkbenchAdapter ( ) { public Object [ ] getChildren ( Object o ) { } public ImageDescriptor getImageDescriptor ( Object object ) { } public String getLabel ( Object o ) { } public Object getParent ( Object o ) { } } ; public Object getAdapter ( Object adaptableObject , Class adapterType ) { } public Class [ ] getAdapterList ( ) { } }
class PeriodicRotatingFileHandlerAdd implements ModelAddOperationHandler { static final PeriodicRotatingFileHandlerAdd INSTANCE = new PeriodicRotatingFileHandlerAdd ( ) ; @ Override public OperationResult execute ( final OperationContext context , final ModelNode operation , final ResultHandler resultHandler ) throws OperationFailedException { final PathAddress address = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) ; final String name = address . getLastElement ( ) . getValue ( ) ; final ModelNode compensatingOperation = new ModelNode ( ) ; compensatingOperation . get ( OP_ADDR ) . set ( operation . require ( OP_ADDR ) ) ; compensatingOperation . get ( OP ) . set ( REMOVE ) ; final ModelNode subModel = context . getSubModel ( ) ; subModel . get ( CommonAttributes . AUTOFLUSH ) . set ( operation . get ( CommonAttributes . AUTOFLUSH ) ) ; subModel . get ( CommonAttributes . ENCODING ) . set ( operation . get ( CommonAttributes . ENCODING ) ) ; subModel . get ( CommonAttributes . FORMATTER ) . set ( operation . get ( CommonAttributes . FORMATTER ) ) ; subModel . get ( CommonAttributes . LEVEL ) . set ( operation . get ( CommonAttributes . LEVEL ) ) ; subModel . get ( CommonAttributes . FILE ) . set ( operation . get ( CommonAttributes . FILE ) ) ; subModel . get ( CommonAttributes . SUFFIX ) . set ( operation . get ( CommonAttributes . SUFFIX ) ) ; if ( ( context . getRuntimeContext ( ) ) != null ) { context . getRuntimeContext ( ) . setRuntimeTask ( new RuntimeTask ( ) { public void execute ( RuntimeTaskContext context ) throws OperationFailedException { final ServiceTarget serviceTarget = context . getServiceTarget ( ) ; try { final PeriodicRotatingFileHandlerService service = new PeriodicRotatingFileHandlerService ( ) ; final ServiceBuilder < Handler > serviceBuilder = serviceTarget . addService ( LogServices . handlerName ( name ) , service ) ; if ( operation . hasDefined ( CommonAttributes . FILE ) ) { final HandlerFileService fileService = new HandlerFileService ( operation . get ( CommonAttributes . FILE , CommonAttributes . PATH ) . asString ( ) ) ; final ServiceBuilder < ? > fileBuilder = serviceTarget . addService ( LogServices . handlerFileName ( name ) , fileService ) ; <START_BUG> if ( operation . hasDefined ( RELATIVE_TO ) ) { <END_BUG> fileBuilder . addDependency ( AbstractPathService . pathNameOf ( operation . get ( CommonAttributes . FILE , CommonAttributes . RELATIVE_TO ) . asString ( ) ) , String . class , fileService . getRelativeToInjector ( ) ) ; } fileBuilder . setInitialMode ( ACTIVE ) . install ( ) ; serviceBuilder . addDependency ( LogServices . handlerFileName ( name ) , String . class , service . getFileNameInjector ( ) ) ; } service . setLevel ( Level . parse ( operation . get ( CommonAttributes . LEVEL ) . asString ( ) ) ) ; final Boolean autoFlush = operation . get ( CommonAttributes . AUTOFLUSH ) . asBoolean ( ) ; if ( autoFlush != null ) service . setAutoflush ( autoFlush . booleanValue ( ) ) ; if ( operation . hasDefined ( CommonAttributes . SUFFIX ) ) service . setSuffix ( operation . get ( CommonAttributes . SUFFIX ) . asString ( ) ) ; if ( operation . hasDefined ( CommonAttributes . ENCODING ) ) service . setEncoding ( operation . get ( CommonAttributes . ENCODING ) . asString ( ) ) ; if ( operation . hasDefined ( CommonAttributes . FORMATTER ) ) service . setFormatterSpec ( PeriodicRotatingFileHandlerAdd . createFormatterSpec ( operation ) ) ; serviceBuilder . setInitialMode ( ACTIVE ) ; serviceBuilder . install ( ) ; resultHandler . handleResultComplete ( ) ; } catch ( Throwable t ) { throw new OperationFailedException ( new ModelNode ( ) . set ( t . getLocalizedMessage ( ) ) ) ; } } } ) ; } else { resultHandler . handleResultComplete ( ) ; } return new org . jboss . as . controller . BasicOperationResult ( compensatingOperation ) ; } static AbstractFormatterSpec createFormatterSpec ( final ModelNode operation ) { } }
public abstract class PassivationStoreRemove extends AbstractRemoveStepHandler { private final PassivationStoreAdd add ; PassivationStoreRemove ( PassivationStoreAdd add ) { } @ Override protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode model ) throws OperationFailedException { } @ Override protected void recoverServices ( OperationContext context , ModelNode operation , ModelNode model ) throws OperationFailedException { if ( context . isResourceServiceRestartAllowed ( ) ) { <START_BUG> this . add . installRuntimeService ( context , model , null ) ; <END_BUG> } else { context . revertReloadRequired ( ) ; } } void removeRuntimeService ( OperationContext context , ModelNode operation ) { } }
public class ClaimantAddItemController { private Claim claim = null ; public ClaimantAddItemController ( Claim claim ) { } public void addItem ( String dateSTR , String category , String description , Double amount , String currency ) throws StatusException { if ( ( AppSingleton . getInstance ( ) . getStatus ( ) . equals ( "Submitted" ) ) || ( AppSingleton . getInstance ( ) . getStatus ( ) . equals ( "Approved" ) ) ) { throw new StatusException ( ) ; } Date date = null ; try { date = AppSingleton . getDateFormat ( ) . parse ( dateSTR ) ; } catch ( ParseException e ) { date = null ; } Item item = new Item ( ) ; item . setDate ( date ) ; item . setCategory ( category ) ; item . setDescription ( description ) ; item . setAmount ( amount ) ; item . setCurrency ( currency ) ; <START_BUG> if ( ( ( date . equals ( "" ) ) || ( description . equals ( "" ) ) ) || ( amount == null ) ) { <END_BUG> item . setMissValue ( true ) ; } else { item . setMissValue ( false ) ; } item . addModelListener ( new Listener ( ) { @ Override public void update ( ) { claim . notifyListeners ( ) ; } } ) ; claim . getItemList ( ) . add ( item ) ; claim . notifyListeners ( ) ; } }
public class ItemRenderer extends StatBlockRenderer { private PsrdDbAdapter dbAdapter ; public ItemRenderer ( PsrdDbAdapter dbAdapter ) { } @ Override public String renderTitle ( ) { } @ Override public String renderDetails ( ) { StringBuffer sb = new StringBuffer ( ) ; Cursor curs = dbAdapter . getItemDetails ( sectionId ) ; boolean has_next = curs . moveToFirst ( ) ; if ( has_next ) { <START_BUG> sb . append ( addField ( "Aura" , "" ) ) ; <END_BUG> sb . append ( addField ( "CL" , curs . getString ( 2 ) ) ) ; sb . append ( addField ( "Slot" , curs . getString ( 1 ) , false ) ) ; sb . append ( addField ( "Price" , curs . getString ( 3 ) , false ) ) ; sb . append ( addField ( "Weight" , curs . getString ( 4 ) ) ) ; sb . append ( renderStatBlockBreaker ( "Construction" ) ) ; sb . append ( addField ( "Requirements" , curs . getString ( 5 ) , false ) ) ; sb . append ( addField ( "Skill" , curs . getString ( 6 ) , false ) ) ; sb . append ( addField ( "CR<seq2seq4repair_space>Increase" , curs . getString ( 7 ) , false ) ) ; sb . append ( addField ( "Cost" , curs . getString ( 8 ) ) ) ; sb . append ( renderStatBlockBreaker ( "Description" ) ) ; this . suppressNextTitle = true ; } return sb . toString ( ) ; } }
class DefaultBindingResolver extends BindingResolver { Map compilerBindingsToASTBindings ; Map newAstToOldAst ; Map bindingsToAstNodes ; Map astNodesToBindings ; DefaultBindingResolver ( ) { } IBinding resolveName ( Name name ) { } private IBinding resolveNameForMessageSend ( Name name , AstNode node ) { } private IBinding resolveNameForMessageSend ( Name name , AstNode node , int index ) { } private IBinding resolveNameForNameReference ( Name name , AstNode node ) { } private IBinding resolveNameForPackageDeclaration ( Name name ) { } ITypeBinding resolveType ( Type type ) { } ITypeBinding resolveWellKnownType ( String name ) { } ITypeBinding resolveType ( TypeDeclaration type ) { } IMethodBinding resolveMethod ( MethodDeclaration method ) { } IVariableBinding resolveVariable ( VariableDeclaration variable ) { AbstractVariableDeclaration abstractVariableDeclaration = ( ( AbstractVariableDeclaration ) ( this . newAstToOldAst . get ( variable ) ) ) ; if ( abstractVariableDeclaration instanceof FieldDeclaration ) { <START_BUG> FieldDeclaration fieldDeclaration = ( ( FieldDeclaration ) ( this . newAstToOldAst . get ( variable ) ) ) ; <END_BUG> return this . getVariableBinding ( fieldDeclaration . binding ) ; } return this . getVariableBinding ( ( ( LocalDeclaration ) ( abstractVariableDeclaration ) ) . binding ) ; } IVariableBinding resolveVariable ( FieldDeclaration variable ) { } ITypeBinding resolveExpressionType ( Expression expression ) { } public ASTNode findDeclaringNode ( IBinding binding ) { } void store ( ASTNode node , AstNode oldASTNode ) { } protected ITypeBinding getTypeBinding ( TypeBinding referenceBinding ) { } protected IPackageBinding getPackageBinding ( PackageBinding packageBinding ) { } protected IVariableBinding getVariableBinding ( VariableBinding variableBinding ) { } protected IMethodBinding getMethodBinding ( MethodBinding methodBinding ) { } private BlockScope retrieveEnclosingScope ( ASTNode node ) { } }
public class Starburst extends JDesktopPane { public Random rand = new Random ( ) ; private BufferedImage canvas ; private int [ ] pixels ; public boolean [ ] [ ] current ; public PixelOperationsList operations ; public Pair centerPair ; private PropertyManager propertyManager ; private PropertyTreeNode properties ; public static final ExecutorService exec = Executors . newCachedThreadPool ( ) ; private static final int THREADNUM = ( Runtime . getRuntime ( ) . availableProcessors ( ) ) + 1 ; public static void main ( final String [ ] args ) throws InterruptedException , InvocationTargetException { } private static boolean isInt ( String arg ) { } public void setupKeyAndClickListeners ( JFrame window ) { } public Starburst ( int w , int h ) { } public Starburst ( Dimension size ) { } private void genMany ( String outputDirectory , int howMany ) { } private void saveRandomName ( String outputDirectory ) { } private String randomstr ( int len ) { } private void copyParamsFromFile ( File file ) { } private void save ( File f ) { } public void asyncNewImage ( ) { } public void newImage ( ) { } private void savePixels ( ) { } private void loadPixels ( ) { } @ Override public void paintComponent ( Graphics g ) { } private void setParams ( ) { } private void keyPressed ( char key ) { } private static boolean isNamedAfterAncestor ( File f ) { } private static int p ( int i ) { } private File chooseFile ( int dialogType , int selectionMode ) { } private void mousePressed ( ) { } private void seedImage ( Property < ? extends String > how ) { } private void fillOperations ( ) { for ( int x = 0 ; x < ( current . length ) ; x ++ ) { for ( int y = 0 ; y < ( current [ 0 ] . length ) ; y ++ ) { if ( current [ x ] [ y ] ) { for ( Pair p : getNeighbors ( x , y ) ) { if ( ! ( current [ p . x ] [ p . y ] ) ) <START_BUG> operations . addPoint ( x , y ) ; <END_BUG> } } } } } public int getPixel ( int x , int y ) { } public void setPixel ( int x , int y , int c ) { } private void falsifyCurrent ( ) { } private void fillAllPixels ( ) { } private Iterable < Pair > getNeighbors ( int x , int y ) { } private void fillAll ( ) { } private void finalizePixels ( Property < ? extends String > how ) { } void printloc ( int x , int y ) { } public void fillPixel ( int x , int y ) { } public int getImageWidth ( ) { } public int getImageHeight ( ) { } int biasedRandom ( int minVal , int maxVal , double biastocenter , double biasFactor ) { } }
public class Citadel extends JavaPlugin { private static Logger logger ; private static CitadelReinforcementData db ; private static ReinforcementManager rm ; private CommandHandler cHandle ; private static Citadel instance ; public void onEnable ( ) { Citadel . instance = this ; Citadel . logger = getLogger ( ) ; if ( ! ( Bukkit . getPluginManager ( ) . isPluginEnabled ( "NameLayer" ) ) ) { Citadel . Log ( "Citadel<seq2seq4repair_space>is<seq2seq4repair_space>shutting<seq2seq4repair_space>down<seq2seq4repair_space>because<seq2seq4repair_space>it<seq2seq4repair_space>could<seq2seq4repair_space>not<seq2seq4repair_space>find<seq2seq4repair_space>NameLayer" ) ; this . getPluginLoader ( ) . disablePlugin ( this ) ; } <START_BUG> this . saveDefaultConfig ( ) ; <END_BUG> new CitadelConfigManager ( getConfig ( ) ) ; ReinforcementType . initializeReinforcementTypes ( ) ; NaturalReinforcementType . initializeNaturalReinforcementsTypes ( ) ; NonReinforceableType . initializeNonReinforceableTypes ( ) ; initializeDatabase ( ) ; Citadel . rm = new ReinforcementManager ( Citadel . db ) ; registerListeners ( ) ; registerCommands ( ) ; } public void onDisable ( ) { } public void initializeDatabase ( ) { } private void registerListeners ( ) { } private void registerCommands ( ) { } public static void Log ( String message ) { } public static ReinforcementManager getReinforcementManager ( ) { } public static Citadel getInstance ( ) { } public static CitadelReinforcementData getCitadelDatabase ( ) { } public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) { } }
public class PageInstanceMapper extends AbstractComponentMapper { public PageInstanceMapper ( ) { } public IRequestHandler mapRequest ( Request request ) { } public Url mapHandler ( IRequestHandler requestHandler ) { PageComponentInfo info = null ; if ( requestHandler instanceof RenderPageRequestHandler ) { IRequestablePage page = ( ( RenderPageRequestHandler ) ( requestHandler ) ) . getPage ( ) ; PageInfo i = new PageInfo ( page . getPageId ( ) ) ; info = new PageComponentInfo ( i , null ) ; } else if ( requestHandler instanceof ListenerInterfaceRequestHandler ) { ListenerInterfaceRequestHandler handler = ( ( ListenerInterfaceRequestHandler ) ( requestHandler ) ) ; IRequestablePage page = handler . getPage ( ) ; <START_BUG> String componentPath = handler . getComponent ( ) . getPageRelativePath ( ) ; <END_BUG> RequestListenerInterface listenerInterface = handler . getListenerInterface ( ) ; Integer renderCount = null ; if ( listenerInterface . isIncludeRenderCount ( ) ) { renderCount = page . getRenderCount ( ) ; } PageInfo pageInfo = new PageInfo ( page . getPageId ( ) ) ; ComponentInfo componentInfo = new ComponentInfo ( renderCount , requestListenerInterfaceToString ( listenerInterface ) , componentPath , handler . getBehaviorIndex ( ) ) ; info = new PageComponentInfo ( pageInfo , componentInfo ) ; } if ( info != null ) { Url url = new Url ( ) ; url . getSegments ( ) . add ( getContext ( ) . getNamespace ( ) ) ; url . getSegments ( ) . add ( getContext ( ) . getPageIdentifier ( ) ) ; encodePageComponentInfo ( url , info ) ; return url ; } else { return null ; } } public int getCompatibilityScore ( Request request ) { } }
public class TabList18 extends CustomTabList18 implements IMyTabListHandler { private static String getSlotID ( int n ) { } private final int [ ] slots_ping = new int [ ConfigManager . getTabSize ( ) ] ; private int sendSlots = 0 ; private final String [ ] send = new String [ ConfigManager . getTabSize ( ) ] ; private final String [ ] sendTextures = new String [ ConfigManager . getTabSize ( ) ] ; public TabList18 ( ProxiedPlayer player ) { } @ Override public void recreate ( ) { } private void resize ( int size ) { } private void removeSlot ( int i ) { } private void updateSlot ( int row , String text , int ping , String [ ] textures ) { } private void createSlot ( int row ) { PlayerListItem pli = new PlayerListItem ( ) ; pli . setAction ( ADD_PLAYER ) ; Item item = new Item ( ) ; UUID offlineId = UUID . nameUUIDFromBytes ( ( "OfflinePlayer:" + ( TabList18 . getSlotID ( row ) ) ) . getBytes ( Charsets . UTF_8 ) ) ; item . setUuid ( offlineId ) ; item . setDisplayName ( "<seq2seq4repair_space>" ) ; item . setGamemode ( 0 ) ; item . setPing ( 0 ) ; item . setUsername ( TabList18 . getSlotID ( row ) ) ; item . setProperties ( new String [ 0 ] [ 0 ] ) ; pli . setItems ( new Item [ ] { item } ) ; getPlayer ( ) . unsafe ( ) . sendPacket ( pli ) ; <START_BUG> send [ row ] = "<seq2seq4repair_space>" ; <END_BUG> slots_ping [ row ] = 0 ; sendTextures [ row ] = null ; } public void unload ( ) { } No newline ; at end ; of file ; }
public class MultiPassIndexSplitter { public void split ( Version version , IndexReader in , Directory [ ] outputs , boolean seq ) throws IOException { if ( ( outputs == null ) || ( ( outputs . length ) < 2 ) ) { throw new IOException ( "Invalid<seq2seq4repair_space>number<seq2seq4repair_space>of<seq2seq4repair_space>outputs." ) ; } if ( ( in == null ) || ( ( in . numDocs ( ) ) < 2 ) ) { throw new IOException ( "Not<seq2seq4repair_space>enough<seq2seq4repair_space>documents<seq2seq4repair_space>for<seq2seq4repair_space>splitting" ) ; } int numParts = outputs . length ; MultiPassIndexSplitter . FakeDeleteIndexReader input = new MultiPassIndexSplitter . FakeDeleteIndexReader ( in ) ; int maxDoc = input . maxDoc ( ) ; int partLen = maxDoc / numParts ; for ( int i = 0 ; i < numParts ; i ++ ) { input . undeleteAll ( ) ; if ( seq ) { int lo = partLen * i ; int hi = lo + partLen ; for ( int j = 0 ; j < lo ; j ++ ) { input . deleteDocument ( j ) ; } if ( i < ( numParts - 1 ) ) { for ( int j = hi ; j < maxDoc ; j ++ ) { input . deleteDocument ( j ) ; } } } else { for ( int j = 0 ; j < maxDoc ; j ++ ) { if ( ( ( ( j + numParts ) - i ) % numParts ) != 0 ) { input . deleteDocument ( j ) ; } } } IndexWriter w = new IndexWriter ( outputs [ i ] , new IndexWriterConfig ( version , null ) . setOpenMode ( CREATE ) ) ; System . err . println ( ( ( "Writing<seq2seq4repair_space>part<seq2seq4repair_space>" + ( i + 1 ) ) + "<seq2seq4repair_space>..." ) ) ; final List < ? extends MultiPassIndexSplitter . FakeDeleteAtomicIndexReader > sr = input . getSequentialSubReaders ( ) ; w . addIndexes ( sr . toArray ( new IndexReader [ sr . size ( ) ] ) ) ; <START_BUG> w . close ( ) ; <END_BUG> } System . err . println ( "Done." ) ; } @ SuppressWarnings ( "deprecation" ) public static void main ( String [ ] args ) throws Exception { } private static final class FakeDeleteIndexReader extends BaseCompositeReader < MultiPassIndexSplitter . FakeDeleteAtomicIndexReader > { public FakeDeleteIndexReader ( IndexReader reader ) { } private static MultiPassIndexSplitter . FakeDeleteAtomicIndexReader [ ] initSubReaders ( IndexReader reader ) { } public void deleteDocument ( int docID ) { } public void undeleteAll ( ) { } @ Override protected void doClose ( ) { } } private static final class FakeDeleteAtomicIndexReader extends FilterAtomicReader { FixedBitSet liveDocs ; public FakeDeleteAtomicIndexReader ( AtomicReader reader ) { } @ Override public int numDocs ( ) { } public void undeleteAll ( ) { } public void deleteDocument ( int n ) { } @ Override public Bits getLiveDocs ( ) { } } }
@ Entity @ Table ( name = "EMP_MBI" ) @ IdClass ( EmpId . class ) public class Employee { @ Id int empId ; @ Id @ Enumerated Employee . EmpType empType ; @ OneToOne PhoneNumber phoneNumber ; public PhoneNumber getPhoneNumber ( ) { } public void setPhoneNumber ( PhoneNumber phoneNumber ) { } public int getEmpId ( ) { } public void setEmpId ( int empId ) { } public Employee . EmpType getEmpType ( ) { } public void setEmpType ( Employee . EmpType empType ) { } public boolean equals ( Object o ) { Employee e = ( ( Employee ) ( o ) ) ; PhoneNumber p = e . getPhoneNumber ( ) ; <START_BUG> if ( ( p . getNumber ( ) ) != ( phoneNumber . getNumber ( ) ) ) <END_BUG> return false ; return true ; } public enum EmpType { A1 , A2 , A3 , A4 ; } }
public class TaintMethodSummaryMap extends HashMap < String , TaintMethodSummary > { private static final long serialVersionUID = 1L ; public void load ( InputStream input ) throws IOException { <START_BUG> BufferedReader reader = new BufferedReader ( new InputStreamReader ( input ) ) ; <END_BUG> for ( ; ; ) { String line = reader . readLine ( ) ; if ( line == null ) { break ; } line = line . trim ( ) ; if ( line . isEmpty ( ) ) { continue ; } putFromLine ( line ) ; } } public void dump ( PrintStream output ) { } private void putFromLine ( String line ) throws IOException { } }
public class Room implements Serializable { private static final long serialVersionUID = - 6795914098104059358L ; private static int roomIdCounter = 0 ; private int roomId ; private RoomType roomtype ; private int price ; private int hotelId ; private SortedSet < Calendar > occupiedDates ; private Map < Calendar , Calendar > checkInCheckOutPairs ; public Room ( RoomType roomType , int price , int hotelId ) { } public void bookRoom ( Calendar checkIn , Calendar checkout ) { int daysBetween = ( ( int ) ( ( checkout . getTimeInMillis ( ) ) - ( checkIn . getTimeInMillis ( ) ) ) ) / ( ( ( 1000 * 60 ) * 60 ) * 24 ) ; <START_BUG> for ( int i = 0 ; i < ( daysBetween - 1 ) ; i ++ ) { <END_BUG> servers . misc . Calendar addDate = ( ( servers . misc . Calendar ) ( checkIn . clone ( ) ) ) ; addDate . add ( DAY_OF_MONTH , i ) ; occupiedDates . add ( addDate ) ; } checkInCheckOutPairs . put ( checkIn , checkout ) ; } public boolean roomIsAvailable ( Calendar checkIn , Calendar checkout ) { } public Calendar getCheckoutDate ( Calendar checkin ) { } @ Override public boolean equals ( Object obj ) { } public int getRoomId ( ) { } public void cancel ( Calendar checkIn , Calendar checkOut ) { } public boolean hasCheckout ( Calendar date ) { } public RoomType getRoomType ( ) { } public String getStatusOnDate ( Calendar date ) { } }
public class GamePanel extends JPanel { private int setSize ; private int myID ; private int gameID ; private PlayerPanel players = new PlayerPanel ( ) ; private ChatPanel chat ; private JPanel buttons = new JPanel ( ) ; private CardGrid grid ; public JButton logoutButton = new JButton ( "Logout" ) ; public JButton setButton = new JButton ( "<html>&nbsp;<br>SET<br>&nbsp;</html>" ) ; public JButton quitButton = new JButton ( "Quit" ) ; private ClientConnection connection ; private Timer t = new Timer ( 1 , null ) ; private int timer ; public int colorIndex = 0 ; private Color [ ] colors = new Color [ ] { Color . blue , Color . red , Color . green , Color . orange , Color . magenta , Color . gray , Color . pink , Color . yellow , Color . cyan } ; public GamePanel ( int playerID , int setSize , ClientConnection connection ) { } private void buildGameGUI ( ) { } public void blockTimer ( final int time ) { } private void setTimer ( final int time ) { } private void addGameButtons ( ) { } private void submitSet ( ) { } public void addTestButton ( JButton b ) { } public void setGameID ( int gid ) { } public void setSelectionColor ( Color c ) { } public void setPlayerColor ( ) { } public void unblockButton ( ) { } public void showNotification ( String message , Icon icon , boolean hasIcon ) { WebNotificationPopup notify = new WebNotificationPopup ( ) ; notify . setDisplayTime ( 3000 ) ; notify . setContent ( message ) ; if ( hasIcon && ( icon != null ) ) <START_BUG> notify . setIcon ( players . getIcon ( 1 ) ) ; <END_BUG> NotificationManager . showNotification ( notify ) ; } public void addCard ( int id ) { } public void addPlayer ( int id , String name , int score , int rating ) { } public void removePlayer ( int id ) { } public void increaseScore ( int id ) { } public void decreaseScore ( int id ) { } public CardGrid getCards ( ) { } public PlayerPanel getPlayers ( ) { } public ChatPanel getChat ( ) { } public void clearGrid ( ) { } No newline ; at end ; of file ; }
public final class GuiPackage implements LocaleChangeListener { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static GuiPackage guiPack ; private boolean dirty = false ; private Map < TestElement , JMeterGUIComponent > nodesToGui = new HashMap < TestElement , JMeterGUIComponent > ( ) ; private Map < Class < ? > , JMeterGUIComponent > guis = new HashMap < Class < ? > , JMeterGUIComponent > ( ) ; private Map < Class < ? > , JMeterGUIComponent > testBeanGUIs = new HashMap < Class < ? > , JMeterGUIComponent > ( ) ; private JMeterTreeNode currentNode = null ; private boolean currentNodeUpdated = false ; private final JMeterTreeModel treeModel ; private final JMeterTreeListener treeListener ; private MainFrame mainFrame ; private JToolBar toolbar ; private JCheckBoxMenuItem menuToolBar ; private JCheckBoxMenuItem menuItemLoggerPanel ; private LoggerPanel loggerPanel ; private GuiPackage ( JMeterTreeModel treeModel , JMeterTreeListener treeListener ) { } public static GuiPackage getInstance ( ) { } public static GuiPackage getInstance ( JMeterTreeListener listener , JMeterTreeModel treeModel ) { } public JMeterGUIComponent getGui ( TestElement node ) { } public JMeterGUIComponent getGui ( TestElement node , Class < ? > guiClass , Class < ? > testClass ) { } public void removeNode ( TestElement node ) { } public JMeterGUIComponent getCurrentGui ( ) { } public JMeterTreeNode getNodeOf ( TestElement userObject ) { } public TestElement createTestElement ( Class < ? > guiClass , Class < ? > testClass ) { } public TestElement createTestElement ( String objClass ) { } private JMeterGUIComponent getGuiFromCache ( Class < ? > guiClass , Class < ? > testClass ) throws IllegalAccessException , InstantiationException { } public void updateCurrentGui ( ) { } public void updateCurrentNode ( ) { } public JMeterTreeNode getCurrentNode ( ) { } public TestElement getCurrentElement ( ) { } public void setDirty ( boolean dirty ) { } public boolean isDirty ( ) { } public HashTree addSubTree ( HashTree subTree ) throws IllegalUserActionException { } public HashTree getCurrentSubTree ( ) { } public JMeterTreeModel getTreeModel ( ) { } public ValueReplacer getReplacer ( ) { } public void setMainFrame ( MainFrame newMainFrame ) { } public MainFrame getMainFrame ( ) { } public JMeterTreeListener getTreeListener ( ) { } public void setMainToolbar ( JToolBar newToolbar ) { } public JToolBar getMainToolbar ( ) { } public void setMenuItemToolbar ( JCheckBoxMenuItem newMenuToolBar ) { } public JCheckBoxMenuItem getMenuItemToolbar ( ) { } public void displayPopUp ( MouseEvent e , JPopupMenu popup ) { } public void displayPopUp ( Component invoker , MouseEvent e , JPopupMenu popup ) { if ( popup != null ) { GuiPackage . log . debug ( ( ( ( ( ( "Showing<seq2seq4repair_space>pop<seq2seq4repair_space>up<seq2seq4repair_space>for<seq2seq4repair_space>" + invoker ) + "<seq2seq4repair_space>at<seq2seq4repair_space>x,y<seq2seq4repair_space>=<seq2seq4repair_space>" ) + ( e . getX ( ) ) ) + "," ) + ( e . getY ( ) ) ) ) ; popup . pack ( ) ; popup . show ( invoker , e . getX ( ) , e . getY ( ) ) ; popup . setVisible ( true ) ; <START_BUG> popup . requestFocus ( ) ; <END_BUG> } } @ Override public void localeChanged ( LocaleChangeEvent event ) { } private String testPlanFile ; private final List < Stoppable > stoppables = Collections . synchronizedList ( new ArrayList < Stoppable > ( ) ) ; public void setTestPlanFile ( String f ) { } public String getTestPlanFile ( ) { } public void clearTestPlan ( ) { } public void clearTestPlan ( TestElement element ) { } public static void showErrorMessage ( final String message , final String title ) { } public static void showInfoMessage ( final String message , final String title ) { } public static void showWarningMessage ( final String message , final String title ) { } public static void showMessage ( final String message , final String title , final int type ) { } public void unregister ( Stoppable stoppable ) { } public void register ( Stoppable stoppable ) { } public List < Stoppable > getStoppables ( ) { } public void setMenuItemLoggerPanel ( JCheckBoxMenuItem menuItemLoggerPanel ) { } public JCheckBoxMenuItem getMenuItemLoggerPanel ( ) { } public void setLoggerPanel ( LoggerPanel loggerPanel ) { } public LoggerPanel getLoggerPanel ( ) { } }
public class MenuActionEngine extends ActionEngine { private int menuBusyTimer = 0 ; private int menuBusyTime = 10 ; private MenuHandlerData menuHandlerData ; public MenuActionEngine ( InputListenerAggregator listener , MenuHandlerData menuHandlerData ) { } public void activateActiveMenuSelection ( ) { if ( ! ( isBusy ( ) ) ) { Menu menu = menuHandlerData . getTopActiveMenu ( ) ; <START_BUG> menu . activateSelection ( ) ; <END_BUG> } } public void openMenu ( Menu menu ) throws SlickException { } private void makeBusy ( ) { } public void closeAllMenus ( ) { } public void update ( ) { } private void updateBusyTimer ( ) { } private boolean isBusy ( ) { } public void changeActiveTextLine ( char xOrY , int direction ) { } public void setQuitting ( ) { } public void closeTopActiveMenu ( ) { } public void toggleMenu ( Menu menu ) throws SlickException { } }
public class AccountsAdapter extends ArrayAdapter < Account > { private final Customer customer ; public AccountsAdapter ( Context context , Customer customer , List < Account > accounts ) { } private static class ViewHolder { final TextView tvAccountInfo ; ViewHolder ( TextView tvAccountInfo ) { } } @ Override public View getView ( int position , View convertView , ViewGroup parent ) { Account account = getItem ( position ) ; AccountsAdapter . ViewHolder holder = null ; View view = convertView ; view = LayoutInflater . from ( getContext ( ) ) . inflate ( account_list_item_layout , null ) ; TextView tvAccountInfo = ( ( TextView ) ( view . findViewById ( tvAccountInfo ) ) ) ; view . setTag ( new AccountsAdapter . ViewHolder ( tvAccountInfo ) ) ; Object tag = view . getTag ( ) ; if ( tag instanceof AccountsAdapter . ViewHolder ) { holder = ( ( AccountsAdapter . ViewHolder ) ( tag ) ) ; } if ( ( account != null ) && ( holder != null ) ) { if ( ( holder . tvAccountInfo ) != null ) { SpannableStringBuilder builder = new SpannableStringBuilder ( ) ; String temp ; SpannableString text ; <START_BUG> temp = Long . toString ( account . getCustomerId ( ) ) ; <END_BUG> text = new SpannableString ( temp ) ; text . setSpan ( new android . text . style . ForegroundColorSpan ( getContext ( ) . getResources ( ) . getColor ( black ) ) , 0 , text . length ( ) , SPAN_EXCLUSIVE_EXCLUSIVE ) ; builder . append ( text ) ; temp = "<seq2seq4repair_space>[<seq2seq4repair_space>" ; text = new SpannableString ( temp ) ; text . setSpan ( new android . text . style . ForegroundColorSpan ( getContext ( ) . getResources ( ) . getColor ( white ) ) , 0 , text . length ( ) , SPAN_EXCLUSIVE_EXCLUSIVE ) ; builder . append ( text ) ; temp = account . getType ( ) ; text = new SpannableString ( temp ) ; text . setSpan ( new android . text . style . ForegroundColorSpan ( getContext ( ) . getResources ( ) . getColor ( black ) ) , 0 , text . length ( ) , SPAN_EXCLUSIVE_EXCLUSIVE ) ; builder . append ( text ) ; temp = "<seq2seq4repair_space>]<seq2seq4repair_space>" ; text = new SpannableString ( temp ) ; text . setSpan ( new android . text . style . ForegroundColorSpan ( getContext ( ) . getResources ( ) . getColor ( white ) ) , 0 , text . length ( ) , SPAN_EXCLUSIVE_EXCLUSIVE ) ; builder . append ( text ) ; temp = account . getBalance ( ) ; text = new SpannableString ( temp ) ; text . setSpan ( new android . text . style . ForegroundColorSpan ( getContext ( ) . getResources ( ) . getColor ( black ) ) , 0 , text . length ( ) , SPAN_EXCLUSIVE_EXCLUSIVE ) ; builder . append ( text ) ; holder . tvAccountInfo . setText ( builder ) ; } } return view ; } }
public class DebugComponent extends SearchComponent { public static final String COMPONENT_NAME = "debug" ; @ Override public void prepare ( ResponseBuilder rb ) throws IOException { } @ SuppressWarnings ( "unchecked" ) @ Override public void process ( ResponseBuilder rb ) throws IOException { } public void modifyRequest ( ResponseBuilder rb , SearchComponent who , ShardRequest sreq ) { } @ Override public void handleResponses ( ResponseBuilder rb , ShardRequest sreq ) { } private Set < String > excludeSet = new HashSet < String > ( Arrays . asList ( "explain" ) ) ; @ Override public void finishStage ( ResponseBuilder rb ) { if ( ( rb . isDebug ( ) ) && ( ( rb . stage ) == ( ResponseBuilder . STAGE_GET_FIELDS ) ) ) { NamedList info = null ; NamedList explain = new SimpleOrderedMap ( ) ; Object [ ] arr = new Object [ ( rb . resultIds . size ( ) ) * 2 ] ; for ( ShardRequest sreq : rb . finished ) { if ( ( ( sreq . purpose ) & ( ShardRequest . PURPOSE_GET_DEBUG ) ) == 0 ) continue ; for ( ShardResponse srsp : sreq . responses ) { <START_BUG> NamedList sdebug = ( ( NamedList ) ( srsp . rsp . getResponse ( ) . get ( "debug" ) ) ) ; <END_BUG> info = ( ( NamedList ) ( merge ( sdebug , info , excludeSet ) ) ) ; NamedList sexplain = ( ( NamedList ) ( sdebug . get ( "explain" ) ) ) ; for ( int i = 0 ; i < ( sexplain . size ( ) ) ; i ++ ) { String id = sexplain . getName ( i ) ; ShardDoc sdoc = rb . resultIds . get ( id ) ; int idx = sdoc . positionInResponse ; arr [ ( idx << 1 ) ] = id ; arr [ ( ( idx << 1 ) + 1 ) ] = sexplain . getVal ( i ) ; } } } explain = HighlightComponent . removeNulls ( new SimpleOrderedMap ( Arrays . asList ( arr ) ) ) ; if ( info == null ) { info = new SimpleOrderedMap ( ) ; } int idx = info . indexOf ( "explain" , 0 ) ; if ( idx >= 0 ) { info . setVal ( idx , explain ) ; } else { info . add ( "explain" , explain ) ; } rb . setDebugInfo ( info ) ; rb . rsp . add ( "debug" , rb . getDebugInfo ( ) ) ; } } Object merge ( Object source , Object dest , Set < String > exclude ) { } @ Override public String getDescription ( ) { } @ Override public String getVersion ( ) { } @ Override public String getSourceId ( ) { } @ Override public String getSource ( ) { } @ Override public URL [ ] getDocs ( ) { } }
public class closed implements Runnable { private static boolean jsr169_test = false ; public static void main ( String [ ] args ) { } static boolean shutdownTest ( String databaseName , String shutdownString ) throws SQLException { } private Connection cc ; private String sql ; String result ; private closed ( Connection cc , String sql ) { } public void run ( ) { try { cc . createStatement ( ) . execute ( sql ) ; result = "Sleep<seq2seq4repair_space>thread<seq2seq4repair_space>completed<seq2seq4repair_space>" + ( sql ) ; } catch ( SQLException sqle ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( sql ) ; sb . append ( "<seq2seq4repair_space>-<seq2seq4repair_space>" ) ; sb . append ( sqle . getSQLState ( ) ) ; while ( sqle != null ) { if ( sqle != null ) { sb . append ( ",<seq2seq4repair_space>" ) ; sb . append ( sqle . getSQLState ( ) ) ; sb . append ( "<seq2seq4repair_space>--<seq2seq4repair_space>" ) ; if ( ( sqle . getMessage ( ) . indexOf ( "InterruptedException" ) ) != ( - 1 ) ) sb . append ( "InterruptedException" ) ; else { sb . append ( sqle . getMessage ( ) ) ; <START_BUG> sqle . printStackTrace ( ) ; <END_BUG> } } else { sb . append ( sqle . getMessage ( ) ) ; } sqle = sqle . getNextException ( ) ; } result = sb . toString ( ) ; } } static boolean testStatement ( Connection conn ) throws SQLException { } static boolean testPreparedStatement ( Connection conn ) throws SQLException { } static boolean testResultSet ( Connection conn ) throws SQLException { } static boolean testConnection ( Connection conn ) throws SQLException { } static boolean testDerby62 ( Connection conn ) throws SQLException { } }
public class AlignmentUtils { public static class MismatchCount { public int numMismatches = 0 ; public long mismatchQualities = 0 ; } public static long mismatchingQualities ( SAMRecord r , byte [ ] refSeq , int refIndex ) { } public static AlignmentUtils . MismatchCount getMismatchCount ( SAMRecord r , byte [ ] refSeq , int refIndex ) { } public static AlignmentUtils . MismatchCount getMismatchCount ( SAMRecord r , byte [ ] refSeq , int refIndex , int startOnRead , int nReadBases ) { } public static int mismatchesInRefWindow ( ReadBackedPileup pileup , ReferenceContext ref , boolean ignoreTargetSite ) { } public static int mismatchesInRefWindow ( PileupElement p , ReferenceContext ref , boolean ignoreTargetSite ) { } public static int mismatchesInRefWindow ( PileupElement p , ReferenceContext ref , boolean ignoreTargetSite , boolean qualitySumInsteadOfMismatchCount ) { } public static BitSet mismatchesInRefWindow ( SAMRecord read , ReferenceContext ref , int maxMismatches , int windowSize ) { } public static int getNumAlignmentBlocks ( final SAMRecord r ) { } public static int getNumAlignedBases ( final SAMRecord r ) { } public static byte [ ] alignmentToByteArray ( final Cigar cigar , final byte [ ] read , final byte [ ] ref ) { final byte [ ] alignment = new byte [ read . length ] ; int refPos = 0 ; int alignPos = 0 ; for ( int iii = 0 ; iii < ( cigar . numCigarElements ( ) ) ; iii ++ ) { final CigarElement ce = cigar . getCigarElement ( iii ) ; final int elementLength = ce . getLength ( ) ; switch ( ce . getOperator ( ) ) { case I : case S : for ( int jjj = 0 ; jjj < elementLength ; jjj ++ ) { alignment [ ( alignPos ++ ) ] = '+' ; } break ; case D : case N : <START_BUG> refPos ++ ; <END_BUG> break ; case M : for ( int jjj = 0 ; jjj < elementLength ; jjj ++ ) { alignment [ alignPos ] = ref [ refPos ] ; alignPos ++ ; refPos ++ ; } break ; case H : case P : break ; default : throw new org . broadinstitute . sting . utils . exceptions . ReviewedStingException ( ( "Unsupported<seq2seq4repair_space>cigar<seq2seq4repair_space>operator:<seq2seq4repair_space>" + ( ce . getOperator ( ) ) ) ) ; } } return alignment ; } public static int calcAlignmentByteArrayOffset ( final Cigar cigar , int pileupOffset , final int alignmentStart , final int refLocus ) { } public static byte [ ] readToAlignmentByteArray ( final Cigar cigar , final byte [ ] read ) { } public static boolean isReadUnmapped ( final SAMRecord r ) { } public static boolean isMateUnmapped ( final SAMRecord r ) { } public static boolean isReadUniquelyMapped ( SAMRecord read ) { } public static byte [ ] getQualsInCycleOrder ( SAMRecord read ) { } public static byte [ ] getOriginalQualsInCycleOrder ( SAMRecord read ) { } public static Cigar leftAlignIndel ( Cigar cigar , final byte [ ] refSeq , final byte [ ] readSeq , final int refIndex , final int readIndex ) { } private static boolean cigarHasZeroSizeElement ( Cigar c ) { } private static Cigar cleanUpCigar ( Cigar c ) { } private static Cigar moveCigarLeft ( Cigar cigar , int indexOfIndel ) { } private static byte [ ] createIndelString ( final Cigar cigar , final int indexOfIndel , final byte [ ] refSeq , final byte [ ] readSeq , int refIndex , int readIndex ) { } }
public class WeaponExpandableListBladeAdapter extends WeaponExpandableListElementAdapter { public WeaponExpandableListBladeAdapter ( Context context , View . OnLongClickListener listener ) { } @ Override public ViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { } private static class WeaponBladeViewHolder extends WeaponElementViewHolder { TextView specialView ; DrawSharpness sharpnessDrawable ; ImageView note1v ; ImageView note2v ; ImageView note3v ; public WeaponBladeViewHolder ( View weaponView ) { } } @ Override public void onBindViewHolder ( RecyclerView . ViewHolder viewHolder , int position ) { super . onBindViewHolder ( viewHolder , position ) ; WeaponExpandableListBladeAdapter . WeaponBladeViewHolder holder = ( ( WeaponExpandableListBladeAdapter . WeaponBladeViewHolder ) ( viewHolder ) ) ; Weapon weapon = ( ( WeaponListEntry ) ( getItemAt ( position ) ) ) . weapon ; String type = weapon . getWtype ( ) ; if ( type . equals ( "Hunting<seq2seq4repair_space>Horn" ) ) { String special = weapon . getHornNotes ( ) ; holder . note1v . setTag ( weapon . getId ( ) ) ; holder . note2v . setTag ( weapon . getId ( ) ) ; holder . note3v . setTag ( weapon . getId ( ) ) ; holder . note1v . setVisibility ( VISIBLE ) ; holder . note2v . setVisibility ( VISIBLE ) ; holder . note3v . setVisibility ( VISIBLE ) ; holder . specialView . setVisibility ( VISIBLE ) ; holder . specialView . setText ( "NOTES:<seq2seq4repair_space>" ) ; final Bitmap bitmap = getBitmapFromMemCache ( getNoteDrawable ( special . charAt ( 0 ) ) ) ; if ( bitmap != null ) { holder . note1v . setImageBitmap ( bitmap ) ; } else { new LoadImage ( holder . note1v , getNoteDrawable ( special . charAt ( 0 ) ) ) . execute ( ) ; } final Bitmap bitmap2 = getBitmapFromMemCache ( getNoteDrawable ( special . charAt ( 1 ) ) ) ; if ( bitmap2 != null ) { holder . note2v . setImageBitmap ( bitmap2 ) ; } else { <START_BUG> new LoadImage ( holder . note1v , getNoteDrawable ( special . charAt ( 1 ) ) ) . execute ( ) ; <END_BUG> } final Bitmap bitmap3 = getBitmapFromMemCache ( getNoteDrawable ( special . charAt ( 2 ) ) ) ; if ( bitmap3 != null ) { holder . note3v . setImageBitmap ( bitmap3 ) ; } else { new LoadImage ( holder . note3v , getNoteDrawable ( special . charAt ( 2 ) ) ) . execute ( ) ; } } else if ( type . equals ( "Gunlance" ) ) { holder . specialView . setVisibility ( VISIBLE ) ; String special = weapon . getShellingType ( ) ; holder . specialView . setText ( special ) ; } else if ( ( type . equals ( "Switch<seq2seq4repair_space>Axe" ) ) || ( type . equals ( "Charge<seq2seq4repair_space>Blade" ) ) ) { holder . specialView . setVisibility ( VISIBLE ) ; String special = weapon . getPhial ( ) ; holder . specialView . setText ( special ) ; } holder . sharpnessDrawable . init ( weapon . getSharpness1 ( ) , weapon . getSharpness2 ( ) ) ; holder . sharpnessDrawable . invalidate ( ) ; } private String getNoteDrawable ( char note ) { } }
public class UnitRenderer implements IMoveListener { private UnitMoveExecutor moveExecutor ; private IBoard board ; private ICameraController cameraController ; private ArrayList < UnitRenderModel > renderModels ; private IRenderBuilding renderBuilding = RenderBuilding . getInstance ( ) ; private HashMap < Position , IRenderObject > unitPositionsAndRenderObjects ; private Queue < Move > currentAnimations = new LinkedList < Move > ( ) ; private boolean animationIsActive = false ; private boolean iAmPlayer1 ; public UnitRenderer ( IBoard board , ICameraController cameraController , boolean iAmPlayer1 ) { } public void setupUnitRenderer ( ) { } public void update ( float dt ) { } public void render ( SpriteBatch batch ) { } @ Override public void moveExecuted ( Move move ) { } private void executeMove ( Move move ) { animationIsActive = true ; Position startPos = move . getStartCell ( ) . getPos ( ) ; Position endPos = move . getTargetCell ( ) . getPos ( ) ; cameraController . makeSureVisible ( startPos , endPos ) ; if ( ( ( endPos . getX ( ) ) < ( startPos . getPos ( ) . getX ( ) ) ) && ( unitPositionsAndRenderObjects . get ( startPos ) . getRenderModel ( ) . isTurnedRight ( ) ) ) { unitPositionsAndRenderObjects . get ( startPos ) . getRenderModel ( ) . turnDirection ( ) ; } else if ( ( ( endPos . getX ( ) ) >= ( startPos . getX ( ) ) ) && ( ! ( unitPositionsAndRenderObjects . get ( startPos ) . getRenderModel ( ) . isTurnedRight ( ) ) ) ) <START_BUG> unitPositionsAndRenderObjects . get ( endPos ) . getRenderModel ( ) . turnDirection ( ) ; <END_BUG> if ( move instanceof AttackMove ) { IRenderObject attacker = unitPositionsAndRenderObjects . get ( startPos ) ; ArrayList < IRenderObject > victims = getVictims ( ( ( AttackMove ) ( move ) ) ) ; moveExecutor . attackMove ( attacker , victims ) ; } else if ( move instanceof MovementMove ) { IRenderObject mover = unitPositionsAndRenderObjects . get ( startPos ) ; unitPositionsAndRenderObjects . remove ( startPos ) ; moveExecutor . movementMove ( mover , ( ( MovementMove ) ( move ) ) ) ; } } public boolean noAnimationWaiting ( ) { } public void movementMoveComplete ( IRenderObject currentActor , Position endPos ) { } public void attackMoveFinished ( ) { } private ArrayList < IRenderObject > getVictims ( AttackMove move ) { } }
public abstract class AbstractType implements Comparator < byte [ ] > { public abstract String getString ( byte [ ] bytes ) { } public void validate ( byte [ ] bytes ) { } public Comparator < byte [ ] > getReverseComparator ( ) { } public String getString ( Collection < byte [ ] > names ) { } public String getColumnsString ( Collection < IColumn > columns ) { StringBuilder builder = new StringBuilder ( ) ; for ( IColumn column : columns ) { <START_BUG> builder . append ( getString ( column . name ( ) ) ) . append ( "," ) ; <END_BUG> } return builder . toString ( ) ; } }
public class ActionAddOperation extends UMLChangeAction { public static ActionAddOperation SINGLETON = new ActionAddOperation ( ) ; public ActionAddOperation ( ) { } public void actionPerformed ( ActionEvent ae ) { ProjectBrowser pb = ProjectBrowser . getInstance ( ) ; Project p = ProjectManager . getManager ( ) . getCurrentProject ( ) ; Object target = TargetManager . getInstance ( ) . getModelTarget ( ) ; if ( ! ( target instanceof MClassifier ) ) return ; MClassifier cls = ( ( MClassifier ) ( target ) ) ; MOperation oper = UmlFactory . getFactory ( ) . getCore ( ) . buildOperation ( cls ) ; <START_BUG> pb . setTarget ( oper ) ; <END_BUG> Iterator it = pb . getEditorPane ( ) . findPresentationsFor ( cls , p . getDiagrams ( ) ) . iterator ( ) ; while ( it . hasNext ( ) ) { MElementListener listener = ( ( MElementListener ) ( it . next ( ) ) ) ; UmlModelEventPump . getPump ( ) . removeModelEventListener ( listener , oper ) ; UmlModelEventPump . getPump ( ) . addModelEventListener ( listener , oper ) ; } super . actionPerformed ( ae ) ; } public boolean shouldBeEnabled ( ) { } }
public abstract class AbstractDefinition extends SyntaxElement implements XpandDefinition { private Template owner = null ; private DeclaredParameter [ ] params ; private Identifier name ; private Identifier type ; private Statement [ ] body ; protected String _stringRepresentation = null ; protected boolean wildParams = false ; public AbstractDefinition ( final Identifier name , final Identifier type , final DeclaredParameter [ ] params , final Statement [ ] body ) { } public XpandResource getOwner ( ) { } public void setOwner ( final Template owner ) { } public DeclaredParameter [ ] getParams ( ) { } public List < DeclaredParameter > getParamsAsList ( ) { } public Identifier getType ( ) { } public String getTargetType ( ) { } public Identifier getDefName ( ) { } public String getName ( ) { } public String getQualifiedName ( ) { } public String getParamString ( boolean typesOnly ) { if ( ( ( params ) == null ) || ( ( params . length ) == 0 ) ) return wildParams ? "(*)" : "" ; <START_BUG> final StringBuffer buff = new StringBuffer ( "(" ) ; <END_BUG> for ( int i = 0 ; i < ( params . length ) ; i ++ ) { final DeclaredParameter p = params [ i ] ; buff . append ( p . getType ( ) . getValue ( ) ) ; if ( ! typesOnly ) { buff . append ( "<seq2seq4repair_space>" ) . append ( p . getName ( ) . getValue ( ) ) ; } if ( ( i + 1 ) < ( params . length ) ) { buff . append ( "," ) ; } } if ( wildParams ) { buff . append ( ",*" ) ; } return buff . append ( ")" ) . toString ( ) ; } public Statement [ ] getBody ( ) { } public List < Statement > getBodyAsList ( ) { } public void analyze ( XpandExecutionContext ctx , final Set < AnalysationIssue > issues ) { } public void evaluate ( XpandExecutionContext ctx , Object _this , Object ... params ) { } protected XpandExecutionContext prepareDeclaredParameters ( Object _this , XpandExecutionContext context , Object ... params ) { } @ Override public String toString ( ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( Object obj ) { } }
public class ConfigurationTest extends AbstractTasklet implements Configurable { protected String m_message ; public void configure ( final Configuration configuration ) throws ConfigurationException { } public void run ( ) throws AntException { <START_BUG> getLogger ( ) . info ( m_message ) ; <END_BUG> } }
public class CheckForNewMessagesCommand extends FolderCommand { FolderCommandAdapter adapter ; IMAPFolder inboxFolder ; boolean needGUIUpdate ; public CheckForNewMessagesCommand ( DefaultCommandReference [ ] references ) { } public CheckForNewMessagesCommand ( AbstractFrameController frame , DefaultCommandReference [ ] references ) { } public void execute ( Worker worker ) throws Exception { FolderCommandReference [ ] references = ( ( FolderCommandReference [ ] ) ( getReferences ( ) ) ) ; adapter = new FolderCommandAdapter ( references ) ; FolderCommandReference [ ] r = adapter . getSourceFolderReferences ( ) ; IMAPRootFolder srcFolder = ( ( IMAPRootFolder ) ( r [ 0 ] . getFolder ( ) ) ) ; ( ( StatusObservableImpl ) ( srcFolder . getObservable ( ) ) ) . setWorker ( worker ) ; <START_BUG> inboxFolder = ( ( IMAPFolder ) ( srcFolder . getChild ( "Inbox" ) ) ) ; <END_BUG> int total = inboxFolder . getMessageFolderInfo ( ) . getExists ( ) ; int recent = inboxFolder . getMessageFolderInfo ( ) . getRecent ( ) ; int unseen = inboxFolder . getMessageFolderInfo ( ) . getUnseen ( ) ; inboxFolder . getHeaderList ( ) ; int newTotal = inboxFolder . getMessageFolderInfo ( ) . getExists ( ) ; int newRecent = inboxFolder . getMessageFolderInfo ( ) . getRecent ( ) ; int newUnseen = inboxFolder . getMessageFolderInfo ( ) . getUnseen ( ) ; if ( ( ( newRecent != recent ) || ( newTotal != total ) ) || ( newUnseen != unseen ) ) { needGUIUpdate = true ; ImapItem item = srcFolder . getAccountItem ( ) . getImapItem ( ) ; if ( ( newRecent != recent ) && ( item . getBoolean ( "enable_sound" ) ) ) { String file = item . get ( "sound_file" ) ; log . info ( ( "playing<seq2seq4repair_space>sound<seq2seq4repair_space>file=" + file ) ) ; if ( file . equalsIgnoreCase ( "default" ) ) { PlaySound . play ( "newmail.wav" ) ; } else { try { PlaySound . play ( new URL ( file ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } } } } public void updateGUI ( ) throws Exception { } }
public abstract class Scrollable extends Control { ScrollBar horizontalBar ; ScrollBar verticalBar ; int scrolledHandle ; Scrollable ( ) { } public Scrollable ( Composite parent , int style ) { } int clientHandle ( ) { } public Rectangle computeTrim ( int x , int y , int width , int height ) { } ScrollBar createScrollBar ( int type ) { } void createWidget ( ) { } void deregister ( ) { } int findScrollViewer ( int current , int scrollViewerType ) { } public Rectangle getClientArea ( ) { } public ScrollBar getHorizontalBar ( ) { } int getScrollBarHandle ( int style ) { } public ScrollBar getVerticalBar ( ) { } void HandlePreviewMouseWheel ( int sender , int e ) { super . HandlePreviewMouseWheel ( sender , e ) ; if ( ! ( checkEvent ( e ) ) ) return ; if ( ( ( state ) & ( CANVAS ) ) != 0 ) { if ( ( verticalBar ) != null ) { int vHandle = verticalBar . handle ; int delta = OS . MouseWheelEventArgs_Delta ( e ) ; int lines = OS . SystemParameters_WheelScrollLines ( ) ; double value = OS . RangeBase_Value ( vHandle ) ; double newValue = value ; Event event = new Event ( ) ; if ( lines != ( - 1 ) ) { double smallIncrement = OS . RangeBase_SmallChange ( vHandle ) ; newValue += ( smallIncrement * ( ( - delta ) / 120 ) ) * lines ; event . detail = ( delta < 0 ) ? SWT . ARROW_DOWN : SWT . ARROW_UP ; } else { double largeIncrement = OS . RangeBase_LargeChange ( vHandle ) ; newValue += largeIncrement * ( ( - delta ) / 120 ) ; event . detail = ( delta < 0 ) ? SWT . PAGE_DOWN : SWT . PAGE_UP ; } OS . RangeBase_Value ( vHandle , newValue ) ; newValue = OS . RangeBase_Value ( vHandle ) ; if ( value != newValue ) { <START_BUG> verticalBar . sendEvent ( Selection ) ; <END_BUG> } } } } void register ( ) { } void releaseChildren ( boolean destroy ) { } void releaseHandle ( ) { } int topHandle ( ) { } }
public class TestTimeLimitingCollector extends LuceneTestCase { private static final int SLOW_DOWN = 3 ; private static final long TIME_ALLOWED = 17 * ( TestTimeLimitingCollector . SLOW_DOWN ) ; private static final double MULTI_THREAD_SLACK = 7 ; private static final int N_DOCS = 3000 ; private static final int N_THREADS = 50 ; private IndexSearcher searcher ; private Directory directory ; private IndexReader reader ; private final String FIELD_NAME = "body" ; private Query query ; private Counter counter ; private TimerThread counterThread ; @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; counter = Counter . newCounter ( true ) ; counterThread = new TimerThread ( counter ) ; counterThread . start ( ) ; final String [ ] docText = new String [ ] { "docThatNeverMatchesSoWeCanRequireLastDocCollectedToBeGreaterThanZero" , "one<seq2seq4repair_space>blah<seq2seq4repair_space>three" , "one<seq2seq4repair_space>foo<seq2seq4repair_space>three<seq2seq4repair_space>multiOne" , "one<seq2seq4repair_space>foobar<seq2seq4repair_space>three<seq2seq4repair_space>multiThree" , "blueberry<seq2seq4repair_space>pancakes" , "blueberry<seq2seq4repair_space>pie" , "blueberry<seq2seq4repair_space>strudel" , "blueberry<seq2seq4repair_space>pizza" } ; directory = newDirectory ( ) ; RandomIndexWriter iw = new RandomIndexWriter ( random ( ) , directory , newIndexWriterConfig ( TEST_VERSION_CURRENT , new org . apache . lucene . analysis . MockAnalyzer ( random ( ) ) ) . setMergePolicy ( newLogMergePolicy ( ) ) ) ; for ( int i = 0 ; i < ( TestTimeLimitingCollector . N_DOCS ) ; i ++ ) { add ( docText [ ( i % ( docText . length ) ) ] , iw ) ; } reader = iw . getReader ( ) ; <START_BUG> iw . close ( ) ; <END_BUG> searcher = newSearcher ( reader ) ; BooleanQuery booleanQuery = new BooleanQuery ( ) ; booleanQuery . add ( new TermQuery ( new Term ( FIELD_NAME , "one" ) ) , SHOULD ) ; for ( int i = 1 ; i < ( docText . length ) ; i ++ ) { String [ ] docTextParts = docText [ i ] . split ( "\\s+" ) ; for ( String docTextPart : docTextParts ) { booleanQuery . add ( new TermQuery ( new Term ( FIELD_NAME , docTextPart ) ) , SHOULD ) ; } } query = booleanQuery ; searcher . search ( query , null , 1000 ) ; } @ Override public void tearDown ( ) throws Exception { } private void add ( String value , RandomIndexWriter iw ) throws IOException { } private void search ( Collector collector ) throws Exception { } public void testSearch ( ) { } private void doTestSearch ( ) { } private Collector createTimedCollector ( TestTimeLimitingCollector . MyHitCollector hc , long timeAllowed , boolean greedy ) { } public void testTimeoutGreedy ( ) { } public void testTimeoutNotGreedy ( ) { } private void doTestTimeout ( boolean multiThreaded , boolean greedy ) { } private long maxTime ( boolean multiThreaded ) { } private String maxTimeStr ( boolean multiThreaded ) { } public void testModifyResolution ( ) { } public void testSearchMultiThreaded ( ) throws Exception { } public void testTimeoutMultiThreaded ( ) throws Exception { } private void doTestMultiThreads ( final boolean withTimeout ) throws Exception { } private class MyHitCollector extends SimpleCollector { private final BitSet bits = new BitSet ( ) ; private int slowdown = 0 ; private int lastDocCollected = - 1 ; private int docBase = 0 ; public void setSlowDown ( int milliseconds ) { } public int hitCount ( ) { } public int getLastDocCollected ( ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override public void collect ( final int doc ) throws IOException { } @ Override protected void doSetNextReader ( AtomicReaderContext context ) throws IOException { } @ Override public boolean acceptsDocsOutOfOrder ( ) { } } }
public class EclipseFileTransfer extends FileTransferSharedObject implements FileTransferListener { private static final long serialVersionUID = - 4496151870561737078L ; FileSenderUI senderUI ; ID eclipseStageID ; public EclipseFileTransfer ( FileSenderUI view , ID target , InputStream ins , FileTransferParams params , ID receiverID ) { } protected SharedObjectDescription getReplicaDescription ( ID remoteMember ) { } public void init ( ISharedObjectConfig config ) throws SharedObjectInitException { } public EclipseFileTransfer ( FileTransferParams params , ID receiverID ) { } public EclipseFileTransfer ( ) { } public void sendStart ( FileTransferSharedObject obj , long length , float rate ) { } public void sendData ( FileTransferSharedObject obj , int dataLength ) { } public void sendDone ( FileTransferSharedObject obj , Exception e ) { } protected File makePath ( EclipseCollabSharedObject stage , boolean server , File file , long length , float rate ) { } protected File localFile = null ; protected FileReceiverUI receiverUI = null ; protected EclipseCollabSharedObject receiverStage = null ; public void receiveStart ( FileTransferSharedObject obj , File aFile , long length , float rate ) { } public void receiveData ( FileTransferSharedObject obj , int dataLength ) { } public void receiveDone ( FileTransferSharedObject obj , Exception e ) { } protected boolean votingCompleted ( ) throws SharedObjectAddAbortException { } private class FileReceiver implements Runnable { private File aFile = null ; private long length ; private float rate ; public FileReceiver ( File aFile , long length , float rate ) { } public void run ( ) { boolean isServer = false ; if ( ClientPlugin . getDefault ( ) . getPluginPreferences ( ) . getBoolean ( PREF_CONFIRM_FILE_RECEIVE ) ) { MessageDialog dialog = new MessageDialog ( ClientPlugin . getDefault ( ) . getActiveShell ( ) , "File<seq2seq4repair_space>Receive<seq2seq4repair_space>Confirmation" , null , "Accept<seq2seq4repair_space>file?" , MessageDialog . QUESTION , null , 0 ) ; dialog . setBlockOnOpen ( true ) ; int response = dialog . open ( ) ; if ( response == ( MessageDialog . CANCEL ) ) { return ; } } try { receiverStage = ( ( EclipseCollabSharedObject ) ( getContext ( ) . getSharedObjectManager ( ) . getSharedObject ( eclipseStageID ) ) ) ; } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } try { <START_BUG> isServer = getContext ( ) . isGroupServer ( ) ; <END_BUG> } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } if ( ( receiverStage ) != null ) { receiverUI = receiverStage . getFileReceiverUI ( EclipseFileTransfer . this , transferParams ) ; } localFile = makePath ( receiverStage , isServer , aFile , length , rate ) ; transferParams . setRemoteFile ( localFile ) ; if ( ( receiverUI ) != null ) { receiverUI . receiveStart ( getHomeContainerID ( ) , localFile , length , rate ) ; } else { System . out . println ( ( "Receiving<seq2seq4repair_space>to<seq2seq4repair_space>local<seq2seq4repair_space>file:<seq2seq4repair_space>" + ( localFile ) ) ) ; } } } }
public class ClassScope extends Scope { public TypeDeclaration referenceContext ; private TypeReference superTypeReference ; private static final char [ ] IncompleteHierarchy = new char [ ] { 'h' , 'a' , 's' , '<seq2seq4repair_space>' , 'i' , 'n' , 'c' , 'o' , 'n' , 's' , 'i' , 's' , 't' , 'e' , 'n' , 't' , '<seq2seq4repair_space>' , 'h' , 'i' , 'e' , 'r' , 'a' , 'r' , 'c' , 'h' , 'y' } ; public ClassScope ( Scope parent , TypeDeclaration context ) { } void buildAnonymousTypeBinding ( SourceTypeBinding enclosingType , ReferenceBinding supertype ) { } private void buildFields ( ) { boolean hierarchyIsInconsistent = referenceContext . binding . isHierarchyInconsistent ( ) ; if ( ( referenceContext . fields ) == null ) { if ( hierarchyIsInconsistent ) { referenceContext . binding . fields = new FieldBinding [ 1 ] ; referenceContext . binding . fields [ 0 ] = new FieldBinding ( ClassScope . IncompleteHierarchy , IntBinding , AccPrivate , referenceContext . binding , null ) ; } else { referenceContext . binding . fields = NoFields ; } return ; } FieldDeclaration [ ] fields = referenceContext . fields ; int size = fields . length ; int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) { switch ( fields [ i ] . getKind ( ) ) { case AbstractVariableDeclaration . FIELD : case AbstractVariableDeclaration . ENUM_CONSTANT : count ++ ; } } if ( hierarchyIsInconsistent ) count ++ ; FieldBinding [ ] fieldBindings = new FieldBinding [ count ] ; HashtableOfObject knownFieldNames = new HashtableOfObject ( count ) ; boolean duplicate = false ; count = 0 ; for ( int i = 0 ; i < size ; i ++ ) { FieldDeclaration field = fields [ i ] ; if ( ( field . getKind ( ) ) == ( AbstractVariableDeclaration . INITIALIZER ) ) { if ( referenceContext . binding . isInterface ( ) ) problemReporter ( ) . interfaceCannotHaveInitializers ( referenceContext . binding , field ) ; } else { FieldBinding fieldBinding = new FieldBinding ( field , null , ( ( field . modifiers ) | ( AccUnresolved ) ) , referenceContext . binding ) ; checkAndSetModifiersForField ( fieldBinding , field ) ; if ( knownFieldNames . containsKey ( field . name ) ) { duplicate = true ; FieldBinding previousBinding = ( ( FieldBinding ) ( knownFieldNames . get ( field . name ) ) ) ; if ( previousBinding != null ) { for ( int f = 0 ; f < i ; f ++ ) { FieldDeclaration previousField = fields [ f ] ; if ( ( previousField . binding ) == previousBinding ) { problemReporter ( ) . duplicateFieldInType ( referenceContext . binding , previousField ) ; previousField . binding = null ; break ; } } } knownFieldNames . put ( field . name , null ) ; problemReporter ( ) . duplicateFieldInType ( referenceContext . binding , field ) ; field . binding = null ; } else { knownFieldNames . put ( field . name , fieldBinding ) ; if ( fieldBinding != null ) fieldBindings [ ( count ++ ) ] = fieldBinding ; } } } if ( duplicate ) { FieldBinding [ ] newFieldBindings = new FieldBinding [ fieldBindings . length ] ; size = count ; count = 0 ; for ( int i = 0 ; i < size ; i ++ ) { FieldBinding fieldBinding = fieldBindings [ i ] ; if ( ( knownFieldNames . get ( fieldBinding . name ) ) != null ) newFieldBindings [ ( count ++ ) ] = fieldBinding ; } fieldBindings = newFieldBindings ; } if ( hierarchyIsInconsistent ) <START_BUG> fieldBindings [ ( count ++ ) ] = new FieldBinding ( ClassScope . IncompleteHierarchy , VoidBinding , AccPrivate , referenceContext . binding , null ) ; <END_BUG> if ( count != ( fieldBindings . length ) ) System . arraycopy ( fieldBindings , 0 , ( fieldBindings = new FieldBinding [ count ] ) , 0 , count ) ; for ( int i = 0 ; i < count ; i ++ ) fieldBindings [ i ] . id = i ; referenceContext . binding . fields = fieldBindings ; } void buildFieldsAndMethods ( ) { } private LocalTypeBinding buildLocalType ( SourceTypeBinding enclosingType , PackageBinding packageBinding ) { } void buildLocalTypeBinding ( SourceTypeBinding enclosingType ) { } private void buildMemberTypes ( AccessRestriction accessRestriction ) { } private void buildMethods ( ) { } SourceTypeBinding buildType ( SourceTypeBinding enclosingType , PackageBinding packageBinding , AccessRestriction accessRestriction ) { } private void buildTypeVariables ( ) { } private void checkAndSetModifiers ( ) { } private void checkAndSetModifiersForField ( FieldBinding fieldBinding , FieldDeclaration fieldDecl ) { } private void checkForInheritedMemberTypes ( SourceTypeBinding sourceType ) { } private void checkParameterizedTypeBounds ( ) { } private void connectMemberTypes ( ) { } private boolean connectSuperclass ( ) { } private boolean connectEnumSuperclass ( ) { } private boolean connectSuperInterfaces ( ) { } void connectTypeHierarchy ( ) { } private void connectTypeHierarchyWithoutMembers ( ) { } public boolean detectCycle ( TypeBinding superType , TypeReference reference , TypeBinding [ ] argTypes ) { } private boolean detectCycle ( SourceTypeBinding sourceType , ReferenceBinding superType , TypeReference reference ) { } private ReferenceBinding findAmbiguousInterface ( ReferenceBinding newInterface , ReferenceBinding currentType ) { } private ReferenceBinding findSupertype ( TypeReference typeReference ) { } public ProblemReporter problemReporter ( ) { } public TypeDeclaration referenceType ( ) { } public String toString ( ) { } }
public class TypeDeclaration extends BodyDeclaration { private static final int LEGAL_MODIFIERS = ( ( ( ( ( ( Modifier . PUBLIC ) | ( Modifier . PRIVATE ) ) | ( Modifier . PROTECTED ) ) | ( Modifier . STATIC ) ) | ( Modifier . FINAL ) ) | ( Modifier . ABSTRACT ) ) | ( Modifier . STRICTFP ) ; private boolean isInterface = false ; private int modifiers = Modifier . NONE ; private SimpleName typeName = null ; private Name optionalSuperclassName = null ; private ASTNode . NodeList superInterfaceNames = new ASTNode . NodeList ( false , Name . class ) ; private ASTNode . NodeList bodyDeclarations = new ASTNode . NodeList ( true , BodyDeclaration . class ) ; TypeDeclaration ( AST ast ) { } ASTNode clone ( AST target ) { } boolean equalSubtrees ( Object other ) { } void accept0 ( ASTVisitor visitor ) { } public boolean isInterface ( ) { } public void setInterface ( boolean isInterface ) { } public int getModifiers ( ) { } public void setModifiers ( int modifiers ) { <START_BUG> modifiers &= ~ ( IConstants . AccDeprecated ) ; <END_BUG> if ( ( modifiers & ( ~ ( TypeDeclaration . LEGAL_MODIFIERS ) ) ) != 0 ) { throw new IllegalArgumentException ( ) ; } modifying ( ) ; this . modifiers = modifiers ; } public SimpleName getName ( ) { } public void setName ( SimpleName typeName ) { } public Name getSuperclass ( ) { } public void setSuperclass ( Name superclassName ) { } public List superInterfaces ( ) { } public List bodyDeclarations ( ) { } public SingleVariableDeclaration [ ] getFields ( ) { } public MethodDeclaration [ ] getMethods ( ) { } public TypeDeclaration [ ] getTypes ( ) { } public boolean isPackageMemberTypeDeclaration ( ) { } public boolean isMemberTypeDeclaration ( ) { } public boolean isLocalTypeDeclaration ( ) { } public ITypeBinding resolveBinding ( ) { } int memSize ( ) { } int treeSize ( ) { } }
public class BenchmarkSetup { public static final Type TERMINATION_TYPE = Type . TIME ; public static Integer [ ] TERMINATION_LIMITS = new Integer [ ] { 2000 , 5000 , 10000 , 20000 } ; public static final boolean INCLUDE_FLASH = true ; public static enum AlgorithmType { FLASH ( ) { @ Override public String toString ( ) { } } , HEURAKLES ( ) { @ Override public String toString ( ) { } } , INFORMATION_LOSS_BOUNDS ( ) { @ Override public String toString ( ) { } } ; } public static class Algorithm { private BenchmarkSetup . AlgorithmType type ; private TerminationConfiguration terminationConfig ; public Algorithm ( BenchmarkSetup . AlgorithmType type , TerminationConfiguration terminationConfig ) { } @ Override public String toString ( ) { } public TerminationConfiguration getTerminationConfig ( ) { <START_BUG> return terminationConfig . clone ( ) ; <END_BUG> } public BenchmarkSetup . AlgorithmType getType ( ) { } public String getStatusSuffix ( ) { } } public static enum BenchmarkCriterion { K_ANONYMITY ( ) { @ Override public String toString ( ) { } } , L_DIVERSITY ( ) { @ Override public String toString ( ) { } } , T_CLOSENESS ( ) { @ Override public String toString ( ) { } } , D_PRESENCE ( ) { @ Override public String toString ( ) { } } ; } public static enum BenchmarkDataset { ADULT ( ) { @ Override public String toString ( ) { } } , CUP ( ) { @ Override public String toString ( ) { } } , FARS ( ) { @ Override public String toString ( ) { } } , ATUS ( ) { @ Override public String toString ( ) { } } , IHIS ( ) { @ Override public String toString ( ) { } } ; } public static List < BenchmarkSetup . Algorithm > getAlgorithms ( ) { } public static ARXConfiguration getConfiguration ( BenchmarkSetup . BenchmarkDataset dataset , Metric < ? > metric , double suppression , BenchmarkSetup . BenchmarkCriterion ... criteria ) throws IOException { } public static double [ ] getSuppression ( ) { } @ SuppressWarnings ( "rawtypes" ) public static Metric [ ] getMetrics ( ) { } public static BenchmarkSetup . BenchmarkCriterion [ ] [ ] getCriteria ( ) { } public static Data getData ( BenchmarkSetup . BenchmarkDataset dataset ) throws IOException { } @ SuppressWarnings ( "incomplete-switch" ) public static Data getData ( BenchmarkSetup . BenchmarkDataset dataset , BenchmarkSetup . BenchmarkCriterion [ ] criteria ) throws IOException { } public static BenchmarkSetup . BenchmarkDataset [ ] getDatasets ( ) { } public static Hierarchy getHierarchy ( BenchmarkSetup . BenchmarkDataset dataset , String attribute ) throws IOException { } public static String [ ] getQuasiIdentifyingAttributes ( BenchmarkSetup . BenchmarkDataset dataset ) { } public static DataSubset getResearchSubset ( BenchmarkSetup . BenchmarkDataset dataset ) throws IOException { } public static String getSensitiveAttribute ( BenchmarkSetup . BenchmarkDataset dataset ) { } }
public class CloseAllPerspectivesAction extends Action implements ActionFactory . IWorkbenchAction { private IWorkbenchWindow workbenchWindow ; public CloseAllPerspectivesAction ( IWorkbenchWindow window ) { } public void run ( ) { if ( ( workbenchWindow ) == null ) { return ; } IWorkbenchPage page = workbenchWindow . getActivePage ( ) ; if ( page != null ) { <START_BUG> ( ( WorkbenchPage ) ( page ) ) . closeAllPerspectives ( ) ; <END_BUG> } } public void dispose ( ) { } }
public class SecurityDomainResourceDefinition extends SimpleResourceDefinition { public static final SimpleAttributeDefinition CACHE_TYPE = new org . jboss . as . controller . SimpleAttributeDefinitionBuilder ( Constants . CACHE_TYPE , org . jboss . dmr . ModelType . STRING , true ) . build ( ) ; private final boolean registerRuntimeOnly ; SecurityDomainResourceDefinition ( boolean registerRuntimeOnly ) { } public void registerAttributes ( final ManagementResourceRegistration resourceRegistration ) { } @ Override public void registerOperations ( ManagementResourceRegistration resourceRegistration ) { } public static ServiceName getSecurityDomainServiceName ( PathAddress pathAddress ) { PathAddress domain = Util . getParentAddressByKey ( pathAddress , SECURITY_DOMAIN ) ; if ( domain == null ) <START_BUG> throw new IllegalArgumentException ( "Address<seq2seq4repair_space>did<seq2seq4repair_space>not<seq2seq4repair_space>contain<seq2seq4repair_space>a<seq2seq4repair_space>security<seq2seq4repair_space>domain<seq2seq4repair_space>name" ) ; <END_BUG> return SERVICE_NAME . append ( domain . getLastElement ( ) . getValue ( ) ) ; } @ SuppressWarnings ( "unchecked" ) private static ServiceController < SecurityDomainContext > getSecurityDomainService ( OperationContext context , String securityDomain ) { } static class ListCachePrincipals extends AbstractRuntimeOnlyHandler { static final SecurityDomainResourceDefinition . ListCachePrincipals INSTANCE = new SecurityDomainResourceDefinition . ListCachePrincipals ( ) ; @ Override protected void executeRuntimeStep ( OperationContext context , ModelNode operation ) throws OperationFailedException { } } static final class FlushOperation extends AbstractRuntimeOnlyHandler { static final SecurityDomainResourceDefinition . FlushOperation INSTANCE = new SecurityDomainResourceDefinition . FlushOperation ( ) ; @ Override protected void executeRuntimeStep ( OperationContext context , ModelNode operation ) throws OperationFailedException { } } }
public class FavouritesSelectActivity extends ActionBarActivity { private final String LOG_TAG = FavouritesSelectActivity . class . getSimpleName ( ) ; private final String FILE_FAVOURITES = "favourites" ; private ArrayAdapter < String > adapterFavouriteStops ; private SparseBooleanArray checkedItems ; private List < String > selectedItems ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { int id = item . getItemId ( ) ; if ( id == ( id . action_favourites_save ) ) { try { if ( ( ( selectedItems ) != null ) && ( ! ( selectedItems . isEmpty ( ) ) ) ) { FileOutputStream file = openFileOutput ( FILE_FAVOURITES , MODE_PRIVATE ) ; file . write ( Serializer . serialize ( selectedItems ) ) ; file . close ( ) ; } } catch ( IOException ioe ) { <START_BUG> Log . e ( LOG_TAG , ioe . getMessage ( ) ) ; <END_BUG> } finish ( ) ; } return super . onOptionsItemSelected ( item ) ; } }
public abstract class AbstractMessage < T extends AbstractMessage < T > > implements IMessage , IMessageHandler < T , IMessage > { protected abstract void read ( PacketBuffer buffer ) throws IOException { } protected abstract void write ( PacketBuffer buffer ) throws IOException { } protected abstract boolean isValidOnSide ( Side side ) { } protected abstract void process ( EntityPlayer player , Side side ) { } @ Override public void fromBytes ( ByteBuf buffer ) { } @ Override public void toBytes ( ByteBuf buffer ) { } @ Override public final IMessage onMessage ( T msg , MessageContext ctx ) { <START_BUG> if ( ! ( isValidOnSide ( ctx . side ) ) ) { <END_BUG> throw new RuntimeException ( ( ( ( "Invalid<seq2seq4repair_space>side<seq2seq4repair_space>" + ( ctx . side . name ( ) ) ) + "<seq2seq4repair_space>for<seq2seq4repair_space>" ) + ( msg . getClass ( ) . getSimpleName ( ) ) ) ) ; } msg . process ( proxy . getPlayerEntity ( ctx ) , ctx . side ) ; return null ; } }
public class SignaturePatternTestCase extends TestCase { public SignaturePatternTestCase ( String name ) { } BcelWorld world = new BcelWorld ( ) ; public void testThrowsMatch ( ) throws IOException { } public void testInstanceMethodMatch ( ) throws IOException { } public void testStaticMethodMatch ( ) throws IOException { } public void testFieldMatch ( ) throws IOException { } public void testConstructorMatch ( ) throws IOException { } public void checkMatch ( SignaturePattern p , Member [ ] yes , Member [ ] no ) throws IOException { } private void checkMatch ( SignaturePattern p , Member member , boolean b ) { <START_BUG> boolean matches = p . matches ( member , world ) ; <END_BUG> assertEquals ( ( ( ( p . toString ( ) ) + "<seq2seq4repair_space>matches<seq2seq4repair_space>" ) + ( member . toString ( ) ) ) , b , matches ) ; } private SignaturePattern makeMethodPat ( String pattern ) { } private SignaturePattern makeFieldPat ( String pattern ) { } private void checkSerialization ( SignaturePattern p ) throws IOException { } }
public class CreateEmployeeAction extends Action { private EmployeeDAO employeeDAO ; private FormBeanFactory < EmployeeForm > formBeanFactory = FormBeanFactory . getInstance ( EmployeeForm . class ) ; public CreateEmployeeAction ( Model model ) { } public String getName ( ) { } public String perform ( HttpServletRequest request ) { List < String > errors = new ArrayList < String > ( ) ; request . setAttribute ( "errors" , errors ) ; try { EmployeeForm form = formBeanFactory . create ( request ) ; request . setAttribute ( "form" , form ) ; request . setAttribute ( "employeeList" , employeeDAO . getEmployees ( ) ) ; if ( ! ( form . isPresent ( ) ) ) { System . out . println ( "create<seq2seq4repair_space>employee<seq2seq4repair_space>form<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>present!" ) ; return "employee/create-employee.jsp" ; } errors . addAll ( form . getValidationErrors ( ) ) ; EmployeeBean employee = employeeDAO . read ( form . getUsername ( ) ) ; if ( employee != null ) { System . out . println ( "<seq2seq4repair_space>employee<seq2seq4repair_space>is<seq2seq4repair_space>already<seq2seq4repair_space>exist" ) ; errors . add ( "Employee<seq2seq4repair_space>username<seq2seq4repair_space>is<seq2seq4repair_space>already<seq2seq4repair_space>exist." ) ; } if ( ( errors . size ( ) ) != 0 ) { return "employee/create-employee.jsp" ; } System . out . println ( "create<seq2seq4repair_space>employee<seq2seq4repair_space>now!" ) ; employee = new EmployeeBean ( ) ; employee . setUsername ( form . getUsername ( ) ) ; System . out . println ( ( "username<seq2seq4repair_space>=<seq2seq4repair_space>" + ( form . getUsername ( ) ) ) ) ; employee . setFirstname ( form . getFirstname ( ) ) ; System . out . println ( ( "first<seq2seq4repair_space>=<seq2seq4repair_space>" + ( form . getFirstname ( ) ) ) ) ; employee . setLastname ( form . getLastname ( ) ) ; System . out . println ( ( "last<seq2seq4repair_space>=<seq2seq4repair_space>" + ( form . getLastname ( ) ) ) ) ; employee . setPassword ( form . getPassword ( ) ) ; System . out . println ( ( "pass<seq2seq4repair_space>=<seq2seq4repair_space>" + ( form . getPassword ( ) ) ) ) ; employee . setStatus ( 0 ) ; <START_BUG> employeeDAO . createAutoIncrement ( employee ) ; <END_BUG> HttpSession session = request . getSession ( false ) ; session . setAttribute ( "employee" , employee ) ; return "employee/create-employee.jsp" ; } catch ( RollbackException e ) { errors . add ( e . getMessage ( ) ) ; return "employee/create-employee.jsp" ; } catch ( FormBeanException e ) { errors . add ( e . getMessage ( ) ) ; return "employee/create-employee.jsp" ; } } }
public class WeldBootstrapService implements Service < WeldBootstrapService > { public static final ServiceName SERVICE_NAME = ServiceName . of ( "WeldBootstrapService" ) ; private final WeldBootstrap bootstrap ; private final WeldDeployment deployment ; private final Environment environment ; private final Map < String , BeanDeploymentArchive > beanDeploymentArchives ; private final BeanDeploymentArchiveImpl rootBeanDeploymentArchive ; private final String deploymentName ; private final InjectedValue < WeldSecurityServices > securityServices = new InjectedValue < WeldSecurityServices > ( ) ; private final InjectedValue < WeldTransactionServices > weldTransactionServices = new InjectedValue < WeldTransactionServices > ( ) ; private volatile boolean started ; public WeldBootstrapService ( WeldDeployment deployment , Environment environment , final String deploymentName ) { } public synchronized void start ( final StartContext context ) { if ( started ) { throw MESSAGES . alreadyRunning ( "WeldContainer" ) ; } started = true ; DEPLOYMENT_LOGGER . startingWeldService ( deploymentName ) ; addWeldService ( SecurityServices . class , securityServices . getValue ( ) ) ; addWeldService ( TransactionServices . class , weldTransactionServices . getValue ( ) ) ; ModuleGroupSingletonProvider . addClassLoaders ( deployment . getModule ( ) . getClassLoader ( ) , deployment . getSubDeploymentClassLoaders ( ) ) ; ClassLoader oldTccl = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; try { WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( deployment . getModule ( ) . getClassLoader ( ) ) ; <START_BUG> bootstrap . startContainer ( environment , deployment ) ; <END_BUG> } finally { WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl ) ; } } public synchronized void stop ( final StopContext context ) { } public BeanManagerImpl getBeanManager ( String beanArchiveId ) { } public < T extends Service > void addWeldService ( Class < T > type , T service ) { } public BeanManager getBeanManager ( ) { } public Set < BeanDeploymentArchive > getBeanDeploymentArchives ( ) { } public boolean isStarted ( ) { } WeldBootstrap getBootstrap ( ) { } @ Override public WeldBootstrapService getValue ( ) throws IllegalArgumentException , IllegalStateException { } public InjectedValue < WeldSecurityServices > getSecurityServices ( ) { } public InjectedValue < WeldTransactionServices > getWeldTransactionServices ( ) { } }
public class ConfigFrame implements ActionListener , ListSelectionListener { private JDialog dialog ; private AccountListTable listView ; private AccountList accountList ; private AccountItem accountItem ; JTextField nameTextField = new JTextField ( ) ; JButton addButton ; JButton removeButton ; JButton editButton ; private int index ; public ConfigFrame ( ) { } public AccountItem getSelected ( ) { } public void setSelected ( AccountItem item ) { } public void initComponents ( ) { } public void valueChanged ( ListSelectionEvent e ) { } public void showAccountDialog ( ) { } public void actionPerformed ( ActionEvent e ) { String action = e . getActionCommand ( ) ; if ( action . equals ( "CLOSE" ) ) { try { config . save ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } dialog . setVisible ( false ) ; } else if ( action . equals ( "ADD" ) ) { try { <START_BUG> new AccountWizardLauncher ( ) . launchWizard ( ) ; <END_BUG> listView . update ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } else if ( action . equals ( "REMOVE" ) ) { Object [ ] options = new Object [ ] { "Delete" , "No" } ; int n = JOptionPane . showOptionDialog ( null , "Would<seq2seq4repair_space>you<seq2seq4repair_space>really<seq2seq4repair_space>like<seq2seq4repair_space>to<seq2seq4repair_space>delete<seq2seq4repair_space>this<seq2seq4repair_space>account?" , "Question" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , null , options , options [ 1 ] ) ; if ( n == ( JOptionPane . NO_OPTION ) ) { return ; } AccountItem item = accountList . remove ( index ) ; if ( item . isPopAccount ( ) ) { popServerCollection . removePopServer ( item . getUid ( ) ) ; } else { FolderTreeNode folder = ( ( FolderTreeNode ) ( treeModel . getImapFolder ( item . getUid ( ) ) ) ) ; try { FolderTreeNode parentFolder = ( ( FolderTreeNode ) ( folder . getParent ( ) ) ) ; folder . removeFolder ( ) ; treeModel . nodeStructureChanged ( parentFolder ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } mailCheckingManager . remove ( item . getUid ( ) ) ; removeButton . setEnabled ( false ) ; editButton . setEnabled ( false ) ; listView . update ( ) ; } else if ( action . equals ( "EDIT" ) ) { showAccountDialog ( ) ; listView . update ( ) ; } } }
public class TestPatternExpressionText extends TestCase { private EPServiceProvider epService ; public void setUp ( ) { Configuration config = SupportConfigFactory . getConfiguration ( ) ; config . addEventType ( "SupportBean" , SupportBean . class . getName ( ) ) ; config . addEventType ( "A" , SupportBean_A . class . getName ( ) ) ; config . addEventType ( "B" , SupportBean_B . class . getName ( ) ) ; config . addEventType ( "C" , SupportBean_C . class . getName ( ) ) ; config . addEventType ( "D" , SupportBean_D . class . getName ( ) ) ; config . addEventType ( "E" , SupportBean_E . class . getName ( ) ) ; config . addEventType ( "F" , SupportBean_F . class . getName ( ) ) ; config . addEventType ( "G" , SupportBean_G . class . getName ( ) ) ; <START_BUG> epService = EPServiceProviderManager . getProvider ( TestPatternExpressionText . class . getSimpleName ( ) , config ) ; <END_BUG> epService . initialize ( ) ; if ( InstrumentationHelper . ENABLED ) { InstrumentationHelper . startTest ( epService , this . getClass ( ) , getName ( ) ) ; } } protected void tearDown ( ) throws Exception { } public void testOp ( ) throws Exception { } private void runAssertion ( String patternText , String expectedIfDifferent ) { } private void runAssertionEPL ( String epl , String patternText , String expectedIfDifferent ) { } No newline ; at end ; of file ; }
public class LoggingSubsystemTestCase extends AbstractLoggingSubsystemTest { private static final Pattern COLOR_PATTERN = Pattern . compile ( "(%K\\{[a-zA-Z]*?})" ) ; @ Override protected String getSubsystemXml ( ) throws IOException { } @ Test public void testExpressions ( ) throws Exception { } @ Test public void testConfiguration ( ) throws Exception { } @ Test public void testTransformers712 ( ) throws Exception { } @ Test public void testTransformers713 ( ) throws Exception { } @ Test public void testTransformers720 ( ) throws Exception { } @ Test public void testRejectExpressions712 ( ) throws Exception { } @ Test public void testRejectExpressions713 ( ) throws Exception { } @ Test public void testFailedTransformedBootOperations720 ( ) throws Exception { } private void testTransformer1_1_0 ( ModelTestControllerVersion controllerVersion ) throws Exception { } private void testRejectExpressions1_1_0 ( ModelTestControllerVersion controllerVersion ) throws Exception { final ModelVersion modelVersion = ModelVersion . create ( 1 , 1 , 0 ) ; final KernelServicesBuilder builder = createKernelServicesBuilder ( LoggingTestEnvironment . getManagementInstance ( ) ) ; builder . createLegacyKernelServicesBuilder ( null , controllerVersion , modelVersion ) . addMavenResourceURL ( ( "org.jboss.as:jboss-as-logging:" + ( controllerVersion . getMavenGavVersion ( ) ) ) ) ; KernelServices mainServices = builder . build ( ) ; KernelServices legacyServices = mainServices . getLegacyServices ( modelVersion ) ; Assert . assertNotNull ( legacyServices ) ; Assert . assertTrue ( "main<seq2seq4repair_space>services<seq2seq4repair_space>did<seq2seq4repair_space>not<seq2seq4repair_space>boot" , mainServices . isSuccessfulBoot ( ) ) ; Assert . assertTrue ( legacyServices . isSuccessfulBoot ( ) ) ; final List < ModelNode > ops = builder . parseXmlResource ( "/expressions.xml" ) ; <START_BUG> ModelTestUtils . checkFailedTransformedBootOperations ( mainServices , modelVersion , ops , new FailedOperationTransformationConfig ( ) . addFailedAttribute ( SUBSYSTEM_ADDRESS , new org . jboss . as . model . test . FailedOperationTransformationConfig . NewAttributesConfig ( LoggingRootResource . ATTRIBUTES ) ) . addFailedAttribute ( createRootLoggerAddress ( ) , new org . jboss . as . model . test . FailedOperationTransformationConfig . RejectExpressionsConfig ( RootLoggerResourceDefinition . EXPRESSION_ATTRIBUTES ) ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( LOGGER_PATH ) , new org . jboss . as . model . test . FailedOperationTransformationConfig . RejectExpressionsConfig ( LoggerResourceDefinition . EXPRESSION_ATTRIBUTES ) ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( ASYNC_HANDLER_PATH ) , new org . jboss . as . model . test . FailedOperationTransformationConfig . RejectExpressionsConfig ( AsyncHandlerResourceDefinition . ATTRIBUTES ) ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( CONSOLE_HANDLER_PATH ) , ChainedConfig . createBuilder ( ATTRIBUTES ) . addConfig ( new org . jboss . as . model . test . FailedOperationTransformationConfig . RejectExpressionsConfig ( ConsoleHandlerResourceDefinition . ATTRIBUTES ) ) . build ( ) ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( FILE_HANDLER_PATH ) , new org . jboss . as . model . test . FailedOperationTransformationConfig . RejectExpressionsConfig ( FileHandlerResourceDefinition . ATTRIBUTES ) ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( FILE_HANDLER_PATH ) , ChainedConfig . createBuilder ( ATTRIBUTES ) . addConfig ( new FailedOperationTransformationConfig . NewAttributesConfig ( CommonAttributes . ENABLED ) ) . addConfig ( new org . jboss . as . model . test . FailedOperationTransformationConfig . RejectExpressionsConfig ( Logging . join ( DEFAULT_ATTRIBUTES , CommonAttributes . AUTOFLUSH , CommonAttributes . APPEND , CommonAttributes . FILE ) ) ) . addConfig ( new FailedOperationTransformationConfig . NewAttributesConfig ( AbstractHandlerDefinition . NAMED_FORMATTER ) ) . build ( ) ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( PERIODIC_HANDLER_PATH ) , new org . jboss . as . model . test . FailedOperationTransformationConfig . RejectExpressionsConfig ( PeriodicHandlerResourceDefinition . ATTRIBUTES ) ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( SIZE_ROTATING_HANDLER_PATH ) , ChainedConfig . createBuilder ( SizeRotatingHandlerResourceDefinition . ATTRIBUTES ) . addConfig ( new org . jboss . as . model . test . FailedOperationTransformationConfig . NewAttributesConfig ( SizeRotatingHandlerResourceDefinition . ROTATE_ON_BOOT ) ) . addConfig ( new org . jboss . as . model . test . FailedOperationTransformationConfig . RejectExpressionsConfig ( SizeRotatingHandlerResourceDefinition . ATTRIBUTES ) ) . build ( ) ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( CUSTOM_HANDLE_PATH ) , new org . jboss . as . model . test . FailedOperationTransformationConfig . RejectExpressionsConfig ( CustomHandlerResourceDefinition . ATTRIBUTES ) ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( SYSLOG_HANDLER_PATH ) , REJECTED_RESOURCE ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( PATTERN_FORMATTER_PATH ) , REJECTED_RESOURCE ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( CUSTOM_FORMATTER_PATH ) , REJECTED_RESOURCE ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( LOGGING_PROFILE ) , REJECTED_RESOURCE ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( LOGGING_PROFILE ) . append ( CONSOLE_HANDLER_PATH ) , REJECTED_RESOURCE ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( LOGGING_PROFILE ) . append ( FILE_HANDLER_PATH ) , REJECTED_RESOURCE ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( LOGGING_PROFILE ) . append ( ROOT_LOGGER_PATH ) , REJECTED_RESOURCE ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( LOGGING_PROFILE ) . append ( LOGGER_PATH ) , REJECTED_RESOURCE ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( LOGGING_PROFILE ) . append ( SYSLOG_HANDLER_PATH ) , REJECTED_RESOURCE ) . addFailedAttribute ( SUBSYSTEM_ADDRESS . append ( LOGGING_PROFILE ) . append ( PATTERN_FORMATTER_PATH ) , REJECTED_RESOURCE ) ) ; <END_BUG> } private void testTransformer1_2_0 ( final ModelTestControllerVersion controllerVersion ) throws Exception { } private void testFailedTransformedBootOperations1_2_0 ( final ModelTestControllerVersion controllerVersion ) throws Exception { } private void testTransformOperations ( final KernelServices mainServices , final ModelVersion modelVersion , final ModelNode legacyModel ) throws Exception { } private static ModelNode executeTransformOperation ( final KernelServices kernelServices , final ModelVersion modelVersion , final ModelNode op ) throws OperationFailedException { } private static ModelNode executeTransformOperation ( final KernelServices kernelServices , final ModelVersion modelVersion , final TransformedOperation transformedOp ) throws OperationFailedException { } private static void addRemoveHandler ( final KernelServices kernelServices , final ModelVersion modelVersion , final ModelNode address , final AttributeDefinition handlerAttribute , final String handlerName ) throws OperationFailedException { } private static void validateLegacyFormatter ( final KernelServices kernelServices , final ModelVersion modelVersion , final ModelNode address ) throws OperationFailedException { } private static void validateLegacyFilter ( final KernelServices kernelServices , final ModelVersion modelVersion , final ModelNode address , final String filterExpression ) throws OperationFailedException { }
public class ClassDetailsActivity extends Activity { private static final int PADDING = 15 ; private static final int LENGTH_OF_TIME_DESCRIPTION = 17 ; ArrayList rawResultsList ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( activity_class_details ) ; AssetManager manager ; manager = getAssets ( ) ; InputStream inputStream = null ; try { inputStream = manager . open ( "spring2016.txt" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } Intent intent = getIntent ( ) ; String classroom = intent . getStringExtra ( CLASSROOM_STRING ) ; String day = intent . getStringExtra ( DAY_STRING ) ; MyHandler myHandler = new MyHandler ( classroom , day , inputStream ) ; myHandler . skipTimeSearch ( ) ; rawResultsList = myHandler . getDetailedRooms ( ) ; ArrayList timeResultsList = getTrimmedResults ( rawResultsList ) ; ScrollView sv = new ScrollView ( this ) ; LinearLayout ll = new LinearLayout ( this ) ; ll . setOrientation ( VERTICAL ) ; sv . addView ( ll ) ; TextView firstBox = new TextView ( this ) ; firstBox . setText ( ( ( ( ( "The<seq2seq4repair_space>classroom:<seq2seq4repair_space>" + classroom ) + "<seq2seq4repair_space>on<seq2seq4repair_space>" ) + day ) + "<seq2seq4repair_space>has<seq2seq4repair_space>these<seq2seq4repair_space>classes" ) ) ; ll . addView ( firstBox ) ; for ( int i = 0 ; i < ( timeResultsList . size ( ) ) ; i ++ ) { <START_BUG> System . out . println ( ( "Got<seq2seq4repair_space>this:<seq2seq4repair_space>" + ( timeResultsList . get ( i ) . toString ( ) ) ) ) ; <END_BUG> TextView tv = new TextView ( this ) ; tv . setText ( timeResultsList . get ( i ) . toString ( ) ) ; tv . setPadding ( 0 , ClassDetailsActivity . PADDING , 0 , ClassDetailsActivity . PADDING ) ; tv . setTag ( i ) ; ll . addView ( tv ) ; } this . setContentView ( sv ) ; } public ArrayList getTrimmedResults ( ArrayList rawList ) { } }
public class AssortView extends Button { public interface OnTouchAssortButtonListener { public void onTouchAssortButtonListener ( String str ) { } public void onTouchAssortButtonUP ( ) { } } public AssortView ( Context context ) { } public AssortView ( Context context , AttributeSet attrs ) { } public AssortView ( Context context , AttributeSet attrs , int defStyle ) { } private String [ ] mAssortChars = new String [ ] { "?" , "#" , "A" , "B" , "C" , "D" , "E" , "F" , "G" , "H" , "I" , "J" , "K" , "L" , "M" , "N" , "O" , "P" , "Q" , "R" , "S" , "T" , "U" , "V" , "W" , "X" , "Y" , "Z" } ; private Paint mPaint = new Paint ( ) ; private int mSelectedIndex = - 1 ; private AssortView . OnTouchAssortButtonListener onTouchListener ; public void setOnTouchAssortListener ( AssortView . OnTouchAssortButtonListener onTouchListener ) { } @ Override protected void onDraw ( Canvas canvas ) { super . onDraw ( canvas ) ; int height = getHeight ( ) ; int width = getWidth ( ) ; int interval = height / ( mAssortChars . length ) ; for ( int i = 0 , length = mAssortChars . length ; i < length ; i ++ ) { mPaint . setAntiAlias ( true ) ; <START_BUG> mPaint . setTypeface ( DEFAULT_BOLD ) ; <END_BUG> mPaint . setColor ( GRAY ) ; mPaint . setTextSize ( 30 ) ; if ( i == ( mSelectedIndex ) ) { mPaint . setColor ( Color . parseColor ( "#1abc9a" ) ) ; mPaint . setFakeBoldText ( true ) ; mPaint . setTextSize ( 60 ) ; } float xPos = ( width / 2 ) - ( ( mPaint . measureText ( mAssortChars [ i ] ) ) / 2 ) ; float yPos = ( interval * i ) + interval ; canvas . drawText ( mAssortChars [ i ] , xPos , yPos , mPaint ) ; mPaint . reset ( ) ; } } @ Override public boolean dispatchTouchEvent ( MotionEvent event ) { } @ Override public boolean onTouchEvent ( MotionEvent event ) { } public void clear ( ) { } }
public abstract class Border < T > extends WebMarkupContainerWithAssociatedMarkup < T > implements IComponentResolver { private static final String BODY = "body" ; private static final String BORDER = "border" ; private boolean bodyVisible = true ; private MarkupContainer body ; public Border ( MarkupContainer parent , final String id ) { } public Border ( MarkupContainer parent , final String id , final IModel < T > model ) { } protected MarkupContainer getBodyContainer ( ) { } protected MarkupContainer newBorderBodyContainer ( final MarkupContainer parent ) { } public Border setBorderBodyVisible ( boolean bodyVisible ) { } @ Override public MarkupFragment getMarkupFragment ( String path ) { <START_BUG> MarkupFragment fragment = Border . getAssociatedMarkupFragment ( false ) ; <END_BUG> if ( fragment != null ) { fragment = fragment . getChildFragment ( path , false ) ; } if ( fragment == null ) { fragment = super . getMarkupFragment ( path ) ; } return fragment ; } @ Override protected final void onComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } public boolean resolve ( final MarkupContainer container , final MarkupStream markupStream , final ComponentTag tag ) { } @ Override public void renderHead ( HeaderContainer container ) { } private class BorderBody extends WebMarkupContainer implements IComponentResolver { private static final long serialVersionUID = 1L ; private transient boolean wasOpenClose = false ; public BorderBody ( final MarkupContainer parent ) { } @ Override public MarkupFragment getMarkupFragment ( ) { } @ Override protected void onComponentTag ( final ComponentTag tag ) { } @ Override protected void onComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } public boolean resolve ( final MarkupContainer container , final MarkupStream markupStream , final ComponentTag tag ) { } } }
public class AncestorUnitsDAO extends BaseDAO < List < Integer > > { private int unitId ; public AncestorUnitsDAO ( HttpServlet servlet , int unitId ) { } @ Override protected List < Integer > processData ( Connection connection ) throws Exception { LinkedList < Integer > result = new LinkedList < > ( ) ; for ( int fatherId = unitId ; ; ) { fatherId = UnitFieldDAO . fatherId ( connection , fatherId ) ; <START_BUG> if ( fatherId == 0 ) <END_BUG> break ; result . addFirst ( fatherId ) ; } return result ; } }
public class MessageFragment extends Fragment { private Context context ; private View rootView ; @ InjectView ( id . titleText ) TextView tvTitle ; @ InjectView ( id . tv_btn_register ) TextView tvNavBtnRegister ; @ InjectView ( id . tv_btn_login ) TextView tvNavBtnLogin ; @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { } private void initVisitorNavigationBar ( View v ) { <START_BUG> tvTitle . setText ( main_me ) ; <END_BUG> tvTitle . setVisibility ( VISIBLE ) ; tvNavBtnRegister . setVisibility ( GONE ) ; tvNavBtnLogin . setVisibility ( GONE ) ; } @ OnClick ( id . tv_btn_content_register ) public void onContentRegisterClick ( ) { } @ OnClick ( id . tv_btn_content_login ) public void onContentLoginCLick ( ) { } }
class StressCategory { static Priority [ ] priority = new Priority [ ] { Priority . DEBUG , Priority . INFO , Priority . WARN , Priority . ERROR , Priority . FATAL } ; static Priority defaultPriority = Category . getRoot ( ) . getPriority ( ) ; static int LENGTH ; static String [ ] names ; static Category [ ] cat ; static StressCategory . CT [ ] ct ; static Random random = new Random ( 10 ) ; public static void main ( String [ ] args ) { } static void permute ( int n ) { } static void swap ( String [ ] names , int i , int j ) { } public static void permutationDump ( ) { } static void createLoop ( int n ) { if ( n == ( StressCategory . LENGTH ) ) { for ( int i = 0 ; i < ( StressCategory . LENGTH ) ; i ++ ) { if ( ( StressCategory . ct [ i ] ) == null ) StressCategory . cat [ i ] = null ; else { StressCategory . cat [ i ] = Category . getInstance ( StressCategory . ct [ i ] . catstr ) ; StressCategory . cat [ i ] . setPriority ( StressCategory . ct [ i ] . priority ) ; } } StressCategory . test ( ) ; <START_BUG> _default . clear ( ) ; <END_BUG> } else { StressCategory . ct [ n ] = null ; StressCategory . createLoop ( ( n + 1 ) ) ; StressCategory . ct [ n ] = new StressCategory . CT ( StressCategory . names [ n ] , null ) ; StressCategory . createLoop ( ( n + 1 ) ) ; int r = StressCategory . random . nextInt ( ) ; if ( r < 0 ) r = - r ; StressCategory . ct [ n ] = new StressCategory . CT ( StressCategory . names [ n ] , StressCategory . priority [ ( r % 5 ) ] ) ; StressCategory . createLoop ( ( n + 1 ) ) ; } } static void test ( ) { } static void ctDump ( ) { } static void catDump ( ) { } static boolean checkCorrectness ( int i ) { } static Priority getExpectedPrioriy ( StressCategory . CT ctParam ) { } static class CT { public String catstr ; public Priority priority ; CT ( String catstr , Priority priority ) { } } }
class ObjectNameAddressUtil { private static final ObjectNameAddressUtil . EscapedCharacter [ ] ESCAPED_KEY_CHARACTERS ; static ObjectName createObjectName ( final String domain , final PathAddress pathAddress ) { } static PathAddress resolvePathAddress ( final String domain , final Resource rootResource , final ObjectName name ) { } private static PathAddress searchPathAddress ( final PathAddress address , final Resource resource , final Map < String , String > properties ) { } static PathAddress toPathAddress ( String domain , ImmutableManagementResourceRegistration registry , ObjectName name ) { } private static PathAddress searchPathAddress ( PathAddress address , ImmutableManagementResourceRegistration registry , Map < String , String > properties ) { if ( ( properties . size ( ) ) == 0 ) { return address ; } for ( Map . Entry < String , String > entry : properties . entrySet ( ) ) { PathAddress childAddress = PathAddress . pathAddress ( ObjectNameAddressUtil . replaceEscapedCharactersInKey ( entry . getKey ( ) ) , ObjectNameAddressUtil . replaceEscapedCharactersInValue ( entry . getValue ( ) ) ) ; <START_BUG> ImmutableManagementResourceRegistration subModel = registry . getSubModel ( address ) ; <END_BUG> if ( subModel != null ) { Map < String , String > childProps = new HashMap < String , String > ( properties ) ; childProps . remove ( entry . getKey ( ) ) ; PathAddress foundAddr = ObjectNameAddressUtil . searchPathAddress ( address . append ( childAddress ) , subModel , childProps ) ; if ( foundAddr != null ) { return foundAddr ; } } } return null ; } private static void escapeKey ( ObjectNameAddressUtil . EscapedCharacter [ ] escapedCharacters , StringBuilder sb , String value ) { } private static void escapeValue ( final StringBuilder sb , final String value ) { } private static String checkAndReplace ( boolean condition , String original , String search , String replacement ) { } private static String replaceEscapedCharactersInKey ( String escaped ) { } private static String replaceEscapedCharactersInValue ( final String escaped ) { } private static class EscapedCharacter { private final String ch ; private final String hexPart ; private final String escaped ; EscapedCharacter ( Character ch ) { } String getChar ( ) { } String getEscaped ( ) { } } }
public final class Java2WSWidgetFactory { private Java2WSWidgetFactory ( ) { } public static Label createSOAPBindingLabel ( Composite parent ) { } public static Combo createSOAPBingCombo ( Composite parent , final Java2WSContext context ) { } public static Button createXSDImportsButton ( Composite parent , final Java2WSContext context ) { } public static Label createFrontendLabel ( Composite parent ) { } public static Combo createFrontendCombo ( Composite parent , final Java2WSContext context ) { } public static Label createDatabindingLabel ( Composite parent ) { } public static Combo createDatabindingCombo ( Composite parent , final Java2WSContext context ) { } public static Button createGenerateClientButton ( Composite parent , final Java2WSContext context ) { } public static Button createGenerateServerButton ( Composite parent , final Java2WSContext context ) { } public static Button createGenerateWrapperFaultBeanButton ( Composite parent , final Java2WSContext context ) { } public static Button createGenerateWSDLButton ( Composite parent , final Java2WSContext context ) { } public static Label createWSDLFileNameLabel ( Composite parent ) { } public static Text createWSDLFileNameText ( Composite parent , final Java2WSDataModel model ) { } public static Button createUseSEIButton ( Composite parent ) { } public static Label createInformationLabel ( Composite parent , IType startingPointType ) { } public static Label createPaddingLabel ( Composite parent ) { } public static Button createSelectSEIButton ( Composite parent ) { } public static Label createSelectSEILabel ( Composite parent ) { } public static Combo createSelectSEICombo ( Composite parent , final Java2WSDataModel model , IType javaStartingPointType ) { <START_BUG> final Combo seiCombo = new Combo ( parent , SWT . READ_ONLY ) ; <END_BUG> seiCombo . setToolTipText ( JAVA2WS_SELECT_SEI_TOOLTIP ) ; IJavaProject javaProject = JDTUtils . getJavaProject ( model . getProjectName ( ) ) ; try { ITypeHierarchy typeHierarchy = javaStartingPointType . newTypeHierarchy ( javaProject , null ) ; IType [ ] allInterfaces = typeHierarchy . getAllInterfaces ( ) ; for ( int i = 0 ; i < ( allInterfaces . length ) ; i ++ ) { IType itype = allInterfaces [ i ] ; if ( ( ! ( itype . isBinary ( ) ) ) && ( itype . getResource ( ) . getProject ( ) . equals ( javaProject . getProject ( ) ) ) ) { seiCombo . add ( itype . getFullyQualifiedName ( ) ) ; } } } catch ( JavaModelException jme ) { CXFUIPlugin . log ( jme . getStatus ( ) ) ; } seiCombo . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { String seiInterfaceName = seiCombo . getText ( ) ; model . setFullyQualifiedJavaInterfaceName ( seiInterfaceName ) ; } } ) ; seiCombo . select ( ( - 1 ) ) ; return seiCombo ; } public static Button createExtractSEIButton ( Composite parent ) { } public static Label createExtractSEILabel ( Composite parent ) { } public static Text createSEIInterfaceNameText ( Composite parent ) { } public static Label createMemebersToExtractLabel ( Composite parent ) { } public static CheckboxTableViewer createSEIMembersToExtractTableViewer ( Composite parent ) { } public static Button createSelectAllButton ( Composite parent ) { } public static Button createDeselectAllButton ( Composite parent ) { } public static Label createSelectImplementationLabel ( Composite parent ) { } public static Combo createSelectImplementationCombo ( Composite parent , final Java2WSDataModel model , IType javaStartingPointType ) { } }
public class InviteUserController extends Controller { @ FXML public ListView < User > invited ; @ FXML public ListView < User > declined ; @ FXML public ListView < User > accepted ; @ FXML public ComboBox < User > searchPerson ; @ FXML public void handleSearchPerson ( ActionEvent actionEvent ) { } @ Override public void initialize ( URL location , ResourceBundle resources ) { } private Appointment appointment ; public void setAppointment ( Appointment appointment ) { } public Appointment getAppointment ( ) { } public void setListOfPerson ( ListView < User > listOfPerson , ObservableList < User > persons , Color color ) { if ( ( appointment ) != null ) { listOfPerson . setItems ( persons ) ; listOfPerson . setCellFactory ( ( list ) -> { return new ListCell < User > ( ) { @ Override protected void updateItem ( User item , boolean empty ) { super . updateItem ( item , empty ) ; if ( ( item == null ) || empty ) { setText ( null ) ; } else { setTextFill ( color ) ; setText ( item . getEmail ( ) ) ; } } } ; } ) ; listOfPerson . setOnMouseClicked ( new EventHandler < MouseEvent > ( ) { @ Override public void handle ( MouseEvent click ) { if ( ( click . getClickCount ( ) ) == 2 ) { User user = listOfPerson . getSelectionModel ( ) . getSelectedItem ( ) ; if ( user == null ) { return ; } else { Action response = Dialogs . create ( ) . title ( "Remove<seq2seq4repair_space>person?" ) . message ( "Do<seq2seq4repair_space>want<seq2seq4repair_space>to<seq2seq4repair_space>remove<seq2seq4repair_space>this<seq2seq4repair_space>person<seq2seq4repair_space>from<seq2seq4repair_space>the<seq2seq4repair_space>appointment?" ) . showConfirm ( ) ; <START_BUG> if ( response == ( Actions . YES ) ) { <END_BUG> listOfPerson . getItems ( ) . remove ( user ) ; } } } } } ) ; } } @ FXML public void handleCancel ( ActionEvent actionEvent ) { } @ FXML public void handleSave ( ActionEvent actionEvent ) { } }
public class UpToDate extends MatchingTask implements Condition { private ArrayList sourceFileSets = new ArrayList ( ) ; protected Mapper mapperElement = null ; private String _property ; private File _targetFile ; private String _value ; public void setProperty ( String property ) { } public void setTargetFile ( File file ) { } public void setValue ( String value ) { } public void addSrcfiles ( FileSet fs ) { } public Mapper createMapper ( ) throws TaskException { if ( ( mapperElement ) != null ) { throw new TaskException ( "Cannot<seq2seq4repair_space>define<seq2seq4repair_space>more<seq2seq4repair_space>than<seq2seq4repair_space>one<seq2seq4repair_space>mapper" ) ; } <START_BUG> mapperElement = new Mapper ( getProject ( ) ) ; <END_BUG> return mapperElement ; } public boolean eval ( ) throws TaskException { } public void execute ( ) throws TaskException { } protected boolean scanDir ( File srcDir , String [ ] files ) throws TaskException { } private String getValue ( ) { } }
public class TwoPhaseCommitEventProcessor implements IEventProcessor , ISharedObjectContainerTransaction { BaseSharedObject sharedObject = null ; byte transactionState = ISharedObjectContainerTransaction . ACTIVE ; Object lock = new Object ( ) ; List participants = new Vector ( ) ; Map failed = new HashMap ( ) ; int timeout = ISharedObjectTransactionConfig . DEFAULT_TIMEOUT ; int minFailedToAbort = 0 ; long identifier = 0 ; ISharedObjectTransactionParticipantsFilter participantsFilter = null ; public TwoPhaseCommitEventProcessor ( BaseSharedObject bse , ISharedObjectTransactionConfig config ) { } protected void trace ( String msg ) { } protected void traceStack ( String msg , Throwable t ) { } protected int getTimeout ( ) { } protected int getMinFailedToAbort ( ) { } protected boolean isPrimary ( ) { } protected BaseSharedObject getSharedObject ( ) { } protected ID getHomeID ( ) { } protected void addParticipants ( ID [ ] ids ) { } protected void removeParticipant ( ID id ) { } protected void addFailed ( ID remote , Throwable failure ) { } protected ISharedObjectContext getContext ( ) { } public boolean processEvent ( Event event ) { } protected void handleActivated ( ISharedObjectActivatedEvent event ) { } protected void replicateTo ( ID [ ] remotes ) { } protected void handlePrimaryActivated ( ISharedObjectActivatedEvent event ) { } private long getNextIdentifier ( ) { } protected void handleReplicaActivated ( ISharedObjectActivatedEvent event ) { } protected void handleJoined ( IContainerConnectedEvent event ) { } protected void handleCreateResponse ( ISharedObjectCreateResponseEvent event ) { } protected void handleDeparted ( IContainerDisconnectedEvent event ) { } protected void handleVotingCompletedCreateResponse ( ID fromID , Throwable e , long identifier1 ) { } protected void handlePostCommitFailure ( ID fromID , Throwable e , long identifier1 ) { } protected void sendCommit ( ) throws SharedObjectAddAbortException { } public byte getTransactionState ( ) { } protected void setTransactionState ( byte state ) { } public void waitToCommit ( ) throws SharedObjectAddAbortException { } protected void doTMAbort ( Throwable except ) throws SharedObjectAddAbortException { } protected void doTMCommit ( ) throws SharedObjectAddAbortException { trace ( "doTMCommit" ) ; <START_BUG> if ( ( getSharedObject ( ) . getGroupID ( ) ) != null ) { <END_BUG> sendCommit ( ) ; } localCommitted ( ) ; } protected void localCommitted ( ) { } protected boolean isVotingCompleted ( ) throws SharedObjectAddAbortException { } }
public class CustomLoadMetricDefinition extends SimpleResourceDefinition { static final PathElement PATH = PathElement . pathElement ( CUSTOM_LOAD_METRIC ) ; protected static final CustomLoadMetricDefinition INSTANCE = new CustomLoadMetricDefinition ( ) ; static final SimpleAttributeDefinition CLASS = SimpleAttributeDefinitionBuilder . create ( CommonAttributes . CLASS , STRING , false ) . setAllowExpression ( false ) . setRestartAllServices ( ) . build ( ) ; static final AttributeDefinition [ ] ATTRIBUTES = new AttributeDefinition [ ] { CustomLoadMetricDefinition . CLASS , LoadMetricDefinition . WEIGHT , LoadMetricDefinition . CAPACITY , LoadMetricDefinition . PROPERTY } ; static void buildTransformation ( ModelVersion version , ResourceTransformationDescriptionBuilder builder ) { <START_BUG> if ( VERSION_1_2_0 . requiresTransformation ( version ) ) { <END_BUG> builder . addChildResource ( CustomLoadMetricDefinition . PATH ) . getAttributeBuilder ( ) . addRejectCheck ( SIMPLE_EXPRESSIONS , CustomLoadMetricDefinition . CLASS , LoadMetricDefinition . WEIGHT ) . addRejectCheck ( CapacityCheckerAndConverter . INSTANCE , LoadMetricDefinition . CAPACITY ) . setValueConverter ( CapacityCheckerAndConverter . INSTANCE , LoadMetricDefinition . CAPACITY ) . end ( ) ; } } private CustomLoadMetricDefinition ( ) { } @ Override public void registerAttributes ( ManagementResourceRegistration resourceRegistration ) { } }
public class LineBreakHandler implements CharacterHandler { private final boolean fallbackToEscape ; private final boolean leaveOnLnBreak ; public LineBreakHandler ( boolean leaveOnLnBreak , boolean fallbackToEscape ) { } @ Override public void handle ( ParsingContext ctx ) throws CommandFormatException { if ( ( ctx . getCharacter ( ) ) == '\\' ) { if ( ( ( ctx . getInput ( ) . length ( ) ) > ( ( ctx . getLocation ( ) ) + ( LINE_SEPARATOR . length ( ) ) ) ) && ( ctx . getInput ( ) . startsWith ( LINE_SEPARATOR , ( ( ctx . getLocation ( ) ) + 1 ) ) ) ) { if ( leaveOnLnBreak ) { ctx . leaveState ( ) ; ctx . advanceLocation ( LINE_SEPARATOR . length ( ) ) ; } } else if ( fallbackToEscape ) { ctx . enterState ( INSTANCE ) ; } else { <START_BUG> doHandle ( ctx ) ; <END_BUG> } } else { doHandle ( ctx ) ; } } protected void doHandle ( ParsingContext ctx ) throws CommandFormatException { } }
@ DPU . AsTransformer public class Relational extends ConfigurableBase < RelationalConfig_V1 > implements ConfigDialogProvider < RelationalConfig_V1 > { private static final Logger LOG = LoggerFactory . getLogger ( Relational . class ) ; private Messages messages ; private DPUContext context ; @ AsInput ( name = "inputTables" ) public RelationalDataUnit inputTables ; @ AsOutput ( name = "outputTable" ) public WritableRelationalDataUnit outputTable ; public Relational ( ) { } @ Override public void execute ( DPUContext context ) throws DPUException , InterruptedException { this . context = context ; this . messages = new Messages ( this . context . getLocale ( ) , this . getClass ( ) . getClassLoader ( ) ) ; String targetTableName = this . config . getTargetTableName ( ) . toUpperCase ( ) ; String userSqlQuery = this . config . getSqlQuery ( ) ; Iterator < RelationalDataUnit . Entry > tablesIteration ; try { tablesIteration = RelationalHelper . getTables ( this . inputTables ) . iterator ( ) ; } catch ( DataUnitException ex ) { this . context . sendMessage ( ERROR , this . messages . getString ( "errors.dpu.failed" ) , this . messages . getString ( "errors.tables.iterator" ) , ex ) ; return ; } int tablesCount = 0 ; while ( tablesIteration . hasNext ( ) ) { tablesIteration . next ( ) ; tablesCount ++ ; } if ( tablesCount < 1 ) { this . context . sendMessage ( ERROR , this . messages . getString ( "errors.dpu.failed" ) , this . messages . getString ( "errors.tables.input" ) ) ; return ; } Connection conn = null ; Statement stmnt = null ; try { conn = getDbConnectionInternal ( ) ; if ( DatabaseHelper . checkTableExists ( conn , targetTableName ) ) { <START_BUG> this . context . sendMessage ( ERROR , this . messages . getString ( "errors.db.tableunique.short" ) , this . messages . getString ( "errors.db.tableunique.long" ) ) ; <END_BUG> return ; } Relational . LOG . debug ( "Going<seq2seq4repair_space>to<seq2seq4repair_space>convert<seq2seq4repair_space>user<seq2seq4repair_space>select<seq2seq4repair_space>SQL<seq2seq4repair_space>query<seq2seq4repair_space>{}<seq2seq4repair_space>to<seq2seq4repair_space>Select<seq2seq4repair_space>into<seq2seq4repair_space>query" , userSqlQuery ) ; String selectIntoQuery = DatabaseHelper . convertSelectQueryToSelectIntoQuery ( userSqlQuery , targetTableName ) ; Relational . LOG . debug ( "Query<seq2seq4repair_space>converted<seq2seq4repair_space>to:<seq2seq4repair_space>{}" , selectIntoQuery ) ; Relational . LOG . debug ( "Executing<seq2seq4repair_space>SQL<seq2seq4repair_space>transformation<seq2seq4repair_space>of<seq2seq4repair_space>input<seq2seq4repair_space>tables<seq2seq4repair_space>into<seq2seq4repair_space>output<seq2seq4repair_space>table" ) ; stmnt = conn . createStatement ( ) ; stmnt . execute ( selectIntoQuery ) ; Relational . LOG . debug ( "Transformation<seq2seq4repair_space>of<seq2seq4repair_space>input<seq2seq4repair_space>tables<seq2seq4repair_space>into<seq2seq4repair_space>output<seq2seq4repair_space>table<seq2seq4repair_space>successful" ) ; Relational . LOG . debug ( "Saving<seq2seq4repair_space>output<seq2seq4repair_space>table<seq2seq4repair_space>into<seq2seq4repair_space>output<seq2seq4repair_space>relational<seq2seq4repair_space>data<seq2seq4repair_space>unit" ) ; this . outputTable . addExistingDatabaseTable ( targetTableName , targetTableName ) ; Relational . LOG . debug ( "Output<seq2seq4repair_space>table<seq2seq4repair_space>successfully<seq2seq4repair_space>saved<seq2seq4repair_space>into<seq2seq4repair_space>output<seq2seq4repair_space>relational<seq2seq4repair_space>data<seq2seq4repair_space>unit" ) ; } catch ( SQLException se ) { Relational . LOG . error ( "Database<seq2seq4repair_space>error<seq2seq4repair_space>occured<seq2seq4repair_space>during<seq2seq4repair_space>transforming<seq2seq4repair_space>database<seq2seq4repair_space>tables" , se ) ; DatabaseHelper . tryRollbackConnection ( conn ) ; throw new DPUException ( this . messages . getString ( "errors.db.transformfailed" ) , se ) ; } catch ( Exception e ) { Relational . LOG . error ( "Error<seq2seq4repair_space>occured<seq2seq4repair_space>during<seq2seq4repair_space>transforming<seq2seq4repair_space>database<seq2seq4repair_space>tables" , e ) ; throw new DPUException ( this . messages . getString ( "errors.transformfailed" ) , e ) ; } finally { DatabaseHelper . tryCloseStatement ( stmnt ) ; DatabaseHelper . tryCloseConnection ( conn ) ; } } @ Override public AbstractConfigDialog < RelationalConfig_V1 > getConfigurationDialog ( ) { } private Connection getDbConnectionInternal ( ) throws DataUnitException { } }
public class FileParser { private DataSource data ; private boolean architecture ; private boolean registers ; private boolean mnemonicData ; private boolean instructionFormat ; private boolean adt ; private boolean endian ; private boolean foundArchitecture ; private boolean foundRegisters ; private boolean foundMnemData ; private boolean foundInsFormat ; private boolean foundAdt ; private boolean foundEndian ; private boolean atMnemName ; private boolean working ; private boolean atGlobalOpcodes ; private boolean first ; private boolean emptyLine ; private boolean atMnemTypeHeader ; private boolean atMnemType ; private boolean abort ; private boolean atLocalInsLabels ; private boolean atLocalOpcodes ; private boolean atLocalInsFormat ; private boolean firstAdtEntry ; private MnemonicData currentMnemonicData ; private MnemType currentMnemType ; public FileParser ( String specFile , String assemblyFile ) { } private void scanAssemblyFile ( String fileName ) { } private void scanSpecFile ( String fileName ) { } private void scanLine ( String line ) throws AssemblerException { } private void analyseEndian ( String line ) throws AssemblerException { } private void analyseADT ( String line ) throws AssemblerException { } private void setBooleanValues ( boolean architecture , boolean registers , boolean mnemonicData , boolean instructionFormat , boolean adt , boolean endian ) { } private void analyseArchitecture ( String line ) { } private void analyseRegisters ( String line ) throws AssemblerException { } private void analyseMnemonicData ( String line ) throws AssemblerException { } private void analyseMnemName ( String line ) throws AssemblerException { } private void analyseMnemHeader ( String line ) { } private void analyseMnemType ( String line ) throws AssemblerException { } private void resetBooleanValues ( ) { abort = false ; atMnemName = false ; <START_BUG> atGlobalOpcodes = true ; <END_BUG> first = true ; working = false ; emptyLine = false ; atMnemType = false ; atLocalInsLabels = false ; atLocalOpcodes = false ; atLocalInsFormat = false ; currentMnemonicData = null ; } private void analyseGlobalOpcodes ( String opcodes ) throws AssemblerException { } private void analyseInstructionFormat ( String line ) throws AssemblerException { } private boolean isBinary ( String s ) { } public DataSource getData ( ) { } }
public class DropDownChoice extends AbstractSingleSelectChoice implements IOnChangeListener { private static final long serialVersionUID = 1L ; public DropDownChoice ( final String id ) { } public DropDownChoice ( final String id , final List choices ) { } public DropDownChoice ( final String id , final List data , final IChoiceRenderer renderer ) { } public DropDownChoice ( final String id , IModel model , final List choices ) { } public DropDownChoice ( final String id , IModel model , final List data , final IChoiceRenderer renderer ) { } public DropDownChoice ( String id , IModel choices ) { } public DropDownChoice ( String id , IModel model , IModel choices ) { } public DropDownChoice ( String id , IModel choices , IChoiceRenderer renderer ) { } public DropDownChoice ( String id , IModel model , IModel choices , IChoiceRenderer renderer ) { } public final void onSelectionChanged ( ) { } protected void onComponentTag ( final ComponentTag tag ) { checkComponentTag ( tag , "select" ) ; if ( wantOnSelectionChangedNotifications ( ) ) { <START_BUG> final String url = urlFor ( INTERFACE ) ; <END_BUG> try { Form form = getForm ( ) ; tag . put ( "onChange" , form . getJsForInterfaceUrl ( url ) ) ; } catch ( WicketRuntimeException ex ) { tag . put ( "onChange" , ( ( ( ( "location.href='" + url ) + "&" ) + ( getInputName ( ) ) ) + "='<seq2seq4repair_space>+<seq2seq4repair_space>this.options[this.selectedIndex].value;" ) ) ; } } super . onComponentTag ( tag ) ; } protected void onSelectionChanged ( final Object newSelection ) { } protected boolean wantOnSelectionChangedNotifications ( ) { } }
public class TestUtils { private TestUtils ( ) { } public static void assertEquals ( double expected , double actual , double delta ) { } public static void assertEquals ( String msg , double expected , double actual , double delta ) { } public static void assertSame ( double expected , double actual ) { } public static void assertSame ( Complex expected , Complex actual ) { } public static void assertEquals ( Complex expected , Complex actual , double delta ) { } public static void assertEquals ( double [ ] expected , double [ ] observed , double tolerance ) { } public static Object serializeAndRecover ( Object o ) { } public static void checkSerializedEquality ( Object object ) { } public static void assertRelativelyEquals ( double expected , double actual , double relativeError ) { } public static void assertRelativelyEquals ( String msg , double expected , double actual , double relativeError ) { } public static void assertContains ( String msg , Complex [ ] values , Complex z , double epsilon ) { } public static void assertContains ( Complex [ ] values , Complex z , double epsilon ) { } public static void assertContains ( String msg , double [ ] values , double x , double epsilon ) { } public static void assertContains ( double [ ] values , double x , double epsilon ) { } public static void assertEquals ( String msg , RealMatrix expected , RealMatrix observed , double tolerance ) { } public static void assertEquals ( FieldMatrix < ? extends FieldElement < ? > > expected , FieldMatrix < ? extends FieldElement < ? > > observed ) { } public static void assertEquals ( String msg , double [ ] expected , double [ ] observed , double tolerance ) { StringBuffer out = new StringBuffer ( msg ) ; if ( ( expected . length ) != ( observed . length ) ) { out . append ( "\n<seq2seq4repair_space>Arrays<seq2seq4repair_space>not<seq2seq4repair_space>same<seq2seq4repair_space>length.<seq2seq4repair_space>\n" ) ; out . append ( "expected<seq2seq4repair_space>has<seq2seq4repair_space>length<seq2seq4repair_space>" ) ; out . append ( expected . length ) ; out . append ( "<seq2seq4repair_space>observed<seq2seq4repair_space>length<seq2seq4repair_space>=<seq2seq4repair_space>" ) ; out . append ( observed . length ) ; Assert . fail ( out . toString ( ) ) ; } boolean failure = false ; for ( int i = 0 ; i < ( expected . length ) ; i ++ ) { try { <START_BUG> Assert . assertEquals ( expected [ i ] , observed [ i ] , tolerance ) ; <END_BUG> } catch ( AssertionFailedError ex ) { failure = true ; out . append ( "\n<seq2seq4repair_space>Elements<seq2seq4repair_space>at<seq2seq4repair_space>index<seq2seq4repair_space>" ) ; out . append ( i ) ; out . append ( "<seq2seq4repair_space>differ.<seq2seq4repair_space>" ) ; out . append ( "<seq2seq4repair_space>expected<seq2seq4repair_space>=<seq2seq4repair_space>" ) ; out . append ( expected [ i ] ) ; out . append ( "<seq2seq4repair_space>observed<seq2seq4repair_space>=<seq2seq4repair_space>" ) ; out . append ( observed [ i ] ) ; } } if ( failure ) { Assert . fail ( out . toString ( ) ) ; } } public static < T extends FieldElement < T > > void assertEquals ( T [ ] m , T [ ] n ) { } }
public class TreeSelectionManager extends SelectionManager { protected FolderTreeNode folder ; protected Vector treeListenerList ; public TreeSelectionManager ( ) { } public FolderTreeNode getFolder ( ) { } public void addFolderSelectionListener ( FolderSelectionListener listener ) { } public void fireFolderSelectionEvent ( FolderTreeNode oldFolder , FolderTreeNode newFolder ) { } public DefaultCommandReference [ ] getSelection ( ) { log . info ( ( "folder=" + ( folder ) ) ) ; FolderCommandReference [ ] references = new FolderCommandReference [ 1 ] ; <START_BUG> references [ 0 ] = new FolderCommandReference ( ( ( Folder ) ( folder ) ) ) ; <END_BUG> return references ; } }
public class Snippet83 extends ByteArrayTransfer { private static Snippet83 _instance = new Snippet83 ( ) ; private int [ ] ids ; private String [ ] names ; public static void main ( String [ ] args ) { Display display = new Display ( ) ; Shell shell = new Shell ( display ) ; shell . setLayout ( new FillLayout ( ) ) ; Canvas canvas = new Canvas ( shell , SWT . NONE ) ; DropTarget target = new DropTarget ( canvas , ( ( DND . DROP_DEFAULT ) | ( DND . DROP_LINK ) ) ) ; target . setTransfer ( new Transfer [ ] { Snippet83 . getInstance ( ) } ) ; target . addDropListener ( new DropTargetAdapter ( ) { public void dragEnter ( DropTargetEvent event ) { <START_BUG> String ops = null ; <END_BUG> if ( ( ( event . operations ) & ( DND . DROP_COPY ) ) != 0 ) ops += "Copy;" ; if ( ( ( event . operations ) & ( DND . DROP_MOVE ) ) != 0 ) ops += "Move;" ; if ( ( ( event . operations ) & ( DND . DROP_LINK ) ) != 0 ) ops += "Link;" ; System . out . println ( ( "Allowed<seq2seq4repair_space>Operations<seq2seq4repair_space>are<seq2seq4repair_space>" + ops ) ) ; TransferData [ ] data = event . dataTypes ; for ( int i = 0 ; i < ( data . length ) ; i ++ ) { int id = data [ i ] . type ; String name = Snippet83 . getNameFromId ( id ) ; System . out . println ( ( ( ( "Data<seq2seq4repair_space>type<seq2seq4repair_space>is<seq2seq4repair_space>" + id ) + "<seq2seq4repair_space>" ) + name ) ) ; } } } ) ; shell . setSize ( 400 , 400 ) ; shell . open ( ) ; while ( ! ( shell . isDisposed ( ) ) ) { if ( ! ( display . readAndDispatch ( ) ) ) display . sleep ( ) ; } display . dispose ( ) ; } public static Snippet83 getInstance ( ) { } Snippet83 ( ) { } public void javaToNative ( Object object , TransferData transferData ) { } public Object nativeToJava ( TransferData transferData ) { } protected String [ ] getTypeNames ( ) { } protected int [ ] getTypeIds ( ) { } static String getNameFromId ( int id ) { } }
public class ContextAdmin { private ContextManager cm ; private Request realRequest ; private String submit = null ; private String addContextPath = null ; private String addContextDocBase = null ; private String removeContextName = null ; public void setSubmit ( String s ) { } public void setAddContextPath ( String s ) { } public void setAddContextDocBase ( String s ) { } public void setRemoveContextName ( String s ) { } public void init ( HttpServletRequest request ) { } public Enumeration getContextNames ( ) { } public String [ ] getContextInfo ( String contextName ) { ( Enumeration ) ++ ; String key ; Context context ; Vector v = new Vector ( ) ; context = cm . getContext ( contextName ) ; v . addElement ( ( "DOC<seq2seq4repair_space>BASE:<seq2seq4repair_space>" + ( context . getDocBase ( ) ) ) ) ; <START_BUG> v . addElement ( ( "FULL<seq2seq4repair_space>DOC<seq2seq4repair_space>BASE:<seq2seq4repair_space>" + ( context . getDocumentBase ( ) . toString ( ) ) ) ) ; <END_BUG> v . addElement ( ( "PATH:<seq2seq4repair_space>" + ( context . getPath ( ) ) ) ) ; if ( ( context . getWorkDir ( ) ) != null ) v . addElement ( ( "WORK<seq2seq4repair_space>DIR:<seq2seq4repair_space>" + ( RequestUtil . URLDecode ( context . getWorkDir ( ) . getName ( ) ) ) ) ) ; v . addElement ( ( "DESCRIPTION:<seq2seq4repair_space>" + ( context . getDescription ( ) ) ) ) ; v . addElement ( ( "SESSION<seq2seq4repair_space>TIMEOUT:<seq2seq4repair_space>" + ( new Integer ( context . getSessionTimeOut ( ) ) . toString ( ) ) ) ) ; } public String addContext ( ) { } public String removeContext ( ) { } }
public class SearchMessageAction extends FrameAction { public SearchMessageAction ( AbstractFrameController controller ) { } public void actionPerformed ( ActionEvent evt ) { Folder searchFolder = ( ( Folder ) ( treeModel . getFolder ( 106 ) ) ) ; <START_BUG> SearchFrame frame = new SearchFrame ( ( ( AbstractMailFrameController ) ( getFrameController ( ) ) ) , searchFolder ) ; <END_BUG> } }
public class FileUtils { private static Random rand = new Random ( System . currentTimeMillis ( ) ) ; private static Object lockReflection = new Object ( ) ; private static Method setLastModified = null ; private boolean onNetWare = Os . isFamily ( "netware" ) ; private static boolean [ ] isSpecial = new boolean [ 256 ] ; private static char [ ] escapedChar1 = new char [ 256 ] ; private static char [ ] escapedChar2 = new char [ 256 ] ; public static FileUtils newFileUtils ( ) { } protected FileUtils ( ) { } public URL getFileURL ( File file ) throws MalformedURLException { } public void copyFile ( String sourceFile , String destFile ) throws IOException { } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters ) throws IOException { } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { } public void copyFile ( File sourceFile , File destFile ) throws IOException { } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters ) throws IOException { } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { } protected final Method getSetLastModified ( ) { } public void setFileLastModified ( File file , long time ) throws BuildException { } public File resolveFile ( File file , String filename ) { } public File normalize ( String path ) { } public File createTempFile ( String prefix , String suffix , File parentDir ) { } public boolean contentEquals ( File f1 , File f2 ) throws IOException { } public File getParentFile ( File f ) { } public static final String readFully ( Reader rdr ) throws IOException { } public static final String readFully ( Reader rdr , int bufferSize ) throws IOException { } public boolean createNewFile ( File f ) throws IOException { } public boolean isSymbolicLink ( File parent , String name ) throws IOException { } public String removeLeadingPath ( File leading , File path ) { } public String toURI ( String path ) { boolean isDir = new File ( path ) . isDirectory ( ) ; StringBuffer sb = new StringBuffer ( "file:" ) ; try { path = normalize ( path ) . getAbsolutePath ( ) ; sb . append ( "//" ) ; <START_BUG> if ( ! ( path . startsWith ( "/" ) ) ) { <END_BUG> sb . append ( "/" ) ; } } catch ( BuildException e ) { } path = path . replace ( '\\' , '/' ) ; CharacterIterator iter = new StringCharacterIterator ( path ) ; for ( char c = iter . first ( ) ; c != ( CharacterIterator . DONE ) ; c = iter . next ( ) ) { if ( FileUtils . isSpecial [ c ] ) { sb . append ( '%' ) ; sb . append ( FileUtils . escapedChar1 [ c ] ) ; sb . append ( FileUtils . escapedChar2 [ c ] ) ; } else { sb . append ( c ) ; } } if ( isDir && ( ! ( path . endsWith ( "/" ) ) ) ) { sb . append ( '/' ) ; } return sb . toString ( ) ; } public String fromURI ( String uri ) { } public boolean fileNameEquals ( File f1 , File f2 ) { } public void rename ( File from , File to ) throws IOException { } }
public class TestThreadedForceMerge extends LuceneTestCase { private static Analyzer ANALYZER ; private static final int NUM_THREADS = 3 ; private static final int NUM_ITER = 1 ; private static final int NUM_ITER2 = 1 ; private volatile boolean failed ; @ BeforeClass public static void setup ( ) { } private void setFailed ( ) { } public void runTest ( Random random , Directory directory ) throws Exception { IndexWriter writer = new IndexWriter ( directory , newIndexWriterConfig ( TEST_VERSION_CURRENT , TestThreadedForceMerge . ANALYZER ) . setOpenMode ( CREATE ) . setMaxBufferedDocs ( 2 ) . setMergePolicy ( newLogMergePolicy ( ) ) ) ; for ( int iter = 0 ; iter < ( TestThreadedForceMerge . NUM_ITER ) ; iter ++ ) { final int iterFinal = iter ; ( ( LogMergePolicy ) ( writer . getConfig ( ) . getMergePolicy ( ) ) ) . setMergeFactor ( 1000 ) ; final FieldType customType = new FieldType ( StringField . TYPE_STORED ) ; customType . setOmitNorms ( true ) ; for ( int i = 0 ; i < 200 ; i ++ ) { Document d = new Document ( ) ; d . add ( newField ( "id" , Integer . toString ( i ) , customType ) ) ; d . add ( newField ( "contents" , English . intToEnglish ( i ) , customType ) ) ; writer . addDocument ( d ) ; } ( ( LogMergePolicy ) ( writer . getConfig ( ) . getMergePolicy ( ) ) ) . setMergeFactor ( 4 ) ; Thread [ ] threads = new Thread [ TestThreadedForceMerge . NUM_THREADS ] ; for ( int i = 0 ; i < ( TestThreadedForceMerge . NUM_THREADS ) ; i ++ ) { final int iFinal = i ; final IndexWriter writerFinal = writer ; threads [ i ] = new Thread ( ) { @ Override public void run ( ) { try { for ( int j = 0 ; j < ( TestThreadedForceMerge . NUM_ITER2 ) ; j ++ ) { writerFinal . forceMerge ( 1 , false ) ; for ( int k = 0 ; k < ( 17 * ( 1 + iFinal ) ) ; k ++ ) { Document d = new Document ( ) ; d . add ( newField ( "id" , ( ( ( ( ( ( iterFinal + "_" ) + iFinal ) + "_" ) + j ) + "_" ) + k ) , customType ) ) ; d . add ( newField ( "contents" , English . intToEnglish ( ( iFinal + k ) ) , customType ) ) ; writerFinal . addDocument ( d ) ; } for ( int k = 0 ; k < ( 9 * ( 1 + iFinal ) ) ; k ++ ) writerFinal . deleteDocuments ( new Term ( "id" , ( ( ( ( ( ( iterFinal + "_" ) + iFinal ) + "_" ) + j ) + "_" ) + k ) ) ) ; writerFinal . forceMerge ( 1 ) ; } } catch ( Throwable t ) { setFailed ( ) ; System . out . println ( ( ( Thread . currentThread ( ) . getName ( ) ) + ":<seq2seq4repair_space>hit<seq2seq4repair_space>exception" ) ) ; t . printStackTrace ( System . out ) ; } } } ; } for ( int i = 0 ; i < ( TestThreadedForceMerge . NUM_THREADS ) ; i ++ ) threads [ i ] . start ( ) ; for ( int i = 0 ; i < ( TestThreadedForceMerge . NUM_THREADS ) ; i ++ ) threads [ i ] . join ( ) ; assertTrue ( ( ! ( failed ) ) ) ; final int expectedDocCount = ( ( int ) ( ( 1 + iter ) * ( 200 + ( ( ( 8 * ( TestThreadedForceMerge . NUM_ITER2 ) ) * ( ( TestThreadedForceMerge . NUM_THREADS ) / 2.0 ) ) * ( 1 + ( TestThreadedForceMerge . NUM_THREADS ) ) ) ) ) ) ; assertEquals ( ( ( ( ( ( ( ( "index=" + ( writer . segString ( ) ) ) + "<seq2seq4repair_space>numDocs=" ) + ( writer . numDocs ( ) ) ) + "<seq2seq4repair_space>maxDoc=" ) + ( writer . maxDoc ( ) ) ) + "<seq2seq4repair_space>config=" ) + ( writer . getConfig ( ) ) ) , expectedDocCount , writer . numDocs ( ) ) ; assertEquals ( ( ( ( ( ( ( ( "index=" + ( writer . segString ( ) ) ) + "<seq2seq4repair_space>numDocs=" ) + ( writer . numDocs ( ) ) ) + "<seq2seq4repair_space>maxDoc=" ) + ( writer . maxDoc ( ) ) ) + "<seq2seq4repair_space>config=" ) + ( writer . getConfig ( ) ) ) , expectedDocCount , writer . maxDoc ( ) ) ; writer . close ( ) ; writer = new IndexWriter ( directory , newIndexWriterConfig ( TEST_VERSION_CURRENT , TestThreadedForceMerge . ANALYZER ) . setOpenMode ( APPEND ) . setMaxBufferedDocs ( 2 ) ) ; DirectoryReader reader = DirectoryReader . open ( directory ) ; <START_BUG> assertEquals ( ( "reader=" + reader ) , 1 , reader . getSequentialSubReaders ( ) . size ( ) ) ; <END_BUG> assertEquals ( expectedDocCount , reader . numDocs ( ) ) ; reader . close ( ) ; } writer . close ( ) ; } public void testThreadedForceMerge ( ) throws Exception { } }
@ RestController public class TaskService { private TeamMemberDao teamMemberDao ; private QuestStatusDao questStatusDao ; private QuestDao questDao ; private TaskDao taskDao ; @ RequestMapping ( value = "/getLatestTask" , headers = "Accept=application/json" ) public TaskEntity getLatestAvialableTask ( @ RequestParam String deviceId ) { } @ RequestMapping ( value = "/getAvailableTasks" , headers = "Accept=application/json" ) public List < TaskEntityForClientDTO > getAvailableQuests ( @ RequestParam String deviceId ) { } @ RequestMapping ( value = "/attemptSolution" , headers = "Accept=application/json" ) public Object attemptSolution ( @ RequestParam String solutionCandidate , @ RequestParam Long taskId , @ RequestParam String deviceId ) throws JSONException { TaskEntity taskEntity = taskDao . getById ( taskId ) ; TeamMemberEntity teamMember = teamMemberDao . getTeamMemberById ( deviceId ) ; if ( StringUtils . equalsIgnoreCase ( taskEntity . getSolution ( ) , solutionCandidate ) ) { <START_BUG> QuestStatusEntity questStatusEntity = questStatusDao . getByTeam ( team ) ; <END_BUG> if ( ( questStatusEntity . getTasksCompleted ( ) ) != ( ( taskEntity . getTaskOrdinalNumber ( ) ) - 1 ) ) return new Status ( "WRONG<seq2seq4repair_space>TASK<seq2seq4repair_space>ATTEMPTED" ) ; questStatusEntity . setTasksCompleted ( ( ( questStatusEntity . getTasksCompleted ( ) ) + 1 ) ) ; return new TaskStatusEntity ( "Completed" , getLatestAvialableTask ( deviceId ) . getTaskId ( ) ) ; } else { return new Status ( "WRONG" ) ; } } @ RequestMapping ( value = "/getTasksByQuest" , headers = "Accept=application/json" ) public List < TaskEntity > getTasksByQuest ( @ RequestParam Long questId ) { } @ RequestMapping ( value = "/insertTask" , headers = "Accept=application/json" , method = RequestMethod . POST ) public Status insertTask ( @ RequestParam Long questId , @ RequestParam String name , @ RequestParam String description , @ RequestParam String photo , @ RequestParam int ordinalNumber , @ RequestParam String taskType , @ RequestParam String solution ) { } @ RequestMapping ( value = "/removeTaskByTaskId" , headers = "Accept=application/json" , method = RequestMethod . POST ) public Status removeTaskByTaskId ( @ RequestParam Long taskId ) { } @ RequestMapping ( value = "/updateTask" , headers = "Accept=application/json" , method = RequestMethod . POST ) public Status updateTaskByTaskId ( @ RequestParam Long taskId , @ RequestParam String name , @ RequestParam String description , @ RequestParam String photo , @ RequestParam int ordinalNumber , @ RequestParam String taskType , @ RequestParam String solution ) { } @ RequestMapping ( value = "/getTaskById" , headers = "Accept=application/json" , method = RequestMethod . GET ) public TaskEntityForClientDTO getTaskById ( @ RequestParam String deviceId , @ RequestParam Long taskId ) { } public void setTeamMemberDao ( TeamMemberDao teamMemberDao ) { } public void setQuestStatusDao ( QuestStatusDao questStatusDao ) { } public void setTaskDao ( TaskDao taskDao ) { } public void setQuestDao ( QuestDao questDao ) { } }
public class Piece { public int x ; public int y ; public int index ; public Drawable image ; public Button button ; public boolean isMatched ; public Piece ( Button button , int x , int y ) { } public void setDrawable ( Drawable image ) { } public void setIndex ( int index ) { } public static int getLocation ( int x , int y ) { <START_BUG> return x + ( y * ( MainActivity . COL_COUNT ) ) ; <END_BUG> } }
public class TryStatement extends Statement { public Block tryBlock ; public Block [ ] catchBlocks ; public Argument [ ] catchArguments ; public Block finallyBlock ; BlockScope scope ; public boolean subRoutineCannotReturn = true ; ReferenceBinding [ ] caughtExceptionTypes ; boolean tryBlockExit ; boolean [ ] catchExits ; public int [ ] preserveExceptionHandler ; Label subRoutineStartLabel ; public LocalVariableBinding anyExceptionVariable ; public LocalVariableBinding returnAddressVariable ; public LocalVariableBinding secretReturnValue ; public static final char [ ] SecretReturnName = "<seq2seq4repair_space>returnAddress" . toCharArray ( ) ; public static final char [ ] SecretAnyHandlerName = "<seq2seq4repair_space>anyExceptionHandler" . toCharArray ( ) ; public static final char [ ] SecretLocalDeclarationName = "<seq2seq4repair_space>returnValue" . toCharArray ( ) ; int preTryInitStateIndex = - 1 ; int mergedInitStateIndex = - 1 ; public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public boolean cannotReturn ( ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public void resolve ( BlockScope upperScope ) { this . scope = new BlockScope ( upperScope ) ; BlockScope tryScope = new BlockScope ( scope ) ; BlockScope finallyScope = null ; if ( ( ( finallyBlock ) != null ) && ( ( finallyBlock . statements ) != null ) ) { finallyScope = new BlockScope ( scope , false ) ; MethodScope methodScope = scope . methodScope ( ) ; this . returnAddressVariable = new LocalVariableBinding ( TryStatement . SecretReturnName , upperScope . getJavaLangObject ( ) , AccDefault , false ) ; finallyScope . addLocalVariable ( returnAddressVariable ) ; this . returnAddressVariable . constant = NotAConstant ; this . subRoutineStartLabel = new Label ( ) ; this . anyExceptionVariable = new LocalVariableBinding ( TryStatement . SecretAnyHandlerName , scope . getJavaLangThrowable ( ) , AccDefault , false ) ; finallyScope . addLocalVariable ( this . anyExceptionVariable ) ; this . anyExceptionVariable . constant = NotAConstant ; if ( ! ( methodScope . isInsideInitializer ( ) ) ) { MethodBinding methodBinding = ( ( AbstractMethodDeclaration ) ( methodScope . referenceContext ) ) . binding ; if ( methodBinding != null ) { TypeBinding methodReturnType = methodBinding . returnType ; if ( ( methodReturnType . id ) != ( TypeIds . T_void ) ) { this . secretReturnValue = new LocalVariableBinding ( TryStatement . SecretLocalDeclarationName , methodReturnType , AccDefault , false ) ; finallyScope . addLocalVariable ( this . secretReturnValue ) ; this . secretReturnValue . constant = NotAConstant ; } } } finallyBlock . resolveUsing ( finallyScope ) ; finallyScope . shiftScopes = new BlockScope [ ( catchArguments ) == null ? 1 : ( catchArguments . length ) + 1 ] ; finallyScope . shiftScopes [ 0 ] = tryScope ; } this . tryBlock . resolveUsing ( tryScope ) ; if ( ( this . catchBlocks ) != null ) { int length = this . catchArguments . length ; TypeBinding [ ] argumentTypes = new TypeBinding [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { BlockScope catchScope = new BlockScope ( scope ) ; if ( finallyScope != null ) { finallyScope . shiftScopes [ ( i + 1 ) ] = catchScope ; } if ( ( argumentTypes [ i ] = catchArguments [ i ] . resolveForCatch ( catchScope ) ) == null ) return ; catchBlocks [ i ] . resolveUsing ( catchScope ) ; } this . caughtExceptionTypes = new ReferenceBinding [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { caughtExceptionTypes [ i ] = ( ( ReferenceBinding ) ( argumentTypes [ i ] ) ) ; for ( int j = 0 ; j < i ; j ++ ) { <START_BUG> if ( scope . areTypesCompatible ( caughtExceptionTypes [ i ] , argumentTypes [ j ] ) ) { <END_BUG> scope . problemReporter ( ) . wrongSequenceOfExceptionTypesError ( this , i , j ) ; } } } } else { caughtExceptionTypes = new ReferenceBinding [ 0 ] ; } if ( finallyScope != null ) { this . scope . addSubscope ( finallyScope ) ; } } public String toString ( int tab ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope blockScope ) { } }
public final class SimilarityQueries { private SimilarityQueries ( ) { } public static Query formSimilarQuery ( String body , Analyzer a , String field , Set stop ) throws IOException { TokenStream ts = a . tokenStream ( field , new StringReader ( body ) ) ; Token t ; BooleanQuery tmp = new BooleanQuery ( ) ; Set already = new HashSet ( ) ; while ( ( t = ts . next ( ) ) != null ) { String word = t . termText ( ) ; if ( ( stop != null ) && ( stop . contains ( word ) ) ) continue ; if ( ! ( already . add ( word ) ) ) continue ; TermQuery tq = new TermQuery ( new Term ( field , word ) ) ; try { <START_BUG> tmp . add ( tq , false , false ) ; <END_BUG> } catch ( BooleanQuery too ) { break ; } } return tmp ; } }
public class ActivityRule extends BaseRule { public ActivityRule ( Digester digester , String state ) { } public void begin ( Attributes attributes ) throws Exception { } protected void doInsertionAtBegin ( Attributes attributes ) { } protected void doValidationAtBegin ( Attributes attributes ) { } public void end ( ) throws Exception { } protected void doInsertionAtEnd ( ) throws Exception { ActivityInfo activityInfo = ( ( ActivityInfo ) ( digester . pop ( ) ) ) ; Transaction transaction = ( ( Transaction ) ( digester . pop ( ) ) ) ; Issue issue = ( ( Issue ) ( digester . pop ( ) ) ) ; Attribute attribute = Attribute . getInstance ( activityInfo . getName ( ) ) ; if ( attribute == null ) { attribute = Attribute . getInstance ( ) ; attribute . setName ( activityInfo . getName ( ) ) ; attribute . setAttributeType ( activityInfo . getType ( ) ) ; attribute . setDescription ( "Generated<seq2seq4repair_space>by<seq2seq4repair_space>Data<seq2seq4repair_space>import<seq2seq4repair_space>util" ) ; attribute . save ( ) ; if ( attribute . isOptionAttribute ( ) ) { ParentChildAttributeOption newPCAO = ParentChildAttributeOption . getInstance ( ) ; newPCAO . setName ( activityInfo . getName ( ) ) ; newPCAO . setAttributeId ( attribute . getAttributeId ( ) ) ; newPCAO . save ( ) ; } } AttributeValue attributeValue = null ; boolean createTransaction = transaction . getTransactionType ( ) . getTypeId ( ) . equals ( CREATE_ISSUE__PK ) ; if ( createTransaction ) { attributeValue = AttributeValue . getNewInstance ( attribute , issue ) ; } if ( attribute . isOptionAttribute ( ) ) { <START_BUG> AttributeOption attributeOption = AttributeOption . getInstance ( attribute , activityInfo . getName ( ) ) ; <END_BUG> if ( attributeOption == null ) { ParentChildAttributeOption newPCAO = ParentChildAttributeOption . getInstance ( ) ; newPCAO . setName ( activityInfo . getName ( ) ) ; newPCAO . setAttributeId ( attribute . getAttributeId ( ) ) ; newPCAO . save ( ) ; if ( createTransaction ) { attributeOption = AttributeOption . getInstance ( attribute , activityInfo . getValue ( ) ) ; } } if ( createTransaction ) { attributeValue . setOptionId ( attributeOption . getOptionId ( ) ) ; } } else { if ( createTransaction ) { attributeValue . setValue ( activityInfo . getValue ( ) ) ; } } if ( createTransaction ) { attributeValue . startTransaction ( transaction ) ; attributeValue . save ( ) ; } else { Activity activity = new Activity ( ) ; activity . create ( issue , attribute , activityInfo . getDescription ( ) , transaction , activityInfo . getOldValue ( ) , activityInfo . getValue ( ) ) ; } digester . push ( issue ) ; digester . push ( transaction ) ; } protected void doValidationAtEnd ( ) { } }
public class GenLayerLands extends GenLayer { public GenLayerLands ( long seed ) { } @ Override public int [ ] getInts ( int areaX , int areaZ , int areaWidth , int areaHeight ) { int [ ] biomeGen = IntCache . getIntCache ( ( areaWidth * areaHeight ) ) ; for ( int x = 0 ; x < areaWidth ; x ++ ) for ( int z = 0 ; z < areaHeight ; z ++ ) { initChunkSeed ( ( areaX + x ) , ( areaZ + z ) ) ; <START_BUG> biomeGen [ ( ( x * areaWidth ) + z ) ] = ( mediumNormal . biomeID ) + ( ( nextInt ( 3 ) ) == 0 ? 0 : 1 ) ; <END_BUG> } return biomeGen ; } public static GenLayer [ ] generateBiomeGenLayers ( long seed ) { } No newline ; at end ; of file ; }
public abstract class PrintPostageBaseTest extends WebBaseTest { protected PostageFormHelper printFormHelper ; protected WebPostagePage webPostagePage ; protected PrintPostagePage printPostagePage ; protected PrintPostageModule printPostageModule ; private ReturnAddressBean returnAddressBean ; public PrintPostageBaseTest ( String browser , String url , String username , String password ) { } public ReturnAddressBean getShippingAddressBean ( ) { } @ Override @ BeforeSuite ( alwaysRun = true ) public void signIn ( ) { testHelper . beginTest ( "signIn" ) ; boolean pass = true ; try { <START_BUG> webPostagePage = new WebPostagePage ( launchBrowser ( ) ) ; <END_BUG> printPostagePage = webPostagePage . clickPrintPostage ( ) ; printPostageModule = printPostagePage . getPrintModule ( ) ; printFormHelper = new PostageFormHelper ( webPostagePage ) ; testHelper . log ( "Operating<seq2seq4repair_space>System<seq2seq4repair_space>" , getOs ( ) ) ; testHelper . log ( "Browser<seq2seq4repair_space>and<seq2seq4repair_space>Version<seq2seq4repair_space>" , getBrowserWithVersion ( ) ) ; printFormHelper . getUrl ( ) ; printFormHelper . signIn ( ) ; printFormHelper . setReturnAddressBean ( getShippingAddressBean ( ) ) ; } catch ( Exception sie ) { testHelper . logErrorTagStart ( ) ; errorMessage = sie . getMessage ( ) ; pass = false ; testHelper . logError ( errorMessage ) ; captureScreenShot ( String . format ( "%s_FAIL_%s" , testHelper . getTestName ( ) , errorMessage ) ) ; sie . printStackTrace ( ) ; testHelper . logErrorTagEnd ( ) ; } Assert . assertTrue ( pass , String . format ( "%s:<seq2seq4repair_space>%s<seq2seq4repair_space>" , testHelper . getTestName ( ) , errorMessage ) ) ; testHelper . endTest ( ) ; } @ Override @ AfterSuite ( alwaysRun = true ) public void signOut ( ) { } }
final class EmbedBlob extends ConnectionChild implements Blob , EngineLOB { private boolean materialized ; private PositionedStoreStream myStream ; private int locator = 0 ; private long streamLength = - 1 ; private final int streamPositionOffset ; private boolean isValid = true ; private LOBStreamControl control ; EmbedBlob ( byte [ ] blobBytes , EmbedConnection con ) throws SQLException { } protected EmbedBlob ( DataValueDescriptor dvd , EmbedConnection con ) throws StandardException { } private long setBlobPosition ( long logicalPos ) throws IOException , StandardException { } private int read ( long pos ) throws IOException , StandardException { } public long length ( ) throws SQLException { } public byte [ ] getBytes ( long startPos , int length ) throws SQLException { } public InputStream getBinaryStream ( ) throws SQLException { } public long position ( byte [ ] pattern , long start ) throws SQLException { } private boolean checkMatch ( byte [ ] pattern , long pos ) throws IOException , StandardException { } public long position ( Blob pattern , long start ) throws SQLException { } private boolean checkMatch ( Blob pattern , long pos ) throws IOException , StandardException { } private SQLException handleMyExceptions ( Throwable t ) throws SQLException { } protected void finalize ( ) { } public int setBytes ( long pos , byte [ ] bytes ) throws SQLException { } public int setBytes ( long pos , byte [ ] bytes , int offset , int len ) throws SQLException { } public OutputStream setBinaryStream ( long pos ) throws SQLException { } public void truncate ( long len ) throws SQLException { } public void free ( ) throws SQLException { } public InputStream getBinaryStream ( long pos , long length ) throws SQLException { checkValidity ( ) ; if ( pos <= 0 ) { throw Util . generateCsSQLException ( BLOB_BAD_POSITION , new Long ( pos ) ) ; } if ( length < 0 ) { throw Util . generateCsSQLException ( BLOB_NONPOSITIVE_LENGTH , new Long ( length ) ) ; } <START_BUG> if ( length > ( ( this . length ( ) ) - pos ) ) { <END_BUG> throw Util . generateCsSQLException ( POS_AND_LENGTH_GREATER_THAN_LOB , new Long ( pos ) , new Long ( length ) ) ; } try { return new UpdatableBlobStream ( this , getBinaryStream ( ) , ( pos - 1 ) , length ) ; } catch ( IOException ioe ) { throw Util . setStreamFailure ( ioe ) ; } } private void checkValidity ( ) throws SQLException { } boolean isMaterialized ( ) { } public int getLocator ( ) { } }
public class AprsUtilsTest { private static final int APRS_ID_MAX_LENGTH = 9 ; @ Test public void testClientId ( ) { String clientId = AprsUtils . generateClientId ( ) ; assertTrue ( clientId . contains ( "-" ) ) ; assertTrue ( ( ( clientId . length ( ) ) <= ( AprsUtilsTest . APRS_ID_MAX_LENGTH ) ) ) ; int last = 0 ; for ( int i = 0 ; i < 100 ; i ++ ) { clientId = AprsUtils . generateClientId ( ) ; int n = - 1 ; String suffix = null ; try { String [ ] tokens = clientId . split ( "-" ) ; <START_BUG> assertEquals ( 3 , tokens [ 0 ] . length ( ) ) ; <END_BUG> n = Integer . parseInt ( tokens [ 1 ] , 16 ) ; if ( last != 0 ) { assertNotEquals ( last , n ) ; } last = n ; } catch ( NumberFormatException ex ) { fail ( ( ( "could<seq2seq4repair_space>not<seq2seq4repair_space>convert<seq2seq4repair_space>suffix:<seq2seq4repair_space>" + suffix ) + "<seq2seq4repair_space>to<seq2seq4repair_space>integer" ) ) ; } } } @ Test public void testDegToMeters ( ) { } @ Test public void testDegToDms ( ) { } @ Test public void testDegToIgc ( ) { } @ Test public void testToUtcTimestamp ( ) { } @ Test public void testDistance ( ) { } No newline ; at end ; of file ; }
public class JavaReasoningEngine implements IReasoningEngine { @ Override @ NonNull public MAVOTruthValue checkConstraint ( @ NonNull Model model , ExtendibleElementConstraint constraint , @ NonNull MIDLevel constraintLevel ) { String javaClassName = constraint . getImplementation ( ) ; String modelTypeUri = ( constraintLevel == ( MIDLevel . INSTANCES ) ) ? ( ( Model ) ( constraint . eContainer ( ) ) ) . getMetatypeUri ( ) : ( ( Model ) ( constraint . eContainer ( ) ) ) . getUri ( ) ; try { IJavaModelConstraint javaConstraint = ( ( IJavaModelConstraint ) ( MultiModelTypeRegistry . getTypeBundle ( modelTypeUri ) . loadClass ( javaClassName ) . getConstructor ( ) . newInstance ( ) ) ) ; return javaConstraint . validate ( model ) ; } catch ( Exception e ) { <START_BUG> MMINTException . print ( IStatus . ERROR , ( "Java<seq2seq4repair_space>constraint<seq2seq4repair_space>error,<seq2seq4repair_space>evaluating<seq2seq4repair_space>to<seq2seq4repair_space>false:<seq2seq4repair_space>" + javaClassName ) , e ) ; <END_BUG> return MAVOTruthValue . FALSE ; } } @ Override public boolean checkConstraintConsistency ( @ NonNull Model modelType , String constraint ) { } @ Override @ Nullable public Model refineByConstraint ( @ NonNull Model model ) { } }
public interface ModelAddOperationHandler extends ModelUpdateOperationHandler { <START_BUG> Cancellable execute ( NewOperationContext context , ModelNode operation , ResultHandler resultHandler ) ; <END_BUG> }
public class SetrestoreCommand extends CommandAreaShop { public SetrestoreCommand ( AreaShop plugin ) { } @ Override public String getCommandStart ( ) { } @ Override public String getHelp ( CommandSender target ) { } @ Override public void execute ( CommandSender sender , Command command , String [ ] args ) { if ( ! ( sender . hasPermission ( "areashop.setrestore" ) ) ) { plugin . message ( sender , "setrestore-noPermission" ) ; return ; } if ( ( ( ( args . length ) <= 2 ) || ( ( args [ 1 ] ) == null ) ) || ( ( args [ 2 ] ) == null ) ) { plugin . message ( sender , "setrestore-help" ) ; return ; } GeneralRegion region = plugin . getFileManager ( ) . getRegion ( args [ 1 ] ) ; if ( region == null ) { plugin . message ( sender , "setrestore-notRegistered" , args [ 1 ] ) ; return ; } Boolean value = null ; if ( args [ 2 ] . equalsIgnoreCase ( "true" ) ) { value = true ; } else if ( args [ 2 ] . equalsIgnoreCase ( "false" ) ) { value = false ; } region . setRestoreSetting ( value ) ; String valueString = "general" ; if ( value != null ) { valueString = value + "" ; } if ( ( args . length ) > 3 ) { <START_BUG> region . setRestoreProfile ( args [ 3 ] ) ; <END_BUG> plugin . message ( sender , "setrestore-successProfile" , region . getName ( ) , valueString , args [ 3 ] ) ; } else { plugin . message ( sender , "setrestore-success" , region . getName ( ) , valueString ) ; } } @ Override public List < String > getTabCompleteList ( int toComplete , String [ ] start , CommandSender sender ) { } }
public class TestLazyDocument extends LuceneTestCase { public final int NUM_DOCS = atLeast ( 10 ) ; public final String [ ] FIELDS = new String [ ] { "a" , "b" , "c" , "d" , "e" , "f" , "g" , "h" , "i" , "j" , "k" } ; public final int NUM_VALUES = atLeast ( 100 ) ; public Directory dir = newDirectory ( ) ; @ After public void removeIndex ( ) { } @ Before public void createIndex ( ) throws Exception { Analyzer analyzer = new MockAnalyzer ( random ( ) ) ; IndexWriter writer = new IndexWriter ( dir , newIndexWriterConfig ( TEST_VERSION_CURRENT , analyzer ) ) ; try { for ( int docid = 0 ; docid < ( NUM_DOCS ) ; docid ++ ) { Document d = new Document ( ) ; d . add ( newStringField ( "docid" , ( "" + docid ) , YES ) ) ; d . add ( newStringField ( "never_load" , "fail" , YES ) ) ; for ( String f : FIELDS ) { for ( int val = 0 ; val < ( NUM_VALUES ) ; val ++ ) { d . add ( newStringField ( f , ( ( ( ( docid + "_" ) + f ) + "_" ) + val ) , YES ) ) ; } } d . add ( newStringField ( "load_later" , "yes" , YES ) ) ; writer . addDocument ( d ) ; } } finally { <START_BUG> writer . close ( ) ; <END_BUG> } } public void testLazy ( ) throws Exception { } private static class LazyTestingStoredFieldVisitor extends StoredFieldVisitor { public final StoredDocument doc = new StoredDocument ( ) ; public final LazyDocument lazyDoc ; public final Set < String > lazyFieldNames ; LazyTestingStoredFieldVisitor ( LazyDocument l , String ... fields ) { } @ Override public Status needsField ( FieldInfo fieldInfo ) { } @ Override public void stringField ( FieldInfo fieldInfo , String value ) throws IOException { } } }
@ SuppressWarnings ( "serial" ) public class CompactBinaryFile extends File { private byte [ ] binary ; private int pos ; private int subPos ; private boolean reading = false ; private boolean writing = false ; public void read ( ) { } public boolean nextBit ( ) { } private boolean bitAt ( byte b , int pos ) { } public long getNumber ( int bits ) { } private long power ( int p ) { } public void write ( ) { } public void addBit ( boolean bit ) { } public void stopWriting ( ) { } public long getLeft ( ) { } public void nextBits ( boolean [ ] bits , int position , int length ) { } public void resetIterator ( ) { } public boolean hasFinished ( ) { } public void stopReading ( ) { } public void addNumber ( long number , int bits ) { if ( ! ( writing ) ) throw new IllegalStateException ( "Not<seq2seq4repair_space>writing<seq2seq4repair_space>file!" ) ; if ( bits < 1 ) throw new IllegalArgumentException ( "Cannot<seq2seq4repair_space>write<seq2seq4repair_space>a<seq2seq4repair_space>number<seq2seq4repair_space>with<seq2seq4repair_space>less<seq2seq4repair_space>then<seq2seq4repair_space>1<seq2seq4repair_space>bit!" ) ; if ( bits > 64 ) throw new IllegalArgumentException ( "Cannot<seq2seq4repair_space>write<seq2seq4repair_space>a<seq2seq4repair_space>number<seq2seq4repair_space>with<seq2seq4repair_space>more<seq2seq4repair_space>then<seq2seq4repair_space>64<seq2seq4repair_space>bits!" ) ; long a ; <START_BUG> for ( int i = bits ; i >= 0 ; i -- ) { <END_BUG> a = power ( i ) ; addBit ( ( ( number & a ) == a ) ) ; } } public CompactBinaryFile ( File parent , String child ) { } public CompactBinaryFile ( String parent , String child ) { } public CompactBinaryFile ( URI uri ) { } public CompactBinaryFile ( String file ) { } public long getPosition ( ) { } public boolean isReadingFile ( ) { } public boolean isWritingFile ( ) { } No newline ; at end ; of file ; }
class ClipboardProxy { Display display ; int shellHandle ; int atomAtom ; int clipboardAtom ; int motifClipboardAtom ; int primaryAtom ; int targetsAtom ; int [ ] [ ] convertData = new int [ 10 ] [ 3 ] ; Clipboard activeClipboard = null ; Clipboard activePrimaryClipboard = null ; Object [ ] clipboardData ; Transfer [ ] clipboardDataTypes ; Object [ ] primaryClipboardData ; Transfer [ ] primaryClipboardDataTypes ; boolean done = false ; Object selectionValue ; Transfer selectionTransfer ; Callback XtConvertSelectionCallback ; Callback XtLoseSelectionCallback ; Callback XtSelectionDoneCallback ; Callback XtSelectionCallbackCallback ; static byte [ ] ATOM = Converter . wcsToMbcs ( null , "ATOM" , true ) ; static byte [ ] CLIPBOARD = Converter . wcsToMbcs ( null , "CLIPBOARD" , true ) ; static byte [ ] PRIMARY = Converter . wcsToMbcs ( null , "PRIMARY" , true ) ; static byte [ ] TARGETS = Converter . wcsToMbcs ( null , "TARGETS" , true ) ; static byte [ ] _MOTIF_CLIPBOARD_TARGETS = Converter . wcsToMbcs ( null , "_MOTIF_CLIPBOARD_TARGETS" , true ) ; static String ID = "CLIPBOARD<seq2seq4repair_space>PROXY<seq2seq4repair_space>OBJECT" ; static ClipboardProxy _getInstance ( final Display display ) { } ClipboardProxy ( Display display ) { } void clear ( Clipboard owner , int clipboards ) { } void dispose ( ) { } Object getContents ( Transfer transfer , int clipboardType ) { } int [ ] getAvailableTypes ( int clipboardType ) { } void setContents ( Clipboard owner , Object [ ] data , Transfer [ ] dataTypes , int clipboards ) { } void storePtr ( int ptr , int selection , int target ) { int index = - 1 ; for ( int i = 0 ; i < ( convertData . length ) ; i ++ ) { if ( ( convertData [ i ] [ 0 ] ) == 0 ) { index = i ; break ; } } if ( index == ( - 1 ) ) { <START_BUG> int [ ] [ ] newConvertData = new int [ convertData . length ] [ 3 ] ; <END_BUG> System . arraycopy ( convertData , 0 , newConvertData , 0 , convertData . length ) ; index = convertData . length ; convertData = newConvertData ; } convertData [ index ] [ 0 ] = selection ; convertData [ index ] [ 1 ] = target ; convertData [ index ] [ 2 ] = ptr ; } void wait ( int timeout ) { } int checkEvent ( int display , int event , int arg ) { } int XtConvertSelection ( int widget , int selection , int target , int type , int value , int length , int format ) { } int XtLoseSelection ( int widget , int selection ) { } int XtSelectionCallback ( int widget , int client_data , int selection , int type , int value , int length , int format ) { } int XtSelectionDone ( int widget , int selection , int target ) { } }
public final class ScheduledThreadPoolAdd extends AbstractExecutorAdd { private static final long serialVersionUID = 5597662601486525937L ; public ScheduledThreadPoolAdd ( final String name , final ScaledCount maxThreads ) { } @ Override protected < P > void applyUpdate ( final UpdateContext updateContext , final UpdateResultHandler < ? super Void , P > handler , final P param ) { <START_BUG> final BatchBuilder builder = updateContext . getBatchBuilder ( ) ; <END_BUG> final ScaledCount maxThreadsCount = getMaxThreads ( ) ; final int maxThreads = maxThreadsCount . getScaledCount ( ) ; final String name = getName ( ) ; final ServiceName serviceName = ThreadsServices . executorName ( name ) ; final UnboundedQueueThreadPoolService service = new UnboundedQueueThreadPoolService ( maxThreads , getKeepaliveTime ( ) ) ; final ServiceBuilder < ExecutorService > serviceBuilder = builder . addService ( serviceName , service ) ; addThreadFactoryDependency ( serviceName , serviceBuilder , service . getThreadFactoryInjector ( ) , builder ) ; serviceBuilder . install ( ) ; } @ Override protected void applyUpdate ( final ThreadsSubsystemElement element ) throws UpdateFailedException { } }
public class ActionSetRegistry extends RegistryManager implements IRegistryChangeListener { public static final String OTHER_CATEGORY = "org.eclipse.ui.actionSetCategory" ; private ArrayList children = new ArrayList ( ) ; private ArrayList categories = new ArrayList ( 1 ) ; private Map mapPartToActionSets = new HashMap ( ) ; private Map mapCacheToActionSets = new HashMap ( ) ; public ActionSetRegistry ( ) { } public void addActionSet ( ActionSetDescriptor desc ) { } public void addAssociation ( String actionSetId , String partId ) { } public Object [ ] buildNewCacheObject ( IExtensionDelta delta ) { } public IActionSetDescriptor findActionSet ( String id ) { } public ActionSetCategory findCategory ( String id ) { } public IActionSetDescriptor [ ] getActionSets ( ) { } public IActionSetDescriptor [ ] getActionSetsFor ( String partId ) { } public ActionSetCategory [ ] getCategories ( ) { } public void mapActionSetsToCategories ( ) { <START_BUG> ActionSetCategory cat = new ActionSetCategory ( ActionSetRegistry . OTHER_CATEGORY , WorkbenchMessages . getString ( "ActionSetRegistry.otherCategory" ) ) ; <END_BUG> categories . add ( cat ) ; Iterator i = children . iterator ( ) ; while ( i . hasNext ( ) ) { IActionSetDescriptor desc = ( ( IActionSetDescriptor ) ( i . next ( ) ) ) ; cat . addActionSet ( desc ) ; } } public void readFromRegistry ( ) { } public Object removeCache ( String actionSetId ) { } public void remove ( String id ) { } public void removeAssociation ( String actionSetId , String partId ) { } }
public class GeneralTopologyContext implements JSONAware { private StormTopology _topology ; private Map < Integer , String > _taskToComponent ; private Map < String , List < Integer > > _componentToTasks ; private Map < String , Map < String , Fields > > _componentToStreamToFields ; private String _stormId ; protected Map _stormConf ; public GeneralTopologyContext ( StormTopology topology , Map stormConf , Map < Integer , String > taskToComponent , Map < String , List < Integer > > componentToSortedTasks , Map < String , Map < String , Fields > > componentToStreamToFields , String stormId ) { } public String getStormId ( ) { } public StormTopology getRawTopology ( ) { } public String getComponentId ( int taskId ) { <START_BUG> if ( taskId == ( Constants . SYSTEM_TASK_ID ) ) { <END_BUG> return Constants . SYSTEM_COMPONENT_ID ; } else { return _taskToComponent . get ( taskId ) ; } } public Set < String > getComponentStreams ( String componentId ) { } public List < Integer > getComponentTasks ( String componentId ) { } public Fields getComponentOutputFields ( String componentId , String streamId ) { } public Fields getComponentOutputFields ( GlobalStreamId id ) { } public Map < GlobalStreamId , Grouping > getSources ( String componentId ) { } public Map < String , Map < String , Grouping > > getTargets ( String componentId ) { } @ Override public String toJSONString ( ) { } public Map < Integer , String > getTaskToComponent ( ) { } public Set < String > getComponentIds ( ) { } public ComponentCommon getComponentCommon ( String componentId ) { } public int maxTopologyMessageTimeout ( ) { } }
public class ResourceLink extends Link implements IResourceListener { private static final long serialVersionUID = 1L ; private final ResourceReference resourceReference ; private final Resource resource ; public ResourceLink ( final String id , final ResourceReference resourceReference ) { } public ResourceLink ( final String id , final Resource resource ) { } public void onClick ( ) { } protected final String getURL ( ) { if ( ( resourceReference ) != null ) { resourceReference . setLocale ( getLocale ( ) ) ; resourceReference . setStyle ( getStyle ( ) ) ; resourceReference . bind ( getApplication ( ) ) ; return getRequestCycle ( ) . urlFor ( resourceReference ) ; } <START_BUG> return urlFor ( IResourceListener . class ) ; <END_BUG> } public final void onResourceRequested ( ) { } }
public class EngineDependentStrategy extends AbstractTraversalStrategy implements TraversalStrategy { private static final EngineDependentStrategy INSTANCE = new EngineDependentStrategy ( ) ; private EngineDependentStrategy ( ) { } @ Override public void apply ( final Traversal . Admin < ? , ? > traversal , final TraversalEngine traversalEngine ) { <START_BUG> traversal . asAdmin ( ) . getSteps ( ) . stream ( ) . filter ( ( step ) -> step instanceof EngineDependent ) . forEach ( ( step ) -> ( ( EngineDependent ) ( step ) ) . onEngine ( traversalEngine ) ) ; <END_BUG> } public static EngineDependentStrategy instance ( ) { } }
public class PersistenceProviderImpl implements PersistenceProvider , ProviderUtil { static final String CLASS_TRANSFORMER_OPTIONS = "ClassTransformerOptions" ; private static final String EMF_POOL = "EntityManagerFactoryPool" ; private static final Localizer _loc = Localizer . forPackage ( PersistenceProviderImpl . class ) ; private Log _log ; public OpenJPAEntityManagerFactory createEntityManagerFactory ( String name , String resource , Map m ) { } private BrokerFactory getBrokerFactory ( ConfigurationProvider cp , Object poolValue , ClassLoader loader ) { } public OpenJPAEntityManagerFactory createEntityManagerFactory ( String name , Map m ) { } public OpenJPAEntityManagerFactory createContainerEntityManagerFactory ( PersistenceUnitInfo pui , Map m ) { PersistenceProductDerivation pd = new PersistenceProductDerivation ( ) ; try { Object poolValue = Configurations . removeProperty ( PersistenceProviderImpl . EMF_POOL , m ) ; ConfigurationProvider cp = pd . load ( pui , m ) ; if ( cp == null ) return null ; Exception transformerException = null ; String ctOpts = ( ( String ) ( Configurations . getProperty ( PersistenceProviderImpl . CLASS_TRANSFORMER_OPTIONS , pui . getProperties ( ) ) ) ) ; try { pui . addTransformer ( new PersistenceProviderImpl . ClassTransformerImpl ( cp , ctOpts , pui . getNewTempClassLoader ( ) , newConfigurationImpl ( ) ) ) ; } catch ( Exception e ) { transformerException = e ; } if ( ! ( Configurations . containsProperty ( KEY , cp . getProperties ( ) ) ) ) { cp . addProperty ( ( "openjpa." + ( BrokerValue . KEY ) ) , getDefaultBrokerAlias ( ) ) ; } BrokerFactory factory = getBrokerFactory ( cp , poolValue , pui . getClassLoader ( ) ) ; if ( transformerException != null ) { Log log = factory . getConfiguration ( ) . getLog ( LOG_RUNTIME ) ; if ( log . isTraceEnabled ( ) ) { log . warn ( PersistenceProviderImpl . _loc . get ( "transformer-registration-error-ex" , pui ) , transformerException ) ; } else { log . warn ( PersistenceProviderImpl . _loc . get ( "transformer-registration-error" , pui ) ) ; } } OpenJPAConfiguration conf = factory . getConfiguration ( ) ; _log = conf . getLog ( LOG_RUNTIME ) ; loadValidator ( _log , conf ) ; Options o = Configurations . parseProperties ( Configurations . getProperties ( "openjpa.MetaDataRepository" ) ) ; if ( o . getBooleanProperty ( "Preload" ) ) { <START_BUG> conf . getAbstractBrokerFactoryInstance ( ) . preload ( ) ; <END_BUG> } return JPAFacadeHelper . toEntityManagerFactory ( factory ) ; } catch ( Exception e ) { throw PersistenceExceptions . toPersistenceException ( e ) ; } } public ProviderUtil getProviderUtil ( ) { } protected String getDefaultBrokerAlias ( ) { } protected OpenJPAConfiguration newConfigurationImpl ( ) { } private static class ClassTransformerImpl implements ClassTransformer { private final ClassFileTransformer _trans ; private ClassTransformerImpl ( ConfigurationProvider cp , String props , final ClassLoader tmpLoader , OpenJPAConfiguration conf ) { } public byte [ ] transform ( ClassLoader cl , String name , Class < ? > previousVersion , ProtectionDomain pd , byte [ ] bytes ) throws IllegalClassFormatException { } } private void loadAgent ( Log log , OpenJPAConfiguration conf ) { } private void loadValidator ( Log log , OpenJPAConfiguration conf ) { } public LoadState isLoaded ( Object obj ) { } public LoadState isLoadedWithReference ( Object obj , String attr ) { } public LoadState isLoadedWithoutReference ( Object obj , String attr ) { } }
public class NSText extends NSView { public NSText ( ) { } public NSText ( int id ) { } public static int static_class ( ) { } public NSData RTFDFromRange ( NSRange range ) { } public NSData RTFFromRange ( NSRange range ) { } public void alignCenter ( id sender ) { } public void alignLeft ( id sender ) { } public void alignRight ( id sender ) { } public int alignment ( ) { } public NSColor backgroundColor ( ) { } public int baseWritingDirection ( ) { } public void changeFont ( id sender ) { } public void checkSpelling ( id sender ) { } public void copy ( id sender ) { } public void copyFont ( id sender ) { } public void copyRuler ( id sender ) { } public void cut ( id sender ) { } public id delegate ( ) { } public void delete ( id sender ) { } public boolean drawsBackground ( ) { } public NSFont font ( ) { } public boolean importsGraphics ( ) { } public boolean isEditable ( ) { } public boolean isFieldEditor ( ) { } public boolean isHorizontallyResizable ( ) { } public boolean isRichText ( ) { } public boolean isRulerVisible ( ) { } public boolean isSelectable ( ) { } public boolean isVerticallyResizable ( ) { } public NSSize maxSize ( ) { } public NSSize minSize ( ) { } public void paste ( id sender ) { } public void pasteFont ( id sender ) { } public void pasteRuler ( id sender ) { } public boolean readRTFDFromFile ( NSString path ) { } public void replaceCharactersInRange_withRTF_ ( NSRange range , NSData rtfData ) { } public void replaceCharactersInRange_withRTFD_ ( NSRange range , NSData rtfdData ) { } public void replaceCharactersInRange_withString_ ( NSRange range , NSString aString ) { } public void scrollRangeToVisible ( NSRange range ) { } public void selectAll ( id sender ) { } public NSRange selectedRange ( ) { NSRange result = new NSRange ( ) ; <START_BUG> OS . objc_msgSend_struct ( result , this . id , sel_selectedRange ) ; <END_BUG> return result ; } public void setAlignment ( int mode ) { } public void setBackgroundColor ( NSColor color ) { } public void setBaseWritingDirection ( int writingDirection ) { } public void setDelegate ( id anObject ) { } public void setDrawsBackground ( boolean flag ) { } public void setEditable ( boolean flag ) { } public void setFieldEditor ( boolean flag ) { } public void setFont_ ( NSFont obj ) { } public void setFont_range_ ( NSFont font , NSRange range ) { } public void setHorizontallyResizable ( boolean flag ) { } public void setImportsGraphics ( boolean flag ) { } public void setMaxSize ( NSSize newMaxSize ) { } public void setMinSize ( NSSize newMinSize ) { } public void setRichText ( boolean flag ) { } public void setSelectable ( boolean flag ) { } public void setSelectedRange ( NSRange range ) { } public void setString ( NSString string ) { } public void setTextColor_ ( NSColor color ) { } public void setTextColor_range_ ( NSColor color , NSRange range ) { } public void setUsesFontPanel ( boolean flag ) { } public void setVerticallyResizable ( boolean flag ) { } public void showGuessPanel ( id sender ) { } public void sizeToFit ( ) { } public NSString string ( ) { } public void subscript ( id sender ) { } public void superscript ( id sender ) { } public NSColor textColor ( ) { } public void toggleRuler ( id sender ) { } public void underline ( id sender ) { } public void unscript ( id sender ) { } public boolean usesFontPanel ( ) { } public boolean writeRTFDToFile ( NSString path , boolean flag ) { } }
public class ConfigureWidget extends Activity { private ConfigureWidget context ; int widgetID ; private ListView ruleListView ; private DatabaseManager dbManager ; private ArrayList < Rule > ruleArray ; private static String WIDGET_ONCLICK_ACTION = "AUTO_TEXT_MATE.WIGDET_ONCLICK_ACTION" ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( activity_configure_widget ) ; setResult ( RESULT_CANCELED ) ; dbManager = new DatabaseManager ( getApplicationContext ( ) ) ; ruleArray = dbManager . getRulesArray ( ) ; ruleListView = ( ( ListView ) ( findViewById ( configure_list ) ) ) ; context = this ; ruleListView . setAdapter ( new android . widget . ArrayAdapter ( this , layout . simple_list_item_1 , ruleArray ) ) ; ruleListView . setOnItemClickListener ( new AdapterView . OnItemClickListener ( ) { @ Override public void onItemClick ( AdapterView < ? > parent , final View view , final int position , long id ) { Log . i ( "Configure" , ( ( ( "pos:<seq2seq4repair_space>" + position ) + ",<seq2seq4repair_space>id:<seq2seq4repair_space>" ) + id ) ) ; final Rule selectedRule = ruleArray . get ( position ) ; Intent launchedIntent = getIntent ( ) ; Bundle extras = launchedIntent . getExtras ( ) ; if ( extras != null ) { widgetID = extras . getInt ( EXTRA_APPWIDGET_ID , INVALID_APPWIDGET_ID ) ; } if ( ( widgetID ) == ( AppWidgetManager . INVALID_APPWIDGET_ID ) ) { finish ( ) ; } final AppWidgetManager widgetManager = AppWidgetManager . getInstance ( context ) ; final RemoteViews rm = new RemoteViews ( context . getPackageName ( ) , R . layout . layout_widget ) ; rm . setImageViewResource ( widget_backgroundImage , ( ( selectedRule . getStatus ( ) ) == 1 ? drawable . widget_button_green : drawable . widget_button_red ) ) ; rm . setTextViewText ( widget_button , selectedRule . getName ( ) ) ; Intent onClickIntent = new Intent ( ConfigureWidget . WIDGET_ONCLICK_ACTION ) ; onClickIntent . putExtra ( "rule_name" , selectedRule . getName ( ) ) ; <START_BUG> PendingIntent onClickPendingIntent = PendingIntent . getActivity ( context , 0 , onClickIntent , 0 ) ; <END_BUG> rm . setOnClickPendingIntent ( widget_button , onClickPendingIntent ) ; widgetManager . updateAppWidget ( widgetID , rm ) ; Intent resultValue = new Intent ( ) ; resultValue . putExtra ( EXTRA_APPWIDGET_ID , widgetID ) ; setResult ( RESULT_OK , resultValue ) ; finish ( ) ; } } ) ; } No newline ; at end ; of file ; }
public class PairingsGenerator implements Iterator < Set < Pair > > { private final List < Player > remainder ; private final Set < Pair > partial ; private boolean hasNext = true ; private int i = 1 ; private PairingsGenerator generator = null ; public PairingsGenerator ( final Set < Player > players ) { } private PairingsGenerator ( final List < Player > remainder , final Set < Pair > partial ) { } @ Override public boolean hasNext ( ) { } @ Override public Set < Pair > next ( ) { } <START_BUG> public static List < Set < Pair > > generate ( final Set < Player > players ) { <END_BUG> final List < Set < Pair > > pairings = new ArrayList < > ( ) ; PairingsGenerator . generate ( new ArrayList ( players ) , new HashSet ( ) , pairings ) ; return pairings ; } private static void generate ( final List < Player > remainder , final Set < Pair > partial , final List < Set < Pair > > pairings ) { } }
public class Debugger { private static final DateFormat dateFormat = new SimpleDateFormat ( "yyyyMMddHHmmss" ) ; private static final DateFormat humanDateFormat = new SimpleDateFormat ( "yyyy-MM-dd<seq2seq4repair_space>HH:mm:ss" ) ; private final Autorank plugin ; public Debugger ( final Autorank instance ) { } public String createDebugFile ( ) { final String dateFormatSave = Debugger . dateFormat . format ( new Date ( ) ) ; final File txt = new File ( ( ( plugin . getDataFolder ( ) ) + "/debugger" ) , ( ( "debug-" + dateFormatSave ) + ".txt" ) ) ; try { txt . getParentFile ( ) . mkdirs ( ) ; txt . createNewFile ( ) ; } catch ( final IOException e ) { e . printStackTrace ( ) ; return dateFormatSave ; } BufferedWriter out = null ; try { out = new BufferedWriter ( new FileWriter ( txt ) ) ; } catch ( final IOException e ) { e . printStackTrace ( ) ; return dateFormatSave ; } try { out . write ( "This<seq2seq4repair_space>is<seq2seq4repair_space>a<seq2seq4repair_space>debug<seq2seq4repair_space>file<seq2seq4repair_space>of<seq2seq4repair_space>Autorank.<seq2seq4repair_space>You<seq2seq4repair_space>should<seq2seq4repair_space>give<seq2seq4repair_space>this<seq2seq4repair_space>to<seq2seq4repair_space>an<seq2seq4repair_space>author<seq2seq4repair_space>or<seq2seq4repair_space>ticket<seq2seq4repair_space>manager<seq2seq4repair_space>of<seq2seq4repair_space>Autorank." ) ; out . newLine ( ) ; out . write ( "You<seq2seq4repair_space>can<seq2seq4repair_space>go<seq2seq4repair_space>to<seq2seq4repair_space>http://pastebin.com/<seq2seq4repair_space>and<seq2seq4repair_space>paste<seq2seq4repair_space>this<seq2seq4repair_space>file.<seq2seq4repair_space>Then,<seq2seq4repair_space>give<seq2seq4repair_space>the<seq2seq4repair_space>link<seq2seq4repair_space>and<seq2seq4repair_space>state<seq2seq4repair_space>the<seq2seq4repair_space>problems<seq2seq4repair_space>you're<seq2seq4repair_space>having<seq2seq4repair_space>in<seq2seq4repair_space>a<seq2seq4repair_space>ticket<seq2seq4repair_space>on<seq2seq4repair_space>the<seq2seq4repair_space>Autorank<seq2seq4repair_space>page." ) ; out . newLine ( ) ; out . write ( "" ) ; out . newLine ( ) ; out . write ( ( "Date<seq2seq4repair_space>created:<seq2seq4repair_space>" + ( Debugger . humanDateFormat . format ( new Date ( ) ) ) ) ) ; out . newLine ( ) ; out . write ( "" ) ; out . newLine ( ) ; out . write ( ( "Autorank<seq2seq4repair_space>version:<seq2seq4repair_space>" + ( plugin . getDescription ( ) . getVersion ( ) ) ) ) ; out . newLine ( ) ; out . write ( "" ) ; out . newLine ( ) ; out . write ( ( "Server<seq2seq4repair_space>implementation:<seq2seq4repair_space>" + ( plugin . getServer ( ) . getVersion ( ) ) ) ) ; out . newLine ( ) ; out . write ( "" ) ; out . newLine ( ) ; out . write ( ( "Server<seq2seq4repair_space>version:<seq2seq4repair_space>" + ( plugin . getServer ( ) . getBukkitVersion ( ) ) ) ) ; out . newLine ( ) ; out . write ( "" ) ; out . newLine ( ) ; out . write ( ( "Server<seq2seq4repair_space>warning<seq2seq4repair_space>state:<seq2seq4repair_space>" + ( plugin . getServer ( ) . getWarningState ( ) ) ) ) ; out . newLine ( ) ; out . write ( "" ) ; out . newLine ( ) ; out . write ( "Ranks<seq2seq4repair_space>defined:<seq2seq4repair_space>" ) ; out . newLine ( ) ; out . write ( "" ) ; out . newLine ( ) ; <START_BUG> for ( final String change : plugin . getPlayerChecker ( ) . toStringArray ( ) ) { <END_BUG> out . write ( change ) ; out . newLine ( ) ; } out . write ( "" ) ; out . newLine ( ) ; final String usedConfig = ( plugin . getConfigHandler ( ) . useAdvancedConfig ( ) ) ? "AdvancedConfig.yml" : "SimpleConfig.yml" ; out . write ( ( "Config<seq2seq4repair_space>used:<seq2seq4repair_space>" + usedConfig ) ) ; out . newLine ( ) ; out . write ( "" ) ; out . newLine ( ) ; out . write ( ( "Using<seq2seq4repair_space>MySQL:<seq2seq4repair_space>" + ( plugin . getConfigHandler ( ) . useMySQL ( ) ) ) ) ; out . newLine ( ) ; out . write ( "" ) ; out . newLine ( ) ; out . write ( ( "Java<seq2seq4repair_space>version:<seq2seq4repair_space>" + ( System . getProperty ( "java.version" ) ) ) ) ; out . newLine ( ) ; out . write ( "" ) ; out . newLine ( ) ; out . write ( ( "Operating<seq2seq4repair_space>system:<seq2seq4repair_space>" + ( System . getProperty ( "os.name" ) ) ) ) ; out . newLine ( ) ; out . write ( "" ) ; out . newLine ( ) ; out . write ( ( "OS<seq2seq4repair_space>version:<seq2seq4repair_space>" + ( System . getProperty ( "os.version" ) ) ) ) ; out . newLine ( ) ; out . write ( "" ) ; out . newLine ( ) ; out . write ( ( "OS<seq2seq4repair_space>architecture:<seq2seq4repair_space>" + ( System . getProperty ( "os.arch" ) ) ) ) ; out . newLine ( ) ; out . write ( "" ) ; out . newLine ( ) ; out . write ( ( "Loaded<seq2seq4repair_space>addons:<seq2seq4repair_space>" + ( plugin . getAddonManager ( ) . getLoadedAddons ( ) . toString ( ) ) ) ) ; out . newLine ( ) ; out . write ( "" ) ; out . newLine ( ) ; } catch ( final IOException e ) { e . printStackTrace ( ) ; return dateFormatSave ; } try { out . close ( ) ; return dateFormatSave ; } catch ( final IOException e ) { e . printStackTrace ( ) ; return dateFormatSave ; } } }
public class JoinDocFreqValueSource extends FieldCacheSource { public static final String NAME = "joindf" ; protected final String qfield ; public JoinDocFreqValueSource ( String field , String qfield ) { } @ Override public String description ( ) { } @ Override public FunctionValues getValues ( Map context , AtomicReaderContext readerContext ) throws IOException { <START_BUG> final BinaryDocValues terms = cache . getTerms ( readerContext . reader ( ) , field , FAST ) ; <END_BUG> final IndexReader top = ReaderUtil . getTopLevelContext ( readerContext ) . reader ( ) ; Terms t = MultiFields . getTerms ( top , qfield ) ; final TermsEnum termsEnum = ( t == null ) ? TermsEnum . EMPTY : t . iterator ( null ) ; return new IntDocValues ( this ) { final BytesRef ref = new BytesRef ( ) ; @ Override public int intVal ( int doc ) { try { terms . get ( doc , ref ) ; if ( termsEnum . seekExact ( ref ) ) { return termsEnum . docFreq ( ) ; } else { return 0 ; } } catch ( IOException e ) { throw new RuntimeException ( ( ( ( "caught<seq2seq4repair_space>exception<seq2seq4repair_space>in<seq2seq4repair_space>function<seq2seq4repair_space>" + ( description ( ) ) ) + "<seq2seq4repair_space>:<seq2seq4repair_space>doc=" ) + doc ) , e ) ; } } } ; } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } }
public class ClubberAdapter extends ClubMemberAdapter implements Clubber { private LinkedHashMap < Section , ClubberRecord > records ; public ClubberAdapter ( ) { } public ClubberAdapter ( Person person ) { } public Optional < ClubberRecord > getRecord ( Optional < Section > maybeASection ) { } public List < AwardPresentation > getAwards ( ) { } protected LinkedHashMap < Section , ClubberRecord > loadRecords ( ) { } private synchronized Map < Section , ClubberRecord > getRecords ( ) { } private ClubberRecord mapToRecord ( Section section ) { } protected ClubberRecord findRecord ( final Section s ) { } protected ClubberRecord createUnsignedRecord ( final Section section ) { } @ Override public Optional < Section > getNextSection ( ) { } private Optional < Section > getRequiredForBooks ( ) { } private Optional < Section > getRequiredToMoveOn ( Book b ) { } private Optional < Section > getRequiredForBook ( Book b ) { } private Stream < Section > getRequiredForBookStream ( Book b ) { } private Optional < Section > getExtraCredit ( ) { } private Stream < Book > getAgeLevelBooks ( ) { } private Boolean isAgeLevelBook ( Book b ) { } private Stream < Section > getExtraCreditLeft ( Book b ) { } private Stream < Section > getClubberFutureSections ( Book b ) { } @ Override public Optional < Section > getSectionAfter ( Section current ) { } private Stream < Section > sectionStream ( ) { } @ Override public Optional < Section > getSectionBefore ( Section current ) { } private Stream < Section > getClubbersSections ( Book b ) { } private List < Book > getCurrentBookList ( ) { } private boolean isSigned ( Section s ) { } @ Override public Optional < ClubberRecord > getLastRecord ( ) { } @ Override public List < ClubberRecord > getNextSections ( int max ) { } @ Override public Collection < ClubberRecord > getRecords ( Predicate < ClubberRecord > test ) { } @ Override public Optional < Clubber > asClubber ( ) { } @ Override public boolean hasAward ( Award award ) { <START_BUG> return getAwards ( ) . stream ( ) . map ( AwardPresentation :: forAccomplishment ) . filter ( ( n ) -> n . getName ( ) . equals ( award . getName ( ) ) ) . findFirst ( ) . isPresent ( ) ; <END_BUG> } }
public class DefinitionMetadataEqualsHashCodeTests extends TestCase { public void testRootBeanDefinitionEqualsAndHashCode ( ) throws Exception { } public void testChildBeanDefinitionEqualsAndHashCode ( ) throws Exception { } public void testRuntimeBeanReference ( ) throws Exception { } private void setBaseProperties ( AbstractBeanDefinition definition ) { definition . setAbstract ( true ) ; definition . setAttribute ( "foo" , "bar" ) ; definition . setAutowireCandidate ( false ) ; definition . setAutowireMode ( AUTOWIRE_BY_TYPE ) ; definition . setDependencyCheck ( DEPENDENCY_CHECK_OBJECTS ) ; definition . setDependsOn ( new String [ ] { "foo" , "bar" } ) ; definition . setDestroyMethodName ( "destroy" ) ; definition . setEnforceDestroyMethod ( false ) ; definition . setEnforceInitMethod ( true ) ; definition . setFactoryBeanName ( "factoryBean" ) ; definition . setFactoryMethodName ( "factoryMethod" ) ; definition . setInitMethodName ( "init" ) ; definition . setLazyInit ( true ) ; definition . getMethodOverrides ( ) . addOverride ( new LookupOverride ( "foo" , "bar" ) ) ; definition . getMethodOverrides ( ) . addOverride ( new ReplaceOverride ( "foo" , "bar" ) ) ; <START_BUG> definition . getPropertyValues ( ) . addPropertyValue ( "foo" , "bar" ) ; <END_BUG> definition . setResourceDescription ( "desc" ) ; definition . setRole ( ROLE_APPLICATION ) ; definition . setScope ( SCOPE_PROTOTYPE ) ; definition . setSource ( "foo" ) ; } private void assertEqualsContract ( Object master , Object equal , Object notEqual , Object subclass ) { } }
public class BeanShellAssertion extends AbstractTestElement implements Serializable , Assertion , TestListener , ThreadListener { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; public static final String FILENAME = "BeanShellAssertion.filename" ; public static final String SCRIPT = "BeanShellAssertion.query" ; public static final String PARAMETERS = "BeanShellAssertion.parameters" ; private transient BeanShellInterpreter bshInterpreter = null ; public static final String INIT_FILE = "beanshell.assertion.init" ; public BeanShellAssertion ( ) { } private Object readResolve ( ) { } private void init ( ) { try { <START_BUG> bshInterpreter = new BeanShellInterpreter ( BeanShellAssertion . INIT_FILE , BeanShellAssertion . log ) ; <END_BUG> } catch ( ClassNotFoundException e ) { BeanShellAssertion . log . error ( ( "Cannot<seq2seq4repair_space>find<seq2seq4repair_space>BeanShell:<seq2seq4repair_space>" + ( e . toString ( ) ) ) ) ; } } public String getScript ( ) { } public String getFilename ( ) { } public String getParameters ( ) { } public AssertionResult getResult ( SampleResult response ) { } public void threadStarted ( ) { } public void threadFinished ( ) { } public void testEnded ( ) { } public void testEnded ( String host ) { } public void testIterationStart ( LoopIterationEvent event ) { } public void testStarted ( ) { } public void testStarted ( String host ) { } }
public class DomainModelUtil { public static void updateCoreModel ( final Resource rootResource ) { } public static ExtensionContext initializeMasterDomainRegistry ( final ManagementResourceRegistration root , final ExtensibleConfigurationPersister configurationPersister , final ContentRepository contentRepository , final FileRepository fileRepository , final DomainController domainController , final UnregisteredHostChannelRegistry registry ) { } public static ExtensionContext initializeSlaveDomainRegistry ( final ManagementResourceRegistration root , final ExtensibleConfigurationPersister configurationPersister , final ContentRepository contentRepository , final FileRepository fileRepository , final LocalHostControllerInfo hostControllerInfo ) { } private static ExtensionContext initializeDomainRegistry ( final ManagementResourceRegistration root , final ExtensibleConfigurationPersister configurationPersister , final ContentRepository contentRepo , final FileRepository fileRepository , final boolean isMaster , final DomainController domainController , final UnregisteredHostChannelRegistry registry , final LocalHostControllerInfo hostControllerInfo ) { } public static void validateRolloutPlanStructure ( ModelNode plan ) throws OperationFailedException { if ( plan == null ) { <START_BUG> throw new OperationFailedException ( "rolloutPlan<seq2seq4repair_space>argument<seq2seq4repair_space>is<seq2seq4repair_space>null." ) ; <END_BUG> } if ( ! ( plan . hasDefined ( ROLLOUT_PLAN ) ) ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . requiredChildIsMissing ( ROLLOUT_PLAN , ROLLOUT_PLAN , plan . toString ( ) ) ) ; } ModelNode rolloutPlan1 = plan . get ( ROLLOUT_PLAN ) ; final Set < String > keys ; try { keys = rolloutPlan1 . keys ( ) ; } catch ( IllegalArgumentException e ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . requiredChildIsMissing ( ROLLOUT_PLAN , IN_SERIES , plan . toString ( ) ) ) ; } if ( ! ( keys . contains ( IN_SERIES ) ) ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . requiredChildIsMissing ( ROLLOUT_PLAN , IN_SERIES , plan . toString ( ) ) ) ; } if ( ( ( keys . size ( ) ) > 2 ) || ( ( ( keys . size ( ) ) == 2 ) && ( ! ( keys . contains ( ROLLBACK_ACROSS_GROUPS ) ) ) ) ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . unrecognizedChildren ( ROLLOUT_PLAN , ( ( ( IN_SERIES ) + ",<seq2seq4repair_space>" ) + ( ROLLBACK_ACROSS_GROUPS ) ) , plan . toString ( ) ) ) ; } final ModelNode inSeries = rolloutPlan1 . get ( IN_SERIES ) ; if ( ! ( inSeries . isDefined ( ) ) ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . requiredChildIsMissing ( ROLLOUT_PLAN , IN_SERIES , plan . toString ( ) ) ) ; } final List < ModelNode > groups = inSeries . asList ( ) ; if ( groups . isEmpty ( ) ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . inSeriesIsMissingGroups ( plan . toString ( ) ) ) ; } for ( ModelNode group : groups ) { if ( group . hasDefined ( SERVER_GROUP ) ) { final ModelNode serverGroup = group . get ( SERVER_GROUP ) ; final Set < String > groupKeys ; try { groupKeys = serverGroup . keys ( ) ; } catch ( IllegalArgumentException e ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . serverGroupExpectsSingleChild ( plan . toString ( ) ) ) ; } if ( ( groupKeys . size ( ) ) != 1 ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . serverGroupExpectsSingleChild ( plan . toString ( ) ) ) ; } DomainModelUtil . validateInSeriesServerGroup ( serverGroup . asProperty ( ) . getValue ( ) ) ; } else if ( group . hasDefined ( CONCURRENT_GROUPS ) ) { final ModelNode concurrent = group . get ( CONCURRENT_GROUPS ) ; for ( ModelNode child : concurrent . asList ( ) ) { DomainModelUtil . validateInSeriesServerGroup ( child . asProperty ( ) . getValue ( ) ) ; } } else { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . unexpectedInSeriesGroup ( plan . toString ( ) ) ) ; } } } private static final List < String > ALLOWED_SERVER_GROUP_CHILDREN = Arrays . asList ( new String [ ] { ROLLING_TO_SERVERS , MAX_FAILURE_PERCENTAGE , MAX_FAILED_SERVERS } ) ; private static void validateInSeriesServerGroup ( ModelNode serverGroup ) throws OperationFailedException { } }
class PackageFragmentRootInfo extends OpenableElementInfo { protected SourceMapper sourceMapper = null ; protected int fRootKind = IPackageFragmentRoot . K_SOURCE ; protected Object [ ] fNonJavaResources ; public PackageFragmentRootInfo ( ) { } static Object [ ] computeFolderNonJavaResources ( JavaProject project , IContainer folder , char [ ] [ ] inclusionPatterns , char [ ] [ ] exclusionPatterns ) throws JavaModelException { Object [ ] nonJavaResources = new IResource [ 5 ] ; int nonJavaResourcesCounter = 0 ; try { <START_BUG> IClasspathEntry [ ] classpath = project . getResolvedClasspath ( true ) ; <END_BUG> IResource [ ] members = folder . members ( ) ; nextResource : for ( int i = 0 , max = members . length ; i < max ; i ++ ) { IResource member = members [ i ] ; switch ( member . getType ( ) ) { case IResource . FILE : String fileName = member . getName ( ) ; if ( ( Util . isValidCompilationUnitName ( fileName ) ) && ( ! ( Util . isExcluded ( member , inclusionPatterns , exclusionPatterns ) ) ) ) continue nextResource ; if ( Util . isValidClassFileName ( fileName ) ) continue nextResource ; if ( ( org . eclipse . jdt . internal . compiler . util . Util . isArchiveFileName ( fileName ) ) && ( PackageFragmentRootInfo . isClasspathEntry ( member . getFullPath ( ) , classpath ) ) ) continue nextResource ; break ; case IResource . FOLDER : if ( ( Util . isValidFolderNameForPackage ( member . getName ( ) ) ) && ( ( ! ( Util . isExcluded ( member , inclusionPatterns , exclusionPatterns ) ) ) || ( PackageFragmentRootInfo . isClasspathEntry ( member . getFullPath ( ) , classpath ) ) ) ) continue nextResource ; break ; } if ( ( nonJavaResources . length ) == nonJavaResourcesCounter ) { System . arraycopy ( nonJavaResources , 0 , ( nonJavaResources = new IResource [ nonJavaResourcesCounter * 2 ] ) , 0 , nonJavaResourcesCounter ) ; } nonJavaResources [ ( nonJavaResourcesCounter ++ ) ] = member ; } if ( ( nonJavaResources . length ) != nonJavaResourcesCounter ) { System . arraycopy ( nonJavaResources , 0 , ( nonJavaResources = new IResource [ nonJavaResourcesCounter ] ) , 0 , nonJavaResourcesCounter ) ; } return nonJavaResources ; } catch ( CoreException e ) { throw new JavaModelException ( e ) ; } } private Object [ ] computeNonJavaResources ( IJavaProject project , IResource underlyingResource , PackageFragmentRoot handle ) { } synchronized Object [ ] getNonJavaResources ( IJavaProject project , IResource underlyingResource , PackageFragmentRoot handle ) { } public int getRootKind ( ) { } protected SourceMapper getSourceMapper ( ) { } private static boolean isClasspathEntry ( IPath path , IClasspathEntry [ ] resolvedClasspath ) { } void setNonJavaResources ( Object [ ] resources ) { } protected void setRootKind ( int newRootKind ) { } protected void setSourceMapper ( SourceMapper mapper ) { } }
public abstract class MSVSS extends Task { private static final String SS_EXE = "ss" ; public static final String PROJECT_PREFIX = "$" ; public static final String COMMAND_GET = "Get" ; public static final String COMMAND_CHECKOUT = "Checkout" ; public static final String COMMAND_CHECKIN = "Checkin" ; public static final String COMMAND_LABEL = "Label" ; public static final String COMMAND_HISTORY = "History" ; public static final String FLAG_LOGIN = "-Y" ; public static final String FLAG_OVERRIDE_WORKING_DIR = "-GL" ; public static final String FLAG_AUTORESPONSE_DEF = "-I-" ; public static final String FLAG_AUTORESPONSE_YES = "-I-Y" ; public static final String FLAG_AUTORESPONSE_NO = "-I-N" ; public static final String FLAG_RECURSION = "-R" ; public static final String FLAG_VERSION = "-V" ; public static final String FLAG_VERSION_DATE = "-Vd" ; public static final String FLAG_VERSION_LABEL = "-VL" ; public static final String FLAG_WRITABLE = "-W" ; public static final String VALUE_NO = "-N" ; public static final String VALUE_YES = "-Y" ; public static final String FLAG_QUIET = "-O-" ; private String m_SSDir = "" ; private String m_vssLogin = null ; private String m_vssPath = null ; private String m_serverPath = null ; public final void setLogin ( String login ) { } public final void setServerpath ( String serverPath ) { } public final void setSsdir ( final File dir ) { } public final void setVsspath ( String vssPath ) { } public final String getSSCommand ( ) { } public void getLoginCommand ( Commandline cmd ) { } public String getVsspath ( ) { } protected int run ( Commandline cmd ) throws TaskException { try { final Execute2 exe = new Execute2 ( ) ; setupLogger ( exe ) ; if ( ( m_serverPath ) != null ) { final Properties env = new Properties ( ) ; env . setProperty ( "SSDIR" , m_serverPath ) ; exe . setEnvironment ( env ) ; } exe . setWorkingDirectory ( getBaseDirectory ( ) ) ; <START_BUG> exe . setCommandline ( cmd . getCommandline ( ) ) ; <END_BUG> return exe . execute ( ) ; } catch ( IOException e ) { throw new TaskException ( "Error" , e ) ; } } }
public class RegionUpdateObserver extends RestartableThread { private static final long granularityMin = 20 ; private static final long granularityMax = 10000 ; private final BukkitPluginMain rscp ; private final MovingPlayersCatcher movedPlayers = new MovingPlayersCatcher ( ) ; public RegionUpdateObserver ( BukkitPluginMain rscp ) { } public void registerListeners ( ) { } @ Override public void run ( ) { try { Thread . currentThread ( ) . setName ( ( "rscp:" + ( this . getClass ( ) . getSimpleName ( ) ) ) ) ; Thread . currentThread ( ) . setPriority ( Thread . MIN_PRIORITY ) ; long granularity = rscp . settings . getRegionFinderGranularity ( ) ; if ( granularity < ( RegionUpdateObserver . granularityMin ) ) granularity = RegionUpdateObserver . granularityMin ; if ( granularity > ( RegionUpdateObserver . granularityMax ) ) granularity = RegionUpdateObserver . granularityMax ; for ( ; ! ( Thread . interrupted ( ) ) ; Thread . sleep ( granularity ) ) for ( Player player : movedPlayers . getMovedPlayersAsync ( ) ) if ( rscp . regionListProvider . isRegionListChanged ( player ) ) <START_BUG> rscp . permissionManager . resolvePlayer ( player ) ; <END_BUG> } catch ( InterruptedException ex ) { } } }
public class LuceneSegmentInputFormatTest extends AbstractLuceneStorageTest { private LuceneSegmentInputFormat inputFormat ; private JobContext jobContext ; private Configuration conf ; @ Before public void before ( ) throws Exception { } @ After public void after ( ) throws IOException { } @ Test public void testGetSplits ( ) throws IOException , InterruptedException { } private JobContext getJobContext ( Configuration conf , JobID jobID ) throws ClassNotFoundException , IllegalAccessException , InstantiationException , NoSuchMethodException , InvocationTargetException { <START_BUG> Class < ? extends JobContext > clazz = null ; <END_BUG> if ( ! ( JobContext . class . isInterface ( ) ) ) { clazz = JobContext . class ; } else { clazz = ( ( Class < ? extends JobContext > ) ( Class . forName ( "org.apache.hadoop.mapreduce.task.JobContextImpl" ) ) ) ; } return clazz . getConstructor ( Configuration . class , JobID . class ) . newInstance ( conf , jobID ) ; } }
public class RackAwareStrategy extends AbstractReplicationStrategy { public RackAwareStrategy ( TokenMetadata tokenMetadata , int replicas ) { } public ArrayList < InetAddress > getNaturalEndpoints ( Token token , TokenMetadata metadata ) { int startIndex ; ArrayList < InetAddress > endpoints = new ArrayList < InetAddress > ( ) ; boolean bDataCenter = false ; boolean bOtherRack = false ; int foundCount = 0 ; List tokens = metadata . sortedTokens ( ) ; if ( tokens . isEmpty ( ) ) return endpoints ; int index = Collections . binarySearch ( tokens , token ) ; if ( index < 0 ) { index = ( index + 1 ) * ( - 1 ) ; if ( index >= ( tokens . size ( ) ) ) index = 0 ; } int totalNodes = tokens . size ( ) ; Token primaryToken = ( ( Token ) ( tokens . get ( index ) ) ) ; endpoints . add ( metadata . getEndPoint ( primaryToken ) ) ; foundCount ++ ; if ( ( replicas_ ) == 1 ) { return endpoints ; } startIndex = ( index + 1 ) % totalNodes ; <START_BUG> EndPointSnitch endPointSnitch = ( ( EndPointSnitch ) ( StorageService . instance ( ) . getEndPointSnitch ( ) ) ) ; <END_BUG> for ( int i = startIndex , count = 1 ; ( count < totalNodes ) && ( foundCount < ( replicas_ ) ) ; ++ count , i = ( i + 1 ) % totalNodes ) { try { Token t = ( ( Token ) ( tokens . get ( i ) ) ) ; if ( ! ( endPointSnitch . isInSameDataCenter ( metadata . getEndPoint ( primaryToken ) , metadata . getEndPoint ( t ) ) ) ) { if ( ! bDataCenter ) { endpoints . add ( metadata . getEndPoint ( t ) ) ; bDataCenter = true ; foundCount ++ ; } continue ; } if ( ( ! ( endPointSnitch . isOnSameRack ( metadata . getEndPoint ( primaryToken ) , metadata . getEndPoint ( t ) ) ) ) && ( endPointSnitch . isInSameDataCenter ( metadata . getEndPoint ( primaryToken ) , metadata . getEndPoint ( t ) ) ) ) { if ( ! bOtherRack ) { endpoints . add ( metadata . getEndPoint ( t ) ) ; bOtherRack = true ; foundCount ++ ; } } } catch ( UnknownHostException e ) { throw new RuntimeException ( e ) ; } } for ( int i = startIndex , count = 1 ; ( count < totalNodes ) && ( foundCount < ( replicas_ ) ) ; ++ count , i = ( i + 1 ) % totalNodes ) { Token t = ( ( Token ) ( tokens . get ( i ) ) ) ; if ( ! ( endpoints . contains ( metadata . getEndPoint ( t ) ) ) ) { endpoints . add ( metadata . getEndPoint ( t ) ) ; foundCount ++ ; } } return endpoints ; } }
public class IssuesFederatorPreExportHook implements GatewayPreExportHook { private static final Logger LOG = Logger . getLogger ( IssuesFederatorPreExportHook . class . getName ( ) ) ; private static final String SOURCE_TYPE = "Issues" ; private final Properties config = new Properties ( ) ; public IssuesFederatorPreExportHook ( ) { } @ Override public void call ( final Set < TransferItem > transferQueue ) { } private Properties getConfig ( ) { } private Boolean isSanitisationEnabled ( ) { } private boolean isItemAppropriate ( final Map < String , String > metadata ) { } private boolean isSharedProject ( final Destination destination , final Map < String , String > metadata ) { <START_BUG> final Set < Repository > destinationOutboundRepositories = GatewayManagementServiceFacade . getInstance ( ) . getOutboundRepositoriesForDestination ( destination ) ; <END_BUG> if ( ! ( destinationOutboundRepositories . isEmpty ( ) ) ) { for ( final Repository federatedOutboundRepo : destinationOutboundRepositories ) { if ( federatedOutboundRepo . getIdentifier ( ) . equalsIgnoreCase ( metadata . get ( "project" ) ) ) { return true ; } } } return false ; } private void sanitise ( final TransferItem item ) { } }
class DataHandler { public static void main ( String [ ] args ) { ArrayList < SingleInstance > dataset = new ArrayList < > ( ) ; BufferedReader bufferedReader ; String line ; String [ ] tokens ; final int numClusters = 3 ; ArrayList < Centroid > centroids ; try { bufferedReader = new BufferedReader ( new FileReader ( args [ 0 ] ) ) ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { tokens = line . split ( "," ) ; dataset . add ( new SingleInstance ( new DateEntry ( tokens [ 0 ] ) , new Pollution ( tokens [ 1 ] , tokens [ 2 ] , tokens [ 3 ] ) , new BikeData ( tokens [ 4 ] , tokens [ 5 ] ) ) ) ; } System . out . println ( ( "size<seq2seq4repair_space>of<seq2seq4repair_space>list<seq2seq4repair_space>-<seq2seq4repair_space>" + ( dataset . size ( ) ) ) ) ; centroids = DataHandler . calculateStartingCentroids ( dataset , numClusters ) ; ClusterChecker checker = new ClusterChecker ( dataset , centroids ) ; <START_BUG> checker . calculateClosestClustersToData ( ) ; <END_BUG> } catch ( Exception e ) { System . out . println ( ( "Failure<seq2seq4repair_space>in<seq2seq4repair_space>Main<seq2seq4repair_space>-<seq2seq4repair_space>" + e ) ) ; } } public static ArrayList < Centroid > calculateStartingCentroids ( ArrayList < SingleInstance > data , int numClusters ) { } public static int randInt ( int min , int max ) { } No newline ; at end ; of file ; }
@ SuppressWarnings ( "serial" ) public class SnippetTextArea extends KnimeSyntaxTextArea { public SnippetTextArea ( final ScalaSnippet snippet ) { } @ Override public Color getForegroundForToken ( final Token t ) { <START_BUG> if ( this . isInGuardedSection ( t . offset ) ) <END_BUG> return Color . gray ; return super . getForegroundForToken ( t ) ; } private boolean isInGuardedSection ( final int offset ) { } }
public class CompoundPropertyModel extends AbstractPropertyModel implements ICompoundModel { private static final long serialVersionUID = 1L ; public CompoundPropertyModel ( final Object model ) { } protected String propertyExpression ( final Component component ) { } protected Class propertyType ( final Component component ) { if ( component instanceof FormComponent ) { <START_BUG> return ( ( FormComponent ) ( component ) ) . getValidationType ( ) ; <END_BUG> } return null ; } public String toString ( ) { } }
public class ApplyNamedEffect implements ISpellEffect { String _effectName ; public ApplyNamedEffect ( String effectName ) { } @ Override public void apply ( SpellEffectContext context ) { } @ Override public void unapply ( SpellEffectContext context ) { <START_BUG> if ( context . Spell . getGameObject ( ) . hasThisAttribute ( _effectName ) ) { <END_BUG> context . Target . getGameObject ( ) . removeThisAttribute ( _effectName ) ; } } }
public class VelocityContributor extends AbstractBehavior { private static final long serialVersionUID = 1L ; private String encoding = "ISO-8859-1" ; private final IModel < ? extends Map < ? , ? > > model ; private final String templateName ; public VelocityContributor ( String templateName , final IModel < ? extends Map < ? , ? > > model ) { } @ Override public void detach ( Component c ) { if ( ( model ) instanceof IDetachable ) { <START_BUG> ( ( IDetachable ) ( model ) ) . detach ( ) ; <END_BUG> } } public String getEncoding ( ) { } @ Override public void renderHead ( Component component , final IHeaderResponse response ) { } public void setEncoding ( String encoding ) { } protected boolean escapeHtml ( ) { } protected final CharSequence evaluate ( ) { } }
public class SwingManagedJSettlers { private static final String BUILD = "commit:<seq2seq4repair_space>" + ( CommitInfo . COMMIT_HASH_SHORT ) ; public static void main ( String [ ] args ) throws FileNotFoundException , IOException , ClassNotFoundException , MapLoadException { } public static void setupResourceManagers ( HashMap < String , String > argsMap , String defaultConfigFileName ) throws FileNotFoundException , IOException { ConfigurationPropertiesFile configFile = SwingManagedJSettlers . getConfigFile ( argsMap , defaultConfigFileName ) ; SwingResourceLoader . setupResourcesManager ( configFile ) ; if ( ! ( configFile . isSettlersFolderSet ( ) ) ) { JFileChooser fileDialog = new JFileChooser ( ) ; fileDialog . setAcceptAllFileFilterUsed ( false ) ; fileDialog . setFileFilter ( new FileFilter ( ) { @ Override public String getDescription ( ) { return null ; } @ Override public boolean accept ( File f ) { return f . isDirectory ( ) ; } } ) ; fileDialog . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; fileDialog . setDialogType ( JFileChooser . SAVE_DIALOG ) ; fileDialog . setMultiSelectionEnabled ( false ) ; fileDialog . setDialogTitle ( Labels . getString ( "select-settlers-3-folder" ) ) ; fileDialog . showOpenDialog ( null ) ; File selectedFolder = fileDialog . getSelectedFile ( ) ; if ( selectedFolder == null ) { String noFolderSelctedMessage = Labels . getString ( "error-no-settlers-3-folder-selected" ) ; JOptionPane . showMessageDialog ( null , noFolderSelctedMessage ) ; System . err . println ( noFolderSelctedMessage ) ; System . exit ( 1 ) ; } System . out . println ( selectedFolder ) ; try { configFile . setSettlersFolder ( selectedFolder ) ; } catch ( IOException ex ) { String errorSavingSettingsMessage = Labels . getString ( "error-settings-not-saveable" ) ; System . err . println ( errorSavingSettingsMessage ) ; JOptionPane . showMessageDialog ( null , errorSavingSettingsMessage ) ; ex . printStackTrace ( ) ; } } <START_BUG> SwingResourceLoader . setupGraphicsAndSounResources ( configFile ) ; <END_BUG> } public static ConfigurationPropertiesFile getConfigFile ( HashMap < String , String > argsMap , String defaultConfigFileName ) throws IOException { } public static void loadDebugSettings ( HashMap < String , String > argsMap ) { } public static JSettlersScreen startGui ( ) { } private static void generateContent ( HashMap < String , String > argsMap , JSettlersScreen content ) throws IOException , MapLoadException { } private static void startRedrawTimer ( final JSettlersScreen content ) { } private static void startJogl ( Area area ) { } }
public class Assignment extends Expression { public Reference lhs ; public Expression expression ; public Assignment ( Expression lhs , Expression expression , int sourceEnd ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } void checkAssignmentEffect ( BlockScope scope ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } Binding getDirectBinding ( Expression someExpression ) { } public TypeBinding resolveType ( BlockScope scope ) { constant = NotAConstant ; this . resolvedType = lhs . resolveType ( scope ) ; TypeBinding rhsType = expression . resolveType ( scope ) ; if ( ( ( this . resolvedType ) == null ) || ( rhsType == null ) ) { return null ; } checkAssignmentEffect ( scope ) ; if ( ( ( expression . isConstantValueOfTypeAssignableToType ( rhsType , this . resolvedType ) ) || ( ( this . resolvedType . isBaseType ( ) ) && ( BaseTypeBinding . isWidening ( this . resolvedType . id , rhsType . id ) ) ) ) || ( rhsType . isCompatibleWith ( this . resolvedType ) ) ) { expression . implicitWidening ( this . resolvedType , rhsType ) ; return this . resolvedType ; } scope . problemReporter ( ) . typeMismatchErrorActualTypeExpectedType ( expression , rhsType , this . resolvedType ) ; <START_BUG> return null ; <END_BUG> } public String toString ( int tab ) { } public String toStringExpression ( ) { } public String toStringExpressionNoParenthesis ( ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope scope ) { } }
public class LocalConfiguration extends Configuration { public Mode mode = Mode . VERIFY ; public int aliceInputSize = 0 ; public int bobInputSize = 0 ; public int [ ] aliceInput = null ; public int [ ] bobInput = null ; public int [ ] [ ] aliceInput2D = null ; public int [ ] [ ] bobInput2D = null ; public boolean is2Ddata ; public int stackFrameSize = 0 ; public String ServerAddress ; public int ServerPort ; protected LocalConfiguration ( Party party ) throws IOException { } private int [ ] readArrayFromFile ( String file , int length ) throws IOException { List < String > lines = Files . readAllLines ( Paths . get ( file ) ) ; int [ ] data = new int [ length ] ; for ( int i = 0 ; i < ( data . length ) ; ++ i ) <START_BUG> data [ i ] = new Integer ( lines . get ( i ) ) ; <END_BUG> return data ; } protected LocalConfiguration ( LocalConfiguration that ) throws IOException { } No newline ; at end ; of file ; }
public class TestActionGui extends AbstractSamplerGui { private JComboBox targetBox ; private JRadioButton pauseButton ; private JRadioButton stopButton ; private JTextField durationField ; private int target ; private int action ; private int duration ; private static final String targetLabel = JMeterUtils . getResString ( "test_action_target" ) ; private static final String threadTarget = JMeterUtils . getResString ( "test_action_target_thread" ) ; private static final String testTarget = JMeterUtils . getResString ( "test_action_target_test" ) ; private static final String actionLabel = JMeterUtils . getResString ( "test_action_action" ) ; private static final String pauseAction = JMeterUtils . getResString ( "test_action_pause" ) ; private static final String stopAction = JMeterUtils . getResString ( "test_action_stop" ) ; private static final String durationLabel = JMeterUtils . getResString ( "test_action_duration" ) ; public TestActionGui ( ) { } public String getLabelResource ( ) { } public void configure ( TestElement element ) { } public TestElement createTestElement ( ) { } public void modifyTestElement ( TestElement element ) { } private void init ( ) { setLayout ( new VerticalLayout ( 5 , VerticalLayout . LEFT , VerticalLayout . TOP ) ) ; setBorder ( makeBorder ( ) ) ; add ( makeTitlePanel ( ) ) ; HorizontalPanel targetPanel = new HorizontalPanel ( ) ; targetPanel . add ( new JLabel ( TestActionGui . targetLabel ) ) ; DefaultComboBoxModel targetModel = new DefaultComboBoxModel ( ) ; targetModel . addElement ( TestActionGui . threadTarget ) ; targetModel . addElement ( TestActionGui . testTarget ) ; targetBox = new JComboBox ( targetModel ) ; targetBox . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( ( ( String ) ( targetBox . getSelectedItem ( ) ) ) . equals ( TestActionGui . threadTarget ) ) { target = TestAction . THREAD ; } else { target = TestAction . TEST ; } } } ) ; targetPanel . add ( targetBox ) ; add ( targetPanel ) ; HorizontalPanel actionPanel = new HorizontalPanel ( ) ; ButtonGroup actionButtons = new ButtonGroup ( ) ; pauseButton = new JRadioButton ( TestActionGui . pauseAction , true ) ; pauseButton . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { if ( pauseButton . isSelected ( ) ) { action = TestAction . PAUSE ; durationField . setEnabled ( true ) ; } } } ) ; stopButton = new JRadioButton ( TestActionGui . stopAction , false ) ; stopButton . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { if ( stopButton . isSelected ( ) ) { action = TestAction . STOP ; durationField . setEnabled ( false ) ; } } } ) ; actionButtons . add ( pauseButton ) ; actionButtons . add ( stopButton ) ; actionPanel . add ( new JLabel ( TestActionGui . actionLabel ) ) ; actionPanel . add ( pauseButton ) ; actionPanel . add ( stopButton ) ; add ( actionPanel ) ; HorizontalPanel durationPanel = new HorizontalPanel ( ) ; durationField = new JTextField ( 5 ) ; durationField . setText ( Integer . toString ( duration ) ) ; durationField . addFocusListener ( new FocusListener ( ) { public void focusLost ( FocusEvent e ) { try { duration = Integer . parseInt ( durationField . getText ( ) ) ; } catch ( NumberFormatException nfe ) { duration = 0 ; } } public void focusGained ( FocusEvent e ) { } } ) ; <START_BUG> durationPanel . add ( new JLabel ( "Duration" ) ) ; <END_BUG> durationPanel . add ( durationField ) ; add ( durationPanel ) ; } }
@ InterfaceAudience . Private public final class Pusher extends Replication implements Database . ChangeListener { private boolean createTarget ; private boolean creatingTarget ; private boolean observing ; private ReplicationFilter filter ; private boolean dontSendMultipart = false ; SortedSet < Long > pendingSequences ; Long maxPendingSequence ; @ InterfaceAudience . Private public Pusher ( Database db , URL remote , boolean continuous , ScheduledExecutorService workExecutor ) { } @ InterfaceAudience . Private public Pusher ( Database db , URL remote , boolean continuous , HttpClientFactory clientFactory , ScheduledExecutorService workExecutor ) { } @ Override @ InterfaceAudience . Public public boolean isPull ( ) { } @ Override @ InterfaceAudience . Public public boolean shouldCreateTarget ( ) { } @ Override @ InterfaceAudience . Public public void setCreateTarget ( boolean createTarget ) { } @ Override @ InterfaceAudience . Public public void stop ( ) { } @ InterfaceAudience . Private private void addPending ( RevisionInternal revisionInternal ) { } @ InterfaceAudience . Private private void removePending ( RevisionInternal revisionInternal ) { } @ Override @ InterfaceAudience . Private void maybeCreateRemoteDB ( ) { } @ Override @ InterfaceAudience . Private public void beginReplicating ( ) { } @ InterfaceAudience . Private private void stopObserving ( ) { } @ Override @ InterfaceAudience . Private public void changed ( Database . ChangeEvent event ) { } @ Override @ InterfaceAudience . Private protected void processInbox ( final RevisionList changes ) { Map < String , List < String > > diffs = new HashMap < String , List < String > > ( ) ; for ( RevisionInternal rev : changes ) { String docID = rev . getDocId ( ) ; List < String > revs = diffs . get ( docID ) ; if ( revs == null ) { revs = new ArrayList < String > ( ) ; diffs . put ( docID , revs ) ; } revs . add ( rev . getRevId ( ) ) ; addPending ( rev ) ; } Log . v ( TAG_SYNC , "%s:<seq2seq4repair_space>posting<seq2seq4repair_space>to<seq2seq4repair_space>/_revs_diff" , this ) ; Log . v ( TAG_SYNC_ASYNC_TASK , "%s<seq2seq4repair_space>|<seq2seq4repair_space>%s:<seq2seq4repair_space>processInbox()<seq2seq4repair_space>calling<seq2seq4repair_space>asyncTaskStarted()" , this , Thread . currentThread ( ) ) ; asyncTaskStarted ( ) ; sendAsyncRequest ( "POST" , "/_revs_diff" , diffs , new RemoteRequestCompletionBlock ( ) { @ Override public void onCompletion ( Object response , Throwable e ) { try { <START_BUG> Log . v ( TAG_SYNC , "%s:<seq2seq4repair_space>got<seq2seq4repair_space>/_revs_diff<seq2seq4repair_space>response" ) ; <END_BUG> Map < String , Object > results = ( ( Map < String , Object > ) ( response ) ) ; if ( e != null ) { setError ( e ) ; revisionFailed ( ) ; } else if ( ( results . size ( ) ) != 0 ) { final List < Object > docsToSend = new ArrayList < Object > ( ) ; RevisionList revsToSend = new RevisionList ( ) ; for ( RevisionInternal rev : changes ) { Map < String , Object > properties = null ; Map < String , Object > revResults = ( ( Map < String , Object > ) ( results . get ( rev . getDocId ( ) ) ) ) ; if ( revResults == null ) { continue ; } List < String > revs = ( ( List < String > ) ( revResults . get ( "missing" ) ) ) ; if ( ( revs == null ) || ( ! ( revs . contains ( rev . getRevId ( ) ) ) ) ) { removePending ( rev ) ; continue ; } EnumSet < Database . TDContentOptions > contentOptions = EnumSet . of ( TDIncludeAttachments ) ; if ( ( ! ( dontSendMultipart ) ) && ( ( revisionBodyTransformationBlock ) == null ) ) { contentOptions . add ( TDBigAttachmentsFollow ) ; } RevisionInternal loadedRev ; try { loadedRev = db . loadRevisionBody ( rev , contentOptions ) ; properties = new HashMap < String , Object > ( rev . getProperties ( ) ) ; } catch ( CouchbaseLiteException e1 ) { Log . w ( TAG_SYNC , "%s<seq2seq4repair_space>Couldn't<seq2seq4repair_space>get<seq2seq4repair_space>local<seq2seq4repair_space>contents<seq2seq4repair_space>of<seq2seq4repair_space>%s" , rev , Pusher . this ) ; revisionFailed ( ) ; continue ; } RevisionInternal populatedRev = transformRevision ( loadedRev ) ; List < String > possibleAncestors = ( ( List < String > ) ( revResults . get ( "possible_ancestors" ) ) ) ; properties = new HashMap < String , Object > ( populatedRev . getProperties ( ) ) ; Map < String , Object > revisions = db . getRevisionHistoryDictStartingFromAnyAncestor ( populatedRev , possibleAncestors ) ; properties . put ( "_revisions" , revisions ) ; populatedRev . setProperties ( properties ) ; if ( properties . containsKey ( "_attachments" ) ) { int minRevPos = Pusher . findCommonAncestor ( populatedRev , possibleAncestors ) ; Database . stubOutAttachmentsInRevBeforeRevPos ( populatedRev , ( minRevPos + 1 ) , false ) ; properties = populatedRev . getProperties ( ) ; if ( ( ! ( dontSendMultipart ) ) && ( uploadMultipartRevision ( populatedRev ) ) ) { continue ; } } if ( ( properties == null ) || ( ! ( properties . containsKey ( "_id" ) ) ) ) { throw new IllegalStateException ( "properties<seq2seq4repair_space>must<seq2seq4repair_space>contain<seq2seq4repair_space>a<seq2seq4repair_space>document<seq2seq4repair_space>_id" ) ; } revsToSend . add ( rev ) ; docsToSend . add ( properties ) ; } uploadBulkDocs ( docsToSend , revsToSend ) ; } else { for ( RevisionInternal revisionInternal : changes ) { removePending ( revisionInternal ) ; } } } finally { Log . v ( TAG_SYNC_ASYNC_TASK , "%s<seq2seq4repair_space>|<seq2seq4repair_space>%s:<seq2seq4repair_space>processInbox.sendAsyncRequest()<seq2seq4repair_space>calling<seq2seq4repair_space>asyncTaskFinished()" , this , Thread . currentThread ( ) ) ; asyncTaskFinished ( 1 ) ; } } } ) ; } @ InterfaceAudience . Private protected void uploadBulkDocs ( List < Object > docsToSend , final RevisionList changes ) { } @ InterfaceAudience . Private private boolean uploadMultipartRevision ( final RevisionInternal revision ) { } private void uploadJsonRevision ( final RevisionInternal rev ) { }
public abstract class Border extends WebMarkupContainerWithAssociatedMarkup implements IComponentResolver { private static final long serialVersionUID = 1L ; static final String BODY = "body" ; static final String BORDER = "border" ; static final String BODY_ID = "_body" ; private final Border . BorderBodyContainer body ; private transient MarkupStream originalMarkupStream ; private transient ComponentTag openTag ; private int beginOfBodyIndex ; private transient boolean rendering ; public Border ( final String id ) { } public Border ( final String id , final IModel < ? > model ) { } public final Border . BorderBodyContainer getBodyContainer ( ) { } Border . BorderBodyContainer newBorderBodyContainer ( final String id ) { } @ Override public MarkupContainer add ( final Component ... children ) { } @ Override public Component add ( final IBehavior ... behaviors ) { } public MarkupContainer addToBorder ( final Component ... children ) { } public Component addToBorder ( final IBehavior ... behaviors ) { } public Border addToBorderBody ( final Component ... child ) { } public Component addToBorderBody ( final IBehavior ... behaviors ) { } public final Component getFromBorderBody ( final String path ) { } public boolean resolve ( final MarkupContainer container , final MarkupStream markupStream , final ComponentTag tag ) { if ( ( rendering ) == false ) { if ( tag instanceof WicketTag ) { WicketTag wtag = ( ( WicketTag ) ( tag ) ) ; if ( wtag . isBodyTag ( ) ) { rendering = true ; try { <START_BUG> body . render ( markupStream ) ; <END_BUG> } finally { rendering = false ; } return true ; } } } return false ; } @ Override protected void onComponentTag ( final ComponentTag tag ) { } @ Override protected final void onComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } @ Override public void renderHead ( HtmlHeaderContainer container ) { } @ Override public IMarkupFragment getMarkup ( final Component child ) { } public class BorderBodyContainer extends WebMarkupContainer { private static final long serialVersionUID = 1L ; private transient boolean wasOpenCloseTag = false ; private boolean transparentResolver ; public BorderBodyContainer ( final String id ) { } @ Override public final boolean isTransparentResolver ( ) { } public final void setTransparentResolver ( final boolean value ) { } @ Override protected void onComponentTag ( final ComponentTag tag ) { } @ Override protected void onComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } @ Override public IMarkupFragment getMarkup ( ) { } @ Override public IMarkupFragment getMarkup ( final Component child ) { } } }
public class PresentSelectorTest extends BaseSelectorTest { private Project project ; public PresentSelectorTest ( String name ) { } public BaseSelector getInstance ( ) { } public void testValidate ( ) { } public void testSelectionBehaviour ( ) { PresentSelector s ; String results ; Mapper m ; Mapper . MapperType identity = new Mapper . MapperType ( ) ; identity . setValue ( "identity" ) ; Mapper . MapperType glob = new Mapper . MapperType ( ) ; glob . setValue ( "glob" ) ; Mapper . MapperType merge = new Mapper . MapperType ( ) ; merge . setValue ( "merge" ) ; Mapper . MapperType flatten = new Mapper . MapperType ( ) ; flatten . setValue ( "flatten" ) ; try { makeBed ( ) ; s = ( ( PresentSelector ) ( getInstance ( ) ) ) ; s . setTargetdir ( beddir ) ; results = selectionString ( s ) ; assertEquals ( "TTTTTTTTTTTT" , results ) ; s = ( ( PresentSelector ) ( getInstance ( ) ) ) ; s . setTargetdir ( beddir ) ; m = s . createMapper ( ) ; m . setType ( identity ) ; results = selectionString ( s ) ; assertEquals ( "TTTTTTTTTTTT" , results ) ; s = ( ( PresentSelector ) ( getInstance ( ) ) ) ; <START_BUG> File subdir = new File ( "src/etc/testcases/taskdefs/expected" ) ; <END_BUG> s . setTargetdir ( subdir ) ; m = s . createMapper ( ) ; m . setType ( flatten ) ; results = selectionString ( s ) ; if ( JavaEnvUtils . isJavaVersion ( JAVA_1_1 ) ) { assertEquals ( "TTTTTFFFFFFF" , results ) ; } else { assertEquals ( "TTTTTTTTTTTF" , results ) ; } s = ( ( PresentSelector ) ( getInstance ( ) ) ) ; s . setTargetdir ( beddir ) ; m = s . createMapper ( ) ; m . setType ( merge ) ; m . setTo ( "asf-logo.gif.gz" ) ; results = selectionString ( s ) ; assertEquals ( "TTTTTTTTTTTT" , results ) ; s = ( ( PresentSelector ) ( getInstance ( ) ) ) ; subdir = new File ( beddir , "tar/bz2" ) ; s . setTargetdir ( subdir ) ; m = s . createMapper ( ) ; m . setType ( glob ) ; m . setFrom ( "*.bz2" ) ; m . setTo ( "*.tar.bz2" ) ; results = selectionString ( s ) ; assertEquals ( "FFTFFFFFFFFF" , results ) ; try { makeMirror ( ) ; s = ( ( PresentSelector ) ( getInstance ( ) ) ) ; subdir = getProject ( ) . resolveFile ( "selectortest2" ) ; s . setTargetdir ( subdir ) ; results = mirrorSelectionString ( s ) ; assertEquals ( "TTTFFTTTTTTT" , results ) ; results = selectionString ( s ) ; assertEquals ( "TTTFFTTTTTTT" , results ) ; } finally { cleanupMirror ( ) ; } } finally { cleanupBed ( ) ; } } }
public class Table { public static final String SYSTEM_TABLE = "system" ; private static final Logger logger = LoggerFactory . getLogger ( Table . class ) ; private static final String SNAPSHOT_SUBDIR_NAME = "snapshots" ; static final ReentrantReadWriteLock flusherLock = new ReentrantReadWriteLock ( true ) ; private static Timer flushTimer = new Timer ( "FLUSH-TIMER" ) ; private final boolean waitForCommitLog ; private static final Map < String , Table > instances = new org . cliffc . high_scale_lib . NonBlockingHashMap < String , Table > ( ) ; public final String name ; private final Map < Integer , ColumnFamilyStore > columnFamilyStores = new HashMap < Integer , ColumnFamilyStore > ( ) ; private SortedSet < String > applicationColumnFamilies ; private final TimerTask flushTask ; public static Table open ( String table ) { } public static Table clear ( String table ) throws IOException { } public Collection < ColumnFamilyStore > getColumnFamilyStores ( ) { } public ColumnFamilyStore getColumnFamilyStore ( int cfId ) { } @ Deprecated public ColumnFamilyStore getColumnFamilyStore ( String cfName ) { } public void forceCleanup ( ) { } public void snapshot ( String clientSuppliedName ) { } public static String getTimestampedSnapshotName ( String clientSuppliedName ) { } public void clearSnapshot ( ) throws IOException { } public List < SSTableReader > forceAntiCompaction ( Collection < Range > ranges , InetAddress target ) { } public void forceCompaction ( ) { } List < SSTableReader > getAllSSTablesOnDisk ( ) { } private Table ( String table ) { } public void dropCf ( int cfId ) throws IOException { } public void initCf ( int cfId , String cfName ) { } public void renameCf ( int cfId , String newName ) throws IOException { } public Row getRow ( QueryFilter filter ) throws IOException { } public void apply ( RowMutation mutation , Object serializedMutation , boolean writeCommitLog ) throws IOException { HashMap < ColumnFamilyStore , Memtable > memtablesToFlush = new HashMap < ColumnFamilyStore , Memtable > ( 2 ) ; Table . flusherLock . readLock ( ) . lock ( ) ; try { if ( writeCommitLog ) { CommitLog . instance ( ) . add ( mutation , serializedMutation ) ; } DecoratedKey key = StorageService . getPartitioner ( ) . decorateKey ( mutation . key ( ) ) ; for ( ColumnFamily columnFamily : mutation . getColumnFamilies ( ) ) { Memtable memtableToFlush ; ColumnFamilyStore cfs = columnFamilyStores . get ( columnFamily . id ( ) ) ; if ( cfs == null ) { <START_BUG> Table . logger . error ( ( "Attempting<seq2seq4repair_space>to<seq2seq4repair_space>mutate<seq2seq4repair_space>non-existant<seq2seq4repair_space>column<seq2seq4repair_space>family<seq2seq4repair_space>" + ( columnFamily . name ( ) ) ) ) ; <END_BUG> } else { if ( ( memtableToFlush = cfs . apply ( key , columnFamily ) ) != null ) memtablesToFlush . put ( cfs , memtableToFlush ) ; ColumnFamily cachedRow = cfs . getRawCachedRow ( key ) ; if ( cachedRow != null ) cachedRow . addAll ( columnFamily ) ; } } } finally { Table . flusherLock . readLock ( ) . unlock ( ) ; } for ( Map . Entry < ColumnFamilyStore , Memtable > entry : memtablesToFlush . entrySet ( ) ) entry . getKey ( ) . maybeSwitchMemtable ( entry . getValue ( ) , writeCommitLog ) ; } public List < Future < ? > > flush ( ) throws IOException { } void load ( RowMutation rowMutation ) throws IOException { } public String getDataFileLocation ( long expectedCompactedFileSize ) { } public static String getSnapshotPath ( String dataDirPath , String tableName , String snapshotName ) { } public static Iterable < Table > all ( ) { } public void truncate ( String cfname ) throws IOException , InterruptedException , ExecutionException { } }
public class HandComparator implements Comparator < Hand > { private final CardComparator cardComparator ; public HandComparator ( ) { } @ Override public int compare ( Hand hand1 , Hand hand2 ) { } protected int compareHighCard ( Card [ ] [ ] cards1 , Card [ ] [ ] cards2 ) { } protected int compareHighCard ( Card [ ] cards1 , Card [ ] cards2 ) { ParameterCheck . requireNotNullSameLength ( cards1 , cards2 ) ; Card [ ] sortedCards1 = Arrays . copyOf ( cards1 , cards1 . length ) ; Arrays . sort ( sortedCards1 , cardComparator ) ; Card [ ] sortedCards2 = Arrays . copyOf ( cards2 , cards2 . length ) ; Arrays . sort ( sortedCards2 , cardComparator ) ; for ( int i = 0 ; i < ( cards1 . length ) ; i ++ ) { <START_BUG> int comparison = cardComparator . compare ( cards1 [ i ] , cards2 [ i ] ) ; <END_BUG> if ( comparison != 0 ) { return comparison ; } } return 0 ; } }
public class UserControl extends Thread { private Socket socket ; private BufferedReader input ; private BufferedWriter output ; private int userID ; private boolean bValidConnection = true ; private ArrayList < Document > requestDocs ; private ArrayList < LinkedList > linkedLists ; private ArrayList < Integer > workingDocIds ; public UserControl ( Socket socket , int userID ) { } @ Override protected void finalize ( ) throws Throwable { } public void run ( ) { } private void commandToUser ( Object commandToUser ) { } private void commandParser ( String commandFromUser ) { } private void requestDocMetaHandler ( RequestDocMeta requestDocMeta ) { } private void requestAnnoTaskWork ( RequestAnnoTaskWork requestAnnoTaskWork ) { } private void deleteListRequestHandler ( RequestAddDeleteList requestedDeleteList ) { } private void thesaurusRequestHandler ( RequestAddThesaurus entryComponents ) { } private void removeDeleteList ( String deleteTerm ) { } private String readThesaurus ( String term ) { } private void removeThesaurusTable ( String term ) { } private boolean isExistDeleteList ( String term ) { } private boolean isExistThesaurusTable ( String term ) { } private void addDeleteList ( String term ) { } private void addThesaurus ( String conceptFrom , String conceptTo , String metaOntology ) { } private void documentRequestHandler ( DocumentRequest documentRequest ) { } private void requestTermTransferHandler ( RequestTermTransfer requestTermTransfer ) { } private ArrayList < TermFreqByDoc > nGramFilter ( ArrayList < Integer > docIdList ) { <START_BUG> ArrayList < TermFreqByDoc > filtering = TermFreqDBManager . getInstance ( ) . getTermConditional ( docIdList . get ( 0 ) ) ; <END_BUG> TermFreqDBManager . getInstance ( ) . termLock ( docIdList , userID ) ; for ( int i = ( filtering . size ( ) ) - 1 ; i >= 0 ; i -- ) { TermFreqByDoc termFreqByDocFilter = filtering . get ( i ) ; int termFreqSum = 0 ; for ( int termFreq : termFreqByDocFilter . values ( ) ) { termFreqSum = termFreqSum + termFreq ; } if ( ( ( termFreqByDocFilter . getNgram ( ) ) == 1 ) || ( termFreqSum > 1 ) ) { termFreqByDocFilter . setTermFreq4RequestedCorpus ( termFreqSum ) ; continue ; } filtering . remove ( termFreqByDocFilter ) ; } return filtering ; } private void requestByDateHandler ( RequestByDate requestByDate ) { } private void requestConceptToList ( RequestConceptToList requestConceptToList ) { } private void outputScheme ( ArrayList < ConceptToList > originConceptLists , ArrayList < ConceptToList > processedConceptLists ) { } private void requestLinkedList ( RequestGetLinkedList requestedLinkedList ) { } private void transferObject ( Object obj ) { } private void termUnlock ( int userID ) { } private String commandFromUser ( ) { } }
public class WeatherChecker { private static final Logger LOGGER = LoggerFactory . getLogger ( WeatherChecker . class ) ; private static final String BASE_URL = "http://api.openweathermap.org/data/2.5/weather?q=" ; public static Weather getWeather ( String searchTerm ) throws WeatherCheckerException { } private static Weather getWeatherFromJson ( JSONObject json ) throws JSONException { Weather weather = new Weather ( ) ; JSONObject main = json . getJSONObject ( "main" ) ; JSONArray weatherArray = json . getJSONArray ( "weather" ) ; JSONObject wind = json . getJSONObject ( "wind" ) ; JSONObject sys = json . getJSONObject ( "sys" ) ; JSONObject clouds = json . getJSONObject ( "clouds" ) ; String cloudCover = clouds . getString ( "all" ) ; weather . setClouds ( cloudCover ) ; String windSpeed = wind . getString ( "speed" ) ; weather . setWind ( windSpeed ) ; String country = sys . getString ( "country" ) ; weather . setCountry ( country ) ; <START_BUG> String city = sys . getString ( "name" ) ; <END_BUG> weather . setCity ( city ) ; String temp = main . getString ( "temp" ) ; temp = WeatherChecker . convertToFarenheit ( temp ) ; weather . setTemp ( temp ) ; String humidity = main . getString ( "humidity" ) ; weather . setHumidity ( humidity ) ; if ( ( weatherArray . length ( ) ) > 0 ) { String description = weatherArray . getJSONObject ( 0 ) . getString ( "description" ) ; weather . setDescription ( description ) ; } return weather ; } private static String convertToFarenheit ( String kelvin ) { } private static String getUrl ( String appKey , String searchTerm ) { } private static String getAppKey ( ) throws WeatherCheckerException { } public static void main ( String [ ] args ) { } }
public class Converter { private final String testSuiteName ; private final String outPath ; public static Converter createConverForFile ( String testSuiteName , String outPath ) { } public static Converter createConverForPath ( String testSuiteName , String outPath ) { } private Converter ( String testSuiteName , String outPath , boolean isFilename ) { } public void convert ( String streamToRead ) throws FileNotFoundException , IOException { } private InstrumentationResultParser createParser ( String testSuite , final XMLResultFormatter outputter ) { ITestRunListener listener = new ITestRunListener ( ) { @ Override public void testEnded ( TestIdentifier test , Map < String , String > arg1 ) { System . out . println ( ( "testEnded<seq2seq4repair_space>" + test ) ) ; outputter . endTest ( test ) ; } @ Override public void testFailed ( TestFailure arg0 , TestIdentifier test , String arg2 ) { System . out . println ( ( ( ( "testFailed<seq2seq4repair_space>" + arg0 ) + "/" ) + arg2 ) ) ; BufferedReader reader = new BufferedReader ( new StringReader ( arg2 ) ) ; try { String error = reader . readLine ( ) ; <START_BUG> String [ ] errorSeperated = error . split ( ":" ) ; <END_BUG> outputter . addFailure ( test , ( ( errorSeperated . length ) > 1 ? errorSeperated [ 1 ] . trim ( ) : "Failed" ) , errorSeperated [ 0 ] . trim ( ) , arg2 . substring ( error . length ( ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; outputter . addFailure ( test , e ) ; } } @ Override public void testRunEnded ( long elapsedTime , Map < String , String > arg1 ) { } @ Override public void testRunFailed ( String name ) { System . out . println ( ( "testRunFailed<seq2seq4repair_space>" + name ) ) ; } @ Override public void testRunStarted ( String name , int arg1 ) { } @ Override public void testRunStopped ( long elapsedTime ) { } @ Override public void testStarted ( final TestIdentifier test ) { System . out . println ( ( "testStarted<seq2seq4repair_space>" + ( test . toString ( ) ) ) ) ; outputter . startTest ( test ) ; } } ; return new InstrumentationResultParser ( testSuite , listener ) ; } }
public class Database { private static Database db ; private static Connection connection ; public static void main ( String [ ] args ) throws ClassNotFoundException , SQLException { } public static Database getDB ( ) throws ClassNotFoundException , SQLException { } private Database ( String s ) throws ClassNotFoundException , SQLException { } public static boolean addTrade ( Trade trade ) { } public static Date getLastUpdateTime ( ) { } public static SearchResult search ( Search s ) { try { PreparedStatement ps = Database . connection . prepareStatement ( ( "SELECT<seq2seq4repair_space>*<seq2seq4repair_space>FROM<seq2seq4repair_space>data<seq2seq4repair_space>WHERE<seq2seq4repair_space>" + ( ( ( ( ( ( ( ( "tradeType<seq2seq4repair_space>=<seq2seq4repair_space>?<seq2seq4repair_space>AND" + "assetClass<seq2seq4repair_space>=<seq2seq4repair_space>?<seq2seq4repair_space>AND" ) + "taxonomy<seq2seq4repair_space>=<seq2seq4repair_space>?<seq2seq4repair_space>AND" ) + "optionStrikePrice<seq2seq4repair_space>>=<seq2seq4repair_space>?<seq2seq4repair_space>AND" ) + "optionStrikePrice<seq2seq4repair_space><=<seq2seq4repair_space>?<seq2seq4repair_space>AND" ) + "currency<seq2seq4repair_space>=<seq2seq4repair_space>?<seq2seq4repair_space>AND" ) + "startTime<seq2seq4repair_space>>=<seq2seq4repair_space>?<seq2seq4repair_space>AND" ) + "endTime<seq2seq4repair_space><=<seq2seq4repair_space>?<seq2seq4repair_space>AND" ) + "1<seq2seq4repair_space>=<seq2seq4repair_space>1" ) ) ) ; ps . setShort ( 1 , s . getTradeType ( ) . getValue ( ) ) ; ps . setShort ( 2 , s . getAssetClass ( ) . getValue ( ) ) ; ps . setString ( 3 , s . getAsset ( ) ) ; ps . setFloat ( 4 , s . getMinPrice ( ) ) ; ps . setFloat ( 5 , s . getMaxPrice ( ) ) ; <START_BUG> ps . setString ( 6 , s . getCurrency ( ) . getCurrencyCode ( ) ) ; <END_BUG> ps . setTimestamp ( 7 , new java . sql . Timestamp ( s . getStartTime ( ) . getTime ( ) ) ) ; ps . setTimestamp ( 8 , new java . sql . Timestamp ( s . getEndTime ( ) . getTime ( ) ) ) ; ps . execute ( ) ; return null ; } catch ( SQLException ex ) { System . err . println ( "Search<seq2seq4repair_space>failed" ) ; return new SearchResult ( new LinkedList < Trade > ( ) , 0 ) ; } } public static boolean saveSearch ( Search s ) { } public static List < Search > getSavedSearches ( ) { } public static List < UPI > getMatchingUPI ( String s ) { } }
public interface Console { void addCompleter ( CommandLineCompleter completer ) { } boolean isUseHistory ( ) { } void setUseHistory ( boolean useHistory ) { } CommandHistory getHistory ( ) { } void setHistoryFile ( File f ) { } void clearScreen ( ) { } void printColumns ( Collection < String > list ) { } void print ( String line ) { } void printNewLine ( ) { } String readLine ( String prompt ) { } String readLine ( String prompt , Character mask ) { } int getTerminalWidth ( ) { } int getTerminalHeight ( ) { } static final class Factory { public static Console getConsole ( CommandContext ctx ) throws CliInitializationException { } public static Console getConsole ( final CommandContext ctx , InputStream is , OutputStream os ) throws CliInitializationException { org . jboss . aesh . console . Console aeshConsole = null ; try { aeshConsole = new org . jboss . aesh . console . Console ( ) ; } catch ( IOException e ) { <START_BUG> e . printStackTrace ( ) ; <END_BUG> } final org . jboss . aesh . console . Console finalAeshConsole = aeshConsole ; return new Console ( ) { private CommandContext cmdCtx = ctx ; private org . jboss . aesh . console . Console console = finalAeshConsole ; private CommandHistory history = new HistoryImpl ( ) ; @ Override public void addCompleter ( final CommandLineCompleter completer ) { console . addCompletion ( new Completion ( ) { @ Override public void complete ( CompleteOperation co ) { int offset = completer . complete ( cmdCtx , co . getBuffer ( ) , co . getCursor ( ) , co . getCompletionCandidates ( ) ) ; co . setOffset ( offset ) ; if ( ( ( co . getCompletionCandidates ( ) . size ( ) ) == 1 ) && ( co . getCompletionCandidates ( ) . get ( 0 ) . startsWith ( co . getBuffer ( ) ) ) ) co . doAppendSeparator ( true ) ; else co . doAppendSeparator ( false ) ; } } ) ; } @ Override public boolean isUseHistory ( ) { return ! ( Settings . getInstance ( ) . isHistoryDisabled ( ) ) ; } @ Override public void setUseHistory ( boolean useHistory ) { Settings . getInstance ( ) . setHistoryDisabled ( ( ! useHistory ) ) ; } @ Override public CommandHistory getHistory ( ) { return history ; } @ Override public void setHistoryFile ( File f ) { Settings . getInstance ( ) . setHistoryFile ( f ) ; } @ Override public void clearScreen ( ) { try { console . clear ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } @ Override public void printColumns ( Collection < String > list ) { String [ ] newList = new String [ list . size ( ) ] ; list . toArray ( newList ) ; try { console . pushToStdOut ( Parser . formatDisplayList ( newList , console . getTerminalSize ( ) . getHeight ( ) , console . getTerminalSize ( ) . getWidth ( ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } @ Override public void print ( String line ) { try { console . pushToStdOut ( line ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } @ Override public void printNewLine ( ) { try { console . pushToStdOut ( Config . getLineSeparator ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } @ Override public String readLine ( String prompt ) { try { ConsoleOutput output = console . read ( prompt ) ; return output != null ? output . getBuffer ( ) : null ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } } @ Override public String readLine ( String prompt , Character mask ) { try { return console . read ( new Prompt ( prompt ) , mask ) . getBuffer ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } } @ Override public int getTerminalWidth ( ) { return console . getTerminalSize ( ) . getWidth ( ) ; } @ Override public int getTerminalHeight ( ) { return console . getTerminalSize ( ) . getHeight ( ) ; } class HistoryImpl implements CommandHistory { @ SuppressWarnings ( "unchecked" ) @ Override public List < String > asList ( ) { return console . getHistory ( ) . getAll ( ) ; } @ Override public boolean isUseHistory ( ) { return ! ( Settings . getInstance ( ) . isHistoryDisabled ( ) ) ; } @ Override public void setUseHistory ( boolean useHistory ) { Settings . getInstance ( ) . setHistoryDisabled ( ( ! useHistory ) ) ; } @ Override public void clear ( ) { console . getHistory ( ) . clear ( ) ; } @ Override public void setMaxSize ( int maxSize ) { Settings . getInstance ( ) . setHistorySize ( maxSize ) ; } @ Override public int getMaxSize ( ) { return Settings . getInstance ( ) . getHistorySize ( ) ; } } } ; } } }
public class Translate extends MatchingTask { private String bundle ; private String bundleLanguage ; private String bundleCountry ; private String bundleVariant ; private File toDir ; private String srcEncoding ; private String destEncoding ; private String bundleEncoding ; private String startToken ; private String endToken ; private boolean forceOverwrite ; private Vector filesets = new Vector ( ) ; private Hashtable resourceMap = new Hashtable ( ) ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private long [ ] bundleLastModified = new long [ 7 ] ; private long srcLastModified ; private long destLastModified ; private boolean loaded = false ; public void setBundle ( String bundle ) { } public void setBundleLanguage ( String bundleLanguage ) { } public void setBundleCountry ( String bundleCountry ) { } public void setBundleVariant ( String bundleVariant ) { } public void setToDir ( File toDir ) { } public void setStartToken ( String startToken ) { } public void setEndToken ( String endToken ) { } public void setSrcEncoding ( String srcEncoding ) { } public void setDestEncoding ( String destEncoding ) { } public void setBundleEncoding ( String bundleEncoding ) { } public void setForceOverwrite ( boolean forceOverwrite ) { } public void addFileset ( FileSet set ) { } public void execute ( ) throws BuildException { } private void loadResourceMaps ( ) throws BuildException { Locale locale = new Locale ( bundleLanguage , bundleCountry , bundleVariant ) ; String language = ( ( locale . getLanguage ( ) . length ( ) ) > 0 ) ? "_" + ( locale . getLanguage ( ) ) : "" ; String country = ( ( locale . getCountry ( ) . length ( ) ) > 0 ) ? "_" + ( locale . getCountry ( ) ) : "" ; String variant = ( ( locale . getVariant ( ) . length ( ) ) > 0 ) ? "_" + ( locale . getVariant ( ) ) : "" ; String bundleFile = ( ( ( bundle ) + language ) + country ) + variant ; processBundle ( bundleFile , 0 , false ) ; bundleFile = ( ( bundle ) + language ) + country ; processBundle ( bundleFile , 1 , false ) ; bundleFile = ( bundle ) + language ; processBundle ( bundleFile , 2 , false ) ; bundleFile = bundle ; processBundle ( bundleFile , 3 , false ) ; locale = Locale . getDefault ( ) ; language = ( ( locale . getLanguage ( ) . length ( ) ) > 0 ) ? "_" + ( locale . getLanguage ( ) ) : "" ; country = ( ( locale . getCountry ( ) . length ( ) ) > 0 ) ? "_" + ( locale . getCountry ( ) ) : "" ; variant = ( ( locale . getVariant ( ) . length ( ) ) > 0 ) ? "_" + ( locale . getVariant ( ) ) : "" ; bundleEncoding = System . getProperty ( "file.encoding" ) ; bundleFile = ( ( ( bundle ) + language ) + country ) + variant ; processBundle ( bundleFile , 4 , false ) ; bundleFile = ( ( bundle ) + language ) + country ; processBundle ( bundleFile , 5 , false ) ; bundleFile = ( bundle ) + language ; <START_BUG> processBundle ( bundleFile , 6 , false ) ; <END_BUG> } private void processBundle ( final String bundleFile , final int i , final boolean checkLoaded ) throws BuildException { } private void loadResourceMap ( FileInputStream ins ) throws BuildException { } private void translate ( ) throws BuildException { } }
public class Rmic extends MatchingTask { private static final String FAIL_MSG = "Rmic<seq2seq4repair_space>failed,<seq2seq4repair_space>messages<seq2seq4repair_space>should<seq2seq4repair_space>have<seq2seq4repair_space>been<seq2seq4repair_space>provided." ; private boolean verify = false ; private boolean filtering = false ; private boolean iiop = false ; private boolean idl = false ; private boolean debug = false ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private Vector compileList = new Vector ( ) ; private ClassLoader loader = null ; private File baseDir ; private String classname ; private Path compileClasspath ; private Path extdirs ; private String idlopts ; private String iiopopts ; private File sourceBase ; private String stubVersion ; public void setBase ( File base ) { } public void setClassname ( String classname ) { } public void setClasspath ( Path classpath ) throws TaskException { } public void setClasspathRef ( Reference r ) throws TaskException { } public void setDebug ( boolean debug ) { } public void setExtdirs ( Path extdirs ) throws TaskException { } public void setFiltering ( boolean filter ) { } public void setIdl ( boolean idl ) { } public void setIdlopts ( String idlopts ) { } public void setIiop ( boolean iiop ) { } public void setIiopopts ( String iiopopts ) { } public void setIncludeantruntime ( boolean include ) { } public void setIncludejavaruntime ( boolean include ) { } public void setSourceBase ( File sourceBase ) { } public void setStubVersion ( String stubVersion ) { } public void setVerify ( boolean verify ) { } public File getBase ( ) { } public String getClassname ( ) { } public Path getClasspath ( ) { } public Vector getCompileList ( ) { } public boolean getDebug ( ) { } public Path getExtdirs ( ) { } public Vector getFileList ( ) { } public boolean getFiltering ( ) { } public boolean getIdl ( ) { } public String getIdlopts ( ) { } public boolean getIiop ( ) { } public String getIiopopts ( ) { } public boolean getIncludeantruntime ( ) { } public boolean getIncludejavaruntime ( ) { } public ClassLoader getLoader ( ) { } public Class getRemoteInterface ( Class testClass ) { } public File getSourceBase ( ) { } public String getStubVersion ( ) { } public boolean getVerify ( ) { } public boolean isValidRmiRemote ( String classname ) { } public Path createClasspath ( ) throws TaskException { } public Path createExtdirs ( ) throws TaskException { } public void execute ( ) throws TaskException { } protected void scanDir ( File baseDir , String [ ] files , FileNameMapper mapper ) throws TaskException { } private boolean isValidRmiRemote ( Class testClass ) { } private void moveGeneratedFile ( File baseDir , File sourceBaseFile , String classname , RmicAdapter adapter ) throws TaskException { String classFileName = ( classname . replace ( '.' , File . separatorChar ) ) + ".class" ; String [ ] generatedFiles = adapter . getMapper ( ) . mapFileName ( classFileName ) ; for ( int i = 0 ; i < ( generatedFiles . length ) ; i ++ ) { String sourceFileName = ( classFileName . substring ( 0 , ( ( classFileName . length ( ) ) - 6 ) ) ) + ".java" ; File oldFile = new File ( baseDir , sourceFileName ) ; File newFile = new File ( sourceBaseFile , sourceFileName ) ; try { if ( filtering ) { final FilterSetCollection filters = new FilterSetCollection ( project . getGlobalFilterSet ( ) ) ; <START_BUG> FileUtils . newFileUtils ( ) . copyFile ( oldFile , newFile , filters ) ; <END_BUG> } else { FileUtil . copyFile ( oldFile , newFile ) ; } oldFile . delete ( ) ; } catch ( IOException ioe ) { String msg = ( ( ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>copy<seq2seq4repair_space>" + oldFile ) + "<seq2seq4repair_space>to<seq2seq4repair_space>" ) + newFile ) + "<seq2seq4repair_space>due<seq2seq4repair_space>to<seq2seq4repair_space>" ) + ( ioe . getMessage ( ) ) ; throw new TaskException ( msg , ioe ) ; } } } }
public abstract class CacheAdd extends AbstractAddStepHandler { private static final Logger log = Logger . getLogger ( CacheAdd . class . getPackage ( ) . getName ( ) ) ; private static final String DEFAULTS = "infinispan-defaults.xml" ; private static volatile Map < CacheMode , Configuration > defaults = null ; public static synchronized Configuration getDefaultConfiguration ( CacheMode cacheMode ) { } private static ConfigurationBuilderHolder load ( String resource ) { URL url = CacheAdd . find ( resource , CacheAdd . class . getClassLoader ( ) ) ; CacheAdd . log . debugf ( "Loading<seq2seq4repair_space>Infinispan<seq2seq4repair_space>defaults<seq2seq4repair_space>from<seq2seq4repair_space>%s" , url . toString ( ) ) ; ParserRegistry parser = new ParserRegistry ( ParserRegistry . class . getClassLoader ( ) ) ; try ( InputStream input = url . openStream ( ) ) { return parser . parse ( input ) ; } catch ( IOException e ) { <START_BUG> throw new IllegalStateException ( String . format ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>parse<seq2seq4repair_space>%s" , url ) , e ) ; <END_BUG> } } private static URL find ( String resource , ClassLoader ... loaders ) { } final CacheMode mode ; CacheAdd ( CacheMode mode ) { } @ Override protected void populateModel ( ModelNode operation , ModelNode model ) throws OperationFailedException { } @ Override protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode model , ServiceVerificationHandler verificationHandler , List < ServiceController < ? > > newControllers ) throws OperationFailedException { } Collection < ServiceController < ? > > installRuntimeServices ( OperationContext context , ModelNode operation , ModelNode containerModel , ModelNode cacheModel , ServiceVerificationHandler verificationHandler ) throws OperationFailedException { } void removeRuntimeServices ( OperationContext context , ModelNode operation , ModelNode containerModel , ModelNode cacheModel ) throws OperationFailedException { } protected PathAddress getCacheAddressFromOperation ( ModelNode operation ) { } protected PathAddress getCacheContainerAddressFromOperation ( ModelNode operation ) { } ServiceController < ? > installCacheConfigurationService ( ServiceTarget target , String containerName , String cacheName , boolean defaultCache , ModuleIdentifier moduleId , ConfigurationBuilder builder , Configuration config , List < CacheAdd . Dependency < ? > > dependencies , ServiceVerificationHandler verificationHandler ) { } ServiceController < ? > installCacheService ( ServiceTarget target , String containerName , String cacheName , boolean defaultCache , ServiceController . Mode initialMode , Configuration config , ServiceVerificationHandler verificationHandler ) { } @ SuppressWarnings ( "rawtypes" ) ServiceController < ? > installJndiService ( ServiceTarget target , String containerName , String cacheName , boolean defaultCache , String jndiName , ServiceVerificationHandler verificationHandler ) { } private static JndiName createJndiName ( String container , String cache ) { } private static BindInfo createCacheBinding ( JndiName name ) { } private static < T > void addDependency ( ServiceBuilder < ? > builder , CacheAdd . Dependency < T > dependency ) { } void populate ( ModelNode fromModel , ModelNode toModel ) throws OperationFailedException { } void processModelNode ( OperationContext context , String containerName , ModelNode cache , ConfigurationBuilder builder , List < CacheAdd . Dependency < ? > > dependencies ) throws OperationFailedException { } private static String findStoreKey ( ModelNode cache ) { } private static ModelNode getStoreModelNode ( ModelNode cache ) { } private StoreConfigurationBuilder < ? , ? > buildCacheStore ( OperationContext context , PersistenceConfigurationBuilder persistenceBuilder , String containerName , ModelNode store , String storeKey , List < CacheAdd . Dependency < ? > > dependencies ) throws OperationFailedException { } private static AbstractJdbcStoreConfigurationBuilder < ? , ? > buildJdbcStore ( PersistenceConfigurationBuilder persistenceBuilder , OperationContext context , ModelNode store ) throws OperationFailedException { } private static void buildBinaryKeyedTable ( TableManipulationConfigurationBuilder < ? , ? > builder , OperationContext context , ModelNode table ) throws OperationFailedException { } private static void buildStringKeyedTable ( TableManipulationConfigurationBuilder < ? , ? > builder , OperationContext context , ModelNode table ) throws OperationFailedException { } private static void buildTable ( TableManipulationConfigurationBuilder < ? , ? > builder , OperationContext context , ModelNode table , String defaultTableNamePrefix ) throws OperationFailedException { } private static String getColumnProperty ( OperationContext context , ModelNode table , String columnKey , AttributeDefinition columnAttribute , String defaultValue ) throws OperationFailedException { } protected class Dependency < I > { private final ServiceName name ; private final Class < I > type ; private final Injector < I > target ; Dependency ( ServiceName name ) { } Dependency ( ServiceName name , Class < I > type , Injector < I > target ) { } ServiceName getName ( ) { } public Class < I > getType ( ) { } public Injector < I > getInjector ( ) { } } private abstract class SimpleInjector < I > implements Injector < I > { @ Override public void uninject ( ) { } } private static class CacheDependencies implements CacheService . Dependencies { private final Value < EmbeddedCacheManager > container ; private final InjectedValue < XAResourceRecoveryRegistry > recoveryRegistry = new InjectedValue < XAResourceRecoveryRegistry > ( ) ; CacheDependencies ( Value < EmbeddedCacheManager > container ) { } Injector < XAResourceRecoveryRegistry > getRecoveryRegistryInjector ( ) { } @ Override public EmbeddedCacheManager getCacheContainer ( ) { } @ Override public XAResourceRecoveryRegistry getRecoveryRegistry ( ) { } } private static class CacheConfigurationDependencies implements CacheConfigurationService . Dependencies { private final Value < EmbeddedCacheManager > container ; private final InjectedValue < TransactionManager > tm = new InjectedValue < TransactionManager > ( ) ; private final InjectedValue < TransactionSynchronizationRegistry > tsr = new InjectedValue < TransactionSynchronizationRegistry > ( ) ; private final InjectedValue < ModuleLoader > moduleLoader = new InjectedValue < ModuleLoader > ( ) ; CacheConfigurationDependencies ( Value < EmbeddedCacheManager > container ) { } Injector < TransactionManager > getTransactionManagerInjector ( ) { } Injector < TransactionSynchronizationRegistry > getTransactionSynchronizationRegistryInjector ( ) { } Injector < ModuleLoader > getModuleLoaderInjector ( ) { } @ Override public EmbeddedCacheManager getCacheContainer ( ) { } @ Override public TransactionManager getTransactionManager ( ) { } @ Override public TransactionSynchronizationRegistry getTransactionSynchronizationRegistry ( ) { } @ Override public ModuleLoader getModuleLoader ( ) { } } }
public class ReloadableResourceBundleMessageSource extends AbstractMessageSource implements ResourceLoaderAware { private static final String PROPERTIES_SUFFIX = ".properties" ; private static final String XML_SUFFIX = ".xml" ; private String [ ] basenames = new String [ 0 ] ; private String defaultEncoding ; private Properties fileEncodings ; private boolean fallbackToSystemLocale = true ; private long cacheMillis = - 1 ; private PropertiesPersister propertiesPersister = new DefaultPropertiesPersister ( ) ; private ResourceLoader resourceLoader = new DefaultResourceLoader ( ) ; private final Map cachedFilenames = new HashMap ( ) ; private final Map cachedProperties = new HashMap ( ) ; private final Map cachedMergedProperties = new HashMap ( ) ; public void setBasename ( String basename ) { } public void setBasenames ( String [ ] basenames ) { } public void setDefaultEncoding ( String defaultEncoding ) { } public void setFileEncodings ( Properties fileEncodings ) { } public void setFallbackToSystemLocale ( boolean fallbackToSystemLocale ) { } public void setCacheSeconds ( int cacheSeconds ) { } public void setPropertiesPersister ( PropertiesPersister propertiesPersister ) { } public void setResourceLoader ( ResourceLoader resourceLoader ) { } @ Override protected String resolveCodeWithoutArguments ( String code , Locale locale ) { } @ Override protected MessageFormat resolveCode ( String code , Locale locale ) { } protected ReloadableResourceBundleMessageSource . PropertiesHolder getMergedProperties ( Locale locale ) { } protected List calculateAllFilenames ( String basename , Locale locale ) { } protected List calculateFilenamesForLocale ( String basename , Locale locale ) { List result = new ArrayList ( 3 ) ; String language = locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; String variant = locale . getVariant ( ) ; <START_BUG> StringBuffer temp = new StringBuffer ( basename ) ; <END_BUG> if ( ( language . length ( ) ) > 0 ) { temp . append ( '_' ) . append ( language ) ; result . add ( 0 , temp . toString ( ) ) ; } if ( ( country . length ( ) ) > 0 ) { temp . append ( '_' ) . append ( country ) ; result . add ( 0 , temp . toString ( ) ) ; } if ( ( variant . length ( ) ) > 0 ) { temp . append ( '_' ) . append ( variant ) ; result . add ( 0 , temp . toString ( ) ) ; } return result ; } protected ReloadableResourceBundleMessageSource . PropertiesHolder getProperties ( String filename ) { } protected ReloadableResourceBundleMessageSource . PropertiesHolder refreshProperties ( String filename , ReloadableResourceBundleMessageSource . PropertiesHolder propHolder ) { } protected Properties loadProperties ( Resource resource , String filename ) throws IOException { } public void clearCache ( ) { } public void clearCacheIncludingAncestors ( ) { } @ Override public String toString ( ) { } protected class PropertiesHolder { private Properties properties ; private long fileTimestamp = - 1 ; private long refreshTimestamp = - 1 ; private final Map cachedMessageFormats = new HashMap ( ) ; public PropertiesHolder ( Properties properties , long fileTimestamp ) { } public PropertiesHolder ( ) { } public Properties getProperties ( ) { } public long getFileTimestamp ( ) { } public void setRefreshTimestamp ( long refreshTimestamp ) { } public long getRefreshTimestamp ( ) { } public String getProperty ( String code ) { } public MessageFormat getMessageFormat ( String code , Locale locale ) { } } }
public abstract class QueryMetricsHandler extends AbstractRuntimeOnlyHandler { private final PersistenceUnitServiceRegistry persistenceUnitRegistry ; private QueryMetricsHandler ( PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } @ Override protected void executeRuntimeStep ( OperationContext context , ModelNode operation ) throws OperationFailedException { handleQueryStatistics ( context , operation ) ; <START_BUG> context . completeStep ( ) ; <END_BUG> } protected abstract void handle ( QueryStatistics statistics , OperationContext context , String attributeName , String originalQueryName ) { } private void handleQueryStatistics ( OperationContext context , ModelNode operation ) { } static final QueryMetricsHandler getExecutionCount ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } static final QueryMetricsHandler getCacheHitCount ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } static final QueryMetricsHandler getCachePutCount ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } static final QueryMetricsHandler getCacheMissCount ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } static final QueryMetricsHandler getExecutionRowCount ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } static final QueryMetricsHandler getExecutionAvgTime ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } static final QueryMetricsHandler getExecutionMaxTime ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } static final QueryMetricsHandler getExecutionMinTime ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } public static OperationStepHandler getOriginalName ( PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } }
public class WeibullDistribution extends AbstractRealDistribution { public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1.0E-9 ; private static final long serialVersionUID = 8589540077390120676L ; private final double shape ; private final double scale ; private final double solverAbsoluteAccuracy ; private double numericalMean = Double . NaN ; private boolean numericalMeanIsCalculated = false ; private double numericalVariance = Double . NaN ; private boolean numericalVarianceIsCalculated = false ; public WeibullDistribution ( double alpha , double beta ) throws NotStrictlyPositiveException { } public WeibullDistribution ( double alpha , double beta , double inverseCumAccuracy ) { } public WeibullDistribution ( RandomGenerator rng , double alpha , double beta ) throws NotStrictlyPositiveException { } public WeibullDistribution ( RandomGenerator rng , double alpha , double beta , double inverseCumAccuracy ) throws NotStrictlyPositiveException { } public double getShape ( ) { } public double getScale ( ) { } public double density ( double x ) { } @ Override public double logDensity ( double x ) { } public double cumulativeProbability ( double x ) { } @ Override public double inverseCumulativeProbability ( double p ) { double ret ; if ( ( p < 0.0 ) || ( p > 1.0 ) ) { throw new OutOfRangeException ( p , 0.0 , 1.0 ) ; } else if ( p == 0 ) { ret = 0.0 ; } else if ( p == 1 ) { ret = Double . POSITIVE_INFINITY ; } else { <START_BUG> ret = ( scale ) * ( FastMath . pow ( ( - ( FastMath . log ( ( 1.0 - p ) ) ) ) , ( 1.0 / ( shape ) ) ) ) ; <END_BUG> } return ret ; } @ Override protected double getSolverAbsoluteAccuracy ( ) { } public double getNumericalMean ( ) { } protected double calculateNumericalMean ( ) { } public double getNumericalVariance ( ) { } protected double calculateNumericalVariance ( ) { } public double getSupportLowerBound ( ) { } public double getSupportUpperBound ( ) { } public boolean isSupportLowerBoundInclusive ( ) { } public boolean isSupportUpperBoundInclusive ( ) { } public boolean isSupportConnected ( ) { } }
public class TermsFilterTest extends LuceneTestCase { public void testCachability ( ) throws Exception { } public void testMissingTerms ( ) throws Exception { } public void testMissingField ( ) throws Exception { } public void testFieldNotPresent ( ) throws IOException { } public void testSkipField ( ) throws IOException { } public void testRandom ( ) throws IOException { } private TermsFilter termsFilter ( boolean singleField , Term ... terms ) { } private TermsFilter termsFilter ( boolean singleField , Collection < Term > termList ) { } public void testHashCodeAndEquals ( ) { int num = atLeast ( 100 ) ; final boolean singleField = random ( ) . nextBoolean ( ) ; List < Term > terms = new ArrayList < Term > ( ) ; Set < Term > uniqueTerms = new HashSet < Term > ( ) ; for ( int i = 0 ; i < num ; i ++ ) { String field = "field" + ( singleField ? "1" : random ( ) . nextInt ( 100 ) ) ; String string = _TestUtil . randomRealisticUnicodeString ( random ( ) ) ; terms . add ( new Term ( field , string ) ) ; uniqueTerms . add ( new Term ( field , string ) ) ; TermsFilter left = termsFilter ( ( singleField ? random ( ) . nextBoolean ( ) : false ) , uniqueTerms ) ; Collections . shuffle ( terms , random ( ) ) ; TermsFilter right = termsFilter ( ( singleField ? random ( ) . nextBoolean ( ) : false ) , terms ) ; assertEquals ( right , left ) ; assertEquals ( right . hashCode ( ) , left . hashCode ( ) ) ; <START_BUG> if ( i > 0 ) { <END_BUG> List < Term > asList = new ArrayList < Term > ( uniqueTerms ) ; asList . remove ( 0 ) ; TermsFilter notEqual = termsFilter ( ( singleField ? random ( ) . nextBoolean ( ) : false ) , asList ) ; assertFalse ( left . equals ( notEqual ) ) ; assertFalse ( right . equals ( notEqual ) ) ; } } } public void testNoTerms ( ) { } }
public class SolrWriter extends DIHWriterBase implements DIHWriter { private static final Logger log = LoggerFactory . getLogger ( SolrWriter . class ) ; static final String LAST_INDEX_KEY = "last_index_time" ; private final UpdateRequestProcessor processor ; SolrQueryRequest req ; public SolrWriter ( UpdateRequestProcessor processor , SolrQueryRequest req ) { } @ Override public void close ( ) { } @ Override public boolean upload ( SolrInputDocument d ) { } @ Override public void deleteDoc ( Object id ) { try { SolrWriter . log . info ( ( "Deleting<seq2seq4repair_space>document:<seq2seq4repair_space>" + id ) ) ; DeleteUpdateCommand delCmd = new DeleteUpdateCommand ( req ) ; <START_BUG> delCmd . id = id . toString ( ) ; <END_BUG> processor . processDelete ( delCmd ) ; } catch ( IOException e ) { SolrWriter . log . error ( ( "Exception<seq2seq4repair_space>while<seq2seq4repair_space>deleteing:<seq2seq4repair_space>" + id ) , e ) ; } } @ Override public void deleteByQuery ( String query ) { } @ Override public void commit ( boolean optimize ) { } @ Override public void rollback ( ) { } @ Override public void doDeleteAll ( ) { } static String getResourceAsString ( InputStream in ) throws IOException { } static String getDocCount ( ) { } @ Override public void init ( Context context ) { } }
public class VelocityMessageComposerTest { private static final String AN_EMAIL_ADDRESS_VERIFICATION_CODE = "AN_EMAIL_ADDRESS_VERIFICATION_CODE" ; private VelocityMessageComposer messageComposer ; @ Before public void setUp ( ) throws IOException { <START_BUG> messageComposer = new VelocityMessageComposer ( new ApplicationConfig ( ) . velocityEngine ( ) ) ; <END_BUG> } @ Test public void signUpActivationMessageShouldBePatchedWithUserInfo ( ) { } @ Test public void signUpActivationMessageShouldMentionUserAnakin ( ) { } @ Test ( expected = IllegalStateException . class ) public void signUpActivationMessageShouldFailIfUserIsMissingActivationId ( ) { } @ Test public void resetPasswordMessageShouldBePatchedWithUserInfo ( ) { } private static final String A_RESET_PASSWORD_KEY = "reset_password_key" ; @ Test public void resetPasswordMessageShouldMentionUserAnakin ( ) { } @ Test ( expected = IllegalStateException . class ) public void resetPasswordMessageShouldFailIfUserIsMissingActivationId ( ) { } private void assertThatAllPlaceholsersHasBeenPatched ( String message ) { } }
public class CCMCheck extends Continuus { private File file = null ; private String comment = null ; private String task = null ; protected Vector filesets = new Vector ( ) ; public CCMCheck ( ) { } public File getFile ( ) { } public void setFile ( File v ) { } public String getComment ( ) { } public void setComment ( String v ) { } public String getTask ( ) { } public void setTask ( String v ) { } public void addFileset ( FileSet set ) { } public void execute ( ) throws BuildException { } private void doit ( ) { Commandline commandLine = new Commandline ( ) ; commandLine . setExecutable ( getCcmCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( getCcmAction ( ) ) ; checkOptions ( commandLine ) ; int result = run ( commandLine ) ; <START_BUG> if ( Execute . isFailure ( 0 ) ) { <END_BUG> String msg = "Failed<seq2seq4repair_space>executing:<seq2seq4repair_space>" + ( commandLine . toString ( ) ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { } public static final String FLAG_COMMENT = "/comment" ; public static final String FLAG_TASK = "/task" ; }
public class JoranConfigurator extends ConfiguratorBase { Interpreter joranInterpreter ; LoggerRepository repository ; boolean listAppnderAttached = false ; public JoranConfigurator ( ) { } protected interface ParseAction { void parse ( final SAXParser parser , final DefaultHandler handler ) throws IOException , SAXException { } } public final void doConfigure ( final URL url , final LoggerRepository repository ) { } public final void doConfigure ( final String filename , final LoggerRepository repository ) { } public final void doConfigure ( final File file , final LoggerRepository repository ) { } public final void doConfigure ( final InputSource source , final LoggerRepository repository ) { } public final void doConfigure ( final InputStream stream , final LoggerRepository repository ) { } protected void doConfigure ( final JoranConfigurator . ParseAction action , final LoggerRepository repository ) { this . repository = repository ; selfInitialize ( this . repository ) ; ExecutionContext ec = joranInterpreter . getExecutionContext ( ) ; List errorList = ec . getErrorList ( ) ; SAXParser saxParser = null ; try { SAXParserFactory spf = SAXParserFactory . newInstance ( ) ; spf . setValidating ( false ) ; spf . setNamespaceAware ( true ) ; saxParser = spf . newSAXParser ( ) ; } catch ( Exception pce ) { final String errMsg = "Parser<seq2seq4repair_space>configuration<seq2seq4repair_space>error<seq2seq4repair_space>occured" ; getLogger ( repository ) . error ( errMsg , pce ) ; ec . addError ( new ErrorItem ( errMsg , pce ) ) ; return ; } <START_BUG> JoranDocument document = new JoranDocument ( errorList ) ; <END_BUG> try { action . parse ( saxParser , document ) ; } catch ( IOException ie ) { final String errMsg = "I/O<seq2seq4repair_space>error<seq2seq4repair_space>occured<seq2seq4repair_space>while<seq2seq4repair_space>parsing<seq2seq4repair_space>xml<seq2seq4repair_space>file" ; getLogger ( repository ) . error ( errMsg , ie ) ; ec . addError ( new ErrorItem ( errMsg , ie ) ) ; } catch ( Exception ex ) { final String errMsg = "Problem<seq2seq4repair_space>parsing<seq2seq4repair_space>XML<seq2seq4repair_space>document.<seq2seq4repair_space>See<seq2seq4repair_space>previously<seq2seq4repair_space>reported<seq2seq4repair_space>errors.<seq2seq4repair_space>Abandoning<seq2seq4repair_space>all<seq2seq4repair_space>further<seq2seq4repair_space>processing." ; getLogger ( repository ) . error ( errMsg , ex ) ; errorList . add ( new ErrorItem ( errMsg ) ) ; return ; } ec . pushObject ( repository ) ; String errMsg ; try { attachListAppender ( repository ) ; document . replay ( joranInterpreter ) ; getLogger ( repository ) . debug ( "Finished<seq2seq4repair_space>parsing." ) ; } catch ( SAXException e ) { } finally { detachListAppender ( repository ) ; } } public List getErrorList ( ) { } protected void selfInitialize ( LoggerRepository repository ) { } public ExecutionContext getExecutionContext ( ) { } }
class OSGiSubsystemAdd extends AbstractBoottimeAddStepHandler { static final OSGiSubsystemAdd INSTANCE = new OSGiSubsystemAdd ( ) ; private OSGiRuntimeResource resource ; private OSGiSubsystemAdd ( ) { } @ Override protected Resource createResource ( OperationContext context ) { } @ Override protected void populateModel ( final ModelNode operation , final ModelNode model ) throws OperationFailedException { } @ Override protected void performBoottime ( final OperationContext context , final ModelNode operation , final ModelNode model , final ServiceVerificationHandler verificationHandler , final List < ServiceController < ? > > newControllers ) throws OperationFailedException { OSGiLogger . LOGGER . infoActivatingSubsystem ( ) ; final Activation activation = Activation . valueOf ( ACTIVATION . resolveModelAttribute ( context , model ) . asString ( ) . toUpperCase ( Locale . ENGLISH ) ) ; final ServiceTarget serviceTarget = context . getServiceTarget ( ) ; final InitialDeploymentTracker deploymentTracker = new InitialDeploymentTracker ( context , verificationHandler ) ; final ModuleRegistrationTracker registrationTracker = new ModuleRegistrationTracker ( ) ; final List < SubsystemExtension > extensions = new ArrayList < SubsystemExtension > ( ) ; final Iterator < SubsystemExtension > services = ServiceLoader . load ( SubsystemExtension . class , getClass ( ) . getClassLoader ( ) ) . iterator ( ) ; while ( services . hasNext ( ) ) { extensions . add ( services . next ( ) ) ; } context . addStep ( new OperationStepHandler ( ) { @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { <START_BUG> newControllers . add ( FrameworkBootstrapService . addService ( serviceTarget , resource , extensions , verificationHandler ) ) ; <END_BUG> newControllers . add ( registrationTracker . install ( serviceTarget , verificationHandler ) ) ; context . completeStep ( NOOP_ROLLBACK_HANDLER ) ; } } , RUNTIME ) ; context . addStep ( new AbstractDeploymentChainStep ( ) { @ Override protected void execute ( DeploymentProcessorTarget processorTarget ) { processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , STRUCTURE , STRUCTURE_OSGI_MANIFEST , new OSGiManifestStructureProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , STRUCTURE , STRUCTURE_BUNDLE_SUB_DEPLOYMENT , new BundleSubDeploymentMarkingProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , PARSE , PARSE_OSGI_BUNDLE_INFO , new OSGiBundleInfoParseProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , PARSE , PARSE_OSGI_PROPERTIES , new OSGiXServiceParseProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , PARSE , PARSE_OSGI_DEPLOYMENT , new BundleDeploymentProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , PARSE , PARSE_OSGI_COMPONENTS , new OSGiComponentParseProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , PARSE , PARSE_OSGI_SUBSYSTEM_ACTIVATOR , new org . jboss . as . osgi . deployment . FrameworkActivateProcessor ( deploymentTracker ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , REGISTER , REGISTER_BUNDLE_INSTALL , new org . jboss . as . osgi . deployment . BundleInstallProcessor ( deploymentTracker ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , DEPENDENCIES , DEPENDENCIES_BUNDLE , new BundleDependenciesProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , CONFIGURE_MODULE , CONFIGURE_RESOLVE_BUNDLE , new BundleResolveProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , CONFIGURE_MODULE , CONFIGURE_DEFERRED_PHASE , new DeferredPhaseProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , INSTALL , INSTALL_RESOLVER_MODULE , new org . jboss . as . osgi . deployment . ModuleRegisterProcessor ( registrationTracker ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , INSTALL , INSTALL_BUNDLE_ACTIVATE , new BundleActivateProcessor ( ) ) ; } } , RUNTIME ) ; for ( SubsystemExtension extension : extensions ) { extension . performBoottime ( context , operation , model , verificationHandler , newControllers ) ; } newControllers . add ( SubsystemState . addService ( serviceTarget , activation ) ) ; } }
public class ShareController extends ServerCall < ProjectInfo > { public ShareController ( ProjectSpaceBase projectSpace , Usersession session , IProgressMonitor monitor ) { } @ Override @ SuppressWarnings ( "unchecked" ) protected ProjectInfo run ( ) throws ESException { getProgressMonitor ( ) . beginTask ( ShareController_Sharing_Project , 100 ) ; getProgressMonitor ( ) . worked ( 1 ) ; getProgressMonitor ( ) . subTask ( ShareController_Preparing_Share ) ; final LogMessage logMessage = eINSTANCE . createLogMessage ( ) ; logMessage . setAuthor ( getUsersession ( ) . getUsername ( ) ) ; logMessage . setClientDate ( new Date ( ) ) ; logMessage . setMessage ( ShareController_Initial_Commit ) ; ProjectInfo projectInfo = null ; getProjectSpace ( ) . stopChangeRecording ( ) ; getProgressMonitor ( ) . worked ( 10 ) ; if ( getProgressMonitor ( ) . isCanceled ( ) ) { getProjectSpace ( ) . save ( ) ; getProjectSpace ( ) . startChangeRecording ( ) ; getProgressMonitor ( ) . done ( ) ; } getProgressMonitor ( ) . subTask ( ShareController_Sharing_Project_With_Server ) ; getProjectSpace ( ) . save ( ) ; projectInfo = createProject ( logMessage ) ; addParticipant ( projectInfo . getProjectId ( ) ) ; getProgressMonitor ( ) . worked ( 30 ) ; getProgressMonitor ( ) . subTask ( "Finalizing<seq2seq4repair_space>share" ) ; getProgressMonitor ( ) . subTask ( ShareController_Settings_Attributes ) ; setUsersession ( getUsersession ( ) ) ; ESWorkspaceProviderImpl . getObserverBus ( ) . register ( getProjectSpace ( ) , ESLoginObserver . class ) ; getProjectSpace ( ) . save ( ) ; getProjectSpace ( ) . startChangeRecording ( ) ; getProjectSpace ( ) . setBaseVersion ( ModelUtil . clone ( projectInfo . getVersion ( ) ) ) ; getProjectSpace ( ) . setLastUpdated ( new Date ( ) ) ; getProjectSpace ( ) . setProjectId ( ModelUtil . clone ( projectInfo . getProjectId ( ) ) ) ; getProjectSpace ( ) . setUsersession ( getUsersession ( ) ) ; getProjectSpace ( ) . saveProjectSpaceOnly ( ) ; getProgressMonitor ( ) . worked ( 20 ) ; getProgressMonitor ( ) . subTask ( ShareController_Uploading_Files ) ; getProjectSpace ( ) . getFileTransferManager ( ) . uploadQueuedFiles ( getProgressMonitor ( ) ) ; getProgressMonitor ( ) . worked ( 20 ) ; getProgressMonitor ( ) . subTask ( ShareController_Finalizing_Share ) ; <START_BUG> getProjectSpace ( ) . getOperations ( ) . clear ( ) ; <END_BUG> getProjectSpace ( ) . save ( ) ; getProjectSpace ( ) . updateDirtyState ( ) ; getProgressMonitor ( ) . done ( ) ; ESWorkspaceProviderImpl . getObserverBus ( ) . notify ( ESShareObserver . class ) . shareDone ( getProjectSpace ( ) . toAPI ( ) ) ; return projectInfo ; } private ProjectInfo createProject ( final LogMessage logMessage ) throws ESException { } private void addParticipant ( final ProjectId projectId ) throws ESException { } }
public class ErfTest { @ Test public void testErf0 ( ) { } @ Test public void testErf1960 ( ) { } @ Test public void testErf2576 ( ) { } @ Test public void testErf2807 ( ) { } @ Test public void testErf3291 ( ) { } @ Test public void testLargeValues ( ) { } @ Test public void testErfGnu ( ) { } @ Test public void testErfcGnu ( ) { } @ Test public void testErfcMaple ( ) { double [ ] [ ] ref = new double [ ] [ ] { new double [ ] { 0.1 , 0.460172162722971 } , new double [ ] { 1.2 , 0.115069670221708 } , new double [ ] { 2.3 , 0.0107241100216758 } , new double [ ] { 3.4 , 3.36929265676881E-4 } , new double [ ] { 4.5 , 3.39767312473006E-6 } , new double [ ] { 5.6 , 1.07175902583109E-8 } , new double [ ] { 6.7 , 1.04209769879652E-11 } , new double [ ] { 7.8 , 3.0953587719587E-15 } , new double [ ] { 8.9 , 2.79233437493966E-19 } , new double [ ] { 10.0 , 7.61985302416053E-24 } , new double [ ] { 11.1 , 6.27219439321703E-29 } , new double [ ] { 12.2 , 1.55411978638959E-34 } , new double [ ] { 13.3 , 1.15734162836904E-40 } , new double [ ] { 14.4 , 2.58717592540226E-47 } , new double [ ] { 15.5 , 1.73446079179387E-54 } , new double [ ] { 16.6 , 3.48454651995041E-62 } } ; for ( int i = 0 ; i < 15 ; i ++ ) { <START_BUG> final double result = 0.5 * ( Erf . erfc ( ( ( ref [ i ] [ 0 ] ) / ( Math . sqrt ( 2 ) ) ) ) ) ; <END_BUG> Assert . assertEquals ( ref [ i ] [ 1 ] , result , 1.0E-15 ) ; TestUtils . assertRelativelyEquals ( ref [ i ] [ 1 ] , result , 1.0E-13 ) ; } } @ Test public void testTwoArgumentErf ( ) { } @ Test public void testErfInvNaN ( ) { } @ Test public void testErfInvInfinite ( ) { } @ Test public void testErfInv ( ) { } @ Test public void testErfcInvNaN ( ) { } @ Test public void testErfcInvInfinite ( ) { } @ Test public void testErfcInv ( ) { } }
public abstract class Application { private static Log log = LogFactory . getLog ( Application . class ) ; private List componentResolvers = new ArrayList ( ) ; private IConverterFactory converterFactory = new ConverterFactory ( ) ; private final Localizer localizer ; private final MarkupCache markupCache ; private final String name ; private final Map nameToResourceFactory = new HashMap ( ) ; private final ApplicationPages pages = new ApplicationPages ( ) ; private ResourceStreamLocator resourceStreamLocator ; private ModificationWatcher resourceWatcher ; private ApplicationSettings settings ; private final SharedResources sharedResources = new SharedResources ( ) ; private ICrypt crypt ; public Application ( ) { } public final void addResourceFactory ( final String name , final IResourceFactory resourceFactory ) { } public final List getComponentResolvers ( ) { } public IConverterFactory getConverterFactory ( ) { } public Localizer getLocalizer ( ) { } public final MarkupCache getMarkupCache ( ) { } public final String getName ( ) { } public final ApplicationPages getPages ( ) { } public final Iterator getPageSets ( final Page page ) { } public final IResourceFactory getResourceFactory ( final String name ) { } public ResourceStreamLocator getResourceStreamLocator ( ) { } public final ModificationWatcher getResourceWatcher ( ) { } public ApplicationSettings getSettings ( ) { } public ApplicationSettings createApplicationSettings ( ) { } public final SharedResources getSharedResources ( ) { } public synchronized ICrypt newCrypt ( ) { } public MarkupParser newMarkupParser ( final MarkupContainer container ) { <START_BUG> final MarkupParser parser = new MarkupParser ( container , new wicket . markup . parser . XmlPullParser ( settings . getDefaultMarkupEncoding ( ) ) ) ; <END_BUG> parser . configure ( getSettings ( ) ) ; return parser ; } protected abstract ISessionFactory getSessionFactory ( ) { } protected void init ( ) { } protected void internalInit ( ) { } final void resourceFinderChanged ( ) { } }
public final class JobCompletionTaskListener implements StatusAwareTaskListener { private static final Logger logger = LoggerFactory . getLogger ( ForkTaskListener . class ) ; private final CountDownLatch _countDownLatch ; private final AtomicInteger _successCountDown ; private final AnalysisListener _analysisListener ; private final AnalysisJobMetrics _analysisJobMetrics ; private Date _completionTime ; public JobCompletionTaskListener ( final AnalysisJobMetrics analysisJobMetrics , final AnalysisListener analysisListener , final int callablesToWaitFor ) { } @ Override public void await ( ) throws InterruptedException { } @ Override public boolean isDone ( ) { } @ Override public void await ( long timeout , TimeUnit timeUnit ) throws InterruptedException { } @ Override public void onBegin ( Task task ) { } @ Override public void onComplete ( Task task ) { } @ Override public void onError ( Task task , Throwable throwable ) { JobCompletionTaskListener . logger . debug ( "onError(...)" ) ; <START_BUG> _analysisListener . errorUknown ( _analysisJobMetrics . getAnalysisJob ( ) , throwable ) ; <END_BUG> _countDownLatch . countDown ( ) ; } @ Override public Date getCompletionTime ( ) { } }
public class TestGetProcessInstances { @ Before public void setup ( ) { } @ Test public void getAllProcessIntances ( ) { <START_BUG> List < ProcessLog > logs = DB . getProcessDao ( ) . getProcessInstances ( null , null ) ; <END_BUG> for ( ProcessLog log : logs ) { System . out . println ( log ) ; } } @ After public void destroy ( ) throws IOException { } }
public class MainWindow extends Window implements GlobalEventListener , ProcessWatcherListener { private static final String INTERNAL_CONFIG_FILE = "InternalConfig.properties" ; private static final int PROCESS_WATCH_PERIOD = 1000 * 5 ; private ProcessWatcher processWatcher ; private AppSyncr appSyncr ; private TrayItem trayItem ; private Window logWindow ; private ArrayList < Suggestion > suggestions ; protected boolean quit ; public MainWindow ( Display display ) { } public void showAndActive ( ) { } public void quit ( ) { } public void init ( ) { } private void initForm ( ) { } private void initTrayAndMenu ( ) { } private void onClickSyncManagerButton ( ) { } private void onClickLoginButton ( ) { } private void checkDropboxLoginAndRaiseError ( ) { } public void showTooltip ( ToolTip tip ) { } @ Override public void onGlobalSet ( GlobalEvent e ) { if ( ( e . getEventKey ( ) . equals ( "DropboxLoginError" ) ) && ( e . getBool ( ) ) ) { getShell ( ) . forceActive ( ) ; MessageBox msg = new MessageBox ( getShell ( ) , ( ( SWT . ICON_INFORMATION ) | ( SWT . OK ) ) ) ; msg . setMessage ( Language . getString ( "NeedDropboxLogin" ) ) ; msg . open ( ) ; <START_BUG> new DropboxLoginWindow ( getDisplay ( ) ) . open ( ) ; <END_BUG> } else if ( ( e . getEventKey ( ) . equals ( "RefreshAppConfigs" ) ) && ( e . getBool ( ) ) ) { appSyncr . reload ( ) ; Log . write ( "Reload<seq2seq4repair_space>AppConfigs" ) ; } else if ( e . getEventKey ( ) . equals ( "VariableNotFoundError" ) ) { final AppConfigVariable var = ( ( AppConfigVariable ) ( e . getObject ( ) ) ) ; getDisplay ( ) . asyncExec ( new Runnable ( ) { @ Override public void run ( ) { handleVariableNotFoundError ( var ) ; } } ) ; } else if ( e . getEventKey ( ) . equals ( "MessageBox" ) ) { getShell ( ) . forceActive ( ) ; Shell shell = ( ( Shell ) ( Global . getObject ( "LastShell" ) ) ) ; if ( shell == null ) shell = getShell ( ) ; MessageBox msg = new MessageBox ( shell , ( ( SWT . ICON_INFORMATION ) | ( SWT . OK ) ) ) ; msg . setText ( KURUMTITLE ) ; msg . setMessage ( e . getString ( ) ) ; msg . open ( ) ; } else if ( e . getEventKey ( ) . equals ( "ShowToolTip" ) ) { ToolTip tip = new ToolTip ( getShell ( ) , ( ( SWT . BALLOON ) | ( SWT . ICON_INFORMATION ) ) ) ; tip . setMessage ( e . getString ( ) ) ; tip . setText ( KURUMTITLE ) ; showTooltip ( tip ) ; } else if ( e . getEventKey ( ) . equals ( "OnDropboxLoggedIn" ) ) { if ( ( appSyncr ) != null ) appSyncr . syncAllApps ( ) ; } else if ( e . getEventKey ( ) . equals ( "LastWindowClosed" ) ) { Global . set ( "ShowToolTip" , Language . getString ( "TrayNotice" ) ) ; setJumped ( false ) ; } } private void handleVariableNotFoundError ( AppConfigVariable var ) { } @ Override public void onProcessDisappeared ( ProcessWatcherEvent e ) { } }
public class ProgressMonitorJobsDialog extends ProgressMonitorDialog { private NewProgressViewer viewer ; private int viewerHeight = - 1 ; Composite viewerComposite ; private Button detailsButton ; private long watchTime = - 1 ; protected boolean alreadyClosed = false ; private IProgressMonitor wrapperedMonitor ; protected boolean enableDetailsButton = false ; public ProgressMonitorJobsDialog ( Shell parent ) { } protected Control createDialogArea ( Composite parent ) { } void handleDetailsButtonSelect ( ) { } protected void createButtonsForButtonBar ( Composite parent ) { } protected void createSpacer ( Composite parent ) { } protected void createDetailsButton ( Composite parent ) { } protected Control createButtonBar ( Composite parent ) { } protected void clearCursors ( ) { } protected void updateForSetBlocked ( IStatus reason ) { } public void run ( boolean fork , boolean cancelable , IRunnableWithProgress runnable ) throws InterruptedException , InvocationTargetException { } protected void enableDetails ( boolean enableState ) { } public void watchTicks ( ) { } public void createWrapperedMonitor ( ) { wrapperedMonitor = new IProgressMonitorWithBlocking ( ) { IProgressMonitor superMonitor = ProgressMonitorJobsDialog . super . getProgressMonitor ( ) ; public void beginTask ( String name , int totalWork ) { superMonitor . beginTask ( name , totalWork ) ; checkTicking ( ) ; } private void checkTicking ( ) { if ( ( watchTime ) < 0 ) return ; if ( ( ( System . currentTimeMillis ( ) ) - ( watchTime ) ) > ( ProgressManager . getInstance ( ) . getLongOperationTime ( ) ) ) { watchTime = - 1 ; openDialog ( ) ; } } private void openDialog ( ) { if ( ! ( PlatformUI . isWorkbenchRunning ( ) ) ) return ; PlatformUI . getWorkbench ( ) . getDisplay ( ) . syncExec ( new Runnable ( ) { public void run ( ) { <START_BUG> if ( ! ( ProgressManagerUtil . safeToOpen ( ProgressMonitorJobsDialog . this ) ) ) { <END_BUG> watchTicks ( ) ; return ; } if ( ! ( alreadyClosed ) ) open ( ) ; } } ) ; } public void done ( ) { superMonitor . done ( ) ; checkTicking ( ) ; } public void internalWorked ( double work ) { superMonitor . internalWorked ( work ) ; checkTicking ( ) ; } public boolean isCanceled ( ) { return superMonitor . isCanceled ( ) ; } public void setCanceled ( boolean value ) { superMonitor . setCanceled ( value ) ; } public void setTaskName ( String name ) { superMonitor . setTaskName ( name ) ; checkTicking ( ) ; } public void subTask ( String name ) { superMonitor . subTask ( name ) ; checkTicking ( ) ; } public void worked ( int work ) { superMonitor . worked ( work ) ; checkTicking ( ) ; } public void clearBlocked ( ) { if ( ( superMonitor ) instanceof IProgressMonitorWithBlocking ) ( ( IProgressMonitorWithBlocking ) ( superMonitor ) ) . clearBlocked ( ) ; } public void setBlocked ( IStatus reason ) { openDialog ( ) ; if ( ( superMonitor ) instanceof IProgressMonitorWithBlocking ) ( ( IProgressMonitorWithBlocking ) ( superMonitor ) ) . setBlocked ( reason ) ; } } ; } public IProgressMonitor getProgressMonitor ( ) { } public boolean close ( ) { } }
public class Tstamp extends Task { private Vector customFormats = new Vector ( ) ; private String prefix = "" ; public void setPrefix ( String prefix ) { } public void execute ( ) throws BuildException { try { Date d = new Date ( ) ; Enumeration i = customFormats . elements ( ) ; while ( i . hasMoreElements ( ) ) { Tstamp . CustomFormat cts = ( ( Tstamp . CustomFormat ) ( i . nextElement ( ) ) ) ; <START_BUG> cts . execute ( getProject ( ) , d , location ) ; <END_BUG> } SimpleDateFormat dstamp = new SimpleDateFormat ( "yyyyMMdd" ) ; getProject ( ) . setNewProperty ( ( ( prefix ) + "DSTAMP" ) , dstamp . format ( d ) ) ; SimpleDateFormat tstamp = new SimpleDateFormat ( "HHmm" ) ; getProject ( ) . setNewProperty ( ( ( prefix ) + "TSTAMP" ) , tstamp . format ( d ) ) ; SimpleDateFormat today = new SimpleDateFormat ( "MMMM<seq2seq4repair_space>d<seq2seq4repair_space>yyyy" , Locale . US ) ; getProject ( ) . setNewProperty ( ( ( prefix ) + "TODAY" ) , today . format ( d ) ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public Tstamp . CustomFormat createFormat ( ) { } public class CustomFormat { private TimeZone timeZone ; private String propertyName ; private String pattern ; private String language ; private String country ; private String variant ; private int offset = 0 ; private int field = Calendar . DATE ; private String prefix = "" ; public CustomFormat ( String prefix ) { } public void setProperty ( String propertyName ) { } public void setPattern ( String pattern ) { } public void setLocale ( String locale ) { } public void setTimezone ( String id ) { } public void setOffset ( int offset ) { } public void setUnit ( String unit ) { } public void setUnit ( Tstamp . Unit unit ) { } public void execute ( Project project , Date date , Location location ) { } } public static class Unit extends EnumeratedAttribute { private static final String MILLISECOND = "millisecond" ; private static final String SECOND = "second" ; private static final String MINUTE = "minute" ; private static final String HOUR = "hour" ; private static final String DAY = "day" ; private static final String WEEK = "week" ; private static final String MONTH = "month" ; private static final String YEAR = "year" ; private static final String [ ] units = new String [ ] { Tstamp . Unit . MILLISECOND , Tstamp . Unit . SECOND , Tstamp . Unit . MINUTE , Tstamp . Unit . HOUR , Tstamp . Unit . DAY , Tstamp . Unit . WEEK , Tstamp . Unit . MONTH , Tstamp . Unit . YEAR } ; private Hashtable calendarFields = new Hashtable ( ) ; public Unit ( ) { } public int getCalendarField ( ) { } public String [ ] getValues ( ) { } } }
public class AttachmentModel { private Folder folder ; private Object uid ; private List displayedMimeParts ; private MimePartTree collection ; public AttachmentModel ( ) { } public synchronized void setFolder ( Folder folder ) { } public synchronized void setUid ( Object uid ) { } public Folder getFolder ( ) { } public Object getUid ( ) { } public MimePartTree getCollection ( ) { } public void setCollection ( MimePartTree collection ) { this . collection = collection ; displayedMimeParts = collection . getAllLeafs ( ) ; MimePart bodyPart = collection . getFirstTextPart ( "plain" ) ; if ( bodyPart != null ) { MimePart bodyParent = ( ( MimePart ) ( bodyPart . getParent ( ) ) ) ; if ( bodyParent != null ) { if ( bodyParent . getHeader ( ) . contentSubtype . equals ( "alternative" ) ) { <START_BUG> Vector bodyParts = bodyParent . getChilds ( ) ; <END_BUG> displayedMimeParts . removeAll ( bodyParts ) ; } else { displayedMimeParts . remove ( bodyPart ) ; } } } } public List getDisplayedMimeParts ( ) { } public void setDisplayedMimeParts ( List displayedMimeParts ) { } }
public class StudentInfoActivity extends MenuBaseActivity implements View . OnClickListener { private int GET_PICTURE_RESULT_CODE = 16 ; private ClearProgressDialog clearProgressDialog ; @ Override public void onCreate ( Bundle bundle ) { } @ Override public void onClick ( View v ) { } private void showEditProfileChangeDialog ( ) { } private void showNicknameChangeDialog ( ) { } private void getSimpleProfile ( ) { } private void nicknameChange ( String nickname ) { } private void getProfilePicture ( ) { } private void showProgressDialog ( ) { } private void cancelProgressDialog ( ) { } private void editProfilePicture ( Uri uri ) { new android . os . AsyncTask < Uri , Void , Boolean > ( ) { @ Override protected void onPreExecute ( ) { <START_BUG> showNicknameChangeDialog ( ) ; <END_BUG> } @ Override protected Boolean doInBackground ( Uri ... params ) { try { return com . yscn . knucommunity . Util . NetworkUtil . getInstance ( ) . checkIsLoginUser ( ) . editProfilePicture ( params [ 0 ] ) ; } catch ( IOException | ParseException e ) { e . printStackTrace ( ) ; } return false ; } @ Override protected void onPostExecute ( Boolean bool ) { if ( bool ) { ImageLoaderUtil . getInstance ( ) . initImageLoader ( ) ; ImageLoader . getInstance ( ) . clearMemoryCache ( ) ; ImageLoader . getInstance ( ) . displayImage ( ( ( UrlList . PROFILE_THUMB_IMAGE_URL ) + ( UserData . getInstance ( ) . getStudentNumber ( ) ) ) , ( ( CircleImageView ) ( findViewById ( studentinfo_profile_image ) ) ) , ImageLoaderUtil . getInstance ( ) . getDefaultOptions ( ) ) ; } cancelProgressDialog ( ) ; } } . execute ( uri ) ; } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { } }
public class ReplicationHandler extends RequestHandlerBase implements SolrCoreAware { private static final Logger LOG = LoggerFactory . getLogger ( ReplicationHandler . class . getName ( ) ) ; SolrCore core ; private SnapPuller snapPuller ; private ReentrantLock snapPullLock = new ReentrantLock ( ) ; private String includeConfFiles ; private NamedList < String > confFileNameAlias = new NamedList < String > ( ) ; private boolean isMaster = false ; private boolean isSlave = false ; private boolean replicateOnOptimize = false ; private boolean replicateOnCommit = false ; private boolean replicateOnStart = false ; private int numberBackupsToKeep = 0 ; private int numTimesReplicated = 0 ; private final Map < String , ReplicationHandler . FileInfo > confFileInfoCache = new HashMap < String , ReplicationHandler . FileInfo > ( ) ; private Integer reserveCommitDuration = SnapPuller . readInterval ( "00:00:10" ) ; private volatile IndexCommit indexCommitPoint ; volatile NamedList < Object > snapShootDetails ; private AtomicBoolean replicationEnabled = new AtomicBoolean ( true ) ; @ Override public void handleRequestBody ( SolrQueryRequest req , SolrQueryResponse rsp ) throws Exception { } private List < NamedList < Object > > getCommits ( ) { } private void getFileChecksum ( SolrParams solrParams , SolrQueryResponse rsp ) { } private Map < String , Long > getCheckSums ( String [ ] files , File dir , Checksum checksum ) { } static Long getCheckSum ( Checksum checksum , File f ) { } private volatile SnapPuller tempSnapPuller ; public boolean doFetch ( SolrParams solrParams , boolean forceReplication ) { } boolean isReplicating ( ) { } private void doSnapShoot ( SolrParams params , SolrQueryResponse rsp , SolrQueryRequest req ) { } private void getFileStream ( SolrParams solrParams , SolrQueryResponse rsp ) { } @ SuppressWarnings ( "unchecked" ) private void getFileList ( SolrParams solrParams , SolrQueryResponse rsp ) { String v = solrParams . get ( ReplicationHandler . GENERATION ) ; if ( v == null ) { rsp . add ( "status" , "no<seq2seq4repair_space>index<seq2seq4repair_space>generation<seq2seq4repair_space>specified" ) ; return ; } long gen = Long . parseLong ( v ) ; IndexCommit commit = core . getDeletionPolicy ( ) . getCommitPoint ( gen ) ; if ( commit == null ) { rsp . add ( "status" , "invalid<seq2seq4repair_space>index<seq2seq4repair_space>generation" ) ; return ; } core . getDeletionPolicy ( ) . setReserveDuration ( gen , reserveCommitDuration ) ; List < Map < String , Object > > result = new ArrayList < Map < String , Object > > ( ) ; try { Collection < String > files = new HashSet < String > ( commit . getFileNames ( ) ) ; for ( String fileName : files ) { if ( fileName . endsWith ( ".lock" ) ) continue ; <START_BUG> File file = new File ( core . getIndexDir ( ) , fileName ) ; <END_BUG> Map < String , Object > fileMeta = getFileInfo ( file ) ; result . add ( fileMeta ) ; } } catch ( IOException e ) { rsp . add ( "status" , "unable<seq2seq4repair_space>to<seq2seq4repair_space>get<seq2seq4repair_space>file<seq2seq4repair_space>names<seq2seq4repair_space>for<seq2seq4repair_space>given<seq2seq4repair_space>index<seq2seq4repair_space>generation" ) ; rsp . add ( "exception" , e ) ; ReplicationHandler . LOG . warn ( ( "Unable<seq2seq4repair_space>to<seq2seq4repair_space>get<seq2seq4repair_space>file<seq2seq4repair_space>names<seq2seq4repair_space>for<seq2seq4repair_space>indexCommit<seq2seq4repair_space>generation:<seq2seq4repair_space>" + gen ) , e ) ; } rsp . add ( ReplicationHandler . CMD_GET_FILE_LIST , result ) ; if ( ( ( confFileNameAlias . size ( ) ) < 1 ) || ( core . getCoreDescriptor ( ) . getCoreContainer ( ) . isZooKeeperAware ( ) ) ) return ; ReplicationHandler . LOG . debug ( ( "Adding<seq2seq4repair_space>config<seq2seq4repair_space>files<seq2seq4repair_space>to<seq2seq4repair_space>list:<seq2seq4repair_space>" + ( includeConfFiles ) ) ) ; rsp . add ( ReplicationHandler . CONF_FILES , getConfFileInfoFromCache ( confFileNameAlias , confFileInfoCache ) ) ; } List < Map < String , Object > > getConfFileInfoFromCache ( NamedList < String > nameAndAlias , final Map < String , ReplicationHandler . FileInfo > confFileInfoCache ) { } static class FileInfo { long lastmodified ; String name ; long size ; long checksum ; public FileInfo ( long lasmodified , String name , long size , long checksum ) { } Map < String , Object > getAsMap ( ) { } } void disablePoll ( ) { } void enablePoll ( ) { } boolean isPollingDisabled ( ) { } int getTimesReplicatedSinceStartup ( ) { } void setTimesReplicatedSinceStartup ( ) { } long getIndexSize ( ) { } private Map < String , Object > getFileInfo ( File file ) { } @ Override public String getDescription ( ) { } @ Override public String getSource ( ) { } private long [ ] getIndexVersion ( ) { } @ Override @ SuppressWarnings ( "unchecked" ) public NamedList getStatistics ( ) { } private NamedList < Object > getReplicationDetails ( boolean showSlaveDetails ) { } private void addVal ( NamedList < Object > nl , String key , Properties props , Class clzz ) { } private List < String > getReplicateAfterStrings ( ) { } private long getTimeElapsed ( SnapPuller snapPuller ) { } Properties loadReplicationProperties ( ) { } @ SuppressWarnings ( "unchecked" ) public void inform ( SolrCore core ) { } private boolean isEnabled ( NamedList params ) { } private void registerCloseHook ( ) { } private void registerFileStreamResponseWriter ( ) { } private SolrEventListener getEventListener ( final boolean snapshoot , final boolean getCommit ) { } private class FileStream { private SolrParams params ; private FastOutputStream fos ; private Long indexGen ; private IndexDeletionPolicyWrapper delPolicy ; public FileStream ( SolrParams solrParams ) { } public void write ( OutputStream out ) throws IOException { } private void writeNothing ( ) throws IOException { } } public static final String MASTER_URL = "masterUrl" ; public static final String STATUS = "status" ; public static final String COMMAND = "command" ; public static final String CMD_DETAILS = "details" ; public static final String CMD_BACKUP = "backup" ; public static final String CMD_FETCH_INDEX = "fetchindex" ; public static final String CMD_ABORT_FETCH = "abortfetch" ; public static final String CMD_GET_FILE_LIST = "filelist" ;
public class StorageTest { @ Test public void testWriteToFile ( ) throws Exception { <START_BUG> Storage storageTest = new Storage ( ) ; <END_BUG> Task test1 = new Task ( "attend<seq2seq4repair_space>soccer<seq2seq4repair_space>practice" , null , null , null , null ) ; Task test2 = new Task ( "go<seq2seq4repair_space>to<seq2seq4repair_space>the<seq2seq4repair_space>gym" , null , null , null , null ) ; ArrayList < Task > floatingTasksToDo = new ArrayList < Task > ( ) ; ArrayList < Task > scheduledTasksToDo = new ArrayList < Task > ( ) ; ArrayList < Task > scheduledTasksOverDue = new ArrayList < Task > ( ) ; floatingTasksToDo . add ( test1 ) ; storageTest . writeToCurrentFile ( scheduledTasksToDo , floatingTasksToDo , scheduledTasksOverDue ) ; storageTest . readFromCurrentFile ( scheduledTasksToDo , floatingTasksToDo , scheduledTasksOverDue ) ; } }
public class Decorations extends Canvas { Image image ; Image [ ] images = new Image [ 0 ] ; Menu menuBar ; String text = "" ; boolean minimized ; boolean maximized ; Control savedFocus ; Button defaultButton ; Decorations ( ) { } public Decorations ( Composite parent , int style ) { } static int checkStyle ( int style ) { } void bringToTop ( boolean force ) { } protected void checkSubclass ( ) { } int compare ( ImageData data1 , ImageData data2 ) { } Control computeTabGroup ( ) { } Control computeTabRoot ( ) { } public Button getDefaultButton ( ) { } public Image getImage ( ) { } public Image [ ] getImages ( ) { } public boolean getMaximized ( ) { } public Menu getMenuBar ( ) { } public boolean getMinimized ( ) { } String getNameText ( ) { } public String getText ( ) { } boolean isTabGroup ( ) { } boolean isTabItem ( ) { } Decorations menuShell ( ) { } void releaseChildren ( boolean destroy ) { } void releaseWidget ( ) { } boolean restoreFocus ( ) { } void saveFocus ( ) { int window = OS . GetControlOwner ( handle ) ; <START_BUG> Control control = display . getFocusControl ( window ) ; <END_BUG> if ( ( ( control != null ) && ( control != ( this ) ) ) && ( ( this ) == ( control . menuShell ( ) ) ) ) { setSavedFocus ( control ) ; } } public void setDefaultButton ( Button button ) { } public void setImage ( Image image ) { } public void setImages ( Image [ ] images ) { } public void setMaximized ( boolean maximized ) { } public void setMenuBar ( Menu menu ) { } public void setMinimized ( boolean minimized ) { } void setSavedFocus ( Control control ) { } public void setText ( String string ) { } void sort ( Image [ ] images ) { } boolean traverseItem ( boolean next ) { } boolean traverseReturn ( ) { } }
public class CommandUndo extends CommandBase { @ Override public String getName ( ) { } @ Override public String getCommandUsage ( ICommandSender sender ) { } @ Override public void execute ( ICommandSender sender , String [ ] args ) throws CommandException { CSTELogger . logDebug ( "Undo<seq2seq4repair_space>Command<seq2seq4repair_space>Recieved!" ) ; if ( instance . isBuilding ( ) ) { throw new CommandException ( "cste.commands.error.stillbuilding" ) ; } HashSet < BlockDelta > history = history . getHistory ( ) ; HashSet < String > commands = new HashSet < String > ( ) ; for ( BlockDelta bd : history ) { <START_BUG> if ( bd . isChangedFromCurrent ( ) ) { <END_BUG> String command = ( ( "/setblock<seq2seq4repair_space>" + ( CSTESelectionProcessor . posToStr ( bd . getPos ( ) ) ) ) + "<seq2seq4repair_space>" ) + ( bd . getOldBlockStr ( ) ) ; if ( ! ( commands . contains ( command ) ) ) { commands . add ( command ) ; } } } instance . buildingStart ( commands . size ( ) ) ; for ( String command : commands ) { ChatMessenger . sendMessage ( command ) ; } } @ Override public int getRequiredPermissionLevel ( ) { } public List < ? > addTabCompletionOptions ( ICommandSender sender , String [ ] args , BlockPos pos ) { } }
public class ZipEntry extends java . util . zip . ZipEntry implements Cloneable { public static final int PLATFORM_UNIX = 3 ; public static final int PLATFORM_FAT = 0 ; private static final int SHORT_MASK = 65535 ; private static final int SHORT_SHIFT = 16 ; private int internalAttributes = 0 ; private int platform = ZipEntry . PLATFORM_FAT ; private long externalAttributes = 0 ; private Vector extraFields = null ; private String name = null ; public ZipEntry ( String name ) { } public ZipEntry ( java . util . zip . ZipEntry entry ) throws ZipException { } public ZipEntry ( ZipEntry entry ) throws ZipException { } protected ZipEntry ( ) { } public Object clone ( ) { } public int getInternalAttributes ( ) { } public void setInternalAttributes ( int value ) { } public long getExternalAttributes ( ) { } public void setExternalAttributes ( long value ) { } public void setUnixMode ( int mode ) { } public int getUnixMode ( ) { } public int getPlatform ( ) { } protected void setPlatform ( int platform ) { } public void setExtraFields ( ZipExtraField [ ] fields ) { } public ZipExtraField [ ] getExtraFields ( ) { } public void addExtraField ( ZipExtraField ze ) { } public void removeExtraField ( ZipShort type ) { } public void setExtra ( byte [ ] extra ) throws RuntimeException { try { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } catch ( Exception e ) { <START_BUG> throw new RuntimeException ( e . getMessage ( ) ) ; <END_BUG> } } protected void setExtra ( ) { } public byte [ ] getLocalFileDataExtra ( ) { } public byte [ ] getCentralDirectoryExtra ( ) { } public void setComprSize ( long size ) { } public String getName ( ) { } public boolean isDirectory ( ) { } protected void setName ( String name ) { } public int hashCode ( ) { } public boolean equals ( Object o ) { } }
public class ApplicationSettingsTest { @ After public void detachThreadContext ( ) { } @ Test public void testFrameworkVersion ( ) { <START_BUG> IFrameworkSettings settings = new FrameworkSettings ( ) ; <END_BUG> assertEquals ( "n/a" , settings . getVersion ( ) ) ; } @ Test public void testExceptionOnMissingResourceDefaultValue ( ) throws Exception { } @ Test public void testExceptionOnMissingResourceSetsCorrectly ( ) throws Exception { } @ Test public void testUseDefaultOnMissingResourceDefaultValue ( ) throws Exception { } @ Test public void testUseDefaultOnMissingResourceSetsCorrectly ( ) throws Exception { } @ Test public void testDefaultStringResourceLoaderSetup ( ) { } @ Test public void testOverrideStringResourceLoaderSetup ( ) { } @ Test public void testLocalizer ( ) { } }
public abstract class AbstractLoggingSubsystemTest extends AbstractSubsystemBaseTest { static final String [ ] HANDLER_RESOURCE_KEYS = new String [ ] { CommonAttributes . ASYNC_HANDLER , CommonAttributes . CONSOLE_HANDLER , CommonAttributes . CUSTOM_HANDLER , CommonAttributes . FILE_HANDLER , CommonAttributes . PERIODIC_ROTATING_FILE_HANDLER , CommonAttributes . SIZE_ROTATING_FILE_HANDLER } ; public static final PathElement SUBSYSTEM_PATH = PathElement . pathElement ( SUBSYSTEM , SUBSYSTEM_NAME ) ; static PathAddress SUBSYSTEM_ADDRESS = PathAddress . pathAddress ( AbstractLoggingSubsystemTest . SUBSYSTEM_PATH ) ; public AbstractLoggingSubsystemTest ( ) { } @ BeforeClass public static void setUp ( ) { } @ After public void clearLogContext ( ) { } protected void clearLogContext ( final LogContext logContext ) { } @ Override protected AdditionalInitialization createAdditionalInitialization ( ) { } @ Override protected void compareXml ( String configId , String original , String marshalled ) throws Exception { } static PathAddress createAddress ( final String resourceKey , final String resourceName ) { } static PathAddress createAddress ( final String profileName , final String resourceKey , final String resourceName ) { } static PathAddress createRootLoggerAddress ( ) { } static PathAddress createRootLoggerAddress ( final String profileName ) { } static PathAddress createLoggerAddress ( final String name ) { } static PathAddress createLoggerAddress ( final String profileName , final String name ) { } static PathAddress createConsoleHandlerAddress ( final String name ) { } static PathAddress createConsoleHandlerAddress ( final String profileName , final String name ) { } static PathAddress createFileHandlerAddress ( final String name ) { } static PathAddress createFileHandlerAddress ( final String profileName , final String name ) { } protected KernelServices boot ( ) throws Exception { <START_BUG> final KernelServices kernelServices = createKernelServicesBuilder ( LoggingTestEnvironment . get ( ) ) . setSubsystemXml ( getSubsystemXml ( ) ) . build ( ) ; <END_BUG> final Throwable bootError = kernelServices . getBootError ( ) ; Assert . assertTrue ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>boot:<seq2seq4repair_space>" + ( String . valueOf ( bootError ) ) ) , kernelServices . isSuccessfulBoot ( ) ) ; return kernelServices ; } protected void compare ( final String profileName , final ModelNode node1 , final ModelNode node2 ) { } protected void compare ( final ModelNode currentModel , final ConfigurationPersistence config ) throws OperationFailedException { } protected void compare ( final String profileName , final ModelNode currentModel , final ConfigurationPersistence config ) throws OperationFailedException { } protected void compareLoggers ( final LogContextConfiguration logContextConfiguration , final ModelNode model ) { } protected void compareHandlers ( final LogContextConfiguration logContextConfig , final Collection < String > handlerNames , final ModelNode model ) throws OperationFailedException { } protected ModelNode findHandlerModel ( final ModelNode model , final String name ) { } protected List < String > getHandlerNames ( final ModelNode currentModel ) { } static List < String > modelNodeAsStringList ( final ModelNode node ) { } static ModelNode getSubsystemModel ( final KernelServices kernelServices ) throws OperationFailedException { } static String resolveRelativePath ( final KernelServices kernelServices , final String relativeTo ) throws OperationFailedException { } static class RemoveOperationComparator implements Comparator < PathAddress > { static final AbstractLoggingSubsystemTest . RemoveOperationComparator INSTANCE = new AbstractLoggingSubsystemTest . RemoveOperationComparator ( ) ; static final int GREATER = 1 ; static final int EQUAL = 0 ; static final int LESS = - 1 ; @ Override public int compare ( final PathAddress o1 , final PathAddress o2 ) { } private int compare ( final String key1 , final String key2 ) { } } }
public class JavaBuilder extends IncrementalProjectBuilder { IProject currentProject ; JavaProject javaProject ; IWorkspaceRoot workspaceRoot ; CompilationParticipant [ ] participants ; NameEnvironment nameEnvironment ; SimpleLookupTable binaryLocationsPerProject ; public State lastState ; BuildNotifier notifier ; char [ ] [ ] extraResourceFileFilters ; String [ ] extraResourceFolderFilters ; public static final String SOURCE_ID = "JDT" ; public static boolean DEBUG = false ; static ArrayList builtProjects = null ; public static IMarker [ ] getProblemsFor ( IResource resource ) { } public static IMarker [ ] getTasksFor ( IResource resource ) { } public static void buildStarting ( ) { } public static void buildFinished ( ) { } public static void removeProblemsFor ( IResource resource ) { } public static void removeTasksFor ( IResource resource ) { } public static void removeProblemsAndTasksFor ( IResource resource ) { } public static State readState ( IProject project , DataInputStream in ) throws IOException { } public static void writeState ( Object state , DataOutputStream out ) throws IOException { } protected IProject [ ] build ( int kind , Map ignored , IProgressMonitor monitor ) throws CoreException { } private void buildAll ( ) { } private void buildDeltas ( SimpleLookupTable deltas ) { } protected void clean ( IProgressMonitor monitor ) throws CoreException { } private void cleanup ( ) { } private void clearLastState ( ) { } boolean filterExtraResource ( IResource resource ) { } private SimpleLookupTable findDeltas ( ) { } public State getLastState ( IProject project ) { } private IProject [ ] getRequiredProjects ( boolean includeBinaryPrerequisites ) { } boolean hasBuildpathErrors ( ) throws CoreException { } private boolean hasClasspathChanged ( ) { } private boolean hasJavaBuilder ( IProject project ) throws CoreException { } private boolean hasStructuralDelta ( ) { } private int initializeBuilder ( int kind , boolean forBuild ) throws CoreException { this . javaProject = ( ( JavaProject ) ( JavaCore . create ( currentProject ) ) ) ; this . workspaceRoot = currentProject . getWorkspace ( ) . getRoot ( ) ; if ( forBuild ) { this . participants = JavaModelManager . getJavaModelManager ( ) . compilationParticipants . getCompilationParticipants ( this . javaProject ) ; if ( ( this . participants ) != null ) for ( int i = 0 , l = this . participants . length ; i < l ; i ++ ) if ( ( this . participants [ i ] . aboutToBuild ( this . javaProject ) ) == ( CompilationParticipant . NEEDS_FULL_BUILD ) ) kind = IncrementalProjectBuilder . FULL_BUILD ; String projectName = currentProject . getName ( ) ; if ( ( ( JavaBuilder . builtProjects ) == null ) || ( JavaBuilder . builtProjects . contains ( projectName ) ) ) { org . eclipse . jdt . internal . core . JavaModel . flushExternalFileCache ( ) ; JavaBuilder . builtProjects = new ArrayList ( ) ; } JavaBuilder . builtProjects . add ( projectName ) ; } this . binaryLocationsPerProject = new SimpleLookupTable ( 3 ) ; <START_BUG> this . nameEnvironment = new NameEnvironment ( workspaceRoot , javaProject , binaryLocationsPerProject ) ; <END_BUG> if ( forBuild ) { String filterSequence = javaProject . getOption ( JavaCore . CORE_JAVA_BUILD_RESOURCE_COPY_FILTER , true ) ; char [ ] [ ] filters = ( ( filterSequence != null ) && ( ( filterSequence . length ( ) ) > 0 ) ) ? CharOperation . splitAndTrimOn ( ',' , filterSequence . toCharArray ( ) ) : null ; if ( filters == null ) { this . extraResourceFileFilters = null ; this . extraResourceFolderFilters = null ; } else { int fileCount = 0 ; int folderCount = 0 ; for ( int i = 0 , l = filters . length ; i < l ; i ++ ) { char [ ] f = filters [ i ] ; if ( ( f . length ) == 0 ) continue ; if ( ( f [ ( ( f . length ) - 1 ) ] ) == '/' ) folderCount ++ ; else fileCount ++ ; } this . extraResourceFileFilters = new char [ fileCount ] [ ] ; this . extraResourceFolderFilters = new String [ folderCount ] ; for ( int i = 0 , l = filters . length ; i < l ; i ++ ) { char [ ] f = filters [ i ] ; if ( ( f . length ) == 0 ) continue ; if ( ( f [ ( ( f . length ) - 1 ) ] ) == '/' ) extraResourceFolderFilters [ ( -- folderCount ) ] = new String ( f , 0 , ( ( f . length ) - 1 ) ) ; else extraResourceFileFilters [ ( -- fileCount ) ] = f ; } } } return kind ; } private boolean isClasspathBroken ( IClasspathEntry [ ] classpath , IProject p ) throws CoreException { } private boolean isWorthBuilding ( ) throws CoreException { } void mustPropagateStructuralChanges ( ) { } private void printLocations ( ClasspathLocation [ ] newLocations , ClasspathLocation [ ] oldLocations ) { } private void recordNewState ( State state ) { } public String toString ( ) { } }
public class MemoryLeakFixesTest extends BaseJDBCTestCase { public MemoryLeakFixesTest ( String name ) { } private static long HALFMB = 500 * 1024 ; private static int numRows = 100 ; private static int numPreparedStmts = 2000 ; public void testPrepStmtD210 ( ) throws Exception { } public void testReExecuteD557 ( ) throws Exception { } public void testResultSetgcD3316 ( ) throws Exception { } public void testRepeatedDatabaseCreationWithAutoStats ( ) throws SQLException { final String DB_NAME = "derby-memory-test" ; final File DB_DIR = new File ( "system" , DB_NAME ) ; DataSource ds = JDBCDataSource . getDataSource ( DB_NAME ) ; int iter = 0 ; while ( iter < 50 ) { <START_BUG> traceit ( ( "--<seq2seq4repair_space>" + ( iter ++ ) ) ) ; <END_BUG> if ( PrivilegedFileOpsForTests . exists ( DB_DIR ) ) { assertDirectoryDeleted ( DB_DIR ) ; } JDBCDataSource . setBeanProperty ( ds , "createDatabase" , "create" ) ; Connection conn = ds . getConnection ( ) ; JDBCDataSource . clearStringBeanProperty ( ds , "createDatabase" ) ; Statement s = conn . createStatement ( ) ; s . executeUpdate ( "CREATE<seq2seq4repair_space>TABLE<seq2seq4repair_space>TEST<seq2seq4repair_space>(CINT<seq2seq4repair_space>INT)" ) ; s . executeUpdate ( "CREATE<seq2seq4repair_space>INDEX<seq2seq4repair_space>NDX<seq2seq4repair_space>ON<seq2seq4repair_space>TEST<seq2seq4repair_space>(CINT)" ) ; for ( int i = 0 ; i < 500 ; i ++ ) { s . executeUpdate ( ( ( "INSERT<seq2seq4repair_space>INTO<seq2seq4repair_space>TEST<seq2seq4repair_space>VALUES(" + i ) + ")" ) ) ; s . executeQuery ( ( "SELECT<seq2seq4repair_space>*<seq2seq4repair_space>FROM<seq2seq4repair_space>TEST<seq2seq4repair_space>WHERE<seq2seq4repair_space>CINT=" + i ) ) . close ( ) ; } s . close ( ) ; conn . close ( ) ; JDBCDataSource . setBeanProperty ( ds , "shutdownDatabase" , "shutdown" ) ; try { ds . getConnection ( ) ; fail ( "Expected<seq2seq4repair_space>shutdown<seq2seq4repair_space>exception" ) ; } catch ( SQLException e ) { assertSQLState ( "08006" , e ) ; } finally { JDBCDataSource . clearStringBeanProperty ( ds , "shutdownDatabase" ) ; } if ( isPhoneME ( ) ) { Runtime . getRuntime ( ) . gc ( ) ; } } assertTrue ( PrivilegedFileOpsForTests . exists ( DB_DIR ) ) ; } private static void runFinalizerIfNeeded ( ) { } public static Test suite ( ) { } }
class Client implements IConnection { private static final Logger LOG = LoggerFactory . getLogger ( Client . class ) ; private final int max_retries ; private final int base_sleep_ms ; private final int max_sleep_ms ; private LinkedBlockingQueue < Object > message_queue ; private AtomicReference < Channel > channelRef ; private final ClientBootstrap bootstrap ; private InetSocketAddress remote_addr ; private AtomicInteger retries ; private final Random random = new Random ( ) ; private final ChannelFactory factory ; private AtomicBoolean ready_to_release_resource ; private final int buffer_size ; private final AtomicBoolean being_closed ; @ SuppressWarnings ( "rawtypes" ) Client ( Map storm_conf , String host , int port ) { } void reconnect ( ) { } private int getSleepTimeMs ( ) { } public void send ( int task , byte [ ] message ) { } ArrayList < Object > takeMessages ( ) throws InterruptedException { int size = 0 ; ArrayList < Object > requests = new ArrayList < Object > ( ) ; requests . add ( message_queue . take ( ) ) ; for ( Object msg = message_queue . poll ( ) ; msg != null ; msg = message_queue . poll ( ) ) { requests . add ( msg ) ; <START_BUG> if ( msg . equals ( ControlMessage . closeMessage ( ) ) ) <END_BUG> break ; TaskMessage taskMsg = ( ( TaskMessage ) ( msg ) ) ; size += ( ( taskMsg . message ( ) ) != null ? taskMsg . message ( ) . length : 0 ) + 6 ; if ( size > ( buffer_size ) ) break ; } return requests ; } public void close ( ) { } void close_n_release ( ) { } public TaskMessage recv ( int flags ) { } void setChannel ( Channel channel ) { } }
public class ToolBar extends Composite { ToolItem lastFocus ; ImageList imageList ; public ToolBar ( Composite parent , int style ) { } static int checkStyle ( int style ) { } protected void checkSubclass ( ) { } void createHandle ( int index ) { } public Point computeSize ( int wHint , int hHint , boolean changed ) { } int eventHandle ( ) { } void fixChildren ( Shell newShell , Shell oldShell , Decorations newDecorations , Decorations oldDecorations , Menu [ ] menus ) { } boolean forceFocus ( int focusHandle ) { } public ToolItem getItem ( int index ) { } public ToolItem getItem ( Point point ) { } public int getItemCount ( ) { } public ToolItem [ ] getItems ( ) { } public int getRowCount ( ) { } int gtk_key_press_event ( int widget , int eventPtr ) { } boolean hasFocus ( ) { } public int indexOf ( ToolItem item ) { } boolean mnemonicHit ( char key ) { } boolean mnemonicMatch ( char key ) { } void relayout ( ) { } void releaseChildren ( boolean destroy ) { ToolItem [ ] items = getItems ( ) ; for ( int i = 0 ; i < ( items . length ) ; i ++ ) { ToolItem item = items [ i ] ; if ( ( item != null ) && ( ! ( item . isDisposed ( ) ) ) ) { <START_BUG> item . releaseChildren ( false ) ; <END_BUG> } } super . releaseChildren ( destroy ) ; } void releaseWidget ( ) { } void removeControl ( Control control ) { } int setBounds ( int x , int y , int width , int height , boolean move , boolean resize ) { } void setFontDescription ( int font ) { } void setForegroundColor ( GdkColor color ) { } public void setToolTipText ( String string ) { } }
public class FeedProcessor { private InitialLocation initialLocation ; private Thresholding doThresh ; private VisionFeed visionFeed ; private OrientationFinder findAngle ; private int height ; private int width ; double prevAngle = 0 ; public FeedProcessor ( InitialLocation il , int height , int width , ControlGUI controlGUI , VisionFeed visionFeed ) { } public void processAndUpdateImage ( BufferedImage image , long before , JLabel label ) { } public void calculateAngle ( ) { } public void markObjects ( Graphics imageGraphics ) { Point ball = worldState . getBall ( ) . getPosition ( ) . getCentre ( ) ; Point blue ; Point yellow ; if ( ( worldState . getColor ( ) ) == ( Color . blue ) ) { blue = worldState . getOurRobot ( ) . getPosition ( ) . getCentre ( ) ; yellow = worldState . getOpponentsRobot ( ) . getPosition ( ) . getCentre ( ) ; } else { yellow = worldState . getOurRobot ( ) . getPosition ( ) . getCentre ( ) ; blue = worldState . getOpponentsRobot ( ) . getPosition ( ) . getCentre ( ) ; } imageGraphics . setColor ( Color . red ) ; imageGraphics . drawLine ( 0 , ball . y , 640 , ball . y ) ; imageGraphics . drawLine ( ball . x , 0 , ball . x , 480 ) ; imageGraphics . setColor ( Color . blue ) ; imageGraphics . drawOval ( ( ( blue . x ) - 15 ) , ( ( blue . y ) - 15 ) , 30 , 30 ) ; imageGraphics . setColor ( Color . yellow ) ; imageGraphics . drawOval ( ( ( yellow . x ) - 15 ) , ( ( yellow . y ) - 15 ) , 30 , 30 ) ; imageGraphics . setColor ( Color . white ) ; <START_BUG> imageGraphics . setColor ( Color . red ) ; <END_BUG> imageGraphics . drawLine ( worldState . getOurGrey ( ) . getPosition ( ) . getCentre ( ) . x , worldState . getOurGrey ( ) . getPosition ( ) . getCentre ( ) . y , worldState . getOurRobot ( ) . getPosition ( ) . getCentre ( ) . x , worldState . getOurRobot ( ) . getPosition ( ) . getCentre ( ) . y ) ; imageGraphics . drawLine ( worldState . getOpponentsGrey ( ) . getPosition ( ) . getCentre ( ) . x , worldState . getOpponentsGrey ( ) . getPosition ( ) . getCentre ( ) . y , worldState . getOpponentsRobot ( ) . getPosition ( ) . getCentre ( ) . x , worldState . getOpponentsRobot ( ) . getPosition ( ) . getCentre ( ) . y ) ; } public static void calculateFPS ( long before , Graphics imageGraphics , Graphics frameGraphics , BufferedImage image , int width , int height ) { } public BufferedImage removeBackground ( BufferedImage image , BufferedImage background ) { } public static boolean similarColor ( Color a , Color b ) { } }
public class Snippet6 { public static void main ( String [ ] args ) { Display display = new Display ( ) ; final Shell shell = new Shell ( display ) ; shell . setLayout ( new GridLayout ( ) ) ; final Composite c = new Composite ( shell , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 3 ; c . setLayout ( layout ) ; for ( int i = 0 ; i < 10 ; i ++ ) { Button b = new Button ( c , SWT . PUSH ) ; b . setText ( ( "Button<seq2seq4repair_space>" + i ) ) ; } Button b = new Button ( shell , SWT . PUSH ) ; b . setText ( "add<seq2seq4repair_space>a<seq2seq4repair_space>new<seq2seq4repair_space>button<seq2seq4repair_space>at<seq2seq4repair_space>row<seq2seq4repair_space>2<seq2seq4repair_space>column<seq2seq4repair_space>1" ) ; final int [ ] index = new int [ 1 ] ; b . addListener ( Selection , new Listener ( ) { public void handleEvent ( Event e ) { Button b = new Button ( c , SWT . PUSH ) ; b . setText ( ( "Special<seq2seq4repair_space>" + ( index [ 0 ] ) ) ) ; ( index [ 0 ] ) ++ ; Control [ ] children = c . getChildren ( ) ; b . moveAbove ( children [ 3 ] ) ; <START_BUG> shell . layout ( true ) ; <END_BUG> } } ) ; shell . open ( ) ; while ( ! ( shell . isDisposed ( ) ) ) { if ( ! ( display . readAndDispatch ( ) ) ) display . sleep ( ) ; } display . dispose ( ) ; } }
public class NewEditorAction extends ActiveEditorAction { public NewEditorAction ( IWorkbenchWindow window ) { } public void run ( ) { WorkbenchPage page = ( ( WorkbenchPage ) ( getActivePage ( ) ) ) ; IEditorPart editor = getActiveEditor ( ) ; if ( ( page == null ) || ( editor == null ) ) { return ; } String editorId = editor . getSite ( ) . getId ( ) ; if ( editorId == null ) { return ; } try { <START_BUG> page . openEditor ( editor . getEditorInput ( ) , editorId , true , false ) ; <END_BUG> } catch ( PartInitException e ) { DialogUtil . openError ( page . getWorkbenchWindow ( ) . getShell ( ) , Error , e . getMessage ( ) , e ) ; } } }
final class JVMOptionAddHandler implements OperationStepHandler , DescriptionProvider { static final String OPERATION_NAME = "add-jvm-option" ; static final JVMOptionAddHandler INSTANCE = new JVMOptionAddHandler ( ) ; private final ParameterValidator validator = new StringLengthValidator ( 1 ) ; @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { validator . validateParameter ( JVM_OPTION , operation . get ( JVM_OPTION ) ) ; final Resource resource = context . readResourceForUpdate ( EMPTY_ADDRESS ) ; final ModelNode model = resource . getModel ( ) ; final ModelNode option = operation . require ( JVM_OPTION ) ; ModelNode jvmOptions = model . get ( JVM_OPTIONS ) ; if ( jvmOptions . isDefined ( ) ) { for ( ModelNode optionNode : jvmOptions . asList ( ) ) { if ( optionNode . equals ( option ) ) { throw HostControllerMessages . MESSAGES . jvmOptionAlreadyExists ( option . asString ( ) ) ; } } } model . get ( JVM_OPTIONS ) . add ( option ) ; <START_BUG> context . completeStep ( ) ; <END_BUG> } @ Override public ModelNode getModelDescription ( Locale locale ) { } }
public class XNetThrottle extends AbstractThrottle implements XNetListener { protected boolean isAvailable ; protected TimerTask statusTask ; protected static final int statTimeoutValue = 1000 ; protected XNetTrafficController tc = null ; protected static final int THROTTLEIDLE = 0 ; protected static final int THROTTLESTATSENT = 1 ; protected static final int THROTTLESPEEDSENT = 2 ; protected static final int THROTTLEFUNCSENT = 4 ; public int requestState = XNetThrottle . THROTTLEIDLE ; protected int address ; public XNetThrottle ( XNetSystemConnectionMemo memo , XNetTrafficController controller ) { } public XNetThrottle ( XNetSystemConnectionMemo memo , LocoAddress address , XNetTrafficController controller ) { } public void setXNetTrafficController ( XNetTrafficController controller ) { } @ Override protected void sendFunctionGroup1 ( ) { } @ Override protected void sendFunctionGroup2 ( ) { } @ Override protected void sendFunctionGroup3 ( ) { } @ Override protected void sendFunctionGroup4 ( ) { } @ Override protected void sendFunctionGroup5 ( ) { } protected void sendMomentaryFunctionGroup1 ( ) { } protected void sendMomentaryFunctionGroup2 ( ) { } protected void sendMomentaryFunctionGroup3 ( ) { if ( ( tc . getCommandStation ( ) . getCommandStationType ( ) ) == 16 ) { if ( XNetThrottle . log . isDebugEnabled ( ) ) { XNetThrottle . log . debug ( "Command<seq2seq4repair_space>station<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>support<seq2seq4repair_space>Momentary<seq2seq4repair_space>functions" ) ; } return ; } <START_BUG> XNetMessage msg = XNetMessage . getFunctionGroup2SetMomMsg ( this . getDccAddress ( ) , f9Momentary , f10Momentary , f11Momentary , f12Momentary ) ; <END_BUG> queueMessage ( msg , XNetThrottle . THROTTLEFUNCSENT ) ; } protected void sendMomentaryFunctionGroup4 ( ) { } protected void sendMomentaryFunctionGroup5 ( ) { } public synchronized void setSpeedSetting ( float speed ) { } protected void sendEmergencyStop ( ) { } public void setIsForward ( boolean forward ) { } @ Override public void setSpeedStepMode ( int Mode ) { } protected void throttleDispose ( ) { } public int setDccAddress ( int newaddress ) { } public int getDccAddress ( ) { } protected int getDccAddressHigh ( ) { } protected int getDccAddressLow ( ) { } protected synchronized void sendStatusInformationRequest ( ) { } protected synchronized void sendFunctionStatusInformationRequest ( ) { } protected synchronized void sendFunctionHighInformationRequest ( ) { } protected synchronized void sendFunctionHighMomentaryStatusRequest ( ) { } public float getSpeedIncrement ( ) { } public void message ( XNetReply l ) { } public void message ( XNetMessage l ) { } public void notifyTimeout ( XNetMessage msg ) { } protected void parseSpeedandAvailability ( int b1 ) { } protected void parseSpeedandDirection ( int b2 ) { } protected void parseFunctionInformation ( int b3 , int b4 ) { } protected void parseFunctionHighInformation ( int b3 , int b4 ) { } protected void parseFunctionMomentaryInformation ( int b3 , int b4 ) { } protected void parseFunctionHighMomentaryInformation ( int b3 , int b4 ) { } protected void setIsAvailable ( boolean Available ) { } protected void startStatusTimer ( ) { } protected void stopStatusTimer ( ) { } public LocoAddress getLocoAddress ( ) { } protected LinkedBlockingQueue < XNetThrottle . RequestMessage > requestList = null ; protected synchronized void sendQueuedMessage ( ) { } protected synchronized void queueMessage ( XNetMessage m , int s ) { } protected static class RequestMessage { private int state ; private XNetMessage msg ; RequestMessage ( XNetMessage m , int s ) { } int getState ( ) { } XNetMessage getMsg ( ) { } } private static final Logger log = LoggerFactory . getLogger ( XNetThrottle . class . getName ( ) ) ; }
public final class JDBCDynamicQLQuery extends JDBCAbstractQueryCommand { private final Catalog catalog ; private final JDBCDynamicQLQueryMetaData metadata ; public JDBCDynamicQLQuery ( JDBCStoreManager manager , JDBCQueryMetaData q ) { } public Collection execute ( Method finderMethod , Object [ ] args , CmpEntityBeanContext ctx , EntityProxyFactory factory ) throws FinderException { String dynamicQL = ( ( String ) ( args [ 0 ] ) ) ; if ( getLog ( ) . isDebugEnabled ( ) ) { getLog ( ) . debug ( ( "DYNAMIC-QL:<seq2seq4repair_space>" + dynamicQL ) ) ; } QLCompiler compiler = null ; try { compiler = JDBCQueryManager . getInstance ( metadata . getQLCompilerClass ( ) , catalog ) ; } catch ( Throwable e ) { throw new FinderException ( e . getMessage ( ) ) ; } Object [ ] parameters = ( ( Object [ ] ) ( args [ 1 ] ) ) ; Class [ ] parameterTypes ; if ( parameters == null ) { parameterTypes = new Class [ 0 ] ; } else { parameterTypes = new Class [ parameters . length ] ; for ( int i = 0 ; i < ( parameters . length ) ; i ++ ) { if ( ( parameters [ i ] ) == null ) { throw new FinderException ( ( ( "Parameter[" + i ) + "]<seq2seq4repair_space>is<seq2seq4repair_space>null" ) ) ; } parameterTypes [ i ] = parameters [ i ] . getClass ( ) ; } } try { compiler . compileJBossQL ( dynamicQL , finderMethod . getReturnType ( ) , parameterTypes , metadata ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; throw new FinderException ( ( "Error<seq2seq4repair_space>compiling<seq2seq4repair_space>ejbql:<seq2seq4repair_space>" + t ) ) ; } int offset = toInt ( parameters , compiler . getOffsetParam ( ) , compiler . getOffsetValue ( ) ) ; int limit = toInt ( parameters , compiler . getLimitParam ( ) , compiler . getLimitValue ( ) ) ; JDBCEntityBridge selectEntity = null ; JDBCCMPFieldBridge selectField = null ; SelectFunction selectFunction = null ; if ( compiler . isSelectEntity ( ) ) { selectEntity = ( ( JDBCEntityBridge ) ( compiler . getSelectEntity ( ) ) ) ; } else if ( compiler . isSelectField ( ) ) { selectField = ( ( JDBCCMPFieldBridge ) ( compiler . getSelectField ( ) ) ) ; } else { selectFunction = compiler . getSelectFunction ( ) ; } boolean [ ] mask ; List leftJoinCMRList ; JDBCReadAheadMetaData readahead = metadata . getReadAhead ( ) ; if ( ( selectEntity != null ) && ( readahead . isOnFind ( ) ) ) { mask = selectEntity . getLoadGroupMask ( readahead . getEagerLoadGroup ( ) ) ; boolean modifiedMask = false ; leftJoinCMRList = compiler . getLeftJoinCMRList ( ) ; if ( compiler . isSelectDistinct ( ) ) { JDBCFieldBridge [ ] tableFields = selectEntity . getTableFields ( ) ; for ( int i = 0 ; i < ( tableFields . length ) ; ++ i ) { if ( ( mask [ i ] ) && ( ! ( tableFields [ i ] . getJDBCType ( ) . isSearchable ( ) ) ) ) { if ( ! modifiedMask ) { boolean [ ] original = mask ; mask = new boolean [ original . length ] ; System . arraycopy ( original , 0 , mask , 0 , mask . length ) ; modifiedMask = true ; } mask [ i ] = false ; } } } } else { mask = null ; leftJoinCMRList = Collections . EMPTY_LIST ; } setParameterList ( compiler . getInputParameters ( ) ) ; final CmpEntityBeanComponent component = ( ( JDBCStoreManager ) ( compiler . getStoreManager ( ) ) ) . getComponent ( ) ; EntityProxyFactory factoryToUse = new EntityProxyFactory ( ) { public Object getEntityObject ( Object primaryKey ) { <START_BUG> return ( metadata . isResultTypeMappingLocal ( ) ) && ( ( component . getLocalHomeClass ( ) ) != null ) ? component . getEjbLocalObject ( primaryKey ) : component . getEJBObject ( primaryKey ) ; <END_BUG> } } ; return execute ( compiler . getSQL ( ) , parameters , offset , limit , selectEntity , selectField , selectFunction , ( ( JDBCStoreManager ) ( compiler . getStoreManager ( ) ) ) , mask , compiler . getInputParameters ( ) , leftJoinCMRList , metadata , factoryToUse , log ) ; } }
@ Controller public class UserController { @ Autowired private UserServices userServices ; @ Autowired private NoteServices noteServices ; @ RequestMapping ( "/user/login" ) public String login ( HttpServletRequest request , HttpSession session ) { String email = request . getParameter ( "email" ) ; String password = request . getParameter ( "password" ) ; User user = userServices . getUser ( email , password ) ; if ( user == null ) { request . setAttribute ( "reqmsg" , "" ) ; return "login" ; } else { user . setPassword ( "" ) ; <START_BUG> session . setAttribute ( "cuser" , user ) ; <END_BUG> return "redirect:/user/main" ; } } @ RequestMapping ( "/user/main" ) public String userMain ( HttpServletRequest request , HttpSession session ) { } @ RequestMapping ( "/user/register" ) public String register ( ) { } @ RequestMapping ( "/user/save" ) public String save ( HttpServletRequest request ) { } }
protected abstract boolean isToInclusive ( ) { } public Comparator < ? super K > comparator ( ) { } @ Override public boolean containsKey ( final Object key ) { } @ Override public V remove ( final Object key ) { } @ Override public V get ( final Object key ) { } @ Override public V put ( final K key , final V value ) { } @ Override public Set < Map . Entry < K , V > > entrySet ( ) { } public SortedMap < K , V > subMap ( final K fromKey , final K toKey ) { } public SortedMap < K , V > headMap ( final K toKey ) { } public SortedMap < K , V > tailMap ( final K fromKey ) { } protected boolean inRange ( final K key ) { } protected boolean inRange2 ( final K key ) { } protected boolean inFromRange ( final K key , final boolean forceInclusive ) { } protected boolean inToRange ( final K key , final boolean forceInclusive ) { } protected abstract SortedMap < K , V > createRangeMap ( K fromKey , boolean fromInclusive , K toKey , boolean toInclusive ) { } } private class RangeEntryMap extends AbstractPatriciaTrie < K , V > . RangeMap { private final K fromKey ; private final K toKey ; private final boolean fromInclusive ; private final boolean toInclusive ; protected RangeEntryMap ( final K fromKey , final K toKey ) { } protected RangeEntryMap ( final K fromKey , final boolean fromInclusive , final K toKey , final boolean toInclusive ) { } public K firstKey ( ) { } public K lastKey ( ) { } @ Override protected Set < Map . Entry < K , V > > createEntrySet ( ) { } @ Override public K getFromKey ( ) { } @ Override public K getToKey ( ) { } @ Override public boolean isFromInclusive ( ) { } @ Override public boolean isToInclusive ( ) { } @ Override protected SortedMap < K , V > createRangeMap ( final K fromKey , final boolean fromInclusive , final K toKey , final boolean toInclusive ) { } } private class RangeEntrySet extends AbstractSet < Map . Entry < K , V > > { private final AbstractPatriciaTrie < K , V > . RangeMap delegate ; private transient int size = - 1 ; private transient int expectedModCount ; public RangeEntrySet ( final AbstractPatriciaTrie < K , V > . RangeMap delegate ) { } @ Override public Iterator < Map . Entry < K , V > > iterator ( ) { } @ Override public int size ( ) { } @ Override public boolean isEmpty ( ) { } @ SuppressWarnings ( "unchecked" ) @ Override public boolean contains ( final Object o ) { } @ SuppressWarnings ( "unchecked" ) @ Override public boolean remove ( final Object o ) { } private final class EntryIterator extends AbstractPatriciaTrie < K , V > . TrieIterator < Map . Entry < K , V > > { private final K excludedKey ; private EntryIterator ( final AbstractPatriciaTrie . TrieEntry < K , V > first , final AbstractPatriciaTrie . TrieEntry < K , V > last ) { } @ Override public boolean hasNext ( ) { } public Map . Entry < K , V > next ( ) { } } } private class PrefixRangeMap extends AbstractPatriciaTrie < K , V > . RangeMap { private final K prefix ; private final int offsetInBits ; private final int lengthInBits ; private K fromKey = null ; private K toKey = null ; private transient int expectedModCount = 0 ; private int size = - 1 ; private PrefixRangeMap ( final K prefix , final int offsetInBits , final int lengthInBits ) { } private int fixup ( ) { if ( ( ( size ) == ( - 1 ) ) || ( ( AbstractPatriciaTrie . this . modCount ) != ( expectedModCount ) ) ) { <START_BUG> final Iterator < Map . Entry < K , V > > it = entrySet ( ) . iterator ( ) ; <END_BUG> size = 0 ; Map . Entry < K , V > entry = null ; if ( it . hasNext ( ) ) { entry = it . next ( ) ; size = 1 ; } fromKey = ( entry == null ) ? null : entry . getKey ( ) ; if ( ( fromKey ) != null ) { final AbstractPatriciaTrie . TrieEntry < K , V > prior = previousEntry ( ( ( AbstractPatriciaTrie . TrieEntry < K , V > ) ( entry ) ) ) ; fromKey = ( prior == null ) ? null : prior . getKey ( ) ; } toKey = fromKey ; while ( it . hasNext ( ) ) { ++ ( size ) ; entry = it . next ( ) ; } toKey = ( entry == null ) ? null : entry . getKey ( ) ; if ( ( toKey ) != null ) { entry = nextEntry ( ( ( AbstractPatriciaTrie . TrieEntry < K , V > ) ( entry ) ) ) ; toKey = ( entry == null ) ? null : entry . getKey ( ) ; } expectedModCount = AbstractPatriciaTrie . this . modCount ; } return size ; } public K firstKey ( ) { } public K lastKey ( ) { } @ Override protected boolean inRange ( final K key ) { } @ Override protected boolean inRange2 ( final K key ) { } @ Override protected boolean inFromRange ( final K key , final boolean forceInclusive ) { } @ Override protected boolean inToRange ( final K key , final boolean forceInclusive ) { }
public final class Logging { private static final Logger LOG = Logger . getLogger ( "org.columba" ) ; private static ConsoleHandler consoleHandler ; public static boolean DEBUG = false ; private Logging ( ) { } private static boolean userHasDefinedLogging ( ) { } public static void createDefaultHandler ( ) { if ( ! ( Logging . userHasDefinedLogging ( ) ) ) { Logging . LOG . setUseParentHandlers ( false ) ; Logging . consoleHandler = new ConsoleHandler ( ) ; Logging . consoleHandler . setFormatter ( new OneLineFormatter ( ) ) ; <START_BUG> Logging . consoleHandler . setLevel ( Level . ALL ) ; <END_BUG> Logging . LOG . addHandler ( Logging . consoleHandler ) ; } } public static void setDebugging ( boolean debug ) { } public static void createDefaultFileHandler ( File configDirectory ) { } }
abstract class RFC1522Codec { protected static final char SEP = '?' ; protected static final String POSTFIX = "?=" ; protected static final String PREFIX = "=?" ; protected String encodeText ( final String text , final Charset charset ) throws EncoderException { if ( text == null ) { return null ; } <START_BUG> StringBuffer buffer = new StringBuffer ( ) ; <END_BUG> buffer . append ( RFC1522Codec . PREFIX ) ; buffer . append ( charset ) ; buffer . append ( RFC1522Codec . SEP ) ; buffer . append ( this . getEncoding ( ) ) ; buffer . append ( RFC1522Codec . SEP ) ; byte [ ] rawData = this . doEncoding ( text . getBytes ( charset ) ) ; buffer . append ( StringUtils . newStringUsAscii ( rawData ) ) ; buffer . append ( RFC1522Codec . POSTFIX ) ; return buffer . toString ( ) ; } protected String encodeText ( final String text , final String charsetName ) throws UnsupportedEncodingException , EncoderException { } protected String decodeText ( final String text ) throws UnsupportedEncodingException , DecoderException { } protected abstract String getEncoding ( ) { } protected abstract byte [ ] doEncoding ( byte [ ] bytes ) throws EncoderException { } protected abstract byte [ ] doDecoding ( byte [ ] bytes ) throws DecoderException { } }
public abstract class Expression extends Statement { public static final boolean isConstantValueRepresentable ( Constant constant , int constantTypeID , int targetTypeID ) { } public Constant constant ; public int implicitConversion ; public TypeBinding resolvedType ; public Expression ( ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , boolean valueRequired ) { } public final boolean checkCastTypesCompatibility ( Scope scope , TypeBinding castType , TypeBinding expressionType , Expression expression ) { } public FlowInfo checkNullStatus ( BlockScope scope , FlowContext flowContext , FlowInfo flowInfo , int nullStatus ) { } private MethodBinding [ ] getAllInheritedMethods ( ReferenceBinding binding ) { } private void getAllInheritedMethods0 ( ReferenceBinding binding , ArrayList collector ) { } public void checkNullComparison ( BlockScope scope , FlowContext flowContext , FlowInfo flowInfo , FlowInfo initsWhenTrue , FlowInfo initsWhenFalse ) { } public boolean checkUnsafeCast ( Scope scope , TypeBinding castType , TypeBinding expressionType , TypeBinding match , boolean isNarrowing ) { } public void computeConversion ( Scope scope , TypeBinding runtimeType , TypeBinding compileTimeType ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { <START_BUG> if ( ( ( bits ) & ( IsReachableMASK ) ) == 0 ) { <END_BUG> return ; } generateCode ( currentScope , codeStream , false ) ; } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public void generateOptimizedBoolean ( BlockScope currentScope , CodeStream codeStream , Label trueLabel , Label falseLabel , boolean valueRequired ) { } public void generateOptimizedStringConcatenation ( BlockScope blockScope , CodeStream codeStream , int typeID ) { } public void generateOptimizedStringConcatenationCreation ( BlockScope blockScope , CodeStream codeStream , int typeID ) { } public boolean isCompactableOperation ( ) { } public boolean isConstantValueOfTypeAssignableToType ( TypeBinding constantType , TypeBinding targetType ) { } public boolean isTypeReference ( ) { } public int nullStatus ( FlowInfo flowInfo ) { } public Constant optimizedBooleanConstant ( ) { } public StringBuffer print ( int indent , StringBuffer output ) { } public abstract StringBuffer printExpression ( int indent , StringBuffer output ) { } public StringBuffer printStatement ( int indent , StringBuffer output ) { } public void resolve ( BlockScope scope ) { } public TypeBinding resolveType ( BlockScope scope ) { } public TypeBinding resolveType ( ClassScope scope ) { } public TypeBinding resolveTypeExpecting ( BlockScope scope , TypeBinding expectedType ) { } public void setExpectedType ( TypeBinding expectedType ) { } public void tagAsUnnecessaryCast ( Scope scope , TypeBinding castType ) { } public void tagAsNeedCheckCast ( ) { } public Expression toTypeReference ( ) { } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } public void traverse ( ASTVisitor visitor , ClassScope scope ) { } public void traverse ( ASTVisitor visitor , CompilationUnitScope scope ) { } public LocalVariableBinding localVariableBinding ( ) { } }
public class JobsExecutor extends AbstractExecutor { protected int fJobCounter = 1 ; protected String fExecutorName ; protected boolean fSystem ; protected ISchedulingRule fSchedulingRule ; protected long delay ; public JobsExecutor ( String executorName ) { } public JobsExecutor ( String executorName , boolean system ) { } public JobsExecutor ( String executorName , boolean system , ISchedulingRule schedulingRule ) { } public JobsExecutor ( String executorName , boolean system , ISchedulingRule schedulingRule , long delay ) { } protected void setChildProgressMonitor ( IProgressMonitor parent , IProgressMonitor child ) { } protected void safeRun ( ISafeProgressRunner runner , IProgressRunnable progressRunnable ) { <START_BUG> runner . safeRun ( progressRunnable ) ; <END_BUG> } protected String createJobName ( String executorName , int jobCounter , IProgressRunnable runnable ) { } protected AbstractFuture createFuture ( IProgressMonitor progressMonitor ) { } public IFuture execute ( final IProgressRunnable runnable , final IProgressMonitor clientProgressMonitor ) { } protected void configureJobForExecution ( Job job ) { } }
public class InspectorDebugPanel extends StandardDebugPanel { private static final long serialVersionUID = 1L ; public static final IDebugBarContributor DEBUG_BAR_CONTRIB = new IDebugBarContributor ( ) { private static final long serialVersionUID = 1L ; public Component createComponent ( String id , DebugBar debugBar ) { } } ; public InspectorDebugPanel ( String id ) { } @ Override protected Class < ? extends Page > getLinkPageClass ( ) { } @ Override protected ResourceReference getImageResourceReference ( ) { } @ Override protected IModel < String > getDataModel ( ) { } @ Override protected PageParameters getLinkPageParameters ( ) { PageParameters params = new PageParameters ( ) ; <START_BUG> params . addNamedParameter ( "pageId" , getPage ( ) . getId ( ) ) ; <END_BUG> return params ; } }
public class CollatingIterator < E > implements Iterator < E > { private Comparator < ? super E > comparator = null ; private ArrayList < Iterator < ? extends E > > iterators = null ; private ArrayList < E > values = null ; private BitSet valueSet = null ; private int lastReturned = - 1 ; public CollatingIterator ( ) { } public CollatingIterator ( final Comparator < ? super E > comp ) { } public CollatingIterator ( final Comparator < ? super E > comp , final int initIterCapacity ) { } public CollatingIterator ( final Comparator < ? super E > comp , final Iterator < ? extends E > a , final Iterator < ? extends E > b ) { } public CollatingIterator ( final Comparator < ? super E > comp , final Iterator < ? extends E > [ ] iterators ) { } public CollatingIterator ( final Comparator < ? super E > comp , final Collection < Iterator < ? extends E > > iterators ) { } public void addIterator ( final Iterator < ? extends E > iterator ) { } public void setIterator ( final int index , final Iterator < ? extends E > iterator ) { } public List < Iterator < ? extends E > > getIterators ( ) { <START_BUG> return UnmodifiableList . decorate ( iterators ) ; <END_BUG> } public Comparator < ? super E > getComparator ( ) { } public void setComparator ( final Comparator < ? super E > comp ) { } public boolean hasNext ( ) { } public E next ( ) throws NoSuchElementException { } public void remove ( ) { } public int getIteratorIndex ( ) { } private void start ( ) { } private boolean set ( int i ) { } private void clear ( int i ) { } private void checkNotStarted ( ) throws IllegalStateException { } private int least ( ) { } private boolean anyValueSet ( BitSet set ) { } private boolean anyHasNext ( ArrayList < Iterator < ? extends E > > iters ) { } }
public class Theme implements ITheme { private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle . getBundle ( Theme . class . getName ( ) ) ; private CascadingColorRegistry themeColorRegistry ; private CascadingFontRegistry themeFontRegistry ; private IThemeDescriptor descriptor ; private IPropertyChangeListener themeListener ; private CascadingMap dataMap ; private ListenerList propertyChangeListeners = new ListenerList ( ) ; private ThemeRegistry themeRegistry ; private IPropertyChangeListener propertyListener ; public Theme ( IThemeDescriptor descriptor ) { } private IPropertyChangeListener getPropertyListener ( ) { } private IPropertyChangeListener getCascadeListener ( ) { } public ColorRegistry getColorRegistry ( ) { } public FontRegistry getFontRegistry ( ) { } public void dispose ( ) { } public String getId ( ) { } public void addPropertyChangeListener ( IPropertyChangeListener listener ) { } public void removePropertyChangeListener ( IPropertyChangeListener listener ) { } private void firePropertyChange ( PropertyChangeEvent event ) { } public String getLabel ( ) { <START_BUG> return ( descriptor ) == null ? Theme . RESOURCE_BUNDLE . getString ( "DefaultTheme.label" ) : descriptor . getLabel ( ) ; <END_BUG> } public String getString ( String key ) { } public Set keySet ( ) { } public int getInt ( String key ) { } public boolean getBoolean ( String key ) { } }
final class CollectionToStringConverter implements GenericConverter { private static final String DELIMITER = "," ; private final ConversionService conversionService ; public CollectionToStringConverter ( ConversionService conversionService ) { } public Set < ConvertiblePair > getConvertibleTypes ( ) { } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( source == null ) { return null ; } Collection < ? > sourceCollection = ( ( Collection < ? > ) ( source ) ) ; if ( ( sourceCollection . size ( ) ) == 0 ) { return "" ; } StringBuilder sb = new StringBuilder ( ) ; int i = 0 ; for ( Object sourceElement : sourceCollection ) { if ( i > 0 ) { sb . append ( CollectionToStringConverter . DELIMITER ) ; } <START_BUG> Object targetElement = this . conversionService . convert ( sourceElement , sourceType . elementType ( sourceElement ) , targetType ) ; <END_BUG> sb . append ( targetElement ) ; i ++ ; } return sb . toString ( ) ; } }
public class WeldExtension implements Extension { public static final String SUBSYSTEM_NAME = "weld" ; public static final String NAMESPACE = "urn:jboss:domain:weld:1.0" ; private static final WeldExtension . WeldSubsystemParser parser = new WeldExtension . WeldSubsystemParser ( ) ; private static final PathElement PATH_SUBSYSTEM = PathElement . pathElement ( SUBSYSTEM , WeldExtension . SUBSYSTEM_NAME ) ; private static final String RESOURCE_NAME = ( WeldExtension . class . getPackage ( ) . getName ( ) ) + ".LocalDescriptions" ; private static final int MANAGEMENT_API_MAJOR_VERSION = 1 ; private static final int MANAGEMENT_API_MINOR_VERSION = 0 ; private static final int MANAGEMENT_API_MICRO_VERSION = 0 ; static StandardResourceDescriptionResolver getResourceDescriptionResolver ( final String ... keyPrefix ) { } private static final ResourceDefinition WELD_SUBSYSTEM_RESOURCE = new org . jboss . as . controller . SimpleResourceDefinition ( WeldExtension . PATH_SUBSYSTEM , WeldExtension . getResourceDescriptionResolver ( ) , WeldSubsystemAdd . INSTANCE , ReloadRequiredRemoveStepHandler . INSTANCE ) ; @ Override public void initialize ( final ExtensionContext context ) { ROOT_LOGGER . debug ( "Activating<seq2seq4repair_space>Weld<seq2seq4repair_space>Extension" ) ; final SubsystemRegistration subsystem = context . registerSubsystem ( WeldExtension . SUBSYSTEM_NAME , WeldExtension . MANAGEMENT_API_MAJOR_VERSION , WeldExtension . MANAGEMENT_API_MINOR_VERSION , WeldExtension . MANAGEMENT_API_MICRO_VERSION ) ; final ManagementResourceRegistration registration = subsystem . registerSubsystemModel ( WeldExtension . WELD_SUBSYSTEM_RESOURCE ) ; <START_BUG> registration . registerOperationHandler ( DESCRIBE , INSTANCE , INSTANCE , false , PRIVATE ) ; <END_BUG> subsystem . registerXMLElementWriter ( WeldExtension . parser ) ; } @ Override public void initializeParsers ( final ExtensionParsingContext context ) { } static class WeldSubsystemParser implements XMLStreamConstants , XMLElementReader < List < ModelNode > > , XMLElementWriter < SubsystemMarshallingContext > { @ Override public void readElement ( final XMLExtendedStreamReader reader , final List < ModelNode > list ) throws XMLStreamException { } @ Override public void writeContent ( final XMLExtendedStreamWriter streamWriter , final SubsystemMarshallingContext context ) throws XMLStreamException { } } }
public abstract class Expression extends Statement { public static final boolean isConstantValueRepresentable ( Constant constant , int constantTypeID , int targetTypeID ) { } public Constant constant ; public int implicitConversion ; public TypeBinding resolvedType ; public Expression ( ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , boolean valueRequired ) { } public final boolean checkCastTypesCompatibility ( Scope scope , TypeBinding castType , TypeBinding expressionType , Expression expression ) { } public FlowInfo checkNullStatus ( BlockScope scope , FlowContext flowContext , FlowInfo flowInfo , int nullStatus ) { } private MethodBinding [ ] getAllInheritedMethods ( ReferenceBinding binding ) { } private void getAllInheritedMethods0 ( ReferenceBinding binding , ArrayList collector ) { } public void checkNullComparison ( BlockScope scope , FlowContext flowContext , FlowInfo flowInfo , FlowInfo initsWhenTrue , FlowInfo initsWhenFalse ) { } public boolean checkUnsafeCast ( Scope scope , TypeBinding castType , TypeBinding expressionType , TypeBinding match , boolean isNarrowing ) { } public void computeConversion ( Scope scope , TypeBinding runtimeTimeType , TypeBinding compileTimeType ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public void generateOptimizedBoolean ( BlockScope currentScope , CodeStream codeStream , Label trueLabel , Label falseLabel , boolean valueRequired ) { if ( ( ( constant ) != ( Constant . NotAConstant ) ) && ( ( constant . typeID ( ) ) == ( TypeIds . T_boolean ) ) ) { int pc = codeStream . position ; if ( ( constant . booleanValue ( ) ) == true ) { if ( valueRequired ) { if ( falseLabel == null ) { if ( trueLabel != null ) { codeStream . goto_ ( trueLabel ) ; } } } } else { if ( valueRequired ) { if ( falseLabel != null ) { if ( trueLabel == null ) { codeStream . goto_ ( falseLabel ) ; } } } } codeStream . recordPositionsFrom ( pc , this . sourceStart ) ; return ; } generateCode ( currentScope , codeStream , valueRequired ) ; int position = codeStream . position ; if ( valueRequired ) { if ( falseLabel == null ) { if ( trueLabel != null ) { codeStream . ifne ( trueLabel ) ; } } else { if ( trueLabel == null ) { codeStream . ifeq ( falseLabel ) ; } else { } } } <START_BUG> codeStream . updateLastRecordedEndPC ( position ) ; <END_BUG> } public void generateOptimizedStringConcatenation ( BlockScope blockScope , CodeStream codeStream , int typeID ) { } public void generateOptimizedStringConcatenationCreation ( BlockScope blockScope , CodeStream codeStream , int typeID ) { } public boolean isCompactableOperation ( ) { } public boolean isConstantValueOfTypeAssignableToType ( TypeBinding constantType , TypeBinding targetType ) { } public boolean isTypeReference ( ) { } public int nullStatus ( FlowInfo flowInfo ) { } public Constant optimizedBooleanConstant ( ) { } public StringBuffer print ( int indent , StringBuffer output ) { } public abstract StringBuffer printExpression ( int indent , StringBuffer output ) { } public StringBuffer printStatement ( int indent , StringBuffer output ) { } public void resolve ( BlockScope scope ) { } public TypeBinding resolveType ( BlockScope scope ) { } public TypeBinding resolveType ( ClassScope classScope ) { } public TypeBinding resolveTypeExpecting ( BlockScope scope , TypeBinding expectedType ) { } public void setExpectedType ( TypeBinding expectedType ) { } public void tagAsUnnecessaryCast ( Scope scope , TypeBinding castType ) { } public void tagAsNeedCheckCast ( ) { } public Expression toTypeReference ( ) { } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } public void traverse ( ASTVisitor visitor , ClassScope scope ) { } public void traverse ( ASTVisitor visitor , CompilationUnitScope scope ) { } public LocalVariableBinding localVariableBinding ( ) { } }
public class OrderedList { private List < ListItem > list ; public OrderedList ( ) { } public void insert ( LongConsumer action , long time ) { } public void remove ( LongConsumer action ) { int size = list . size ( ) ; int idx = 0 ; while ( ( idx < size ) && ( ( list . get ( idx ) . getAction ( ) ) != action ) ) idx ++ ; if ( idx < size ) <START_BUG> list . remove ( action ) ; <END_BUG> } public ListItem head ( ) { } public ListItem pop ( ) { } No newline ; at end ; of file ; }
public class LabeledStatement extends Statement { public Statement statement ; public char [ ] label ; public Label targetLabel ; int mergedInitStateIndex = - 1 ; public LabeledStatement ( char [ ] label , Statement statement , int sourceStart , int sourceEnd ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public ASTNode concreteStatement ( ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { int pc = codeStream . position ; if ( ( targetLabel ) != null ) { <START_BUG> targetLabel . codeStream = codeStream ; <END_BUG> if ( ( statement ) != null ) { statement . generateCode ( currentScope , codeStream ) ; } targetLabel . place ( ) ; } if ( ( mergedInitStateIndex ) != ( - 1 ) ) { codeStream . removeNotDefinitelyAssignedVariables ( currentScope , mergedInitStateIndex ) ; } codeStream . recordPositionsFrom ( pc , this . sourceStart ) ; } public StringBuffer printStatement ( int tab , StringBuffer output ) { } public void resolve ( BlockScope scope ) { } public void traverse ( ASTVisitor visitor , BlockScope blockScope ) { } public void resetStateForCodeGeneration ( ) { } }
public class StatefulComponentDescription extends SessionBeanComponentDescription { private Method afterBegin ; private Method afterCompletion ; private Method beforeCompletion ; private final Map < MethodIdentifier , StatefulComponentDescription . StatefulRemoveMethod > removeMethods = new HashMap < MethodIdentifier , StatefulComponentDescription . StatefulRemoveMethod > ( ) ; private StatefulTimeoutInfo statefulTimeout ; private CacheInfo cache ; private Map < Method , String > initMethods = new HashMap < Method , String > ( 0 ) ; public class StatefulRemoveMethod { private final MethodIdentifier methodIdentifier ; private final boolean retainIfException ; StatefulRemoveMethod ( final MethodIdentifier method , final boolean retainIfException ) { } public MethodIdentifier getMethodIdentifier ( ) { } public boolean isRetainIfException ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } } public StatefulComponentDescription ( final String componentName , final String componentClassName , final EjbJarDescription ejbJarDescription , final ServiceName deploymentUnitServiceName , final SessionBeanMetaData descriptorData ) { } private void addInitMethodInvokingInterceptor ( ) { } private void addStatefulSessionSynchronizationInterceptor ( ) { } @ Override public ComponentConfiguration createConfiguration ( final ClassIndex classIndex , final ClassLoader moduleClassLoder ) { } @ Override public boolean allowsConcurrentAccess ( ) { } public Method getAfterBegin ( ) { } public Method getAfterCompletion ( ) { } public Method getBeforeCompletion ( ) { } @ Override public SessionBeanType getSessionBeanType ( ) { } public void setAfterBegin ( final Method afterBegin ) { } public void setAfterCompletion ( final Method afterCompletion ) { } public void setBeforeCompletion ( final Method afterCompletion ) { } @ Override protected void setupViewInterceptors ( EJBViewDescription view ) { } @ Override protected ViewConfigurator getSessionBeanObjectViewConfigurator ( ) { } private void addViewSerializationInterceptor ( final ViewDescription view ) { view . setSerializable ( true ) ; view . setUseWriteReplace ( true ) ; view . getConfigurators ( ) . add ( new ViewConfigurator ( ) { @ Override public void configure ( final DeploymentPhaseContext context , final ComponentConfiguration componentConfiguration , final ViewDescription description , final ViewConfiguration configuration ) throws DeploymentUnitProcessingException { final DeploymentReflectionIndex index = context . getDeploymentUnit ( ) . getAttachment ( REFLECTION_INDEX ) ; ClassReflectionIndex < WriteReplaceInterface > classIndex = index . getClassIndex ( WriteReplaceInterface . class ) ; for ( Method method : classIndex . getMethods ( ) ) { <START_BUG> configuration . addClientInterceptor ( method , new WriteReplaceInterceptor . Factory ( configuration . getViewServiceName ( ) . getCanonicalName ( ) ) , WRITE_REPLACE ) ; <END_BUG> } } } ) ; } public void addRemoveMethod ( final MethodIdentifier removeMethod , final boolean retainIfException ) { } public Collection < StatefulComponentDescription . StatefulRemoveMethod > getRemoveMethods ( ) { } public StatefulTimeoutInfo getStatefulTimeout ( ) { } public void setStatefulTimeout ( final StatefulTimeoutInfo statefulTimeout ) { } private void addStatefulInstanceAssociatingInterceptor ( final EJBViewDescription view ) { } private void addRemoveMethodInterceptor ( final ViewDescription view ) { } public void addInitMethod ( final Method method , final String createMethod ) { } public Map < Method , String > getInitMethods ( ) { } public CacheInfo getCache ( ) { } public void setCache ( CacheInfo cache ) { } @ Override public boolean isPassivationApplicable ( ) { } }
public class SpellEffectFactory { public static HashMap < String , ISpellEffect [ ] > effectMap = new HashMap < String , ISpellEffect [ ] > ( ) ; public static ISpellEffect [ ] create ( String spellName ) { } private static void put ( String key , ISpellEffect ... effects ) { } private static void intitializeMap ( ) { SpellEffectFactory . put ( "absorb<seq2seq4repair_space>essence" , new TransmorphEffect ( "target" ) ) ; SpellEffectFactory . put ( "animate" , new AnimateEffect ( ) ) ; SpellEffectFactory . put ( "ask<seq2seq4repair_space>demon" , new AskDemonEffect ( ) ) ; SpellEffectFactory . put ( "bewilder" , new ApplyClearingEffect ( "bewildered" ) ) ; SpellEffectFactory . put ( "blazing<seq2seq4repair_space>light" , new ExtraCavePhaseEffect ( ) ) ; SpellEffectFactory . put ( "blend<seq2seq4repair_space>into<seq2seq4repair_space>background" , new ExtraActionEffect ( "H" ) ) ; SpellEffectFactory . put ( "blunting" , new ApplyClearingEffect ( "blunted" ) ) ; SpellEffectFactory . put ( "blur" , new FinalChitSpeedEffect ( ) ) ; SpellEffectFactory . put ( "broomstick" , new FlyChitEffect ( ) ) ; SpellEffectFactory . put ( "control<seq2seq4repair_space>bats" , new ControlEffect ( ) ) ; SpellEffectFactory . put ( "curse" , new CurseEffect ( ) ) ; SpellEffectFactory . put ( "elven<seq2seq4repair_space>grace" , new MoveSpeedChangeEffect ( ) ) ; SpellEffectFactory . put ( "exorcise" , new ExorciseEffect ( ) ) ; SpellEffectFactory . put ( "deal<seq2seq4repair_space>with<seq2seq4repair_space>goblins" , new PacifyEffect ( 0 ) ) ; SpellEffectFactory . put ( "disguise" , new PacifyEffect ( 0 ) ) ; SpellEffectFactory . put ( "disjunction" , new ApplyNamedEffect ( "no_w_fat" ) , new ApplyNamedEffect ( "no_ter_harm" ) ) ; SpellEffectFactory . put ( "dissolve<seq2seq4repair_space>spell" , new CancelEffect ( ) ) ; <START_BUG> SpellEffectFactory . put ( "divine<seq2seq4repair_space>might" , new ApplyNamedEffect ( "strong_mf" ) ) ; <END_BUG> SpellEffectFactory . put ( "divine<seq2seq4repair_space>protection" , new ApplyNamedEffect ( "adds_armor" ) ) ; SpellEffectFactory . put ( "elemental<seq2seq4repair_space>power" , new ForcedEnchantEffect ( ) ) ; SpellEffectFactory . put ( "elemental<seq2seq4repair_space>spirit" , new ChitChangeEffect ( ) ) ; SpellEffectFactory . put ( "elven<seq2seq4repair_space>grace" , new MoveSpeedChangeEffect ( ) ) ; SpellEffectFactory . put ( "enchant<seq2seq4repair_space>artifact" , new EnchantEffect ( ) ) ; SpellEffectFactory . put ( "faerie<seq2seq4repair_space>lights" , new ChitChangeEffect ( ) ) ; SpellEffectFactory . put ( "fog" , new ApplyNamedEffect ( Constants . SP_NO_PEER ) ) ; SpellEffectFactory . put ( "gravity" , new ApplyClearingEffect ( "heavied" ) ) ; SpellEffectFactory . put ( "guide<seq2seq4repair_space>spider<seq2seq4repair_space>or<seq2seq4repair_space>octopus" , new ControlEffect ( ) ) ; SpellEffectFactory . put ( "heal" , new HealChitEffect ( ) ) ; SpellEffectFactory . put ( "hop" , new TeleportEffect ( "RandomClearing" ) ) ; SpellEffectFactory . put ( "hurricane<seq2seq4repair_space>winds" , new HurricaneWindsEffect ( ) ) ; SpellEffectFactory . put ( "hypnotize" , new ControlEffect ( ) ) ; SpellEffectFactory . put ( "levitate" , new NoWeightEffect ( ) ) ; SpellEffectFactory . put ( "lost" , new ApplyNamedEffect ( Constants . SP_MOVE_IS_RANDOM ) ) ; SpellEffectFactory . put ( "make<seq2seq4repair_space>whole" , new MakeWholeEffect ( ) ) ; SpellEffectFactory . put ( "melt<seq2seq4repair_space>into<seq2seq4repair_space>mist" , new NullifyEffect ( ) , new DisengageEffect ( ) , new TransmorphEffect ( "mist" ) ) ; SpellEffectFactory . put ( "open<seq2seq4repair_space>gate" , new TeleportEffect ( "KnownGate" ) ) ; SpellEffectFactory . put ( "peace" , new PeaceEffect ( ) ) ; SpellEffectFactory . put ( "pentangle" , new NullifyEffect ( ) ) ; SpellEffectFactory . put ( "persuade" , new PacifyEffect ( 1 ) ) ; SpellEffectFactory . put ( "phantasm" , new PhantasmEffect ( ) ) ; SpellEffectFactory . put ( "poison" , new AddSharpnessEffect ( ) ) ; SpellEffectFactory . put ( "power<seq2seq4repair_space>of<seq2seq4repair_space>the<seq2seq4repair_space>pit" , new PowerPitEffect ( ) ) ; SpellEffectFactory . put ( "prayer" , new ExtraActionEffect ( "R" ) ) ; SpellEffectFactory . put ( "premonition" , new ApplyNamedEffect ( Constants . CHOOSE_TURN ) ) ; SpellEffectFactory . put ( "prophecy" , new ApplyNamedEffect ( Constants . DAYTIME_ACTIONS ) ) ; SpellEffectFactory . put ( "protection<seq2seq4repair_space>from<seq2seq4repair_space>magic" , new PhaseChitEffect ( ) , new NullifyEffect ( ) ) ; SpellEffectFactory . put ( "raise<seq2seq4repair_space>dead" , new SummonEffect ( "undead" ) ) ; SpellEffectFactory . put ( "remedy" , new CancelEffect ( ) ) ; SpellEffectFactory . put ( "repair<seq2seq4repair_space>armor" , new RepairEffect ( ) ) ; SpellEffectFactory . put ( "reverse<seq2seq4repair_space>power" , new ColorModEffect ( ) ) ; SpellEffectFactory . put ( "see/change<seq2seq4repair_space>weather" , new SeeChangeWeatherEffect ( ) ) ; SpellEffectFactory . put ( "see<seq2seq4repair_space>hidden<seq2seq4repair_space>signs" , new ExtraActionEffect ( "S" ) ) ; SpellEffectFactory . put ( "send" , new ControlEffect ( ) ) ; SpellEffectFactory . put ( "sense<seq2seq4repair_space>danger" , new ExtraActionEffect ( "A" ) ) ; SpellEffectFactory . put ( "serpent<seq2seq4repair_space>tongue" , new ControlEffect ( ) ) ; SpellEffectFactory . put ( "shrink" , new ApplyNamedEffect ( "shrink" ) ) ; SpellEffectFactory . put ( "slow<seq2seq4repair_space>monster" , new ApplyNamedEffect ( "slowed" ) ) ; SpellEffectFactory . put ( "small<seq2seq4repair_space>blessing" , new SmallBlessingEffect ( ) ) ; SpellEffectFactory . put ( "sparkle" , new UnassignEffect ( ) ) ; SpellEffectFactory . put ( "summon<seq2seq4repair_space>animal" , new SummonEffect ( "animal" ) ) ; SpellEffectFactory . put ( "summon<seq2seq4repair_space>elemental" , new SummonEffect ( "elemental" ) ) ; SpellEffectFactory . put ( "sword<seq2seq4repair_space>song" , new ApplyNamedEffect ( "alerted_weapon" ) , new AlertWeaponEffect ( ) ) ; SpellEffectFactory . put ( "talk<seq2seq4repair_space>to<seq2seq4repair_space>wise<seq2seq4repair_space>bird" , new InstantPeerEffect ( ) ) ; SpellEffectFactory . put ( "teleport" , new TeleportEffect ( "ChooseTileTwo" ) ) ; SpellEffectFactory . put ( "torch<seq2seq4repair_space>bearer" , new ApplyNamedEffect ( Constants . TORCH_BEARER ) ) ; SpellEffectFactory . put ( "transform" , new TransmorphEffect ( "roll" ) ) ; SpellEffectFactory . put ( "unleash<seq2seq4repair_space>power" , new ActionChangeEffect ( ) ) ; SpellEffectFactory . put ( "vale<seq2seq4repair_space>walker" , new ApplyNamedEffect ( Constants . VALE_WALKER ) ) ; SpellEffectFactory . put ( "violent<seq2seq4repair_space>storm" , new ViolentStormEffect ( ) ) ; SpellEffectFactory . put ( "vision" , new DiscoverRoadEffect ( ) ) ; SpellEffectFactory . put ( "whistle<seq2seq4repair_space>for<seq2seq4repair_space>monsters" , new MoveSoundEffect ( ) ) ; SpellEffectFactory . put ( "witch's<seq2seq4repair_space>brew" , new ChitChangeEffect ( ) ) ; } }
@ RunWith ( Arquillian . class ) public class StatefulBeanTestCase { private static final Logger log = Logger . getLogger ( StatefulBeanTestCase . class . getName ( ) ) ; @ Deployment public static JavaArchive createDeployment ( ) { } @ EJB ( mappedName = "java:global/ejb3-sfsb-example/SimpleStatefulSessionBean!org.jboss.as.demos.ejb3.archive.SimpleStatefulSessionLocal" ) private SimpleStatefulSessionLocal localSfsb ; @ Test public void testSFSB ( ) throws Exception { String state = "not<seq2seq4repair_space>in<seq2seq4repair_space>a<seq2seq4repair_space>good<seq2seq4repair_space>mood!" ; localSfsb . setState ( state ) ; String storedState = localSfsb . getState ( ) ; <START_BUG> Assert . assertEquals ( "Unexpected<seq2seq4repair_space>state<seq2seq4repair_space>returned<seq2seq4repair_space>from<seq2seq4repair_space>stateful<seq2seq4repair_space>session<seq2seq4repair_space>bean" , ( ( ( SimpleInterceptor . class . getSimpleName ( ) ) + "#" ) + state ) , storedState ) ; <END_BUG> } }
@ RunWith ( Arquillian . class ) @ Category ( CommonCriteria . class ) public class EJBSecurityTestCase { private static Context ctx ; @ AfterClass public static void afterClass ( ) throws NamingException { } @ BeforeClass public static void beforeClass ( ) throws NamingException { } @ Deployment public static JavaArchive createDeployment ( ) { final JavaArchive jar = ShrinkWrap . create ( JavaArchive . class , "ejb-security-test.jar" ) ; jar . addPackage ( AnnotatedSLSB . class . getPackage ( ) ) ; <START_BUG> jar . addAsManifestResource ( "ejb/security/ejb-jar.xml" , "ejb-jar.xml" ) ; <END_BUG> jar . addAsManifestResource ( EJBSecurityTestCase . class . getPackage ( ) , "jboss-ejb3.xml" , "jboss-ejb3.xml" ) ; jar . addPackage ( CommonCriteria . class . getPackage ( ) ) ; return jar ; } private static < T > T lookup ( final Class < ? > beanClass , final Class < T > viewClass ) throws NamingException { } @ Test public void testDenyAllAnnotation ( ) throws Exception { } @ Test public void testEJB2 ( ) throws Exception { } @ Test public void testExcludeList ( ) throws Exception { } @ Test public void testSecurityOnBeanInAbsenceOfExplicitSecurityDomain ( ) throws Exception { } @ Test public void testEmptyRolesAllowedAnnotationValue ( ) throws Exception { } }
public class AndroidBrowserHistoryRepositorySession extends AndroidBrowserRepositorySession { public static final String KEY_DATE = "date" ; public static final String KEY_TYPE = "type" ; public static final long DEFAULT_VISIT_TYPE = 1 ; public AndroidBrowserHistoryRepositorySession ( Repository repository , Context context ) { } @ Override protected Record recordFromMirrorCursor ( Cursor cur ) { } @ Override protected String buildRecordString ( Record record ) { } @ Override protected Record transformRecord ( Record record ) throws NullCursorException { } @ SuppressWarnings ( "unchecked" ) private Record addVisitsToRecord ( Record record ) throws NullCursorException { AndroidBrowserHistoryDataExtender dataExtender = ( ( AndroidBrowserHistoryDataAccessor ) ( dbHelper ) ) . getHistoryDataExtender ( ) ; HistoryRecord hist = ( ( HistoryRecord ) ( record ) ) ; Cursor visits = dataExtender . fetch ( hist . guid ) ; visits . moveToFirst ( ) ; JSONArray visitsArray = RepoUtils . getJSONArrayFromCursor ( visits , COL_VISITS ) ; long missingRecords = ( hist . fennecVisitCount ) - ( visitsArray . size ( ) ) ; if ( missingRecords >= 1 ) { if ( missingRecords > 1 ) { for ( int j = 0 ; j < ( missingRecords - 1 ) ; j ++ ) { JSONObject fake = new JSONObject ( ) ; <START_BUG> fake . put ( AndroidBrowserHistoryRepositorySession . KEY_DATE , ( ( ( long ) ( hist . fennecDateVisited ) ) - ( 1 + j ) ) ) ; <END_BUG> fake . put ( AndroidBrowserHistoryRepositorySession . KEY_TYPE , AndroidBrowserHistoryRepositorySession . DEFAULT_VISIT_TYPE ) ; visitsArray . add ( fake ) ; } } JSONObject real = new JSONObject ( ) ; real . put ( AndroidBrowserHistoryRepositorySession . KEY_DATE , hist . fennecDateVisited ) ; real . put ( AndroidBrowserHistoryRepositorySession . KEY_TYPE , AndroidBrowserHistoryRepositorySession . DEFAULT_VISIT_TYPE ) ; visitsArray . add ( real ) ; } hist . visits = visitsArray ; return hist ; } }
public class HttpMirrorServer extends Thread implements Stoppable { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final int ACCEPT_TIMEOUT = 1000 ; private final int daemonPort ; private volatile boolean running ; private volatile Exception except ; public HttpMirrorServer ( int port ) { } @ Override public void run ( ) { } public void stopServer ( ) { } public Exception getException ( ) { } public static void main ( String [ ] args ) { <START_BUG> int port = 8081 ; <END_BUG> if ( ( args . length ) > 0 ) { port = Integer . parseInt ( args [ 0 ] ) ; } LoggingManager . setPriority ( "INFO" ) ; LoggingManager . setLoggingLevels ( System . getProperties ( ) ) ; HttpMirrorServer serv = new HttpMirrorServer ( port ) ; serv . start ( ) ; } }
public class TreeColumn extends Item { Tree parent ; boolean resizable ; boolean moveable ; public TreeColumn ( Tree parent , int style ) { } public TreeColumn ( Tree parent , int style , int index ) { } public void addControlListener ( ControlListener listener ) { } public void addSelectionListener ( SelectionListener listener ) { } static int checkStyle ( int style ) { } protected void checkSubclass ( ) { } void destroyWidget ( ) { } public int getAlignment ( ) { } public boolean getMoveable ( ) { } String getNameText ( ) { } public Tree getParent ( ) { } public boolean getResizable ( ) { } public int getWidth ( ) { } public void pack ( ) { checkWidget ( ) ; int index = parent . indexOf ( this ) ; if ( index == ( - 1 ) ) return ; int columnWidth = 0 ; int hwnd = parent . handle ; int hDC = OS . GetDC ( hwnd ) ; int oldFont = 0 ; int newFont = OS . SendMessage ( hwnd , WM_GETFONT , 0 , 0 ) ; if ( newFont != 0 ) oldFont = OS . SelectObject ( hDC , newFont ) ; int cp = parent . getCodePage ( ) ; RECT rect = new RECT ( ) ; int flags = ( OS . DT_CALCRECT ) | ( OS . DT_NOPREFIX ) ; TVITEM tvItem = new TVITEM ( ) ; tvItem . mask = OS . TVIF_PARAM ; int hItem = OS . SendMessage ( hwnd , TVM_GETNEXTITEM , TVGN_ROOT , 0 ) ; while ( hItem != 0 ) { hItem = OS . SendMessage ( hwnd , TVM_GETNEXTITEM , TVGN_NEXTVISIBLE , hItem ) ; tvItem . hItem = hItem ; OS . SendMessage ( hwnd , TVM_GETITEM , 0 , tvItem ) ; TreeItem item = parent . items [ tvItem . lParam ] ; if ( index == 0 ) { rect . left = item . handle ; if ( ( OS . SendMessage ( hwnd , TVM_GETITEMRECT , 1 , rect ) ) != 0 ) { columnWidth = Math . max ( columnWidth , rect . right ) ; } } else { int imageWidth = 0 ; int textWidth = 0 ; Image image = ( ( item . images ) != null ) ? item . images [ index ] : null ; if ( image != null ) { Rectangle bounds = image . getBounds ( ) ; imageWidth = bounds . width ; } String string = ( ( item . strings ) != null ) ? item . strings [ index ] : null ; if ( string != null ) { TCHAR buffer = new TCHAR ( cp , string , false ) ; OS . DrawText ( hDC , buffer , buffer . length ( ) , rect , flags ) ; textWidth = ( rect . right ) - ( rect . left ) ; } columnWidth = Math . max ( columnWidth , ( ( imageWidth + textWidth ) + ( ( Tree . INSET ) * 3 ) ) ) ; } } <START_BUG> TCHAR buffer = new TCHAR ( cp , text , true ) ; <END_BUG> OS . DrawText ( hDC , buffer , buffer . length ( ) , rect , flags ) ; int headerWidth = ( ( rect . right ) - ( rect . left ) ) + ( Tree . HEADER_MARGIN ) ; if ( ( ( image ) != null ) || ( ( parent . sortColumn ) == ( this ) ) ) { Image headerImage = null ; if ( ( ( parent . sortColumn ) == ( this ) ) && ( ( parent . sortDirection ) != ( SWT . NULL ) ) ) { if ( ( OS . COMCTL32_MAJOR ) < 6 ) { headerImage = display . getSortImage ( parent . sortDirection ) ; } else { headerWidth += Tree . SORT_WIDTH ; } } else { headerImage = image ; } if ( headerImage != null ) { Rectangle bounds = headerImage . getBounds ( ) ; headerWidth += bounds . width ; } int margin = 0 ; int hwndHeader = parent . hwndHeader ; if ( ( hwndHeader != 0 ) && ( ( OS . COMCTL32_VERSION ) >= ( OS . VERSION ( 5 , 80 ) ) ) ) { margin = OS . SendMessage ( hwndHeader , HDM_GETBITMAPMARGIN , 0 , 0 ) ; } else { margin = ( OS . GetSystemMetrics ( SM_CXEDGE ) ) * 3 ; } headerWidth += margin * 2 ; } if ( newFont != 0 ) OS . SelectObject ( hDC , oldFont ) ; OS . ReleaseDC ( hwnd , hDC ) ; setWidth ( Math . max ( headerWidth , columnWidth ) ) ; } void releaseHandle ( ) { } void releaseParent ( ) { } public void removeControlListener ( ControlListener listener ) { } public void removeSelectionListener ( SelectionListener listener ) { } public void setAlignment ( int alignment ) { } public void setImage ( Image image ) { } void setImage ( Image image , boolean sort , boolean right ) { } public void setMoveable ( boolean moveable ) { } public void setResizable ( boolean resizable ) { } void setSortDirection ( int direction ) { } public void setText ( String string ) { } public void setWidth ( int width ) { } }
public class FileHashCache { public static class Entry { public long size ; public long mtime ; public byte [ ] hash ; protected static void longToBytes ( long l , byte [ ] bytes , int offset ) { } protected static long bytesToLong ( byte [ ] bytes , int offset ) { } public byte [ ] toBytes ( ) { } public static FileHashCache . Entry fromBytes ( byte [ ] bytes , int hashLength ) { } } protected File cacheFile ; protected SimpleListFile slf ; protected String mode ; protected ContentAddressingScheme dataScheme ; public FileHashCache ( File cacheFile , ContentAddressingScheme dataScheme , String mode ) { } public boolean isWritable ( ) { } protected SimpleListFile getSlf ( ) { if ( ( slf ) == null ) { try { FileUtil . mkParentDirs ( cacheFile ) ; slf = new SimpleListFile ( cacheFile , mode ) ; <START_BUG> slf . init ( 65536 , ( 1024 * 1024 ) ) ; <END_BUG> } catch ( IOException e ) { if ( ( mode . indexOf ( 'w' ) ) != ( - 1 ) ) { Log . log ( EVENT_WARNING , ( ( "Couldn't<seq2seq4repair_space>open<seq2seq4repair_space>cache<seq2seq4repair_space>file<seq2seq4repair_space>in<seq2seq4repair_space>'" + ( mode ) ) + "'<seq2seq4repair_space>mode,<seq2seq4repair_space>trying<seq2seq4repair_space>again<seq2seq4repair_space>as<seq2seq4repair_space>'r'" ) ) ; try { slf = new SimpleListFile ( cacheFile , "r" ) ; } catch ( IOException ee ) { throw new RuntimeException ( ee ) ; } } else { throw new RuntimeException ( ( ( "Couldn't<seq2seq4repair_space>open<seq2seq4repair_space>cache<seq2seq4repair_space>file<seq2seq4repair_space>in<seq2seq4repair_space>'" + ( mode ) ) + "'<seq2seq4repair_space>mode" ) , e ) ; } } } return slf ; } public FileHashCache . Entry getCachedEntry ( File file ) throws IOException { } public FileHashCache . Entry getCachedValidEntry ( File file ) throws IOException { } public void putHash ( File file , byte [ ] hash ) { } public void putHashUrn ( File file , String urn ) { } public byte [ ] getHash ( FileBlob file ) { } public byte [ ] getCachedHash ( File file ) { } public String getCachedUrn ( File file ) { } public String getUrn ( FileBlob file ) { } public static void main ( String [ ] args ) { } public void close ( ) throws IOException { } }
public class ConversionHelp { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final String CHAR_SET = "UTF-8" ; public static final String ATT_CLASS = "class" ; public static final String ATT_NAME = "name" ; public static final String ATT_ELEMENT_TYPE = "elementType" ; private static final String ATT_TE_ENABLED = "enabled" ; private static final String ATT_TE_TESTCLASS = "testclass" ; private static final String ATT_TE_GUICLASS = "guiclass" ; private static final String ATT_TE_NAME = "testname" ; private static String inVersion ; private static String outVersion = "1.1" ; public static void setInVersion ( String v ) { } public static void setOutVersion ( String v ) { } public static String encode ( String p ) { } public static String decode ( String p ) { } public static String cdata ( byte [ ] chars , String encoding ) throws UnsupportedEncodingException { <START_BUG> StringBuffer buf = new StringBuffer ( "<![CDATA[" ) ; <END_BUG> buf . append ( new String ( chars , encoding ) ) ; buf . append ( "]]>" ) ; return buf . toString ( ) ; } private static final Map < String , String > propertyToAttribute = new HashMap < String , String > ( ) ; private static void mapentry ( String prop , String att ) { } private static void saveClass ( TestElement el , HierarchicalStreamWriter writer , String prop ) { } private static void restoreClass ( TestElement el , HierarchicalStreamReader reader , String prop ) { } private static void saveItem ( TestElement el , HierarchicalStreamWriter writer , String prop , boolean encode ) { } private static void restoreItem ( TestElement el , HierarchicalStreamReader reader , String prop , boolean decode ) { } public static boolean isSpecialProperty ( String name ) { } public static void saveSpecialProperties ( TestElement el , HierarchicalStreamWriter writer ) { } public static void restoreSpecialProperties ( TestElement el , HierarchicalStreamReader reader ) { } }
public class BaseHrefScanner extends TagScanner { private LinkProcessor processor ; public BaseHrefScanner ( ) { } public BaseHrefScanner ( String filter , LinkProcessor processor ) { } public String [ ] getID ( ) { } protected Tag createTag ( TagData tagData , Tag tag , String url ) throws ParserException { String baseUrl = ( ( String ) ( tag . getAttribute ( "HREF" ) ) ) ; String absoluteBaseUrl = "" ; if ( ( baseUrl != null ) && ( ( baseUrl . length ( ) ) > 0 ) ) { <START_BUG> absoluteBaseUrl = baseUrl . trim ( ) ; <END_BUG> processor . setBaseUrl ( absoluteBaseUrl ) ; } return new org . htmlparser . tags . BaseHrefTag ( tagData , absoluteBaseUrl ) ; } }
public class Exporter extends Configured implements Tool { private static final Logger LOG = LoggerFactory . getLogger ( Locator . class ) ; private static final String FAMILY_NAME = Parameters . getName ( "family_name" ) ; private static final String EXPORT_TYPE = Parameters . getName ( "export_type" ) ; public static class EntityExportMapper extends TableMapper < Text , Text > { @ Override protected void map ( ImmutableBytesWritable key , Result value , Context context ) throws IOException , InterruptedException { } private Exporter . EntityExportMapper . DetailsExport getDetailsExport ( String exportType ) { } private abstract class DetailsExport { private static final String ATTRIBUTE_SEPARATOR = "," ; private String fieldSeparator ; private final Map < String , List < String > > details = new HashMap < > ( ) ; DetailsExport ( String fieldSeparator ) { } final void write ( byte [ ] key , byte [ ] value ) { } final byte [ ] export ( ) { } private void append ( StringBuilder exported , String key , List < String > value ) { } public boolean canExport ( ) { } protected String tokenize ( String str ) { } protected String wrap ( String exported ) { } } private class JSONDetailsExport extends Exporter . EntityExportMapper . DetailsExport { private JSONDetailsExport ( ) { } @ Override public String tokenize ( String str ) { } @ Override protected String wrap ( String exported ) { } } private class CSVDetailsExport extends Exporter . EntityExportMapper . DetailsExport { private CSVDetailsExport ( ) { } } } public Job createSubmittableJob ( Configuration conf , String [ ] args ) throws IOException { } private Scan prepareScan ( String family , String startRow , String stopRow ) throws IOException { Scan scan = new Scan ( ) ; scan . addFamily ( Bytes . toBytes ( family ) ) ; scan . setCacheBlocks ( false ) ; scan . setTimeRange ( 0 , LATEST_TIMESTAMP ) ; scan . setStartRow ( Bytes . toBytes ( startRow ) ) ; <START_BUG> scan . setStartRow ( Bytes . toBytes ( stopRow ) ) ; <END_BUG> return scan ; } @ Override public int run ( String [ ] args ) throws Exception { } }
public class TestDocTermOrds extends LuceneTestCase { public void testSimple ( ) throws Exception { } public void testRandom ( ) throws Exception { } public void testRandomWithPrefix ( ) throws Exception { } private void verify ( AtomicReader r , int [ ] [ ] idToOrds , BytesRef [ ] termsArray , BytesRef prefixRef ) throws Exception { final DocTermOrds dto = new DocTermOrds ( r , "field" , prefixRef , Integer . MAX_VALUE , _TestUtil . nextInt ( random ( ) , 2 , 10 ) ) ; final int [ ] docIDToID = DEFAULT . getInts ( r , "id" , false ) ; if ( VERBOSE ) { System . out . println ( ( "TEST:<seq2seq4repair_space>verify<seq2seq4repair_space>prefix=" + ( prefixRef == null ? "null" : prefixRef . utf8ToString ( ) ) ) ) ; System . out . println ( "TEST:<seq2seq4repair_space>all<seq2seq4repair_space>TERMS:" ) ; TermsEnum allTE = MultiFields . getTerms ( r , "field" ) . iterator ( null ) ; int ord = 0 ; while ( ( allTE . next ( ) ) != null ) { System . out . println ( ( ( ( "<seq2seq4repair_space>ord=" + ( ord ++ ) ) + "<seq2seq4repair_space>term=" ) + ( allTE . term ( ) . utf8ToString ( ) ) ) ) ; } } final TermsEnum te = dto . getOrdTermsEnum ( r ) ; <START_BUG> if ( te == null ) { <END_BUG> if ( prefixRef == null ) { assertNull ( MultiFields . getTerms ( r , "field" ) ) ; } else { Terms terms = MultiFields . getTerms ( r , "field" ) ; if ( terms != null ) { TermsEnum termsEnum = terms . iterator ( null ) ; TermsEnum . SeekStatus result = termsEnum . seekCeil ( prefixRef , false ) ; if ( result != ( SeekStatus . END ) ) { assertFalse ( ( ( ( "term=" + ( termsEnum . term ( ) . utf8ToString ( ) ) ) + "<seq2seq4repair_space>matches<seq2seq4repair_space>prefix=" ) + ( prefixRef . utf8ToString ( ) ) ) , StringHelper . startsWith ( termsEnum . term ( ) , prefixRef ) ) ; } else { } } else { } } return ; } if ( VERBOSE ) { System . out . println ( "TEST:<seq2seq4repair_space>TERMS:" ) ; te . seekExact ( 0 ) ; while ( true ) { System . out . println ( ( ( ( "<seq2seq4repair_space>ord=" + ( te . ord ( ) ) ) + "<seq2seq4repair_space>term=" ) + ( te . term ( ) . utf8ToString ( ) ) ) ) ; if ( ( te . next ( ) ) == null ) { break ; } } } TermOrdsIterator iter = null ; final int [ ] buffer = new int [ 5 ] ; for ( int docID = 0 ; docID < ( r . maxDoc ( ) ) ; docID ++ ) { if ( VERBOSE ) { System . out . println ( ( ( ( ( ( ( "TEST:<seq2seq4repair_space>docID=" + docID ) + "<seq2seq4repair_space>of<seq2seq4repair_space>" ) + ( r . maxDoc ( ) ) ) + "<seq2seq4repair_space>(id=" ) + ( docIDToID [ docID ] ) ) + ")" ) ) ; } iter = dto . lookup ( docID , iter ) ; final int [ ] answers = idToOrds [ docIDToID [ docID ] ] ; int upto = 0 ; while ( true ) { final int chunk = iter . read ( buffer ) ; for ( int idx = 0 ; idx < chunk ; idx ++ ) { te . seekExact ( ( ( long ) ( buffer [ idx ] ) ) ) ; final BytesRef expected = termsArray [ answers [ ( upto ++ ) ] ] ; if ( VERBOSE ) { System . out . println ( ( ( ( "<seq2seq4repair_space>exp=" + ( expected . utf8ToString ( ) ) ) + "<seq2seq4repair_space>actual=" ) + ( te . term ( ) . utf8ToString ( ) ) ) ) ; } assertEquals ( ( ( ( ( ( "expected=" + ( expected . utf8ToString ( ) ) ) + "<seq2seq4repair_space>actual=" ) + ( te . term ( ) . utf8ToString ( ) ) ) + "<seq2seq4repair_space>ord=" ) + ( buffer [ idx ] ) ) , expected , te . term ( ) ) ; } if ( chunk < ( buffer . length ) ) { assertEquals ( answers . length , upto ) ; break ; } } } } }
public class ServletResourceManager implements ResourceManager { private final FileResourceManager deploymentResourceManager ; private final Collection < VirtualFile > overlays ; public ServletResourceManager ( final VirtualFile resourcesRoot , final Collection < VirtualFile > overlays ) throws IOException { } @ Override public Resource getResource ( final String path ) throws IOException { Resource res = deploymentResourceManager . getResource ( path ) ; if ( res != null ) { return res ; } String p = path ; if ( p . startsWith ( "/" ) ) { p = p . substring ( 1 ) ; } if ( ( overlays ) != null ) { for ( VirtualFile overlay : overlays ) { VirtualFile child = overlay . getChild ( p ) ; if ( child . exists ( ) ) { URL url = child . toURL ( ) ; <START_BUG> return new URLResource ( url , url . openConnection ( ) ) ; <END_BUG> } } } return null ; } }
final class RemoteServiceImpl implements InvocationHandler , IRemoteService { static final Object [ ] EMPTY_PARAMETERS = new Object [ 0 ] ; RemoteServiceReferenceImpl refImpl ; Object service ; private long nextID ; public RemoteServiceImpl ( final RemoteServiceReferenceImpl refImpl , final Object service ) { } public void callAsync ( final IRemoteCall call , final IRemoteCallListener listener ) { } public IFuture callAsync ( final IRemoteCall call ) { } public Object callSync ( final IRemoteCall call ) throws ECFException { } public void fireAsync ( final IRemoteCall call ) throws ECFException { } public Object getProxy ( ) throws ECFException { } synchronized long getNextID ( ) { } public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { } Method getMethod ( final Class aClass , String aMethodName , final Class [ ] someParameterTypes ) throws NoSuchMethodException { if ( ( someParameterTypes == null ) || ( ( someParameterTypes . length ) == 0 ) ) { return aClass . getMethod ( aMethodName , null ) ; } final Method [ ] methods = aClass . getMethods ( ) ; final int parameterCount = someParameterTypes . length ; aMethodName = aMethodName . intern ( ) ; OUTER : for ( int i = 0 ; i < ( methods . length ) ; i ++ ) { Method candidate = methods [ i ] ; String candidateMethodName = candidate . getName ( ) . intern ( ) ; Class [ ] candidateParameterTypes = candidate . getParameterTypes ( ) ; int candidateParameterCount = candidateParameterTypes . length ; if ( ( candidateParameterCount == parameterCount ) && ( aMethodName == candidateMethodName ) ) { for ( int j = 0 ; j < candidateParameterCount ; j ++ ) { Class clazzA = candidateParameterTypes [ j ] ; Class clazzB = someParameterTypes [ j ] ; if ( ! ( clazzA . isAssignableFrom ( clazzB ) ) ) { continue OUTER ; } } return candidate ; } } <START_BUG> throw new NoSuchMethodException ( ( ( ( ( "No<seq2seq4repair_space>such<seq2seq4repair_space>method:<seq2seq4repair_space>" + aMethodName ) + "(" ) + ( Arrays . toString ( someParameterTypes ) ) ) + ")" ) ) ; <END_BUG> } private class AsyncResult extends Thread { Object result ; Throwable exception ; IRemoteCall call ; private IRemoteCallListener listener ; AsyncResult ( final IRemoteCall call , final IRemoteCallListener listener ) { } public void run ( ) { } } }
public class TaskItem extends Item { TaskBar parent ; Shell shell ; NSImage defaultImage ; int progress ; int iProgress ; int progressState = SWT . DEFAULT ; Image overlayImage ; String overlayText = "" ; Menu menu ; static final int PROGRESS_MAX = 100 ; static final int PROGRESS_TIMER = 350 ; static final int PROGRESS_BARS = 7 ; TaskItem ( TaskBar parent , int style ) { } protected void checkSubclass ( ) { } void createWidget ( ) { } void destroyWidget ( ) { } public Menu getMenu ( ) { } public Image getOverlayImage ( ) { } public String getOverlayText ( ) { } public TaskBar getParent ( ) { } public int getProgress ( ) { } public int getProgressState ( ) { } void releaseHandle ( ) { } void releaseWidget ( ) { } public void setMenu ( Menu menu ) { } public void setOverlayImage ( Image image ) { } public void setOverlayText ( String string ) { } public void setProgress ( int progress ) { } public void setProgressState ( int progressState ) { } void setShell ( Shell shell ) { } void updateImage ( ) { boolean drawProgress = ( ( progress ) != 0 ) && ( ( progressState ) != ( SWT . DEFAULT ) ) ; boolean drawIntermidiate = ( progressState ) == ( SWT . INDETERMINATE ) ; NSApplication app = NSApplication . sharedApplication ( ) ; NSDockTile dock = app . dockTile ( ) ; boolean drawImage = ( ( overlayImage ) != null ) && ( ( dock . badgeLabel ( ) ) == null ) ; if ( ( ( ! drawImage ) && ( ! drawProgress ) ) && ( ! drawIntermidiate ) ) { <START_BUG> app . setApplicationIconImage ( null ) ; <END_BUG> return ; } NSSize size = defaultImage . size ( ) ; NSImage newImage = ( ( NSImage ) ( new NSImage ( ) . alloc ( ) ) ) ; newImage = newImage . initWithSize ( size ) ; NSBitmapImageRep rep = ( ( NSBitmapImageRep ) ( new NSBitmapImageRep ( ) . alloc ( ) ) ) ; rep = rep . initWithBitmapDataPlanes ( 0 , ( ( int ) ( size . width ) ) , ( ( int ) ( size . height ) ) , 8 , 4 , true , false , NSDeviceRGBColorSpace , ( ( OS . NSAlphaFirstBitmapFormat ) | ( OS . NSAlphaNonpremultipliedBitmapFormat ) ) , ( ( ( int ) ( size . width ) ) * 4 ) , 32 ) ; newImage . addRepresentation ( rep ) ; rep . release ( ) ; NSRect rect = new NSRect ( ) ; rect . height = size . height ; rect . width = size . width ; newImage . lockFocus ( ) ; defaultImage . drawInRect ( rect , rect , NSCompositeSourceOver , 1 ) ; if ( drawImage ) { NSImage badgetImage = overlayImage . handle ; NSSize badgeSize = badgetImage . size ( ) ; NSRect srcRect = new NSRect ( ) ; srcRect . height = badgeSize . height ; srcRect . width = badgeSize . width ; NSRect dstRect = new NSRect ( ) ; dstRect . x = ( size . width ) / 2 ; dstRect . height = ( size . height ) / 2 ; dstRect . width = ( size . width ) / 2 ; badgetImage . drawInRect ( dstRect , srcRect , NSCompositeSourceOver , 1 ) ; } if ( drawIntermidiate || drawProgress ) { switch ( progressState ) { case SWT . ERROR : NSColor . colorWithDeviceRed ( 1 , 0 , 0 , 0.6F ) . setFill ( ) ; break ; case SWT . PAUSED : NSColor . colorWithDeviceRed ( 1 , 1 , 0 , 0.6F ) . setFill ( ) ; break ; default : NSColor . colorWithDeviceRed ( 1 , 1 , 1 , 0.6F ) . setFill ( ) ; } rect . width = ( size . width ) / ( ( ( TaskItem . PROGRESS_BARS ) * 2 ) - 1 ) ; rect . height = ( size . height ) / 3 ; int count ; if ( drawIntermidiate ) { count = iProgress ; iProgress = ( ( iProgress ) + 1 ) % ( ( TaskItem . PROGRESS_BARS ) + 1 ) ; getDisplay ( ) . timerExec ( TaskItem . PROGRESS_TIMER , new Runnable ( ) { public void run ( ) { updateImage ( ) ; } } ) ; } else { count = ( ( progress ) * ( TaskItem . PROGRESS_BARS ) ) / ( TaskItem . PROGRESS_MAX ) ; } for ( int i = 0 ; i <= count ; i ++ ) { rect . x = ( i * 2 ) * ( rect . width ) ; NSBezierPath . fillRect ( rect ) ; } } newImage . unlockFocus ( ) ; app . setApplicationIconImage ( newImage ) ; newImage . release ( ) ; } void updateOverlayText ( String string ) { } }
public class WeaveMessage extends Message { public static WeaveMessage . WeaveMessageKind WEAVEMESSAGE_DECLAREPARENTSIMPLEMENTS = new WeaveMessage . WeaveMessageKind ( 1 , "Extending<seq2seq4repair_space>interface<seq2seq4repair_space>set<seq2seq4repair_space>for<seq2seq4repair_space>type<seq2seq4repair_space>'%1'<seq2seq4repair_space>(%2)<seq2seq4repair_space>to<seq2seq4repair_space>include<seq2seq4repair_space>'%3'<seq2seq4repair_space>(%4)" ) ; public static WeaveMessage . WeaveMessageKind WEAVEMESSAGE_ITD = new WeaveMessage . WeaveMessageKind ( 2 , "Type<seq2seq4repair_space>'%1'<seq2seq4repair_space>(%2)<seq2seq4repair_space>has<seq2seq4repair_space>intertyped<seq2seq4repair_space>%3<seq2seq4repair_space>from<seq2seq4repair_space>'%4'<seq2seq4repair_space>(%5)" ) ; public static WeaveMessage . WeaveMessageKind WEAVEMESSAGE_ADVISES = new WeaveMessage . WeaveMessageKind ( 3 , "Type<seq2seq4repair_space>'%1'<seq2seq4repair_space>(%2)<seq2seq4repair_space>advised<seq2seq4repair_space>by<seq2seq4repair_space>%3<seq2seq4repair_space>advice<seq2seq4repair_space>from<seq2seq4repair_space>'%4'<seq2seq4repair_space>(%5)%6" ) ; public static WeaveMessage . WeaveMessageKind WEAVEMESSAGE_DECLAREPARENTSEXTENDS = new WeaveMessage . WeaveMessageKind ( 4 , "Setting<seq2seq4repair_space>superclass<seq2seq4repair_space>of<seq2seq4repair_space>type<seq2seq4repair_space>'%1'<seq2seq4repair_space>(%2)<seq2seq4repair_space>to<seq2seq4repair_space>'%3'<seq2seq4repair_space>(%4)" ) ; public static WeaveMessage . WeaveMessageKind WEAVEMESSAGE_SOFTENS = new WeaveMessage . WeaveMessageKind ( 5 , "Softening<seq2seq4repair_space>exceptions<seq2seq4repair_space>in<seq2seq4repair_space>type<seq2seq4repair_space>'%1'<seq2seq4repair_space>(%2)<seq2seq4repair_space>as<seq2seq4repair_space>defined<seq2seq4repair_space>by<seq2seq4repair_space>aspect<seq2seq4repair_space>'%3'<seq2seq4repair_space>(%4)" ) ; private WeaveMessage ( String message ) { } public static WeaveMessage constructWeavingMessage ( WeaveMessage . WeaveMessageKind kind , String [ ] inserts ) { StringBuffer str = new StringBuffer ( kind . getMessage ( ) ) ; int pos = - 1 ; <START_BUG> while ( ( pos = str . indexOf ( "%" ) ) != ( - 1 ) ) { <END_BUG> int n = Character . getNumericValue ( str . charAt ( ( pos + 1 ) ) ) ; str . replace ( pos , ( pos + 2 ) , inserts [ ( n - 1 ) ] ) ; } return new WeaveMessage ( str . toString ( ) ) ; } public static class WeaveMessageKind { private int id ; private String message ; public WeaveMessageKind ( int id , String message ) { } public String getMessage ( ) { } } }
public class ApacheConfig { public static final String APACHE_CONFIG = "/conf/jserv/tomcat-apache.conf" ; public static final String MOD_JK_CONFIG = "/conf/jk/mod_jk.conf" ; public static final String WORKERS_CONFIG = "/conf/jk/workers.properties" ; public static final String JK_LOG_LOCATION = "/logs/mod_jk.log" ; public ApacheConfig ( ) { } String findApache ( ) { } Log loghelper = new Log ( "tc_log" , this ) ; public void execute ( ContextManager cm ) throws TomcatException { String tomcatHome = cm . getHome ( ) ; String apacheHome = findApache ( ) ; FileWriter configW = new FileWriter ( ( tomcatHome + ( ApacheConfig . APACHE_CONFIG ) ) ) ; PrintWriter pw = new PrintWriter ( configW ) ; PrintWriter mod_jk = new PrintWriter ( new FileWriter ( ( ( tomcatHome + ( ApacheConfig . MOD_JK_CONFIG ) ) + "-auto" ) ) ) ; mod_jk . println ( "###################################################################" ) ; mod_jk . println ( ( "#<seq2seq4repair_space>Auto<seq2seq4repair_space>generated<seq2seq4repair_space>configuration.<seq2seq4repair_space>Dated:<seq2seq4repair_space>" + ( new Date ( ) ) ) ) ; mod_jk . println ( "###################################################################" ) ; mod_jk . println ( ) ; mod_jk . println ( "#" ) ; mod_jk . println ( "#<seq2seq4repair_space>The<seq2seq4repair_space>following<seq2seq4repair_space>line<seq2seq4repair_space>instructs<seq2seq4repair_space>Apache<seq2seq4repair_space>to<seq2seq4repair_space>load<seq2seq4repair_space>the<seq2seq4repair_space>jk<seq2seq4repair_space>module" ) ; mod_jk . println ( "#" ) ; if ( ( System . getProperty ( "os.name" ) . toLowerCase ( ) . indexOf ( "windows" ) ) >= 0 ) { pw . println ( "LoadModule<seq2seq4repair_space>jserv_module<seq2seq4repair_space>modules/ApacheModuleJServ.dll" ) ; mod_jk . println ( "LoadModule<seq2seq4repair_space>jk_module<seq2seq4repair_space>modules/mod_jk.dll" ) ; mod_jk . println ( ) ; mod_jk . println ( ( ( "JkWorkersFile<seq2seq4repair_space>\"" + ( new File ( tomcatHome , ApacheConfig . WORKERS_CONFIG ) . toString ( ) . replace ( '\\' , '/' ) ) ) + "\"" ) ) ; mod_jk . println ( ( ( "JkLogFile<seq2seq4repair_space>\"" + ( new File ( tomcatHome , ApacheConfig . JK_LOG_LOCATION ) . toString ( ) . replace ( '\\' , '/' ) ) ) + "\"" ) ) ; } else { pw . println ( "LoadModule<seq2seq4repair_space>jserv_module<seq2seq4repair_space>libexec/mod_jserv.so" ) ; mod_jk . println ( "LoadModule<seq2seq4repair_space>jk_module<seq2seq4repair_space>libexec/mod_jk.so" ) ; mod_jk . println ( ) ; mod_jk . println ( ( "JkWorkersFile<seq2seq4repair_space>" + ( new File ( tomcatHome , ApacheConfig . WORKERS_CONFIG ) ) ) ) ; mod_jk . println ( ( "JkLogFile<seq2seq4repair_space>" + ( new File ( tomcatHome , ApacheConfig . JK_LOG_LOCATION ) ) ) ) ; } pw . println ( "ApJServManual<seq2seq4repair_space>on" ) ; pw . println ( "ApJServDefaultProtocol<seq2seq4repair_space>ajpv12" ) ; pw . println ( "ApJServSecretKey<seq2seq4repair_space>DISABLED" ) ; pw . println ( "ApJServMountCopy<seq2seq4repair_space>on" ) ; pw . println ( "ApJServLogLevel<seq2seq4repair_space>notice" ) ; pw . println ( ) ; int portInt = 8007 ; <START_BUG> BaseInterceptor [ ] ci = cm . getInterceptors ( ) ; <END_BUG> for ( int i = 0 ; i < ( ci . length ) ; i ++ ) { Object con = ci [ i ] ; if ( con instanceof Ajp12ConnectionHandler ) { PoolTcpConnector tcpCon = ( ( PoolTcpConnector ) ( con ) ) ; portInt = tcpCon . getPort ( ) ; } if ( con instanceof Ajp12Interceptor ) { Ajp12Interceptor tcpCon = ( ( Ajp12Interceptor ) ( con ) ) ; portInt = tcpCon . getPort ( ) ; } } pw . println ( ( "ApJServDefaultPort<seq2seq4repair_space>" + portInt ) ) ; pw . println ( ) ; pw . println ( "AddType<seq2seq4repair_space>text/jsp<seq2seq4repair_space>.jsp" ) ; pw . println ( "AddHandler<seq2seq4repair_space>jserv-servlet<seq2seq4repair_space>.jsp" ) ; pw . println ( ) ; mod_jk . println ( ) ; mod_jk . println ( "#" ) ; mod_jk . println ( "#<seq2seq4repair_space>Log<seq2seq4repair_space>level<seq2seq4repair_space>to<seq2seq4repair_space>be<seq2seq4repair_space>used<seq2seq4repair_space>by<seq2seq4repair_space>mod_jk" ) ; mod_jk . println ( "#" ) ; mod_jk . println ( "JkLogLevel<seq2seq4repair_space>error" ) ; mod_jk . println ( ) ; mod_jk . println ( "###################################################################" ) ; mod_jk . println ( "#<seq2seq4repair_space>SSL<seq2seq4repair_space>configuration<seq2seq4repair_space>#" ) ; mod_jk . println ( "#<seq2seq4repair_space>" ) ; mod_jk . println ( "#<seq2seq4repair_space>By<seq2seq4repair_space>default<seq2seq4repair_space>mod_jk<seq2seq4repair_space>is<seq2seq4repair_space>configured<seq2seq4repair_space>to<seq2seq4repair_space>collect<seq2seq4repair_space>SSL<seq2seq4repair_space>information<seq2seq4repair_space>from" ) ; mod_jk . println ( "#<seq2seq4repair_space>the<seq2seq4repair_space>apache<seq2seq4repair_space>environment<seq2seq4repair_space>and<seq2seq4repair_space>send<seq2seq4repair_space>it<seq2seq4repair_space>to<seq2seq4repair_space>the<seq2seq4repair_space>Tomcat<seq2seq4repair_space>workers.<seq2seq4repair_space>The" ) ; mod_jk . println ( "#<seq2seq4repair_space>problem<seq2seq4repair_space>is<seq2seq4repair_space>that<seq2seq4repair_space>there<seq2seq4repair_space>are<seq2seq4repair_space>many<seq2seq4repair_space>SSL<seq2seq4repair_space>solutions<seq2seq4repair_space>for<seq2seq4repair_space>Apache<seq2seq4repair_space>and<seq2seq4repair_space>as" ) ; mod_jk . println ( "#<seq2seq4repair_space>a<seq2seq4repair_space>result<seq2seq4repair_space>the<seq2seq4repair_space>environment<seq2seq4repair_space>variable<seq2seq4repair_space>names<seq2seq4repair_space>may<seq2seq4repair_space>change." ) ; mod_jk . println ( "#" ) ; mod_jk . println ( "#<seq2seq4repair_space>The<seq2seq4repair_space>following<seq2seq4repair_space>(commented<seq2seq4repair_space>out)<seq2seq4repair_space>JK<seq2seq4repair_space>related<seq2seq4repair_space>SSL<seq2seq4repair_space>configureation" ) ; mod_jk . println ( "#<seq2seq4repair_space>can<seq2seq4repair_space>be<seq2seq4repair_space>used<seq2seq4repair_space>to<seq2seq4repair_space>customize<seq2seq4repair_space>mod_jk's<seq2seq4repair_space>SSL<seq2seq4repair_space>behaviour." ) ; mod_jk . println ( "#<seq2seq4repair_space>" ) ; mod_jk . println ( "#<seq2seq4repair_space>Should<seq2seq4repair_space>mod_jk<seq2seq4repair_space>send<seq2seq4repair_space>SSL<seq2seq4repair_space>information<seq2seq4repair_space>to<seq2seq4repair_space>Tomact<seq2seq4repair_space>(default<seq2seq4repair_space>is<seq2seq4repair_space>On)" ) ; mod_jk . println ( "#<seq2seq4repair_space>JkExtractSSL<seq2seq4repair_space>Off" ) ; mod_jk . println ( "#<seq2seq4repair_space>" ) ; mod_jk . println ( "#<seq2seq4repair_space>What<seq2seq4repair_space>is<seq2seq4repair_space>the<seq2seq4repair_space>indicator<seq2seq4repair_space>for<seq2seq4repair_space>SSL<seq2seq4repair_space>(default<seq2seq4repair_space>is<seq2seq4repair_space>HTTPS)" ) ; mod_jk . println ( "#<seq2seq4repair_space>JkHTTPSIndicator<seq2seq4repair_space>HTTPS" ) ; mod_jk . println ( "#<seq2seq4repair_space>" ) ; mod_jk . println ( "#<seq2seq4repair_space>What<seq2seq4repair_space>is<seq2seq4repair_space>the<seq2seq4repair_space>indicator<seq2seq4repair_space>for<seq2seq4repair_space>SSL<seq2seq4repair_space>session<seq2seq4repair_space>(default<seq2seq4repair_space>is<seq2seq4repair_space>SSL_SESSION_ID)" ) ; mod_jk . println ( "#<seq2seq4repair_space>JkSESSIONIndicator<seq2seq4repair_space>SSL_SESSION_ID" ) ; mod_jk . println ( "#<seq2seq4repair_space>" ) ; mod_jk . println ( "#<seq2seq4repair_space>What<seq2seq4repair_space>is<seq2seq4repair_space>the<seq2seq4repair_space>indicator<seq2seq4repair_space>for<seq2seq4repair_space>client<seq2seq4repair_space>SSL<seq2seq4repair_space>cipher<seq2seq4repair_space>suit<seq2seq4repair_space>(default<seq2seq4repair_space>is<seq2seq4repair_space>SSL_CIPHER)" ) ; mod_jk . println ( "#<seq2seq4repair_space>JkCIPHERIndicator<seq2seq4repair_space>SSL_CIPHER" ) ; mod_jk . println ( "#<seq2seq4repair_space>" ) ; mod_jk . println ( "#<seq2seq4repair_space>What<seq2seq4repair_space>is<seq2seq4repair_space>the<seq2seq4repair_space>indicator<seq2seq4repair_space>for<seq2seq4repair_space>the<seq2seq4repair_space>client<seq2seq4repair_space>SSL<seq2seq4repair_space>certificated<seq2seq4repair_space>(default<seq2seq4repair_space>is<seq2seq4repair_space>SSL_CLIENT_CERT)" ) ; mod_jk . println ( "#<seq2seq4repair_space>JkCERTSIndicator<seq2seq4repair_space>SSL_CLIENT_CERT" ) ; mod_jk . println ( "#<seq2seq4repair_space>" ) ; mod_jk . println ( "#<seq2seq4repair_space>#" ) ; mod_jk . println ( "###################################################################" ) ; mod_jk . println ( ) ; mod_jk . println ( "#" ) ; mod_jk . println ( "#<seq2seq4repair_space>Root<seq2seq4repair_space>context<seq2seq4repair_space>mounts<seq2seq4repair_space>for<seq2seq4repair_space>Tomcat" ) ; mod_jk . println ( "#" ) ; mod_jk . println ( "JkMount<seq2seq4repair_space>/*.jsp<seq2seq4repair_space>ajp12" ) ; mod_jk . println ( "JkMount<seq2seq4repair_space>/servlet/*<seq2seq4repair_space>ajp12" ) ; mod_jk . println ( ) ; Enumeration = cm . getContexts ( ) ; } }
public class SequenceFilesFromLuceneStorageMRJobTest extends AbstractLuceneStorageTest { private SequenceFilesFromLuceneStorageMRJob lucene2seq ; private LuceneStorageConfiguration lucene2SeqConf ; @ Before public void before ( ) throws IOException { lucene2seq = new SequenceFilesFromLuceneStorageMRJob ( ) ; <START_BUG> Configuration configuration = new Configuration ( ) ; <END_BUG> Path seqOutputPath = new Path ( getTestTempDirPath ( ) , "seqOutputPath" ) ; lucene2SeqConf = new LuceneStorageConfiguration ( configuration , Arrays . asList ( getIndexPath1 ( ) , getIndexPath2 ( ) ) , seqOutputPath , SingleFieldDocument . ID_FIELD , Arrays . asList ( FIELD ) ) ; } @ After public void after ( ) throws IOException { } @ Test public void testRun ( ) throws IOException { } }
public class MultiplexAppenderTest extends TestCase { private Logger root ; private Logger logger = Logger . getLogger ( MultiplexAppenderTest . class ) ; public void setUp ( ) { } public void testIllegalStates ( ) { MultiplexAppender appender = null ; appender = new MultiplexAppender ( ) ; try { <START_BUG> appender . activate ( ) ; <END_BUG> fail ( "Should<seq2seq4repair_space>have<seq2seq4repair_space>thrown<seq2seq4repair_space>an<seq2seq4repair_space>IllegalStateException<seq2seq4repair_space>because<seq2seq4repair_space>it<seq2seq4repair_space>should<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>configured<seq2seq4repair_space>correctly" ) ; } catch ( Exception e ) { } appender = null ; } protected void tearDown ( ) throws Exception { } public void testMDCSelector ( ) throws Exception { } public void testcreateMDCAndDailyRollingAppenderFactory ( ) { } }
@ RestController @ RequestMapping ( "/api" ) public class RegistryResource { private final Logger log = LoggerFactory . getLogger ( RegistryResource . class ) ; @ Inject private RegistryRepository registryRepository ; @ Inject private RegistryService registryService ; @ Inject private Validator validator ; @ InitBinder public void initBinder ( WebDataBinder binder ) { } @ RequestMapping ( value = "/registries" , method = RequestMethod . GET , produces = MediaType . APPLICATION_JSON_VALUE ) @ Timed ResponseEntity < List < RegistryOutDTO > > getRegistries ( ) { } @ RequestMapping ( value = "/registries/{id}" , method = RequestMethod . GET , produces = MediaType . APPLICATION_JSON_VALUE ) @ Timed ResponseEntity < RegistryOutDTO > getRegistry ( @ PathVariable String id ) { } @ RequestMapping ( value = "/registries/{id}/status" , method = RequestMethod . GET , produces = MediaType . APPLICATION_JSON_VALUE ) @ Timed ResponseEntity < RegistryStatusDTO > getRegistryStatus ( @ PathVariable String id ) { } @ RequestMapping ( value = "/registries" , method = RequestMethod . POST , produces = MediaType . APPLICATION_JSON_VALUE ) @ Timed public ResponseEntity < RegistryOutDTO > createRegistry ( @ RequestBody @ Valid RegistryInDTO registryInDTO ) { } @ RequestMapping ( value = "/registries/{id}" , method = RequestMethod . PUT , produces = MediaType . APPLICATION_JSON_VALUE ) @ Timed public ResponseEntity < RegistryOutDTO > updateRegistry ( @ RequestBody @ Valid RegistryInDTO registryInDTO , @ PathVariable String id ) { log . debug ( "REST<seq2seq4repair_space>request<seq2seq4repair_space>to<seq2seq4repair_space>save<seq2seq4repair_space>Registry<seq2seq4repair_space>:<seq2seq4repair_space>{}" , registryInDTO ) ; <START_BUG> RegistryOutDTO registryOutDTO = registryService . save ( registryInDTO ) ; <END_BUG> return new ResponseEntity < RegistryOutDTO > ( registryOutDTO , HttpStatus . OK ) ; } @ RequestMapping ( value = "/registries/{id}" , method = RequestMethod . DELETE , produces = MediaType . APPLICATION_JSON_VALUE ) @ ResponseStatus ( HttpStatus . NO_CONTENT ) @ Timed public void deleteRegistry ( @ PathVariable String id ) { } No newline ; at end ; of file ; }
@ Component ( "bugzilla-source" ) public class BugZillaDataSource implements IIssuePlugin { private static final Logger LOGGER = LoggerFactory . getLogger ( BugZillaDataSource . class ) ; @ Autowired private IBZConfigurationDAO bugZillaConfiguration ; @ Autowired private IBugZillaToIssueConvertor bugZillaToIssueConvertor ; @ Autowired private IProjectService projectService ; @ Autowired private IBZServerProxyFactory proxyFactory ; @ Override @ CacheEvict ( allEntries = true , value = "bugZillaCache" ) public void cleanCache ( ) { } @ Cacheable ( "bugZillaCache" ) @ Override public synchronized List < IIssue > getData ( ) { } @ Override public boolean isEmpty ( ) { } public void obtainIssuesForEachBugZillaServer ( final List < IIssue > issues , final BZServerConfiguration conf , IBZServerProxy bugzillaProxy ) { } public void obtainIssuesForProjectsOfAServer ( final BZServerConfiguration conf , final IBZServerProxy bugzillaProxy , final List < IIssue > issues , final List < String > productNames ) { } public Project obtainProjectFromConfigurationAndProductName ( final BZServerConfiguration conf , final String projectKomeaName ) { <START_BUG> Project project = projectService . selectByKey ( projectKomeaName ) ; <END_BUG> if ( ( project == null ) && ( conf . isAutocreateProjects ( ) ) ) { project = projectService . getOrCreate ( projectKomeaName ) ; } return project ; } @ Override public List < IIssue > searchData ( final IFilter < IIssue > _dataFilter ) { } public void setBugZillaConfiguration ( final IBZConfigurationDAO _bugZillaConfiguration ) { } }
public class TimerServiceDeploymentProcessor implements DeploymentUnitProcessor { public static final ServiceName TIMER_SERVICE_NAME = JBOSS . append ( "ejb3" , "timer" ) ; private final ServiceName timerServiceThreadPool ; private final String defaultTimerDataStore ; public TimerServiceDeploymentProcessor ( final ServiceName timerServiceThreadPool , final String defaultTimerDataStore ) { } @ Override public void deploy ( final DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final EEModuleDescription moduleDescription = deploymentUnit . getAttachment ( EE_MODULE_DESCRIPTION ) ; final Module module = deploymentUnit . getAttachment ( MODULE ) ; final EjbJarMetaData ejbJarMetaData = deploymentUnit . getAttachment ( EJB_JAR_METADATA ) ; ServiceName defaultTimerPersistenceService = SERVICE_NAME . append ( defaultTimerDataStore ) ; final Map < String , ServiceName > timerPersistenceServices = new HashMap < String , ServiceName > ( ) ; final TimerServiceRegistry timerServiceRegistry = ( EjbDeploymentMarker . isEjbDeployment ( deploymentUnit ) ) ? new TimerServiceRegistry ( ) : null ; if ( ( ejbJarMetaData != null ) && ( ( ejbJarMetaData . getAssemblyDescriptor ( ) ) != null ) ) { List < TimerServiceMetaData > timerService = ejbJarMetaData . getAssemblyDescriptor ( ) . getAny ( TimerServiceMetaData . class ) ; if ( timerService != null ) { for ( TimerServiceMetaData data : timerService ) { if ( data . getEjbName ( ) . equals ( "*" ) ) { defaultTimerPersistenceService = SERVICE_NAME . append ( data . getDataStoreName ( ) ) ; } else { timerPersistenceServices . put ( data . getEjbName ( ) , SERVICE_NAME . append ( data . getDataStoreName ( ) ) ) ; } } } } final ServiceName finalDefaultTimerPersistenceService = defaultTimerPersistenceService ; for ( final ComponentDescription componentDescription : moduleDescription . getComponentDescriptions ( ) ) { if ( componentDescription . isTimerServiceApplicable ( ) ) { if ( componentDescription . isTimerServiceRequired ( ) ) { final String deploymentName ; if ( ( ( moduleDescription . getDistinctName ( ) ) == null ) || ( ( moduleDescription . getDistinctName ( ) . length ( ) ) == 0 ) ) { deploymentName = ( ( moduleDescription . getApplicationName ( ) ) + "." ) + ( moduleDescription . getModuleName ( ) ) ; } else { deploymentName = ( ( ( ( moduleDescription . getApplicationName ( ) ) + "." ) + ( moduleDescription . getModuleName ( ) ) ) + "." ) + ( moduleDescription . getDistinctName ( ) ) ; } <START_BUG> ROOT_LOGGER . debugf ( "Installing<seq2seq4repair_space>timer<seq2seq4repair_space>service<seq2seq4repair_space>for<seq2seq4repair_space>component<seq2seq4repair_space>%s" , componentDescription . getComponentName ( ) ) ; <END_BUG> componentDescription . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { @ Override public void configure ( final DeploymentPhaseContext context , final ComponentDescription description , final ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { final EJBComponentDescription ejbComponentDescription = ( ( EJBComponentDescription ) ( description ) ) ; final ServiceName invokerServiceName = ejbComponentDescription . getServiceName ( ) . append ( TimedObjectInvokerImpl . SERVICE_NAME ) ; final TimedObjectInvokerImpl invoker = new TimedObjectInvokerImpl ( deploymentName , module ) ; context . getServiceTarget ( ) . addService ( invokerServiceName , invoker ) . addDependency ( componentDescription . getCreateServiceName ( ) , EJBComponent . class , invoker . getEjbComponent ( ) ) . install ( ) ; final ServiceName serviceName = componentDescription . getServiceName ( ) . append ( TimerServiceImpl . SERVICE_NAME ) ; final TimerServiceImpl service = new TimerServiceImpl ( ejbComponentDescription . getScheduleMethods ( ) , serviceName , timerServiceRegistry ) ; final ServiceBuilder < TimerService > createBuilder = context . getServiceTarget ( ) . addService ( serviceName , service ) ; createBuilder . addDependency ( TimerServiceDeploymentProcessor . TIMER_SERVICE_NAME , Timer . class , service . getTimerInjectedValue ( ) ) ; createBuilder . addDependency ( componentDescription . getCreateServiceName ( ) , EJBComponent . class , service . getEjbComponentInjectedValue ( ) ) ; createBuilder . addDependency ( timerServiceThreadPool , ExecutorService . class , service . getExecutorServiceInjectedValue ( ) ) ; if ( timerPersistenceServices . containsKey ( ejbComponentDescription . getEJBName ( ) ) ) { createBuilder . addDependency ( timerPersistenceServices . get ( ejbComponentDescription . getEJBName ( ) ) , TimerPersistence . class , service . getTimerPersistence ( ) ) ; } else { createBuilder . addDependency ( finalDefaultTimerPersistenceService , TimerPersistence . class , service . getTimerPersistence ( ) ) ; } createBuilder . addDependency ( invokerServiceName , TimedObjectInvoker . class , service . getTimedObjectInvoker ( ) ) ; createBuilder . install ( ) ; ejbComponentDescription . setTimerService ( service ) ; configuration . getStartDependencies ( ) . add ( new org . jboss . as . ee . component . DependencyConfigurator < ComponentStartService > ( ) { @ Override public void configureDependency ( final ServiceBuilder < ? > serviceBuilder , final ComponentStartService service ) throws DeploymentUnitProcessingException { serviceBuilder . addDependency ( serviceName ) ; } } ) ; } } ) ; } else { componentDescription . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { @ Override public void configure ( final DeploymentPhaseContext context , final ComponentDescription description , final ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { final EJBComponentDescription ejbComponentDescription = ( ( EJBComponentDescription ) ( description ) ) ; final ServiceName nonFunctionalTimerServiceName = NonFunctionalTimerService . serviceNameFor ( ejbComponentDescription ) ; final NonFunctionalTimerService nonFunctionalTimerService ; if ( ejbComponentDescription instanceof StatefulComponentDescription ) { nonFunctionalTimerService = new NonFunctionalTimerService ( EjbLogger . ROOT_LOGGER . timerServiceMethodNotAllowedForSFSB ( ejbComponentDescription . getComponentName ( ) ) , timerServiceRegistry ) ; } else { nonFunctionalTimerService = new NonFunctionalTimerService ( EjbLogger . ROOT_LOGGER . ejbHasNoTimerMethods ( ) , timerServiceRegistry ) ; } context . getServiceTarget ( ) . addService ( nonFunctionalTimerServiceName , nonFunctionalTimerService ) . install ( ) ; ejbComponentDescription . setTimerService ( nonFunctionalTimerService ) ; configuration . getStartDependencies ( ) . add ( new org . jboss . as . ee . component . DependencyConfigurator < ComponentStartService > ( ) { @ Override public void configureDependency ( ServiceBuilder < ? > serviceBuilder , ComponentStartService service ) throws DeploymentUnitProcessingException { serviceBuilder . addDependency ( nonFunctionalTimerServiceName ) ; } } ) ; } } ) ; } } } } @ Override public void undeploy ( final DeploymentUnit context ) { } }
public class KittenCaptchaPanel extends Panel { private static final long serialVersionUID = 2711167040323855070L ; private static BufferedImage grass = KittenCaptchaPanel . load ( "images/grass.png" ) ; private static final List < KittenCaptchaPanel . Animal > kittens = new ArrayList < KittenCaptchaPanel . Animal > ( ) ; private static final List < KittenCaptchaPanel . Animal > nonKittens = new ArrayList < KittenCaptchaPanel . Animal > ( ) ; private static Random random = new Random ( ( - 1 ) ) ; private static BufferedImage load ( final String filename ) { } private final KittenCaptchaPanel . PlacedAnimalList animals ; private final Label animalSelectionLabel ; private final Image image ; private final KittenCaptchaPanel . CaptchaImageResource imageResource ; private final Dimension imageSize ; public KittenCaptchaPanel ( final String id , final Dimension imageSize ) { } public boolean allKittensSelected ( ) { } public void reset ( ) { } private KittenCaptchaPanel . PlacedAnimal placeAnimal ( final List < KittenCaptchaPanel . PlacedAnimal > animals , final KittenCaptchaPanel . Animal newAnimal ) { } private int random ( final int max ) { } private KittenCaptchaPanel . Animal randomKitten ( ) { } private KittenCaptchaPanel . Animal randomNonKitten ( ) { } private static class Animal { private final BufferedImage highlightedImage ; private final BufferedImage image ; private final boolean isKitten ; private final OpaqueRegion visibleRegion ; private Animal ( final String filename , final boolean isKitten ) { } private BufferedImage load ( final String filename ) { } } private class CaptchaImageResource extends DynamicImageResource { private static final long serialVersionUID = - 1560784998742404278L ; private final KittenCaptchaPanel . PlacedAnimalList animals ; private transient SoftReference < byte [ ] > data = null ; @ Override protected void configureResponse ( ResourceResponse response , Attributes attributes ) { super . configureResponse ( response , attributes ) ; <START_BUG> response . setCacheDuration ( 0 ) ; <END_BUG> } private CaptchaImageResource ( final KittenCaptchaPanel . PlacedAnimalList animals ) { } @ Override protected byte [ ] getImageData ( Attributes attributes ) { } protected void invalidate ( ) { } private boolean allKittensSelected ( ) { } private void clearData ( ) { } private void reset ( ) { } private String selectString ( ) { } } private class PlacedAnimal implements Serializable { private static final long serialVersionUID = - 6703909440564862486L ; private transient KittenCaptchaPanel . Animal animal ; private final int index ; private boolean isHighlighted ; private final boolean isKitten ; private final Point location ; private final float [ ] scales = new float [ ] { 1.0F , 1.0F , 1.0F , 1.0F } ; public PlacedAnimal ( final KittenCaptchaPanel . Animal animal , final Point location ) { } @ Override public String toString ( ) { } private boolean contains ( final Point point ) { } private void draw ( final Graphics2D graphics ) { } private KittenCaptchaPanel . Animal getAnimal ( ) { } private float random ( float min , float max ) { } } private class PlacedAnimalList implements Serializable { private static final long serialVersionUID = 6335852594326213439L ; private final List < KittenCaptchaPanel . PlacedAnimal > animals = new ArrayList < KittenCaptchaPanel . PlacedAnimal > ( ) ; private PlacedAnimalList ( ) { } private boolean allKittensSelected ( ) { } private KittenCaptchaPanel . PlacedAnimal atLocation ( final Point location ) { } private BufferedImage createImage ( ) { } private void reset ( ) { } private String selectString ( ) { } private OpaqueRegion visibleRegion ( final KittenCaptchaPanel . PlacedAnimal animal ) { } } }
public class ApiClient { public static interface ApiCallback < T , K > { public void onSuccess ( T result ) { } public void onFailure ( K request , boolean isNetworkError ) { } } public static interface EmptyApiCallback < T > { public void onSuccess ( ) { } public void onFailure ( T request , boolean isNetworkError ) { } } public interface OnAuthCompleteListener { public void onAuthComplete ( ) { } } private static DefaultHttpClient client = ApiClient . getHttpsClient ( ) ; private static RestAdapter adaptor = new RestAdapter . Builder ( ) . setEndpoint ( DEFAULT_URL ) . setLogLevel ( API_LOG_LEVEL ) . setClient ( new retrofit . client . ApacheClient ( ApiClient . client ) ) . setRequestInterceptor ( ApiClient . createCookiesInterceptor ( ) ) . build ( ) ; private static Cookie cookie ; private static boolean authInProgress ; public static void getDevicesState ( final long lastUpdateTime , final ApiClient . ApiCallback < DevicesStatus , Long > callback ) { } public static void updateDevicesState ( final Device updatedDevice , final ApiClient . EmptyApiCallback < Device > callback ) { } public static void updateDevicesMode ( final Device updatedDevice , final ApiClient . EmptyApiCallback < Device > callback ) { } public static void updateDevicesLevel ( final Device updatedDevice , final ApiClient . EmptyApiCallback < Device > callback ) { } public static void updateTogle ( final Device updatedDevice , final ApiClient . EmptyApiCallback < Device > callback ) { } public static void getLocations ( final ApiClient . ApiCallback < List < Location > , String > callback ) { } public static void auth ( final String login , final String password , final ApiClient . OnAuthCompleteListener listener ) { <START_BUG> ApiClient . authInProgress = true ; <END_BUG> ApiClient . adaptor . create ( me . z_wave . android . network . auth . AuthRequest . class ) . auth ( "login" , login , password , new retrofit . Callback < Object > ( ) { @ Override public void success ( Object obj , retrofit . client . Response response ) { if ( ( ( ApiClient . client . getCookieStore ( ) ) == null ) || ( ( ApiClient . client . getCookieStore ( ) . getCookies ( ) . size ( ) ) == 0 ) ) { ApiClient . auth ( login , password , listener ) ; } else { ApiClient . cookie = ApiClient . client . getCookieStore ( ) . getCookies ( ) . get ( 0 ) ; listener . onAuthComplete ( ) ; ApiClient . authInProgress = false ; } } @ Override public void failure ( RetrofitError error ) { if ( ( ( ApiClient . client . getCookieStore ( ) ) == null ) || ( ( ApiClient . client . getCookieStore ( ) . getCookies ( ) . size ( ) ) == 0 ) ) { ApiClient . auth ( login , password , listener ) ; } else { ApiClient . cookie = ApiClient . client . getCookieStore ( ) . getCookies ( ) . get ( 0 ) ; listener . onAuthComplete ( ) ; ApiClient . authInProgress = false ; } } } ) ; } public static void getNotifications ( final long lastUpdateTime , final ApiClient . ApiCallback < NotificationDataWrapper , Long > callback ) { } public static void getProfiles ( final ApiClient . ApiCallback < List < Profile > , String > callback ) { } private static boolean isNetworkUnreachableError ( RetrofitError retrofitError ) { } public static DefaultHttpClient getHttpsClient ( ) { } private static RequestInterceptor createCookiesInterceptor ( ) { } }
public class UMLLinkedList extends UMLList2 implements MouseListener { public UMLLinkedList ( UMLModelElementListModel2 dataModel , boolean showIcon ) { } public UMLLinkedList ( UMLModelElementListModel2 dataModel ) { } protected void doIt ( ListSelectionEvent e ) { } public void mouseClicked ( MouseEvent e ) { if ( ( e . getSource ( ) ) == ( this ) ) { if ( ( ( e . getClickCount ( ) ) >= 2 ) && ( SwingUtilities . isLeftMouseButton ( e ) ) ) { Object o = getSelectedValue ( ) ; if ( o instanceof MModelElement ) { <START_BUG> TheInstance . setTarget ( o ) ; <END_BUG> } } e . consume ( ) ; } } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } }
@ Stateless @ PermitAll public class CustomerEntityDAO { @ PersistenceContext private EntityManager entityManager ; public CustomerEntity get ( Integer id ) { <START_BUG> return entityManager . find ( CustomerEntity . class , 1 ) ; <END_BUG> } public List < CustomerEntity > getAll ( ) { } public List < CustomerEntity > findByName ( String name ) { } public void persist ( CustomerEntity customer ) { } public void delete ( CustomerEntity customer ) { } }
public class ViewStandings extends ActionBarActivity { private ImageView mImageView ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( help_view_standings2 ) ; <START_BUG> mImageView = ( ( ImageView ) ( findViewById ( imageView ) ) ) ; <END_BUG> mImageView . setImageResource ( view_standings ) ; } }
public class NewLoggingExtension implements NewExtension { public static final String SUBSYSTEM_NAME = "logging" ; private static final PathElement loggersPath = PathElement . pathElement ( LOGGER ) ; private static final PathElement handlersPath = PathElement . pathElement ( HANDLER ) ; public void initialize ( NewExtensionContext context ) { final SubsystemRegistration subsystem = context . registerSubsystem ( NewLoggingExtension . SUBSYSTEM_NAME ) ; final ModelNodeRegistration registration = subsystem . registerSubsystemModel ( SUBSYSTEM ) ; registration . registerOperationHandler ( ADD , NewLoggingExtension . ADD_INSTANCE , SUBSYSTEM_ADD , false ) ; registration . registerOperationHandler ( "set-root-logger" , INSTANCE , SET_ROOT_LOGGER , false ) ; registration . registerOperationHandler ( "remove-root-logger" , NewRootLoggerRemove . INSTANCE , SET_ROOT_LOGGER , false ) ; final ModelNodeRegistration loggers = registration . registerSubModel ( NewLoggingExtension . loggersPath , NewLoggingSubsystemProviders . LOGGER ) ; loggers . registerOperationHandler ( ADD , NewLoggerAdd . INSTANCE , LOGGER_ADD , false ) ; loggers . registerOperationHandler ( REMOVE , NewLoggerRemove . INSTANCE , LOGGER_REMOVE , false ) ; final ModelNodeRegistration handlers = registration . registerSubModel ( NewLoggingExtension . handlersPath , HANDLERS ) ; handlers . registerOperationHandler ( ADD , NewLoggerHandlerAdd . INSTANCE , HANDLER_ADD , false ) ; handlers . registerOperationHandler ( REMOVE , NewLoggerHandlerRemove . INSTANCE , HANDLER_REMOVE , false ) ; <START_BUG> handlers . registerOperationHandler ( "add-async-handler" , NewAsyncHandlerAdd . INSTANCE , ASYNC_HANDLER_ADD , false ) ; <END_BUG> handlers . registerOperationHandler ( "add-console-handler" , NewConsoleHandlerAdd . INSTANCE , CONSOLE_HANDLER_ADD , false ) ; handlers . registerOperationHandler ( "add-file-handler" , NewFileHandlerAdd . INSTANCE , FILE_HANDLER_ADD , false ) ; handlers . registerOperationHandler ( "add-periodic-handler" , NewPeriodicFileHandlerAdd . INSTANCE , PERIODIC_HANDLER_ADD , false ) ; handlers . registerOperationHandler ( "add-size-periodic-handler" , NewSizePeriodicFileHandlerAdd . INSTANCE , SIZE_PERIODIC_HANDLER_ADD , false ) ; } public void initializeParsers ( ExtensionParsingContext context ) { } private static final NewLoggingExtension . NewLoggingSubsystemAdd ADD_INSTANCE = new NewLoggingExtension . NewLoggingSubsystemAdd ( ) ; static class NewLoggingSubsystemAdd implements ModelAddOperationHandler { public Cancellable execute ( final NewOperationContext context , final ModelNode operation , final ResultHandler resultHandler ) { } } }
public class VideoPlayer { private static final String TAG = "VideoPlayer" ; public static void playVideo ( TDActivity activity , TwitchBroadcast broadcast ) { } private static String [ ] getPlaylistUrls ( TwitchBroadcast broadcast ) { } public static void playVideo ( TDActivity activity , String title , String url ) { } private static void playVideoIntern ( TDActivity activity , Bundle args ) { } private static void playVideoExtern ( Context context , Uri uri ) { } public static boolean useInternPlayer ( TDActivity activity ) { } public static class GetVideoCallback extends TDBasicCallback < TwitchBroadcast > implements DialogInterface . OnClickListener { private TDBase fragment ; private TDActivity activity ; private PlaylistAdapter adapter ; private String videoId ; public GetVideoCallback ( TDBase caller , TwitchVideo video ) { } @ Override public TwitchBroadcast startRequest ( ) { } @ Override public void onResponse ( TwitchBroadcast response ) { } @ Override public boolean isAdded ( ) { } @ Override public void onClick ( DialogInterface dialogInterface , int position ) { } } public static class StreamPlaylistCallback extends TDBasicCallback < TwitchStreamPlayList > { private TDBase fragment ; private TDActivity activity ; private String channel ; public StreamPlaylistCallback ( TDBase caller , String channel ) { } @ Override public TwitchStreamPlayList startRequest ( ) { } private TwitchAccessToken getAccessToken ( ) { } private HashMap < TwitchStreamQuality , String > parsePlaylist ( Playlist playlist ) { } @ Override public void onResponse ( TwitchStreamPlayList response ) { if ( ( response != null ) && ( ( response . getStreams ( ) ) != null ) ) { Log . d ( this , ( "Streams<seq2seq4repair_space>:" + ( response . getStreams ( ) . toString ( ) ) ) ) ; if ( ( ( response . getStreams ( ) ) != null ) && ( ( response . getStreams ( ) . size ( ) ) > 0 ) ) { <START_BUG> String quality = fragment . getDefaultSharedPreferences ( ) . getString ( SETTINGS_STREAM_QUALITY , QUALITY_MEDIUM . getName ( ) ) ; <END_BUG> TwitchStreamQuality streamQuality = TwitchStreamPlayList . parseQuality ( quality ) ; Log . d ( this , ( "streamQuality:<seq2seq4repair_space>" + ( streamQuality . getName ( ) ) ) ) ; String url = response . getStream ( streamQuality ) ; if ( url != null ) { VideoPlayer . playVideo ( activity , channel , url ) ; return ; } } } ErrorDialogFragment . ErrorDialogFragmentBuilder builder = new ErrorDialogFragment . ErrorDialogFragmentBuilder ( activity ) ; builder . setMessage ( error_stream_offline ) . setTitle ( dialog_error_title ) . show ( ) ; } @ Override public boolean isAdded ( ) { } } }
public class EditExerciseActivity extends BaseDialogActivity implements TextWatcher , OnClickListener , OnLongClickListener , OnMySpinnerListener { private static final String tag = "EditExerciseActivity" ; TextView m_exer_name_tv ; EditText m_exer_name_et ; EditText m_exer_other_name_et ; EditText m_exer_other_unit_et ; CheckBox m_exer_rep_cb ; CheckBox m_exer_level_cb ; CheckBox m_exer_weight_cb ; CheckBox m_exer_dist_cb ; CheckBox m_exer_time_cb ; CheckBox m_exer_other_cb ; CheckBox m_exer_calorie_cb ; RadioButton m_exer_rep_rb ; RadioButton m_exer_level_rb ; RadioButton m_exer_weight_rb ; RadioButton m_exer_dist_rb ; RadioButton m_exer_time_rb ; RadioButton m_exer_other_rb ; RadioButton m_exer_calorie_rb ; MySpinner m_exer_type_msp ; MySpinner m_exer_group_msp ; MySpinner m_exer_weight_msp ; MySpinner m_exer_dist_msp ; MySpinner m_exer_time_msp ; Button m_ok ; Button m_delete ; Button m_reset ; ExerciseData m_orig_ex_data ; boolean m_dirty = false ; boolean m_et_locked = false ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } @ Override protected void onPause ( ) { } @ Override protected void onRestoreInstanceState ( Bundle icicle ) { } @ Override protected void onSaveInstanceState ( Bundle outState ) { } private boolean fill_forms ( ) { } private void save_data ( ) { } private void fix_name ( SQLiteDatabase db , String new_name ) { } private void delete_entry ( ) { } int find_array_match ( int array_id , String str ) { } private void set_radio ( int which ) { } private int get_radio ( ) { } private boolean is_all_radio_buttons_off ( ) { } @ Override public void onBackPressed ( ) { } @ Override public void onClick ( View v ) { WGlobals . play_short_click ( ) ; if ( ( v . getClass ( ) ) == ( RadioButton . class ) ) { m_dirty = true ; m_ok . setEnabled ( true ) ; m_reset . setEnabled ( true ) ; if ( v == ( m_exer_rep_rb ) ) set_radio ( EXERCISE_COL_REP_NUM ) ; else if ( v == ( m_exer_level_rb ) ) set_radio ( EXERCISE_COL_LEVEL_NUM ) ; else if ( v == ( m_exer_calorie_rb ) ) set_radio ( EXERCISE_COL_CALORIE_NUM ) ; else if ( v == ( m_exer_weight_rb ) ) set_radio ( EXERCISE_COL_WEIGHT_NUM ) ; else if ( v == ( m_exer_dist_rb ) ) set_radio ( EXERCISE_COL_DIST_NUM ) ; else if ( v == ( m_exer_time_rb ) ) set_radio ( EXERCISE_COL_TIME_NUM ) ; else if ( v == ( m_exer_other_rb ) ) set_radio ( EXERCISE_COL_OTHER_NUM ) ; return ; } else if ( ( v . getClass ( ) ) == ( CheckBox . class ) ) { m_dirty = true ; m_ok . setEnabled ( true ) ; m_reset . setEnabled ( true ) ; if ( v == ( m_exer_rep_cb ) ) set_rep_check ( v ) ; else if ( v == ( m_exer_level_cb ) ) set_level_check ( v ) ; else if ( v == ( m_exer_calorie_cb ) ) set_calorie_check ( v ) ; else if ( v == ( m_exer_weight_cb ) ) set_weight_check ( v ) ; else if ( v == ( m_exer_dist_cb ) ) set_dist_check ( v ) ; else if ( v == ( m_exer_time_cb ) ) set_time_check ( v ) ; else if ( v == ( m_exer_other_cb ) ) set_other_check ( v ) ; return ; } if ( v == ( m_ok ) ) { if ( ( check_good_exercise ( true ) ) == false ) { return ; } my_toast ( this , editexer_saved_msg , new String [ ] { m_exer_name_et . getText ( ) . toString ( ) } ) ; save_data ( ) ; AddSetActivity . m_db_dirty = true ; AddSetActivity . m_reset_widgets = true ; <START_BUG> InspectorActivity2 . m_db_dirty = true ; <END_BUG> GraphActivity . m_db_dirty = true ; ExerciseTabHostActivity . m_dirty = true ; m_dirty = false ; m_ok . setEnabled ( false ) ; m_reset . setEnabled ( false ) ; } else if ( v == ( m_reset ) ) { reset ( ) ; } else if ( v == ( m_delete ) ) { show_yes_no_dialog ( editexer_delete_confirm_title , new String [ ] { m_orig_ex_data . name } , editexer_delete_confirm_msg , new String [ ] { m_orig_ex_data . name } , new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { WGlobals . play_short_click ( ) ; delete_entry ( ) ; tabbed_set_result ( RESULT_OK ) ; dismiss_all_dialogs ( ) ; finish ( ) ; } } ) ; } } @ Override public boolean onLongClick ( View v ) { } @ Override public void onMySpinnerSelected ( MySpinner spinner , int position , boolean new_item ) { } @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { } @ Override public void afterTextChanged ( Editable s ) { } @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { } private void set_text_lock ( EditText et , String str ) { } private void set_rep_check ( View v ) { } private void set_level_check ( View v ) { } private void set_calorie_check ( View v ) { } private void set_weight_check ( View v ) { } private void set_dist_check ( View v ) { } private void set_time_check ( View v ) { } private void set_other_check ( View v ) { } private int turn_on_best_significant ( ) { } private boolean check_good_exercise ( boolean warn ) { } private boolean is_duplicate_name ( String name ) { } void reset ( ) { } }
public class Home extends Fragment implements View . OnClickListener { public String TAG = "Home" ; private DatabaseHelper db ; @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { } @ Override public void onClick ( View v ) { FragmentManager fragmentManager = getActivity ( ) . getFragmentManager ( ) ; switch ( v . getId ( ) ) { case id . button_grocery_bag : fragmentManager . beginTransaction ( ) . replace ( container , new ShoppingListsFragment ( ) ) . commit ( ) ; break ; case id . button_transport_icon : <START_BUG> fragmentManager . beginTransaction ( ) . replace ( container , new TravelFragment ( ) ) . commit ( ) ; <END_BUG> break ; } } No newline ; at end ; of file ; }
public class LocalDAO extends SQLiteOpenHelper implements DAO { private SQLiteDatabase db ; private Context context ; private static final String DATABASE_NAME = "borkost" ; private static final int DATABASE_VERSION = 1 ; private static final String DATABASE_CREATE_WINES = "CREATE<seq2seq4repair_space>TABLE<seq2seq4repair_space>IF<seq2seq4repair_space>NOT<seq2seq4repair_space>EXISTS<seq2seq4repair_space>`wines`<seq2seq4repair_space>(\"wine_id\"<seq2seq4repair_space>INTEGER<seq2seq4repair_space>PRIMARY<seq2seq4repair_space>KEY<seq2seq4repair_space>NOT<seq2seq4repair_space>NULL<seq2seq4repair_space>UNIQUE<seq2seq4repair_space>,<seq2seq4repair_space>\"wine_name\"<seq2seq4repair_space>VARCHAR<seq2seq4repair_space>NOT<seq2seq4repair_space>NULL<seq2seq4repair_space>,<seq2seq4repair_space>\"wine_winery\"<seq2seq4repair_space>VARCHAR<seq2seq4repair_space>NOT<seq2seq4repair_space>NULL<seq2seq4repair_space>,<seq2seq4repair_space>\"wine_location\"<seq2seq4repair_space>VARCHAR<seq2seq4repair_space>NOT<seq2seq4repair_space>NULL<seq2seq4repair_space>,<seq2seq4repair_space>\"wine_year\"<seq2seq4repair_space>INTEGER,<seq2seq4repair_space>\"wine_composition\"<seq2seq4repair_space>VARCHAR<seq2seq4repair_space>NOT<seq2seq4repair_space>NULL<seq2seq4repair_space>,<seq2seq4repair_space>\"wine_price\"<seq2seq4repair_space>INTEGER);" ; private static final String DATABASE_CREATE_SCORES = "CREATE<seq2seq4repair_space>TABLE<seq2seq4repair_space>IF<seq2seq4repair_space>NOT<seq2seq4repair_space>EXISTS<seq2seq4repair_space>`scores`<seq2seq4repair_space>(\"user_id\"<seq2seq4repair_space>INTEGER,<seq2seq4repair_space>\"wine_id\"<seq2seq4repair_space>INTEGER,<seq2seq4repair_space>\"score\"<seq2seq4repair_space>DOUBLE,<seq2seq4repair_space>\"timestamp\"<seq2seq4repair_space>DATETIME<seq2seq4repair_space>NOT<seq2seq4repair_space>NULL<seq2seq4repair_space>DEFAULT<seq2seq4repair_space>CURRENT_TIMESTAMP);" ; public LocalDAO ( Context context ) { } @ Override public void onCreate ( SQLiteDatabase database ) { } public SQLiteDatabase getDB ( ) { } private boolean isWineIdUsed ( Wine wine ) { } public boolean deleteWine ( Wine wine ) { } @ Override public void onUpgrade ( SQLiteDatabase database , int oldVersion , int newVersion ) { } public boolean addWine ( Wine wine ) { } @ Override public ArrayList < Wine > getWines ( ) { } public double getScore ( int user_id , int wine_id ) { } @ Override public ArrayList < Score > getScores ( int user_id ) { } @ Override public boolean addOrUpdateScore ( Score remoteScore ) { String whereClause = "user_id<seq2seq4repair_space>=?<seq2seq4repair_space>AND<seq2seq4repair_space>wine_id<seq2seq4repair_space>=?" ; String [ ] whereArgs = new String [ ] { ( remoteScore . getUser_id ( ) ) + "" , ( remoteScore . getWine_id ( ) ) + "" } ; SQLiteDatabase db = getDB ( ) ; Cursor cursor = db . query ( "scores" , null , whereClause , whereArgs , null , null , null ) ; boolean resultsFound = cursor . moveToFirst ( ) ; if ( resultsFound ) { String sTimestamp = cursor . getString ( 3 ) ; Date timestamp = null ; try { timestamp = stringToDate ( sTimestamp ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } <START_BUG> Score localScore = new Score ( Integer . parseInt ( cursor . getString ( 0 ) ) , Integer . parseInt ( cursor . getString ( 1 ) ) , Integer . parseInt ( cursor . getString ( 2 ) ) , timestamp ) ; <END_BUG> if ( ( ( localScore . getScore ( ) ) == ( remoteScore . getScore ( ) ) ) || ( remoteScore . getTimestamp ( ) . before ( localScore . getTimestamp ( ) ) ) ) { db . close ( ) ; return false ; } } ContentValues contentValues = new ContentValues ( ) ; contentValues . put ( "user_id" , remoteScore . getUser_id ( ) ) ; contentValues . put ( "wine_id" , remoteScore . getWine_id ( ) ) ; contentValues . put ( "score" , remoteScore . getScore ( ) ) ; contentValues . put ( "timestamp" , dateToString ( remoteScore . getTimestamp ( ) ) ) ; deleteScore ( remoteScore ) ; db . insert ( "scores" , null , contentValues ) ; System . out . println ( ( "LocalDAO<seq2seq4repair_space>added<seq2seq4repair_space>:<seq2seq4repair_space>" + ( remoteScore . toString ( ) ) ) ) ; db . close ( ) ; return true ; } private boolean deleteScore ( Score score ) { } }
public class ObjFileImporter implements IModelLoader { protected static Pattern linePattern = Pattern . compile ( "^(?<type>.*?)<seq2seq4repair_space>(?<data>.*)$" ) ; protected static Pattern facePattern = Pattern . compile ( "(?<v>\\d+)(/(?<t>\\d+)?(/(?<n>\\d+))?)?" ) ; protected Matcher matcher ; protected String currentLine ; protected int lineNumber ; protected String currentShape = "Default" ; protected List < Vertex > vertexes = new ArrayList < > ( ) ; protected List < ObjFileImporter . UV > uvs = new ArrayList < > ( ) ; protected List < Vector > normals = new ArrayList < > ( ) ; protected List < Face > faces = new ArrayList < > ( ) ; protected Map < String , Shape > shapes = new HashMap < > ( ) ; public ObjFileImporter ( ResourceLocation resourceLocation ) { } public ObjFileImporter ( InputStream inputStream ) { } @ Override public Map < String , Shape > getShapes ( ) { } public void load ( ResourceLocation resourceLocation ) { try { IResource res = Minecraft . getMinecraft ( ) . getResourceManager ( ) . getResource ( resourceLocation ) ; load ( res . getInputStream ( ) ) ; } catch ( IOException e ) { <START_BUG> log . error ( "[ObjFileImporter]<seq2seq4repair_space>An<seq2seq4repair_space>error<seq2seq4repair_space>happened<seq2seq4repair_space>while<seq2seq4repair_space>reading<seq2seq4repair_space>the<seq2seq4repair_space>file<seq2seq4repair_space>:<seq2seq4repair_space>{}" , e ) ; <END_BUG> } } public void load ( InputStream inputStream ) { } private void addVertex ( String data ) { } private void addUV ( String data ) { } private void addNormal ( String data ) { } private void addFace ( String data ) { } private void addShape ( String data ) { } private class UV { float u ; float v ; public UV ( float u , float v ) { } } }
public class ConditionalExpression extends OperatorExpression { public Expression condition ; public Expression valueIfTrue ; public Expression valueIfFalse ; public Constant optimizedBooleanConstant ; public Constant optimizedIfTrueConstant ; public Constant optimizedIfFalseConstant ; int trueInitStateIndex = - 1 ; int falseInitStateIndex = - 1 ; int mergedInitStateIndex = - 1 ; public ConditionalExpression ( Expression condition , Expression valueIfTrue , Expression valueIfFalse ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { int pc = codeStream . position ; BranchLabel endifLabel ; BranchLabel falseLabel ; if ( ( constant ) != ( Constant . NotAConstant ) ) { if ( valueRequired ) codeStream . generateConstant ( constant , implicitConversion ) ; codeStream . recordPositionsFrom ( pc , this . sourceStart ) ; return ; } Constant cst = condition . constant ; Constant condCst = condition . optimizedBooleanConstant ( ) ; boolean needTruePart = ! ( ( ( cst != ( Constant . NotAConstant ) ) && ( ( cst . booleanValue ( ) ) == false ) ) || ( ( condCst != ( Constant . NotAConstant ) ) && ( ( condCst . booleanValue ( ) ) == false ) ) ) ; boolean needFalsePart = ! ( ( ( cst != ( Constant . NotAConstant ) ) && ( ( cst . booleanValue ( ) ) == true ) ) || ( ( condCst != ( Constant . NotAConstant ) ) && ( ( condCst . booleanValue ( ) ) == true ) ) ) ; endifLabel = new BranchLabel ( codeStream ) ; boolean needConditionValue = ( cst == ( Constant . NotAConstant ) ) && ( condCst == ( Constant . NotAConstant ) ) ; falseLabel = new BranchLabel ( codeStream ) ; falseLabel . tagBits |= BranchLabel . USED ; condition . generateOptimizedBoolean ( currentScope , codeStream , null , falseLabel , needConditionValue ) ; if ( ( trueInitStateIndex ) != ( - 1 ) ) { codeStream . removeNotDefinitelyAssignedVariables ( currentScope , trueInitStateIndex ) ; codeStream . addDefinitelyAssignedVariables ( currentScope , trueInitStateIndex ) ; } if ( needTruePart ) { valueIfTrue . generateCode ( currentScope , codeStream , valueRequired ) ; if ( needFalsePart ) { int position = codeStream . position ; codeStream . goto_ ( endifLabel ) ; codeStream . updateLastRecordedEndPC ( currentScope , position ) ; if ( valueRequired ) { codeStream . decrStackSize ( ( ( ( this . resolvedType ) == ( TypeBinding . LONG ) ) || ( ( this . resolvedType ) == ( TypeBinding . DOUBLE ) ) ? 2 : 1 ) ) ; } } } if ( needFalsePart ) { if ( ( falseInitStateIndex ) != ( - 1 ) ) { codeStream . removeNotDefinitelyAssignedVariables ( currentScope , falseInitStateIndex ) ; codeStream . addDefinitelyAssignedVariables ( currentScope , falseInitStateIndex ) ; } <START_BUG> if ( falseLabel . hasForwardReferences ( ) ) { <END_BUG> falseLabel . place ( ) ; } valueIfFalse . generateCode ( currentScope , codeStream , valueRequired ) ; if ( valueRequired ) { codeStream . recordExpressionType ( this . resolvedType ) ; } if ( needTruePart ) { endifLabel . place ( ) ; } } if ( ( mergedInitStateIndex ) != ( - 1 ) ) { codeStream . removeNotDefinitelyAssignedVariables ( currentScope , mergedInitStateIndex ) ; } if ( valueRequired ) codeStream . generateImplicitConversion ( implicitConversion ) ; codeStream . recordPositionsFrom ( pc , this . sourceStart ) ; } public void generateOptimizedBoolean ( BlockScope currentScope , CodeStream codeStream , BranchLabel trueLabel , BranchLabel falseLabel , boolean valueRequired ) { } public int nullStatus ( FlowInfo flowInfo ) { } public Constant optimizedBooleanConstant ( ) { } public StringBuffer printExpressionNoParenthesis ( int indent , StringBuffer output ) { } public TypeBinding resolveType ( BlockScope scope ) { } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } }
public class ResourceStreamResource extends AbstractResource { private static final long serialVersionUID = 1L ; private static final Logger logger = LoggerFactory . getLogger ( ResourceStreamResource . class ) ; private final IResourceStream stream ; private String fileName ; private ContentDisposition contentDisposition = ContentDisposition . INLINE ; private String textEncoding ; private String mimeType ; public ResourceStreamResource ( IResourceStream stream ) { } public ResourceStreamResource setFileName ( String fileName ) { } public ResourceStreamResource setContentDisposition ( ContentDisposition contentDisposition ) { } public ResourceStreamResource setTextEncoding ( String textEncoding ) { } @ Override protected ResourceResponse newResourceResponse ( Attributes attributes ) { ResourceResponse data = new ResourceResponse ( ) ; Time lastModifiedTime = stream . lastModifiedTime ( ) ; if ( lastModifiedTime != null ) { <START_BUG> data . setLastModified ( lastModifiedTime . toDate ( ) ) ; <END_BUG> } if ( data . dataNeedsToBeWritten ( attributes ) ) { InputStream inputStream = null ; if ( ( ( stream ) instanceof IResourceStreamWriter ) == false ) { try { inputStream = stream . getInputStream ( ) ; } catch ( ResourceStreamNotFoundException e ) { data . setError ( SC_NOT_FOUND ) ; close ( ) ; } } data . setContentDisposition ( contentDisposition ) ; Bytes length = stream . length ( ) ; if ( length != null ) { data . setContentLength ( length . bytes ( ) ) ; } data . setFileName ( fileName ) ; data . setContentType ( stream . getContentType ( ) ) ; data . setTextEncoding ( textEncoding ) ; if ( ( stream ) instanceof IResourceStreamWriter ) { data . setWriteCallback ( new WriteCallback ( ) { @ Override public void writeData ( Attributes attributes ) { ( ( IResourceStreamWriter ) ( stream ) ) . write ( attributes . getResponse ( ) ) ; close ( ) ; } } ) ; } else { final InputStream s = inputStream ; data . setWriteCallback ( new WriteCallback ( ) { @ Override public void writeData ( Attributes attributes ) { try { writeStream ( attributes , s ) ; } finally { close ( ) ; } } } ) ; } } return data ; } private void close ( ) { } }
public class TridentWorld implements World { private static final int SIZE = 1 ; private static final int MAX_HEIGHT = 255 ; private static final int MAX_CHUNKS = 30000000 ; private final ChunkCache loadedChunks = new ChunkCache ( this ) ; private final Set < Entity > entities = Factories . collect ( ) . createSet ( ) ; private final String name ; private final WorldLoader loader ; private final Position spawnLocation ; private volatile long time ; private volatile long existed ; private volatile int rainTime ; private volatile int thunderTime ; private volatile double borderSize ; private volatile Dimension dimension ; private volatile Difficulty difficulty ; private volatile GameMode defaultGamemode ; private volatile LevelType type ; private volatile boolean difficultyLocked ; private volatile boolean redstoneTick ; private volatile boolean raining ; private volatile boolean thundering ; private TridentWorld ( String name , WorldLoader loader , boolean throwaway ) { } TridentWorld ( String name , WorldLoader loader ) { } static TridentWorld createWorld ( String name , WorldLoader loader ) { } public void tick ( ) { ThreadsHandler . worldExecutor ( ) . execute ( ( ) -> { redstoneTick = ! ( redstoneTick ) ; if ( ( time ) >= 2400 ) time = 0 ; if ( ( ( time ) % 40 ) == 0 ) TridentPlayer . sendAll ( new PacketPlayOutTimeUpdate ( ) . set ( "worldAge" , existed ) . set ( "time" , time ) ) ; ( rainTime ) -- ; ( thunderTime ) -- ; if ( ( rainTime ) <= 0 ) { raining = ! ( raining ) ; rainTime = ThreadLocalRandom . current ( ) . nextInt ( ) ; } if ( ( thunderTime ) <= 0 ) { thundering = ! ( thundering ) ; thunderTime = ThreadLocalRandom . current ( ) . nextInt ( ) ; } ( time ) ++ ; ( existed ) ++ ; if ( ( ( time ) % 150 ) == 0 ) { Set < ChunkLocation > set = Sets . newHashSet ( ) ; for ( Entity entity : entities ) { if ( entity instanceof Player ) { <START_BUG> Position pos = entity . location ( ) ; <END_BUG> int x = ( ( int ) ( pos . x ( ) ) ) % 16 ; int z = ( ( int ) ( pos . z ( ) ) ) % 16 ; int viewDist = Trident . config ( ) . getInt ( "view-distance" , 7 ) ; for ( int i = x - viewDist ; i < ( x + viewDist ) ; i ++ ) { for ( int j = z - viewDist ; j < ( z + viewDist ) ; j ++ ) { set . add ( ChunkLocation . create ( i , j ) ) ; } } } } loadedChunks . retain ( set ) ; set = null ; } } ) ; } protected void addChunkAt ( ChunkLocation location , Chunk chunk ) { } public Collection < TridentChunk > loadedChunks ( ) { } public void save ( ) { } @ Override public String name ( ) { } @ Override public Chunk chunkAt ( int x , int z , boolean generateIfNotFound ) { } @ Override public TridentChunk chunkAt ( ChunkLocation location , boolean generateIfNotFound ) { } @ Override public Chunk generateChunk ( int x , int z ) { } @ Override public TridentChunk generateChunk ( ChunkLocation location ) { } @ Override public boolean equals ( Object obj ) { } @ Override public Block blockAt ( Position location ) { } @ Override public Difficulty difficulty ( ) { } @ Override public GameMode defaultGamemode ( ) { } @ Override public WorldLoader loader ( ) { } @ Override public LevelType levelType ( ) { } @ Override public Position spawnLocation ( ) { } @ Override public Dimension dimension ( ) { } @ Override public boolean gameRule ( String rule ) { } @ Override public long time ( ) { } @ Override public boolean isRaining ( ) { } @ Override public int rainTime ( ) { } @ Override public boolean isThundering ( ) { } @ Override public int thunderTime ( ) { } @ Override public boolean canGenerateStructures ( ) { } @ Override public double borderSize ( ) { } @ Override public Position borderCenter ( ) { } @ Override public int borderSizeContraction ( ) { } @ Override public int borderSizeContractionTime ( ) { } @ Override public Set < Entity > entities ( ) { } public void addEntity ( Entity entity ) { } private static class PlayerFilter implements FilenameFilter { @ Override public boolean accept ( File file , String name ) { } } No newline ; at end ; of file ; }
public class GrantNode extends MiscellaneousStatementNode { private PrivilegeNode privileges ; private List grantees ; public String toString ( ) { } public String statementToString ( ) { } public void init ( Object privileges , Object grantees ) { } public QueryTreeNode bind ( ) throws StandardException { <START_BUG> privileges = ( ( PrivilegeNode ) ( privileges . bind ( new HashMap ( ) , grantees ) ) ) ; <END_BUG> return this ; } public ConstantAction makeConstantAction ( ) throws StandardException { } }
@ Controller @ RequestMapping ( { "/handle" , "/resource" } ) public class ResourceIdentifierController { public static final String DSPACE_OBJECT = "dspace.object" ; private static final String RESOURCE = "/resource" ; private static final String METS = "mets" ; private static final String DRI = "DRI" ; private static final int STATUS_OK = 200 ; private static final int STATUS_FORBIDDEN = 400 ; @ RequestMapping ( method = { RequestMethod . GET , RequestMethod . HEAD } , value = { "/{prefix:.*}" } ) public String processHandle ( HttpServletRequest request , @ PathVariable String prefix ) { try { Context context = ContextUtil . obtainContext ( request ) ; IdentifierService dis = new DSpace ( ) . getSingletonService ( IdentifierService . class ) ; if ( dis == null ) throw new RuntimeException ( "Cannot<seq2seq4repair_space>instantiate<seq2seq4repair_space>IdentifierService.<seq2seq4repair_space>Problem<seq2seq4repair_space>with<seq2seq4repair_space>spring<seq2seq4repair_space>configuration!" ) ; DSpaceObject dso = dis . resolve ( context , prefix ) ; if ( dso == null ) <START_BUG> throw new RuntimeException ( "Cannot<seq2seq4repair_space>find<seq2seq4repair_space>Item!" ) ; <END_BUG> request . setAttribute ( ResourceIdentifierController . DSPACE_OBJECT , dso ) ; return "forward:/handle/" + ( dso . getHandle ( ) ) ; } catch ( SQLException e ) { return "forward:/error" ; } catch ( IdentifierNotResolvableException e ) { return "forward:/tombstone" ; } catch ( IdentifierNotFoundException e ) { request . setAttribute ( "identifier" , prefix ) ; return "forward:/identifier-not-found" ; } } @ RequestMapping ( "/**/mets.xml" ) public String processMETSHandle ( HttpServletRequest request ) { } @ RequestMapping ( "/**/DRI" ) public String processDRIHandle ( HttpServletRequest request ) { } @ RequestMapping ( "/{prefix}/{suffix}/citation/ris" ) public ModelAndView genRisRepresentation ( @ PathVariable String prefix , @ PathVariable String suffix , HttpServletRequest request , HttpServletResponse response ) { } @ RequestMapping ( "/{prefix}/{suffix}/citation/bib" ) public ModelAndView genBibTexRepresentation ( @ PathVariable String prefix , @ PathVariable String suffix , HttpServletRequest request , HttpServletResponse response ) { } private DSpaceObject getDSO ( HttpServletRequest request , String resourceIdentifier ) { } private int validate ( String resourceID , HttpServletRequest request ) { } }
public class WCMPublicationDeploymentPlugin extends DeploymentPlugin { private ConfigurationManager configurationManager ; private RepositoryService repositoryService ; private PublicationService publicationService ; private WCMPublicationService wcmPublicationService ; private TrashService trashService ; private static final Log LOG = ExoLogger . getLogger ( WCMPublicationDeploymentPlugin . class . getName ( ) ) ; private static final String CLEAN_PUBLICATION = "clean-publication" ; private static final String PUBLISH_FIRST_PUBLICATION = "publish-first-publication" ; private static final String KEEP_PUBLICATION = "keep-publication" ; public WCMPublicationDeploymentPlugin ( InitParams initParams , ConfigurationManager configurationManager , RepositoryService repositoryService , PublicationService publicationService , WCMPublicationService wcmPublicationService , TrashService trashService ) { } public void deploy ( SessionProvider sessionProvider ) throws Exception { } private void cleanPublication ( Node node , String cleanupPublicationType , boolean updateLifecycle ) throws Exception , NotInPublicationLifecycleException { if ( ( node . hasProperty ( "publication:liveRevision" ) ) && ( node . hasProperty ( "publication:currentState" ) ) ) { if ( WCMPublicationDeploymentPlugin . LOG . isInfoEnabled ( ) ) { WCMPublicationDeploymentPlugin . LOG . info ( ( ( "\"" + ( node . getName ( ) ) ) + "\"<seq2seq4repair_space>publication<seq2seq4repair_space>lifecycle<seq2seq4repair_space>has<seq2seq4repair_space>been<seq2seq4repair_space>cleaned<seq2seq4repair_space>up" ) ) ; } <START_BUG> node . setProperty ( "publication:liveRevision" , "" ) ; <END_BUG> node . setProperty ( "publication:currentState" , "published" ) ; } node . getSession ( ) . save ( ) ; if ( ( updateLifecycle && ( WCMPublicationDeploymentPlugin . PUBLISH_FIRST_PUBLICATION . equalsIgnoreCase ( cleanupPublicationType ) ) ) && ( Utils . isDocument ( node ) ) ) { if ( publicationService . isNodeEnrolledInLifecycle ( node ) ) publicationService . unsubcribeLifecycle ( node ) ; wcmPublicationService . updateLifecyleOnChangeContent ( node , "default" , "__system" , "published" ) ; node . save ( ) ; } NodeIterator iter = node . getNodes ( ) ; while ( iter . hasNext ( ) ) { Node childNode = iter . nextNode ( ) ; cleanPublication ( childNode , cleanupPublicationType , false ) ; } } }
public class Parameter extends AbstractStatement implements MetaParameter { private MetaClass type ; private String name ; private boolean isFinal ; public Parameter ( MetaClass type , String name , boolean isFinal ) { } public static Parameter of ( MetaClass type , String name ) { } public static Parameter of ( Class < ? > type , String name ) { } public static Parameter of ( MetaClass type , String name , boolean isFinal ) { } public static Parameter of ( Class < ? > type , String name , boolean isFinal ) { } public static Parameter [ ] of ( MetaParameter [ ] parameters ) { } String generatedCache ; @ Override public String generate ( Context context ) { if ( ( generatedCache ) != null ) return generatedCache ; generatedCache = ( isFinal ) ? ( Final . getCanonicalString ( ) ) + "<seq2seq4repair_space>" : "" ; <START_BUG> return generatedCache += ( ( LoadClassReference . getClassReference ( type , context ) ) + "<seq2seq4repair_space>" ) + ( name ) ; <END_BUG> } @ Override public MetaClass getType ( ) { } @ Override public String getName ( ) { } @ Override public MetaClassMember getDeclaringMember ( ) { } @ Override public Annotation [ ] getAnnotations ( ) { } @ Override public boolean isAnnotationPresent ( Class < ? extends Annotation > annotation ) { } @ Override public < A extends Annotation > A getAnnotation ( Class < A > annotation ) { } @ Override public String toString ( ) { } }
public class CollectionDocumentView extends AbstractDocumentView { private static final long serialVersionUID = 7220521612114533227L ; private JPanel collectionDocumentPanel ; public CollectionDocumentView ( DocumentViewController documentViewController , JScrollPane documentScrollpane , DocumentViewModel documentViewModel ) { } private void buildGUI ( ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; final ModifiedFlowLayout layout = new ModifiedFlowLayout ( ) ; layout . setHgap ( 15 ) ; layout . setVgap ( 15 ) ; collectionDocumentPanel = new JPanel ( layout ) ; collectionDocumentPanel . setBackground ( backgroundColor ) ; this . setLayout ( new BorderLayout ( ) ) ; this . add ( collectionDocumentPanel , BorderLayout . CENTER ) ; documentScrollpane . getViewport ( ) . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JViewport tmp = ( ( JViewport ) ( e . getSource ( ) ) ) ; Dimension dim = layout . computeSize ( tmp . getWidth ( ) , collectionDocumentPanel ) ; collectionDocumentPanel . setPreferredSize ( dim ) ; } } ) ; documentScrollpane . getVerticalScrollBar ( ) . addAdjustmentListener ( new AdjustmentListener ( ) { public void adjustmentValueChanged ( AdjustmentEvent e ) { if ( ! ( e . getValueIsAdjusting ( ) ) ) { repaint ( ) ; } } } ) ; DocumentViewComponent documentViewComponent ; Library library = currentDocument . getCatalog ( ) . getLibrary ( ) ; NameTree embeddedFilesNameTree = currentDocument . getCatalog ( ) . getNames ( ) . getEmbeddedFilesNameTree ( ) ; <START_BUG> List filePairs = embeddedFilesNameTree . getRoot ( ) . getNamesAndValues ( ) ; <END_BUG> for ( int i = 0 , max = filePairs . size ( ) ; i < max ; i += 2 ) { String fileName = Utils . convertStringObject ( library , ( ( StringObject ) ( filePairs . get ( i ) ) ) ) ; HashMap tmp = ( ( HashMap ) ( library . getObject ( ( ( Reference ) ( filePairs . get ( ( i + 1 ) ) ) ) ) ) ) ; FileSpecification fileSpec = new FileSpecification ( library , tmp ) ; tmp = fileSpec . getEmbeddedFileDictionary ( ) ; Reference fileRef = ( ( Reference ) ( tmp . get ( F_KEY ) ) ) ; documentViewComponent = new DocumentViewComponent ( library , fileName , fileRef ) ; JPanel documentViewPanel = new JPanel ( ) ; documentViewPanel . setLayout ( new BoxLayout ( documentViewPanel , BoxLayout . Y_AXIS ) ) ; documentViewPanel . setBackground ( backgroundColor ) ; PageViewDecorator pageViewComponent = new PageViewDecorator ( documentViewComponent ) ; pageViewComponent . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; documentViewPanel . add ( pageViewComponent ) ; JLabel fileNameLabel = new JLabel ( fileName ) ; fileNameLabel . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; documentViewPanel . add ( fileNameLabel ) ; collectionDocumentPanel . add ( documentViewPanel ) ; } collectionDocumentPanel . revalidate ( ) ; documentScrollpane . validate ( ) ; } @ Override public void dispose ( ) { } @ Override public void updateDocumentView ( ) { } public int getNextPageIncrement ( ) { } public int getPreviousPageIncrement ( ) { } public Dimension getDocumentSize ( ) { } }
public class ConcreteAspectCodeGen { private static final String [ ] EMPTY_STRINGS = new String [ 0 ] ; private static final Type [ ] EMPTY_TYPES = new Type [ 0 ] ; private final ConcreteAspect m_concreteAspect ; private final World m_world ; private boolean m_isValid = false ; private ResolvedType m_parent ; private PerClause m_perClause ; ConcreteAspectCodeGen ( Definition . ConcreteAspect concreteAspect , World world ) { } public boolean validate ( ) { } private String stringify ( ) { } public byte [ ] getBytes ( ) { if ( ! ( m_isValid ) ) { throw new RuntimeException ( "Must<seq2seq4repair_space>validate<seq2seq4repair_space>first" ) ; } LazyClassGen cg = new LazyClassGen ( m_concreteAspect . name . replace ( '.' , '/' ) , m_parent . getName ( ) , null , ( ( Modifier . PUBLIC ) + ( Constants . ACC_SUPER ) ) , ConcreteAspectCodeGen . EMPTY_STRINGS , m_world ) ; AnnotationGen ag = new AnnotationGen ( new ObjectType ( "org/aspectj/lang/annotation/Aspect" ) , Collections . EMPTY_LIST , true , cg . getConstantPoolGen ( ) ) ; cg . addAnnotation ( ag . getAnnotation ( ) ) ; if ( ( m_concreteAspect . precedence ) != null ) { SimpleElementValueGen svg = new SimpleElementValueGen ( ElementValueGen . STRING , cg . getConstantPoolGen ( ) , m_concreteAspect . precedence ) ; List elems = new ArrayList ( ) ; elems . add ( new org . aspectj . apache . bcel . generic . annotation . ElementNameValuePairGen ( "value" , svg , cg . getConstantPoolGen ( ) ) ) ; AnnotationGen agprec = new AnnotationGen ( new ObjectType ( "org/aspectj/lang/annotation/DeclarePrecedence" ) , elems , true , cg . getConstantPoolGen ( ) ) ; cg . addAnnotation ( agprec . getAnnotation ( ) ) ; } LazyMethodGen init = new LazyMethodGen ( Modifier . PUBLIC , Type . VOID , "<init>" , ConcreteAspectCodeGen . EMPTY_TYPES , ConcreteAspectCodeGen . EMPTY_STRINGS , cg ) ; InstructionList cbody = init . getBody ( ) ; cbody . append ( ALOAD_0 ) ; cbody . append ( cg . getFactory ( ) . createInvoke ( m_parent . getName ( ) . replace ( '.' , '/' ) , "<init>" , VOID , ConcreteAspectCodeGen . EMPTY_TYPES , INVOKESPECIAL ) ) ; cbody . append ( RETURN ) ; cg . addMethodGen ( init ) ; for ( Iterator it = m_concreteAspect . pointcuts . iterator ( ) ; it . hasNext ( ) ; ) { Definition . Pointcut abstractPc = ( ( Definition . Pointcut ) ( it . next ( ) ) ) ; LazyMethodGen mg = new LazyMethodGen ( Modifier . PUBLIC , Type . VOID , abstractPc . name , ConcreteAspectCodeGen . EMPTY_TYPES , ConcreteAspectCodeGen . EMPTY_STRINGS , cg ) ; SimpleElementValueGen svg = new SimpleElementValueGen ( ElementValueGen . STRING , cg . getConstantPoolGen ( ) , abstractPc . expression ) ; List elems = new ArrayList ( ) ; elems . add ( new org . aspectj . apache . bcel . generic . annotation . ElementNameValuePairGen ( "value" , svg , cg . getConstantPoolGen ( ) ) ) ; AnnotationGen mag = new AnnotationGen ( new ObjectType ( "org/aspectj/lang/annotation/Pointcut" ) , elems , true , cg . getConstantPoolGen ( ) ) ; AnnotationX max = new AnnotationX ( mag . getAnnotation ( ) , m_world ) ; mg . addAnnotation ( max ) ; InstructionList body = mg . getBody ( ) ; body . append ( RETURN ) ; cg . addMethodGen ( mg ) ; } BcelPerClauseAspectAdder perClauseMunger = new BcelPerClauseAspectAdder ( ResolvedType . forName ( m_concreteAspect . name ) . resolve ( m_world ) , m_perClause . getKind ( ) ) ; <START_BUG> perClauseMunger . forceMunge ( cg ) ; <END_BUG> JavaClass jc = cg . getJavaClass ( ( ( BcelWorld ) ( m_world ) ) ) ; ( ( BcelWorld ) ( m_world ) ) . addSourceObjectType ( jc ) ; return jc . getBytes ( ) ; } private void reportError ( String message ) { } }
public class PlaceholderAnalysisJob implements AnalysisJob { private final Datastore _datastore ; private final AnalysisJob _delegateJob ; public PlaceholderAnalysisJob ( Datastore datastore , AnalysisJob delegateJob ) { } @ Override public Datastore getDatastore ( ) { } @ Override public List < InputColumn < ? > > getSourceColumns ( ) { } @ Override public List < TransformerJob > getTransformerJobs ( ) { } @ Override public List < FilterJob > getFilterJobs ( ) { } @ Override public List < AnalyzerJob > getAnalyzerJobs ( ) { final AnalyzerBeanDescriptor < ? > descriptor = Descriptors . ofAnalyzer ( PreviewTransformedDataAnalyzer . class ) ; final Map < ConfiguredPropertyDescriptor , Object > properties = new HashMap < ConfiguredPropertyDescriptor , Object > ( ) ; final List < InputColumn < ? > > columns = new ArrayList < InputColumn < ? > > ( ) ; final Collection < TransformerJob > transformerJobs = getTransformerJobs ( ) ; for ( TransformerJob transformerJob : transformerJobs ) { InputColumn < ? > [ ] outputColumns = transformerJob . getOutput ( ) ; for ( InputColumn < ? > outputColumn : outputColumns ) { columns . add ( outputColumn ) ; } } properties . put ( descriptor . getConfiguredPropertiesForInput ( ) . iterator ( ) . next ( ) , columns . toArray ( new InputColumn [ columns . size ( ) ] ) ) ; final BeanConfiguration beanConfiguration = new org . eobjects . analyzer . job . ImmutableBeanConfiguration ( properties ) ; <START_BUG> final AnalyzerJob analyzerJob = new org . eobjects . analyzer . job . ImmutableAnalyzerJob ( "Record<seq2seq4repair_space>gatherer" , descriptor , beanConfiguration , null ) ; <END_BUG> return Arrays . asList ( analyzerJob ) ; } @ Override public AnalysisJobMetadata getMetadata ( ) { } }
public class UnionNode extends SetOperatorNode { private boolean addNewNodesCalled ; boolean tableConstructor ; boolean topTableConstructor ; public void init ( Object leftResult , Object rightResult , Object all , Object tableConstructor , Object tableProperties ) throws StandardException { } public void markTopTableConstructor ( ) { } boolean tableConstructor ( ) { } public void rejectParameters ( ) throws StandardException { } void setTableConstructorTypes ( ResultColumnList typeColumns ) throws StandardException { } public CostEstimate optimizeIt ( Optimizer optimizer , OptimizablePredicateList predList , CostEstimate outerCost , RowOrdering rowOrdering ) throws StandardException { if ( ( predList != null ) && ( ! ( getCurrentAccessPath ( ) . getJoinStrategy ( ) . isHashJoin ( ) ) ) ) { for ( int i = ( predList . size ( ) ) - 1 ; i >= 0 ; i -- ) { if ( pushOptPredicate ( predList . getOptPredicate ( i ) ) ) predList . removeOptPredicate ( i ) ; } } <START_BUG> addOrLoadBestPlanMapping ( true , this ) ; <END_BUG> leftResultSet = optimizeSource ( optimizer , leftResultSet , getLeftOptPredicateList ( ) , outerCost ) ; rightResultSet = optimizeSource ( optimizer , rightResultSet , getRightOptPredicateList ( ) , outerCost ) ; CostEstimate costEstimate = getCostEstimate ( optimizer ) ; costEstimate . setCost ( leftResultSet . getCostEstimate ( ) . getEstimatedCost ( ) , leftResultSet . getCostEstimate ( ) . rowCount ( ) , ( ( leftResultSet . getCostEstimate ( ) . singleScanRowCount ( ) ) + ( rightResultSet . getCostEstimate ( ) . singleScanRowCount ( ) ) ) ) ; costEstimate . add ( costEstimate , costEstimate ) ; getCurrentAccessPath ( ) . getJoinStrategy ( ) . estimateCost ( this , predList , ( ( ConglomerateDescriptor ) ( null ) ) , outerCost , optimizer , costEstimate ) ; optimizer . considerCost ( this , predList , costEstimate , outerCost ) ; return costEstimate ; } public void pushExpressions ( PredicateList predicateList ) throws StandardException { } public Optimizable modifyAccessPath ( JBitSet outerTables ) throws StandardException { } public ResultSetNode modifyAccessPaths ( ) throws StandardException { } private ResultSetNode addNewNodes ( ) throws StandardException { } public String toString ( ) { } public void bindExpressions ( FromList fromListParam ) throws StandardException { } public void generate ( ActivationClassBuilder acb , MethodBuilder mb ) throws StandardException { } public CostEstimate getFinalCostEstimate ( ) throws StandardException { } String getOperatorName ( ) { } }
public class CassandraBulkLoader { public static class Map extends MapReduceBase implements Mapper < Text , Text , Text , Text > { public void map ( Text key , Text value , OutputCollector < Text , Text > output , Reporter reporter ) throws IOException { } } public static class Reduce extends MapReduceBase implements Reducer < Text , Text , Text , Text > { private Path [ ] localFiles ; private JobConf jobconf ; public void configure ( JobConf job ) { } public void close ( ) { } public void reduce ( Text key , Iterator < Text > values , OutputCollector < Text , Text > output , Reporter reporter ) throws IOException { } } public static void runJob ( String [ ] args ) { } public static Message createMessage ( String keyspace , byte [ ] key , String columnFamily , List < ColumnFamily > columnFamilies ) { ColumnFamily baseColumnFamily ; DataOutputBuffer bufOut = new DataOutputBuffer ( ) ; RowMutation rm ; Message message ; Column column ; baseColumnFamily = new ColumnFamily ( ColumnFamilyType . Standard , DatabaseDescriptor . getComparator ( keyspace , columnFamily ) , DatabaseDescriptor . getSubComparator ( keyspace , columnFamily ) , CFMetaData . getId ( keyspace , columnFamily ) ) ; for ( ColumnFamily cf : columnFamilies ) { bufOut . reset ( ) ; ColumnFamily . serializer ( ) . serializeWithIndexes ( cf , bufOut ) ; byte [ ] data = new byte [ bufOut . getLength ( ) ] ; System . arraycopy ( bufOut . getData ( ) , 0 , data , 0 , bufOut . getLength ( ) ) ; column = new Column ( FBUtilities . toByteBuffer ( cf . id ( ) ) , ByteBuffer . wrap ( data ) , 0 ) ; baseColumnFamily . addColumn ( column ) ; } rm = new RowMutation ( keyspace , ByteBuffer . wrap ( key ) ) ; rm . add ( baseColumnFamily ) ; try { <START_BUG> message = rm . makeRowMutationMessage ( BINARY ) ; <END_BUG> } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return message ; } public static void main ( String [ ] args ) throws Exception { } }
public class FragmentIntent { private final FragmentActivity act ; private BaseContentFrag frag ; private String tag ; private int layoutId ; public FragmentIntent ( final FragmentActivity activity ) { } public void setFrag ( final int LayoutId , final BaseContentFrag fragment ) { } public void loadFrag ( final FragmentManager fragMan ) { final MenuBarFrag menuBar ; final int menuLayout ; switch ( layoutId ) { case id . panel01 : menuLayout = id . topbar01 ; <START_BUG> menuBar = new MenuBarFrag ( act ) ; <END_BUG> break ; case id . panel02 : default : menuBar = new MenuBarFrag ( ) ; menuLayout = id . topbar02 ; break ; case id . panel03 : menuBar = new MenuBarFrag ( ) ; menuLayout = id . topbar03 ; break ; } frag . setMenuBarFrag ( menuBar ) ; fragMan . beginTransaction ( ) . replace ( menuLayout , menuBar , menuBar . getBTag ( ) ) . replace ( layoutId , frag , tag ) . addToBackStack ( tag ) . commit ( ) ; } }
public class War extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public War ( ) { } public void setWarfile ( File warFile ) { } public void setWebxml ( File descr ) { } public void addLib ( ZipFileSet fs ) { } public void addClasses ( ZipFileSet fs ) { } public void addWebinf ( ZipFileSet fs ) { } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( ( ( deploymentDescriptor ) == null ) && ( ! ( isInUpdateMode ( ) ) ) ) { <START_BUG> throw new BuildException ( "webxml<seq2seq4repair_space>attribute<seq2seq4repair_space>is<seq2seq4repair_space>required" , location ) ; <END_BUG> } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { } protected void cleanUp ( ) { } }
@ SuppressWarnings ( "serial" ) @ edu . umd . cs . findbugs . annotations . SuppressWarnings ( value = "SE_BAD_FIELD_STORE" , justification = "We're<seq2seq4repair_space>ignoring<seq2seq4repair_space>serialization" ) public class ThreadViewImpl extends AbstractView < ThreadView , ThreadPresenter > implements ThreadView { private static final int RENDER_DELAY_MILLIS = 1000 ; private static final int RENDER_DISTANCE_PX = 1000 ; private static final String PLACEHOLDER_WIDTH = "100%" ; private static final String PLACEHOLDER_HEIGHT = "300px" ; private static final int PRELOAD_THRESHHOLD = 4 ; private CssLayout layout ; private final ReplyListener replyListener = new ReplyListener ( ) { @ Override public void submit ( final String rawBody ) { } } ; private final Map < Post , PostComponent > postsToComponents = new HashMap < Post , PostComponent > ( ) ; private final LazyLayout postsLayout ; private ReplyComponent reply ; public ThreadViewImpl ( ) { } @ Override protected Component createCompositionRoot ( ) { } @ Override public void initView ( ) { } @ Override protected ThreadPresenter createPresenter ( ) { } @ CheckForNull @ Override public DiscussionThread getCurrentThread ( ) { } @ CheckForNull @ Override public Category getCurrentCategory ( ) { } @ Override public void displayPosts ( final List < Post > posts , @ NonNull final DiscussionThread currentThread ) { layout . removeAllComponents ( ) ; postsLayout . removeAllComponents ( ) ; layout . addComponent ( postsLayout ) ; for ( int i = 0 ; i < ( posts . size ( ) ) ; i ++ ) { final Post post = posts . get ( i ) ; final PostComponent c = newPostComponent ( post ) ; if ( ( i < ( ThreadViewImpl . PRELOAD_THRESHHOLD ) ) || ( i > ( ( posts . size ( ) ) - ( ThreadViewImpl . PRELOAD_THRESHHOLD ) ) ) ) { postsLayout . addComponentEagerly ( c ) ; } else { postsLayout . addComponent ( c ) ; } if ( i == 0 ) { final FloatingBar summaryBar = getSummaryBar ( post , c ) ; summaryBar . setScrollComponent ( c ) ; <START_BUG> postsLayout . addComponentEagerly ( summaryBar ) ; <END_BUG> } } if ( getPresenter ( ) . userMayReply ( ) ) { final Label spacer = new Label ( "<span<seq2seq4repair_space>class=\"eof\">eof</span>" , Label . CONTENT_XHTML ) ; spacer . setStyleName ( "spacer" ) ; layout . addComponent ( spacer ) ; reply = new ReplyComponent ( replyListener , getPresenter ( ) . getFormattingSyntax ( ) , "Post<seq2seq4repair_space>Reply" ) ; layout . addComponent ( reply ) ; final FloatingBar quickReplyBar = getQuickReplyBar ( reply ) ; quickReplyBar . setScrollComponent ( reply ) ; layout . addComponent ( quickReplyBar ) ; } final Label bottomSpacer = new Label ( "" ) ; bottomSpacer . setStyleName ( "spacer" ) ; layout . addComponent ( bottomSpacer ) ; } private PostComponent newPostComponent ( final Post post ) { } private PostComponent newPostSummaryComponent ( final Post post ) { } private Component getThreadSummary ( final Post firstPost ) { } private FloatingBar getSummaryBar ( final Post post , final PostComponent originalPost ) { } private FloatingBar getQuickReplyBar ( final ReplyComponent mirroredReplyComponent ) { } @ Override public void displayThreadNotFoundError ( final String threadIdString ) { } @ Override protected void navigationTo ( final String [ ] arguments ) { } @ Override public void confirmPostReported ( ) { } @ Override public void confirmBanned ( ) { } @ Override public void confirmFollowingThread ( ) { } @ Override public void confirmUnFollowingThread ( ) { } private void swapFollowingMenus ( ) { } @ Override public void confirmPostDeleted ( ) { } @ Deprecated private void reloadPage ( ) { } @ Override public void refreshScores ( final Post post , final long newScore ) { } @ Override public void confirmReplyPostedAndShowIt ( final Post newPost ) { } @ Override public void displayUserCanNotReply ( ) { } @ Override public void displayUserCanNotEdit ( ) { } @ Override public void redirectToDashboard ( ) { } @ Override public void displayNewThreadFormFor ( final Category category ) { } @ Override public void panic ( ) { } @ Override public void appendToReply ( final String textToAppend ) { } @ Override public void refresh ( final Post post ) { } }
public class ReentrantLock { private boolean isLocked = false ; private Thread lockedBy = null ; private int lockCount = 0 ; public synchronized void lock ( ) throws InterruptedException { } public synchronized void unlock ( ) throws IllegalMonitorStateException { Thread callingThread = Thread . currentThread ( ) ; if ( ! ( isLocked ) ) throw new IllegalMonitorStateException ( ) ; if ( ( isLocked ) && ( callingThread != ( lockedBy ) ) ) throw new IllegalMonitorStateException ( ) ; <START_BUG> lockCount -= lockCount ; <END_BUG> if ( ( lockCount ) == 0 ) { isLocked = false ; lockedBy = null ; notify ( ) ; } } }
public class PerlAnnotatorMisc extends PerlAnnotator { private void annotateStringContent ( PerlStringContentElementImpl element , AnnotationHolder holder ) { PsiElement parent = element . getParent ( ) ; <START_BUG> PsiElement grandParent = element . getParent ( ) ; <END_BUG> if ( ! ( ( ( ( parent instanceof PsiPerlConstantName ) || ( grandParent instanceof PsiPerlConstantName ) ) || ( parent instanceof PerlHeredocElementImpl ) ) || ( grandParent instanceof PerlHeredocElementImpl ) ) ) { Annotation annotation = holder . createInfoAnnotation ( ( ( PsiElement ) ( element ) ) , null ) ; if ( parent instanceof PsiPerlStringDq ) annotation . setTextAttributes ( PERL_DQ_STRING ) ; else if ( parent instanceof PsiPerlStringXq ) annotation . setTextAttributes ( PERL_DX_STRING ) ; else annotation . setTextAttributes ( PERL_SQ_STRING ) ; } } @ Override public void annotate ( @ NotNull final PsiElement element , @ NotNull AnnotationHolder holder ) { } No newline ; at end ; of file ; }
public class PluginLoader { public PluginLoader ( ) { } public static Object loadExternalPlugin ( String className , String type , File file , Object [ ] args ) throws Exception { log . debug ( "loading.." ) ; if ( ( type . equals ( "java" ) ) || ( type . equals ( "jar" ) ) ) { String path = file . getPath ( ) ; URL [ ] url = new URL [ 1 ] ; URL newURL = new File ( path ) . toURL ( ) ; url [ 0 ] = newURL ; log . debug ( ( "url=" + newURL ) ) ; return new ExternalClassLoader ( url ) . instanciate ( className , args ) ; } InterpreterHandler handler = ( ( InterpreterHandler ) ( pluginManager . getHandler ( "interpreter" ) ) ) ; <START_BUG> Object instance = handler . getPlugin ( type , "org.columba.core.scripting.PythonInterpreterPlugin" , null ) ; <END_BUG> if ( instance != null ) { AbstractInterpreter ip = ( ( AbstractInterpreter ) ( instance ) ) ; String pythonFile = ( ( file . toString ( ) ) + "/" ) + ( className . toString ( ) ) ; String pythonClass = className . toString ( ) . substring ( 0 , ( ( className . toString ( ) . length ( ) ) - 3 ) ) ; Object i = ip . instanciate ( pythonFile , pythonClass , args , "test" ) ; return i ; } return null ; } }
public class LinkedList { private Node head ; private Node tail ; private int size = 0 ; public LinkedList ( ) { } public void addFront ( int nodeData ) { if ( isEmpty ( ) ) { createNewHeadNode ( nodeData ) ; return ; } else { <START_BUG> Node node = new Node ( nodeData , head . next ) ; <END_BUG> head = node ; } ( size ) ++ ; } public void addBack ( int nodeData ) { } private void createNewHeadNode ( int nodeData ) { } public boolean isEmpty ( ) { } public void printList ( ) { } public int size ( ) { } public int getHead ( ) { } public int getTail ( ) { } @ Override public String toString ( ) { } }
public class ResidencePermissions extends FlagPermissions { protected UUID ownerUUID ; protected String ownerLastKnownName ; protected String world ; protected ClaimedResidence residence ; private ResidencePermissions ( ClaimedResidence res ) { } public ResidencePermissions ( ClaimedResidence res , String creator , String inworld ) { } public boolean playerHas ( String player , String flag , boolean def ) { } @ Override public boolean playerHas ( String player , String world , String flag , boolean def ) { } @ Override public boolean groupHas ( String group , String flag , boolean def ) { } @ Override public boolean has ( String flag , boolean def ) { } public boolean hasApplicableFlag ( String player , String flag ) { } public void applyTemplate ( Player player , FlagPermissions list , boolean resadmin ) { } public boolean hasResidencePermission ( Player player , boolean requireOwner ) { } private boolean checkCanSetFlag ( Player player , String flag , FlagState state , boolean globalflag , boolean resadmin ) { } private boolean hasFlagAccess ( String player , String flag ) { } public boolean setPlayerFlag ( Player player , String targetPlayer , String flag , String flagstate , boolean resadmin ) { } public boolean setGroupFlag ( Player player , String group , String flag , String flagstate , boolean resadmin ) { } public boolean setFlag ( Player player , String flag , String flagstate , boolean resadmin ) { } public boolean removeAllPlayerFlags ( Player player , String targetPlayer , boolean resadmin ) { } public boolean removeAllGroupFlags ( Player player , String group , boolean resadmin ) { } @ Override public boolean setFlag ( String flag , FlagState state ) { } @ Override public boolean setGroupFlag ( String group , String flag , FlagState state ) { } @ Override public boolean setPlayerFlag ( String player , String flag , FlagState state ) { } public void applyDefaultFlags ( Player player , boolean resadmin ) { } public void applyDefaultFlags ( ) { } public void setOwner ( String newOwner , boolean resetFlags ) { } public String getOwner ( ) { } public UUID getOwnerUUID ( ) { } public String getWorld ( ) { } @ Override public Map < String , Object > save ( ) { } public static ResidencePermissions load ( ClaimedResidence res , Map < String , Object > root ) throws Exception { ResidencePermissions newperms = new ResidencePermissions ( res ) ; if ( root . containsKey ( "OwnerUUID" ) ) { newperms . ownerUUID = UUID . fromString ( ( ( String ) ( root . get ( "OwnerUUID" ) ) ) ) ; String name = Residence . getPlayerName ( newperms . ownerUUID ) ; if ( name != null ) newperms . ownerLastKnownName = name ; else newperms . ownerLastKnownName = ( ( String ) ( root . get ( "OwnerLastKnownName" ) ) ) ; <START_BUG> if ( newperms . ownerUUID . toString ( ) . equals ( "ffffffff-ffff-ffff-ffff-ffffffffffff" ) ) { <END_BUG> UUID realUUID = Residence . getPlayerUUID ( newperms . ownerLastKnownName ) ; if ( realUUID != null ) newperms . ownerUUID = realUUID ; } } else if ( root . containsKey ( "Owner" ) ) { String owner = ( ( String ) ( root . get ( "Owner" ) ) ) ; newperms . ownerLastKnownName = owner ; newperms . ownerUUID = Residence . getPlayerUUID ( owner ) ; if ( ( newperms . ownerUUID ) == null ) newperms . ownerUUID = UUID . fromString ( "ffffffff-ffff-ffff-ffff-ffffffffffff" ) ; } else { newperms . ownerUUID = UUID . fromString ( "00000000-0000-0000-0000-000000000000" ) ; newperms . ownerLastKnownName = "Server<seq2seq4repair_space>Land" ; } newperms . world = ( ( String ) ( root . get ( "World" ) ) ) ; FlagPermissions . load ( root , newperms ) ; if ( ( ( ( ( ( newperms . getOwner ( ) ) == null ) || ( ( newperms . world ) == null ) ) || ( ( newperms . playerFlags ) == null ) ) || ( ( newperms . groupFlags ) == null ) ) || ( ( newperms . cuboidFlags ) == null ) ) throw new Exception ( "Invalid<seq2seq4repair_space>Residence<seq2seq4repair_space>Permissions..." ) ; newperms . fixNames ( ) ; return newperms ; } public void fixNames ( ) { } public void applyGlobalDefaults ( ) { } public boolean setFlagGroup ( Player player , String flaggroup , String state , boolean resadmin ) { } public boolean setFlagGroupOnGroup ( Player player , String flaggroup , String group , String state , boolean resadmin ) { } public boolean setFlagGroupOnPlayer ( Player player , String target , String flaggroup , String state , boolean resadmin ) { } }
public class PromptPasswordState implements State { private final ConsoleWrapper theConsole ; private final StateValues stateValues ; private final boolean rePrompt ; public PromptPasswordState ( ConsoleWrapper theConsole , StateValues stateValues , boolean rePrompt ) { } @ Override public State execute ( ) { if ( ( stateValues . isSilentOrNonInteractive ( ) ) == false ) { if ( ( rePrompt ) == false ) { RestrictionLevel level = stateValues . getOptions ( ) . getCheckUtil ( ) . getRestrictionLevel ( ) ; if ( ! ( RELAX . equals ( level ) ) ) { final List < PasswordRestriction > passwordRestrictions = stateValues . getOptions ( ) . getCheckUtil ( ) . getPasswordRestrictions ( ) ; if ( ( passwordRestrictions . size ( ) ) > 0 ) { if ( level == ( RestrictionLevel . REJECT ) ) { theConsole . printf ( ROOT_LOGGER . passwordRequirements ( ) ) ; } else { theConsole . printf ( ROOT_LOGGER . passwordRecommendations ( ) ) ; } theConsole . printf ( AddUser . NEW_LINE ) ; for ( PasswordRestriction passwordRestriction : passwordRestrictions ) { final String message = passwordRestriction . getRequirementMessage ( ) ; if ( ( message != null ) && ( ! ( message . isEmpty ( ) ) ) ) { theConsole . printf ( "<seq2seq4repair_space>-<seq2seq4repair_space>" ) ; theConsole . printf ( message ) ; theConsole . printf ( AddUser . NEW_LINE ) ; } } } } theConsole . printf ( ROOT_LOGGER . passwordPrompt ( ) ) ; char [ ] tempChar = theConsole . readPassword ( "<seq2seq4repair_space>:<seq2seq4repair_space>" ) ; if ( ( tempChar == null ) || ( ( tempChar . length ) == 0 ) ) { <START_BUG> return new ErrorState ( theConsole , ROOT_LOGGER . noPasswordExiting ( ) ) ; <END_BUG> } stateValues . setPassword ( new String ( tempChar ) ) ; return new ValidatePasswordState ( theConsole , stateValues ) ; } else { theConsole . printf ( ROOT_LOGGER . passwordConfirmationPrompt ( ) ) ; char [ ] secondTempChar = theConsole . readPassword ( "<seq2seq4repair_space>:<seq2seq4repair_space>" ) ; if ( secondTempChar == null ) { secondTempChar = new char [ 0 ] ; } if ( ( Arrays . equals ( stateValues . getPassword ( ) . toCharArray ( ) , secondTempChar ) ) == false ) { return new ErrorState ( theConsole , ROOT_LOGGER . passwordMisMatch ( ) , new PromptPasswordState ( theConsole , stateValues , false ) ) ; } return stateValues . groupPropertiesFound ( ) ? new PromptGroupsState ( theConsole , stateValues ) : new PreModificationState ( theConsole , stateValues ) ; } } return new ValidatePasswordState ( theConsole , stateValues ) ; } }
public class Touch extends Task { private interface DateFormatFactory { DateFormat getPrimaryFormat ( ) { } DateFormat getFallbackFormat ( ) { } } private static final Touch . DateFormatFactory DEFAULT_DF_FACTORY = new Touch . DateFormatFactory ( ) { public DateFormat getPrimaryFormat ( ) { } public DateFormat getFallbackFormat ( ) { } } ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File file ; private long millis = - 1 ; private String dateTime ; private Vector filesets = new Vector ( ) ; private Union resources = new Union ( ) ; private boolean dateTimeConfigured ; private boolean mkdirs ; private boolean verbose = true ; private FileNameMapper fileNameMapper = null ; private Touch . DateFormatFactory dfFactory = Touch . DEFAULT_DF_FACTORY ; public Touch ( ) { } public void setFile ( File file ) { } public void setMillis ( long millis ) { } public void setDatetime ( String dateTime ) { } public void setMkdirs ( boolean mkdirs ) { } public void setVerbose ( boolean verbose ) { } public void setPattern ( final String pattern ) { } public void addConfiguredMapper ( Mapper mapper ) { } public void add ( FileNameMapper fileNameMapper ) throws BuildException { } public void addFileset ( FileSet set ) { } public void addFilelist ( FileList list ) { } public void add ( ResourceCollection rc ) { } protected synchronized void checkConfiguration ( ) throws BuildException { } public void execute ( ) throws BuildException { } protected void touch ( ) throws BuildException { } protected void touch ( File file ) { } private long getTimestamp ( ) { } private void touch ( Resource r , long defaultTimestamp ) { if ( ( fileNameMapper ) == null ) { if ( r instanceof FileResource ) { touch ( ( ( FileResource ) ( r ) ) . getFile ( ) , defaultTimestamp ) ; } else { ( ( org . apache . tools . ant . types . resources . Touchable ) ( r ) ) . touch ( defaultTimestamp ) ; } } else { String [ ] mapped = fileNameMapper . mapFileName ( r . getName ( ) ) ; if ( ( mapped != null ) && ( ( mapped . length ) > 0 ) ) { long modTime = ( r . isExists ( ) ) ? r . getLastModified ( ) : defaultTimestamp ; for ( int i = 0 ; i < ( mapped . length ) ; i ++ ) { <START_BUG> touch ( getProject ( ) . resolveFile ( mapped [ i ] ) , modTime ) ; <END_BUG> } } } } private void touch ( File file , long modTime ) { } }
public final class Server { private final ServerCommunicationHandler communicationHandler ; public Server ( ServerCommunicationHandler communicationHandler ) { } public void start ( Standalone serverConf ) throws IOException { } public void stop ( ) throws IOException { } private void sendCommand ( ServerManagerProtocolCommand command ) throws IOException { } private void sendCommand ( ServerManagerProtocolCommand command , Object o ) throws IOException { byte [ ] cmd = ServerManagerProtocolUtils . createCommandBytes ( command , o ) ; <START_BUG> communicationHandler . sendMessage ( cmd , StreamUtils . calculateChecksum ( cmd ) ) ; <END_BUG> } }
public class Main { private static Logger _log = Logger . getLogger ( Main . class ) ; public static final String runMatchArg = "runmatch" ; public static void main ( String [ ] args ) { } private static void createMockData ( Master master ) throws IOException { } private static void createWebAdmin ( ) { } private static void createDirectoryStructure ( boolean isServer ) { } private static void archiveFile ( TarArchiveOutputStream out , String prefix , String fileName , FilenameFilter filter ) throws IOException { } private static void createWorkerTarball ( ) { String targetName = "bs-worker.tar.gz" ; String finalTargetName = ( "static" + ( File . separator ) ) + targetName ; <START_BUG> String [ ] tarFiles = new String [ ] { "README" , "COPYING" , "run.sh" , "run.bat" , "lib" , "static" , "bs-tester.jar" } ; <END_BUG> File finalFile = new File ( finalTargetName ) ; if ( finalFile . exists ( ) ) { return ; } TarArchiveOutputStream out = null ; try { out = new TarArchiveOutputStream ( new GZIPOutputStream ( new BufferedOutputStream ( new FileOutputStream ( targetName ) ) ) ) ; for ( String fileName : tarFiles ) { Main . archiveFile ( out , ( "bs-worker" + ( File . separator ) ) , fileName , new FilenameFilter ( ) { String [ ] prefixes = new String [ ] { ( Config . libDir ) + "jetty" , ( Config . libDir ) + "servlet-api" } ; @ Override public boolean accept ( File dir , String name ) { for ( String p : prefixes ) { if ( name . startsWith ( p ) ) { return false ; } } return true ; } } ) ; } out . finish ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( out != null ) out . close ( ) ; } catch ( IOException e ) { } } File tFile = new File ( targetName ) ; try { FileUtils . moveFile ( tFile , finalFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
public class TestWildcardRandom extends LuceneTestCase { private IndexSearcher searcher ; private IndexReader reader ; private Directory dir ; @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; dir = newDirectory ( ) ; RandomIndexWriter writer = new RandomIndexWriter ( random , dir , newIndexWriterConfig ( TEST_VERSION_CURRENT , new org . apache . lucene . analysis . MockAnalyzer ( random ) ) . setMaxBufferedDocs ( _TestUtil . nextInt ( random , 50 , 1000 ) ) ) ; Document doc = new Document ( ) ; Field field = newField ( "field" , "" , TYPE_UNSTORED ) ; doc . add ( field ) ; NumberFormat df = new DecimalFormat ( "000" , new DecimalFormatSymbols ( Locale . ENGLISH ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { <START_BUG> field . setValue ( df . format ( i ) ) ; <END_BUG> writer . addDocument ( doc ) ; } reader = writer . getReader ( ) ; searcher = newSearcher ( reader ) ; writer . close ( ) ; if ( VERBOSE ) { System . out . println ( ( "TEST:<seq2seq4repair_space>setUp<seq2seq4repair_space>searcher=" + ( searcher ) ) ) ; } } private char N ( ) { } private String fillPattern ( String wildcardPattern ) { } private void assertPatternHits ( String pattern , int numHits ) throws Exception { } @ Override public void tearDown ( ) throws Exception { } public void testWildcards ( ) throws Exception { } }
public class BeanShell extends AbstractFunction implements Serializable { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final long serialVersionUID = 1L ; private static final List desc = new LinkedList ( ) ; private static final String KEY = "__BeanShell" ; public static final String INIT_FILE = "beanshell.function.init" ; private transient Object [ ] values ; private transient BeanShellInterpreter bshInterpreter = null ; public BeanShell ( ) { } public Object clone ( ) throws CloneNotSupportedException { } public synchronized String execute ( SampleResult previousResult , Sampler currentSampler ) throws InvalidVariableException { } public void log_info ( String s ) { } public synchronized void setParameters ( Collection parameters ) throws InvalidVariableException { values = parameters . toArray ( ) ; if ( ( ( values . length ) < 1 ) || ( ( values . length ) > 2 ) ) { throw new InvalidVariableException ( ( "Expecting<seq2seq4repair_space>1<seq2seq4repair_space>or<seq2seq4repair_space>2<seq2seq4repair_space>parameters,<seq2seq4repair_space>but<seq2seq4repair_space>found<seq2seq4repair_space>" + ( values . length ) ) ) ; } try { <START_BUG> bshInterpreter = new BeanShellInterpreter ( BeanShell . INIT_FILE , BeanShell . log ) ; <END_BUG> } catch ( ClassNotFoundException e ) { throw new InvalidVariableException ( "BeanShell<seq2seq4repair_space>not<seq2seq4repair_space>found" ) ; } } public String getReferenceKey ( ) { } public List getArgumentDesc ( ) { } }
public class AttachmentLoader extends AsyncTaskLoader < List < VkAttachment > > { public static final String ARGS_POST_ID = "postId" ; private String mPostId ; public AttachmentLoader ( Context context , Bundle args ) { } @ Override public List < VkAttachment > loadInBackground ( ) { List < VkAttachment > attachments = new ArrayList < > ( ) ; ContentResolver contentResolver = getContext ( ) . getContentResolver ( ) ; Cursor cursor = contentResolver . query ( CONTENT_URI , COLUMNS , ( ( AttachmentContract . COLUMN_POST_ID ) + "<seq2seq4repair_space>=<seq2seq4repair_space>?" ) , new String [ ] { mPostId } , null ) ; <START_BUG> if ( ( cursor != null ) && ( ( cursor . getCount ( ) ) > 0 ) ) { <END_BUG> Gson gson = new Gson ( ) ; try { cursor . moveToFirst ( ) ; while ( ! ( cursor . isAfterLast ( ) ) ) { String type = CursorUtils . getString ( cursor , COLUMN_TYPE ) ; String body = CursorUtils . getString ( cursor , COLUMN_OBJECT ) ; VkAttachment attachment = null ; try { switch ( type ) { case VkPostedPhoto . TYPE : case VkPhoto . TYPE : attachment = gson . fromJson ( body , VkPhoto . class ) ; break ; case VkLink . TYPE : attachment = gson . fromJson ( body , VkLink . class ) ; break ; case VkAudio . TYPE : attachment = gson . fromJson ( body , VkAudio . class ) ; break ; case VkDoc . TYPE : attachment = gson . fromJson ( body , VkDoc . class ) ; break ; case VkVideo . TYPE : attachment = gson . fromJson ( body , VkVideo . class ) ; break ; default : break ; } } catch ( Exception e ) { ErrorHandler . handleError ( this , e ) ; attachment = null ; } if ( attachment != null ) { attachments . add ( attachment ) ; } cursor . moveToNext ( ) ; } } finally { cursor . close ( ) ; } } return attachments ; } @ Override protected void onStartLoading ( ) { } No newline ; at end ; of file ; }
public class SimpleName extends Name { private static final String MISSING_IDENTIFIER = "MISSING" ; private String identifier = SimpleName . MISSING_IDENTIFIER ; SimpleName ( AST ast ) { } ASTNode clone ( AST target ) { } boolean equalSubtrees ( Object other ) { } void accept0 ( ASTVisitor visitor ) { } public String getIdentifier ( ) { } public void setIdentifier ( String identifier ) { if ( identifier == null ) { throw new IllegalArgumentException ( ) ; } <START_BUG> Scanner scanner = this . getAST ( ) . scanner ; <END_BUG> char [ ] source = identifier . toCharArray ( ) ; scanner . setSourceBuffer ( source ) ; scanner . resetTo ( 0 , source . length ) ; try { int tokenType = scanner . getNextToken ( ) ; switch ( tokenType ) { case Scanner . TokenNameIdentifier : break ; default : throw new IllegalArgumentException ( ) ; } } catch ( InvalidInputException e ) { throw new IllegalArgumentException ( ) ; } modifying ( ) ; this . identifier = identifier ; } int memSize ( ) { } int treeSize ( ) { } }
@ Controller @ RequestMapping ( GDEViewNameConstants . INTERNAL ) public class WithdrawRequestController extends AbstractBaseController { @ Autowired private MailService mailService ; @ Autowired private WithdrawRequestService withdrawRequestService ; @ Autowired private FeaturePermissionService featurePermissionService ; @ Autowired private UserRoleService userRoleService ; @ Autowired private UserService userService ; private static final Logger LOG = LoggerFactory . getLogger ( WithdrawRequestController . class ) ; @ RequestMapping ( WITHDRAWAL_REQUEST_VIEW_WITH_SLASH ) public final ModelAndView withdrawRequestDetails ( final HttpServletRequest httpServletRequest , final HttpServletResponse httpServletResponse , final Model model , @ ModelAttribute ( WITHDRAWAL_REQUEST_FORM ) final WithdrawRequestDetailDto withdrawRequestDetailDto , final BindingResult result , Locale locale ) { try { String homeView = WITHDRAWAL_REQUEST_VIEW ; GdeUser loggedUser = GDESessionFacade . getUser ( httpServletRequest ) ; <START_BUG> locale = GDESessionFacade . getUserLocale ( request ) ; <END_BUG> model . addAttribute ( TAB_LIST , featurePermissionService . getAllFeaturePermissionsByRole ( userRoleService . fetchUserRoleEnumList ( loggedUser ) ) ) ; model . addAttribute ( SELECTED_TAB , WITHDRAW_REQUESTS ) ; model . addAttribute ( "onDeleteMessage" , getMessageSource ( ) . getMessage ( "on.delete.message" , null , locale ) ) ; if ( ( loggedUser . getLastLoginRole ( ) ) == ( RoleEnum . ADMINISTRATOR ) ) { model . addAttribute ( "pageTitle" , getMessageSource ( ) . getMessage ( "role.administrator" , null , locale ) ) ; } else if ( ( loggedUser . getLastLoginRole ( ) ) == ( RoleEnum . SUPERVISOR ) ) { model . addAttribute ( "pageTitle" , getMessageSource ( ) . getMessage ( "supervisor" , null , locale ) ) ; } else if ( ( loggedUser . getLastLoginRole ( ) ) == ( RoleEnum . SUPPORT ) ) { model . addAttribute ( "pageTitle" , getMessageSource ( ) . getMessage ( "role.support" , null , locale ) ) ; } String action = withdrawRequestDetailDto . getActionType ( ) ; if ( ( ACCEPT_WITHDRAWAL . equals ( action ) ) || ( REJECT_WITHDRAWAL . equals ( action ) ) ) { if ( ACCEPT_WITHDRAWAL . equals ( action ) ) { withdrawRequestService . actionWithdrawalRequest ( withdrawRequestDetailDto . getObjId ( ) , ACCEPTED_WITHDRAWAL_STRING ) ; } else { withdrawRequestService . actionWithdrawalRequest ( withdrawRequestDetailDto . getObjId ( ) , REJECTED_WITHDRAWAL_STRING ) ; } MailMetaData mailMetaData = getMailMetaDataForWithdrawMail ( withdrawRequestDetailDto , locale , getApplicationPath ( httpServletRequest ) ) ; Map < String , Object > contextVariables = new HashMap < String , Object > ( ) ; contextVariables . put ( "email" , withdrawRequestDetailDto . getEmail ( ) ) ; String emailBodyContent = VelocityHelper . getScript ( mailMetaData . getTemplateName ( ) , contextVariables ) ; mailService . sendRichContentMail ( mailMetaData , emailBodyContent ) ; } if ( ( withdrawRequestDetailDto . getCurrentPage ( ) ) == null ) { withdrawRequestDetailDto . setCurrentPage ( DEFAULT_CURRENT_PAGE ) ; } if ( ( withdrawRequestDetailDto . getNoOfRecords ( ) ) == null ) { withdrawRequestDetailDto . setNoOfRecords ( DEFAULT_NO_OF_RECORDS_ADMIN_ACTION ) ; } if ( StringUtils . isEmpty ( withdrawRequestDetailDto . getSortParameter ( ) ) ) { withdrawRequestDetailDto . setSortParameter ( "withdraw_request_details.creation_date" ) ; } if ( ( withdrawRequestDetailDto . getIsAscending ( ) ) == null ) { withdrawRequestDetailDto . setIsAscending ( false ) ; } PaginationDataDTO paginationDataDTO = new PaginationDataDTO ( withdrawRequestDetailDto ) ; ArrayList < WithdrawRequestDetailDto > objWithdrawRequestDetailDtoList = ( ( ArrayList < WithdrawRequestDetailDto > ) ( withdrawRequestService . getWithdrawRequestList ( withdrawRequestDetailDto , paginationDataDTO ) ) ) ; Integer noOfPages = getNoOfPages ( paginationDataDTO . getAllRecordsCount ( ) , withdrawRequestDetailDto . getNoOfRecords ( ) ) ; UiPaginationDto paginationDto = new UiPaginationDto ( withdrawRequestDetailDto . getCurrentPage ( ) , noOfPages , WITHDRAWAL_REQUEST_VIEW ) ; model . addAttribute ( "totalRequestCount" , paginationDataDTO . getAllRecordsCount ( ) ) ; model . addAttribute ( "paginationDto" , paginationDto ) ; model . addAttribute ( "objWithdrawRequestDetailDtoList" , objWithdrawRequestDetailDtoList ) ; model . addAttribute ( WITHDRAWAL_REQUEST_FORM , withdrawRequestDetailDto ) ; model . addAttribute ( ON_CANCEL_MESSAGE , getMessageSource ( ) . getMessage ( "on.cancel.message" , null , locale ) ) ; model . addAttribute ( "pagingTitle" , getBaseService ( ) . getPagingTitle ( withdrawRequestDetailDto . getCurrentPage ( ) , withdrawRequestDetailDto . getNoOfRecords ( ) , paginationDataDTO . getAllRecordsCount ( ) ) ) ; return new ModelAndView ( homeView ) ; } catch ( Exception e ) { WithdrawRequestController . LOG . error ( GDEStringUtils . concat ( "Error<seq2seq4repair_space>in<seq2seq4repair_space>sending<seq2seq4repair_space>email<seq2seq4repair_space>:<seq2seq4repair_space>" , withdrawRequestDetailDto . getEmail ( ) ) , e ) ; throw new GDEException ( e ) ; } } private MailMetaData getMailMetaDataForWithdrawMail ( final WithdrawRequestDetailDto withdrawRequestDetailDto , final Locale locale , final String contextpath ) { } }
public class TableItem extends Item { Table parent ; String [ ] strings ; Image [ ] images ; boolean checked ; boolean grayed ; boolean cached ; Color foreground ; Color background ; Color [ ] cellForeground ; Color [ ] cellBackground ; Font font ; Font [ ] cellFont ; int width = - 1 ; public TableItem ( Table parent , int style ) { } public TableItem ( Table parent , int style , int index ) { } TableItem ( Table parent , int style , int index , boolean create ) { } static Table checkNull ( Table control ) { } int calculateWidth ( int index , GC gc ) { } protected void checkSubclass ( ) { } void clear ( ) { } void destroyWidget ( ) { } public Color getBackground ( ) { } public Color getBackground ( int index ) { } public Rectangle getBounds ( ) { } public Rectangle getBounds ( int index ) { } public boolean getChecked ( ) { } public Font getFont ( ) { } public Font getFont ( int index ) { } public Color getForeground ( ) { } public Color getForeground ( int index ) { } public boolean getGrayed ( ) { } public Image getImage ( ) { } public Image getImage ( int index ) { } public Rectangle getImageBounds ( int index ) { } public int getImageIndent ( ) { } String getNameText ( ) { } public Table getParent ( ) { } public String getText ( ) { } public String getText ( int index ) { } public Rectangle getTextBounds ( int index ) { } void redraw ( int propertyID ) { if ( ( parent . currentItem ) == ( this ) ) return ; <START_BUG> if ( ( ( parent . drawCount ) != 0 ) && ( propertyID != ( Table . CHECK_COLUMN_ID ) ) ) <END_BUG> return ; int itemIndex = parent . indexOf ( this ) ; if ( itemIndex == ( - 1 ) ) return ; int [ ] id = new int [ ] { parent . getId ( itemIndex ) } ; OS . UpdateDataBrowserItems ( parent . handle , kDataBrowserNoItem , id . length , id , kDataBrowserItemNoProperty , propertyID ) ; if ( propertyID == ( Table . CHECK_COLUMN_ID ) ) { Rect rect = new Rect ( ) ; if ( ( OS . GetDataBrowserItemPartBounds ( parent . handle , parent . getId ( itemIndex ) , propertyID , kDataBrowserPropertyEnclosingPart , rect ) ) == ( OS . noErr ) ) { int x = rect . left ; int y = ( rect . top ) - 1 ; int width = ( rect . right ) - ( rect . left ) ; int height = 1 ; redrawWidget ( parent . handle , x , y , width , height , false ) ; } } } void releaseHandle ( ) { } void releaseParent ( ) { } void releaseWidget ( ) { } public void setBackground ( Color color ) { } public void setBackground ( int index , Color color ) { } public void setChecked ( boolean checked ) { } void setChecked ( boolean checked , boolean notify ) { } public void setFont ( Font font ) { } public void setFont ( int index , Font font ) { } public void setForeground ( Color color ) { } public void setForeground ( int index , Color color ) { } public void setGrayed ( boolean grayed ) { } public void setImage ( Image [ ] images ) { } public void setImage ( int index , Image image ) { } public void setImage ( Image image ) { } public void setImageIndent ( int indent ) { } public void setText ( String [ ] strings ) { } public void setText ( int index , String string ) { } public void setText ( String string ) { } }
public class DomainRolloutStepHandler implements OperationStepHandler { private final DomainOperationContext domainOperationContext ; private final Map < String , ProxyController > hostProxies ; private final Map < String , ProxyController > serverProxies ; private final ExecutorService executorService ; private final ModelNode providedRolloutPlan ; private final boolean trace = DomainControllerLogger . HOST_CONTROLLER_LOGGER . isTraceEnabled ( ) ; public DomainRolloutStepHandler ( final Map < String , ProxyController > hostProxies , final Map < String , ProxyController > serverProxies , final DomainOperationContext domainOperationContext , final ModelNode rolloutPlan , final ExecutorService executorService ) { } @ Override public void execute ( final OperationContext context , final ModelNode operation ) throws OperationFailedException { if ( context . hasFailureDescription ( ) ) { context . setRollbackOnly ( ) ; <START_BUG> context . completeStep ( ) ; <END_BUG> return ; } boolean pushToServers = ! ( domainOperationContext . hasHostLevelFailures ( ) ) ; if ( pushToServers ) { ModelNode ourResult = domainOperationContext . getCoordinatorResult ( ) ; if ( ourResult . has ( FAILURE_DESCRIPTION ) ) { if ( trace ) { DomainControllerLogger . HOST_CONTROLLER_LOGGER . tracef ( "coordinator<seq2seq4repair_space>failed:<seq2seq4repair_space>%s" , ourResult ) ; } pushToServers = false ; domainOperationContext . setCompleteRollback ( true ) ; } else { if ( trace ) { DomainControllerLogger . HOST_CONTROLLER_LOGGER . tracef ( "coordinator<seq2seq4repair_space>succeeded:<seq2seq4repair_space>%s" , ourResult ) ; } for ( ModelNode hostResult : domainOperationContext . getHostControllerResults ( ) . values ( ) ) { if ( hostResult . has ( FAILURE_DESCRIPTION ) ) { if ( trace ) { DomainControllerLogger . HOST_CONTROLLER_LOGGER . tracef ( "host<seq2seq4repair_space>failed:<seq2seq4repair_space>%s" , hostResult ) ; } pushToServers = false ; domainOperationContext . setCompleteRollback ( true ) ; break ; } } } } if ( pushToServers ) { domainOperationContext . setCompleteRollback ( false ) ; final Map < ServerIdentity , ServerTaskExecutor . ExecutedServerRequest > submittedTasks = new HashMap < ServerIdentity , ServerTaskExecutor . ExecutedServerRequest > ( ) ; final List < ServerTaskExecutor . ServerPreparedResponse > preparedResults = new ArrayList < ServerTaskExecutor . ServerPreparedResponse > ( ) ; try { pushToServers ( context , submittedTasks , preparedResults ) ; context . completeStep ( ) ; } finally { boolean completeRollback = domainOperationContext . isCompleteRollback ( ) ; final String localHostName = domainOperationContext . getLocalHostInfo ( ) . getLocalHostName ( ) ; for ( final ServerTaskExecutor . ServerPreparedResponse preparedResult : preparedResults ) { boolean rollback = completeRollback || ( domainOperationContext . isServerGroupRollback ( preparedResult . getServerGroupName ( ) ) ) ; if ( ! ( preparedResult . finalizeTransaction ( ( ! rollback ) ) ) ) { final ServerIdentity identity = preparedResult . getServerIdentity ( ) ; try { final ModelNode result = preparedResult . getPreparedOperation ( ) . getPreparedResult ( ) ; ProxyController proxy = hostProxies . get ( identity . getHostName ( ) ) ; if ( proxy == null ) { if ( localHostName . equals ( identity . getHostName ( ) ) ) { proxy = serverProxies . get ( identity . getServerName ( ) ) ; if ( proxy == null ) { if ( trace ) { DomainControllerLogger . HOST_CONTROLLER_LOGGER . tracef ( "No<seq2seq4repair_space>proxy<seq2seq4repair_space>for<seq2seq4repair_space>%s" , identity ) ; } continue ; } } } final Future < ModelNode > future = executorService . submit ( new ServerRequireRestartTask ( identity , proxy , result ) ) ; submittedTasks . put ( identity , new ServerTaskExecutor . ExecutedServerRequest ( identity , future ) ) ; } catch ( Exception ignore ) { } } } boolean interrupted = false ; try { for ( Map . Entry < ServerIdentity , ServerTaskExecutor . ExecutedServerRequest > entry : submittedTasks . entrySet ( ) ) { final ServerTaskExecutor . ExecutedServerRequest request = entry . getValue ( ) ; final Future < ModelNode > future = request . getFinalResult ( ) ; try { final ModelNode finalResult = ( future . isCancelled ( ) ) ? getCancelledResult ( ) : future . get ( ) ; final ModelNode transformedResult = request . transformResult ( finalResult ) ; domainOperationContext . addServerResult ( entry . getKey ( ) , transformedResult ) ; } catch ( InterruptedException e ) { interrupted = true ; DomainControllerLogger . HOST_CONTROLLER_LOGGER . interruptedAwaitingFinalResponse ( entry . getKey ( ) . getServerName ( ) , entry . getKey ( ) . getHostName ( ) ) ; } catch ( ExecutionException e ) { DomainControllerLogger . HOST_CONTROLLER_LOGGER . caughtExceptionAwaitingFinalResponse ( e . getCause ( ) , entry . getKey ( ) . getServerName ( ) , entry . getKey ( ) . getHostName ( ) ) ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } } else { reportHostFailures ( context , operation ) ; context . completeStep ( ) ; } } private ModelNode getCancelledResult ( ) { } private void pushToServers ( final OperationContext context , final Map < ServerIdentity , ServerTaskExecutor . ExecutedServerRequest > submittedTasks , final List < ServerTaskExecutor . ServerPreparedResponse > preparedResults ) throws OperationFailedException { } private Map < String , Map < ServerIdentity , ModelNode > > getOpsByGroup ( Map < String , ModelNode > hostResults ) { } private ModelNode translateDomainMappedOperation ( final ModelNode domainMappedOperation ) { } private ModelNode getRolloutPlan ( ModelNode rolloutPlan , Map < String , Map < ServerIdentity , ModelNode > > opsByGroup ) throws OperationFailedException { } private void validateServerGroupPlan ( Set < String > found , Property prop ) throws OperationFailedException { } private ModelNode getDefaultRolloutPlan ( Map < String , Map < ServerIdentity , ModelNode > > opsByGroup ) { } private void reportHostFailures ( final OperationContext context , final ModelNode operation ) { } private boolean collectDomainFailure ( OperationContext context , final boolean isDomain ) { } private boolean collectHostFailures ( final OperationContext context , final boolean isDomain ) { } private boolean isDomainOperation ( final ModelNode operation ) { } }
public class LFUCache < K , V > implements SolrCache < K , V > { private List < ConcurrentLFUCache . Stats > statsList ; private long warmupTime = 0 ; private String name ; private int autowarmCount ; private State state ; private CacheRegenerator regenerator ; private String description = "Concurrent<seq2seq4repair_space>LFU<seq2seq4repair_space>Cache" ; private ConcurrentLFUCache < K , V > cache ; private int showItems = 0 ; private Boolean timeDecay = true ; @ Override public Object init ( Map args , Object persistence , CacheRegenerator regenerator ) { } @ Override public String name ( ) { } @ Override public int size ( ) { } @ Override public V put ( K key , V value ) { } @ Override public V get ( K key ) { } @ Override public void clear ( ) { } @ Override public void setState ( State state ) { } @ Override public State getState ( ) { } @ Override public void warm ( SolrIndexSearcher searcher , SolrCache old ) { if ( ( regenerator ) == null ) return ; long warmingStartTime = System . currentTimeMillis ( ) ; LFUCache other = ( ( LFUCache ) ( old ) ) ; if ( ( autowarmCount ) != 0 ) { int sz = other . size ( ) ; if ( ( autowarmCount ) != ( - 1 ) ) sz = Math . min ( sz , autowarmCount ) ; Map items = other . cache . getMostUsedItems ( sz ) ; Map . Entry [ ] itemsArr = new Map . Entry [ items . size ( ) ] ; int counter = 0 ; for ( Object mapEntry : items . entrySet ( ) ) { itemsArr [ ( counter ++ ) ] = ( ( Map . Entry ) ( mapEntry ) ) ; } for ( int i = ( itemsArr . length ) - 1 ; i >= 0 ; i -- ) { try { boolean continueRegen = regenerator . regenerateItem ( searcher , this , old , itemsArr [ i ] . getKey ( ) , itemsArr [ i ] . getValue ( ) ) ; if ( ! continueRegen ) break ; <START_BUG> } catch ( Throwable e ) { <END_BUG> SolrException . log ( log , ( "Error<seq2seq4repair_space>during<seq2seq4repair_space>auto-warming<seq2seq4repair_space>of<seq2seq4repair_space>key:" + ( itemsArr [ i ] . getKey ( ) ) ) , e ) ; } } } warmupTime = ( System . currentTimeMillis ( ) ) - warmingStartTime ; } @ Override public void close ( ) { } @ Override public String getName ( ) { } @ Override public String getVersion ( ) { } @ Override public String getDescription ( ) { } @ Override public Category getCategory ( ) { } @ Override public String getSource ( ) { } @ Override public URL [ ] getDocs ( ) { } private static String calcHitRatio ( long lookups , long hits ) { } @ Override public NamedList getStatistics ( ) { } @ Override public String toString ( ) { } }
public class LZMACompressorInputStream extends CompressorInputStream { private final InputStream in ; public LZMACompressorInputStream ( InputStream inputStream ) throws IOException { } @ Override public int read ( ) throws IOException { int ret = in . read ( ) ; <START_BUG> count ( ( ret == ( - 1 ) ? - 1 : 1 ) ) ; <END_BUG> return ret ; } @ Override public int read ( byte [ ] buf , int off , int len ) throws IOException { } @ Override public long skip ( long n ) throws IOException { } @ Override public int available ( ) throws IOException { } @ Override public void close ( ) throws IOException { } }
public class VariantStatisticsCalculator { private static final String BATCH_SIZE = "batchSize" ; private final JsonFactory jsonFactory ; private ObjectMapper jsonObjectMapper ; protected static Logger logger = LoggerFactory . getLogger ( VariantStatisticsCalculator . class ) ; private String VARIANT_STATS_SUFFIX = ".variants.stats.json.gz" ; private String SOURCE_STATS_SUFFIX = ".source.stats.json.gz" ; public VariantStatisticsCalculator ( ) { } public URI createStats ( VariantDBAdaptor variantDBAdaptor , URI output , QueryOptions options ) throws IOException { OutputStream outputVariantsStream ; Path fileVariantsPath = Paths . get ( ( ( output . getPath ( ) ) + ( VARIANT_STATS_SUFFIX ) ) ) ; outputVariantsStream = new FileOutputStream ( fileVariantsPath . toFile ( ) ) ; VariantStatisticsCalculator . logger . info ( "will<seq2seq4repair_space>write<seq2seq4repair_space>stats<seq2seq4repair_space>to<seq2seq4repair_space>{}" , fileVariantsPath ) ; if ( ( options != null ) && ( options . getBoolean ( "gzip" , true ) ) ) { outputVariantsStream = new GZIPOutputStream ( outputVariantsStream ) ; } OutputStream outputSourceStream ; Path fileSourcePath = Paths . get ( ( ( output . getPath ( ) ) + ( SOURCE_STATS_SUFFIX ) ) ) ; outputSourceStream = new FileOutputStream ( fileSourcePath . toFile ( ) ) ; VariantStatisticsCalculator . logger . info ( "will<seq2seq4repair_space>write<seq2seq4repair_space>source<seq2seq4repair_space>stats<seq2seq4repair_space>to<seq2seq4repair_space>{}" , fileSourcePath ) ; if ( ( options != null ) && ( options . getBoolean ( "gzip" , true ) ) ) { outputSourceStream = new GZIPOutputStream ( outputSourceStream ) ; } ObjectWriter variantsWriter = jsonObjectMapper . writerWithType ( VariantStatsWrapper . class ) ; ObjectWriter sourceWriter = jsonObjectMapper . writerWithType ( VariantSourceStats . class ) ; QueryOptions iteratorQueryOptions = new QueryOptions ( ) ; if ( options != null ) { iteratorQueryOptions = options ; } List < String > include = Arrays . asList ( "chromosome" , "start" , "end" , "alternative" , "reference" , "sourceEntries" ) ; iteratorQueryOptions . add ( "include" , include ) ; VariantSource variantSource = options . get ( VARIANT_SOURCE , VariantSource . class ) ; VariantSourceStats variantSourceStats = new VariantSourceStats ( variantSource . getFileId ( ) , variantSource . getStudyId ( ) ) ; VariantStatisticsCalculator . logger . info ( "starting<seq2seq4repair_space>stats<seq2seq4repair_space>calculation" ) ; long start = System . currentTimeMillis ( ) ; Iterator < Variant > iterator = variantDBAdaptor . iterator ( iteratorQueryOptions ) ; int skippedFiles = 0 ; while ( iterator . hasNext ( ) ) { Variant variant = iterator . next ( ) ; VariantSourceEntry file = variant . getSourceEntry ( variantSource . getFileId ( ) , variantSource . getStudyId ( ) ) ; if ( file == null ) { skippedFiles ++ ; continue ; } VariantStats variantStats = new VariantStats ( variant ) ; file . setStats ( variantStats . calculate ( file . getSamplesData ( ) , file . getAttributes ( ) , null ) ) ; VariantStatsWrapper variantStatsWrapper = new VariantStatsWrapper ( variant . getChromosome ( ) , variant . getStart ( ) , variantStats ) ; outputVariantsStream . write ( variantsWriter . writeValueAsString ( variantStatsWrapper ) . getBytes ( ) ) ; variantSourceStats . updateFileStats ( Collections . singletonList ( variant ) ) ; variantSourceStats . updateSampleStats ( Collections . singletonList ( variant ) , variantSource . getPedigree ( ) ) ; } VariantStatisticsCalculator . logger . info ( "finishing<seq2seq4repair_space>stats<seq2seq4repair_space>calculation,<seq2seq4repair_space>time:<seq2seq4repair_space>{}ms" , ( ( System . currentTimeMillis ( ) ) - start ) ) ; if ( skippedFiles != 0 ) { VariantStatisticsCalculator . logger . warn ( "the<seq2seq4repair_space>sources<seq2seq4repair_space>in<seq2seq4repair_space>{}<seq2seq4repair_space>variants<seq2seq4repair_space>were<seq2seq4repair_space>not<seq2seq4repair_space>found,<seq2seq4repair_space>and<seq2seq4repair_space>therefore<seq2seq4repair_space>couldn't<seq2seq4repair_space>run<seq2seq4repair_space>its<seq2seq4repair_space>stats" , skippedFiles ) ; VariantStatisticsCalculator . logger . info ( "note:<seq2seq4repair_space>maybe<seq2seq4repair_space>the<seq2seq4repair_space>file-id<seq2seq4repair_space>and<seq2seq4repair_space>study-id<seq2seq4repair_space>were<seq2seq4repair_space>not<seq2seq4repair_space>correct?" ) ; } outputSourceStream . write ( sourceWriter . writeValueAsString ( variantSourceStats ) . getBytes ( ) ) ; outputVariantsStream . close ( ) ; outputSourceStream . close ( ) ; <START_BUG> return fileVariantsPath . toUri ( ) ; <END_BUG> } public void loadStats ( VariantDBAdaptor variantDBAdaptor , URI uri , QueryOptions options ) throws IOException { } public void loadVariantStats ( VariantDBAdaptor variantDBAdaptor , URI uri , QueryOptions options ) throws IOException { } public void loadSourceStats ( VariantDBAdaptor variantDBAdaptor , URI uri , QueryOptions options ) throws IOException { } }
class ButtonTab extends AlignableTab { Button button1 ; Button button2 ; Button button3 ; Button button4 ; Button button5 ; Button button6 ; Group textButtonGroup ; Group imageButtonGroup ; Button upButton ; Button downButton ; Button pushButton ; Button checkButton ; Button radioButton ; Button toggleButton ; Button arrowButton ; Button flatButton ; ButtonTab ( ControlExample instance ) { } void createControlGroup ( ) { } void createExampleGroup ( ) { } void createExampleWidgets ( ) { } void createStyleGroup ( ) { } Control [ ] getExampleWidgets ( ) { } String [ ] getMethodNames ( ) { <START_BUG> return new String [ ] { "Selection" , "Text" } ; <END_BUG> } String getTabText ( ) { } void setExampleWidgetAlignment ( ) { } void setExampleWidgetState ( ) { } }
public class StatusBarManagerService extends IStatusBarService . Stub { private static final String TAG = "StatusBarManagerService" ; private static final boolean SPEW = false ; private final Context mContext ; private final WindowManagerService mWindowManager ; private Handler mHandler = new Handler ( ) ; private NotificationDelegate mNotificationDelegate ; private volatile IStatusBar mBar ; private StatusBarIconList mIcons = new StatusBarIconList ( ) ; private final ArrayList < StatusBarManagerService . DisableRecord > mDisableRecords = new ArrayList < StatusBarManagerService . DisableRecord > ( ) ; private IBinder mSysUiVisToken = new Binder ( ) ; private int mDisabled1 = 0 ; private int mDisabled2 = 0 ; private Object mLock = new Object ( ) ; private int mSystemUiVisibility = 0 ; private boolean mMenuVisible = false ; private int mImeWindowVis = 0 ; private int mImeBackDisposition ; private boolean mShowImeSwitcher ; private IBinder mImeToken = null ; private int mCurrentUserId ; private class DisableRecord implements IBinder . DeathRecipient { int userId ; String pkg ; int what1 ; int what2 ; IBinder token ; public void binderDied ( ) { } } public StatusBarManagerService ( Context context , WindowManagerService windowManager ) { } private final StatusBarManagerInternal mInternalService = new StatusBarManagerInternal ( ) { private boolean mNotificationLightOn ; @ Override public void setNotificationDelegate ( NotificationDelegate delegate ) { } @ Override public void buzzBeepBlinked ( ) { } @ Override public void notificationLightPulse ( int argb , int onMillis , int offMillis ) { } @ Override public void notificationLightOff ( ) { } @ Override public void showScreenPinningRequest ( ) { } @ Override public void showAssistDisclosure ( ) { } @ Override public void startAssist ( Bundle args ) { } @ Override public void onCameraLaunchGestureDetected ( int source ) { } } ; @ Override public void expandNotificationsPanel ( ) { } @ Override public void collapsePanels ( ) { } @ Override public void expandSettingsPanel ( ) { } @ Override public void disable ( int what , IBinder token , String pkg ) { } @ Override public void disableForUser ( int what , IBinder token , String pkg , int userId ) { } @ Override public void disable2 ( int what , IBinder token , String pkg ) { <START_BUG> disableForUser ( what , token , pkg , mCurrentUserId ) ; <END_BUG> } @ Override public void disable2ForUser ( int what , IBinder token , String pkg , int userId ) { } private void disableLocked ( int userId , int what , IBinder token , String pkg , int whichFlag ) { } @ Override public void setIcon ( String slot , String iconPackage , int iconId , int iconLevel , String contentDescription ) { } @ Override public void setIconVisibility ( String slot , boolean visible ) { } @ Override public void removeIcon ( String slot ) { } @ Override public void topAppWindowChanged ( final boolean menuVisible ) { } @ Override public void setImeWindowStatus ( final IBinder token , final int vis , final int backDisposition , final boolean showImeSwitcher ) { } @ Override public void setSystemUiVisibility ( int vis , int mask , String cause ) { } private void updateUiVisibilityLocked ( final int vis , final int mask ) { } @ Override public void toggleRecentApps ( ) { } @ Override public void preloadRecentApps ( ) { } @ Override public void cancelPreloadRecentApps ( ) { } @ Override public void showRecentApps ( boolean triggeredFromAltTab ) { } @ Override public void hideRecentApps ( boolean triggeredFromAltTab , boolean triggeredFromHomeKey ) { } @ Override public void setCurrentUser ( int newUserId ) { } @ Override public void setWindowState ( int window , int state ) { } @ Override public void appTransitionPending ( ) { } @ Override public void appTransitionCancelled ( ) { } @ Override public void appTransitionStarting ( long statusBarAnimationsStartTime , long statusBarAnimationsDuration ) { } @ Override public void startAssist ( Bundle args ) { } @ Override public void setAutoRotate ( boolean enabled ) { } private void enforceStatusBar ( ) { } private void enforceExpandStatusBar ( ) { } private void enforceStatusBarService ( ) { } @ Override public void registerStatusBar ( IStatusBar bar , StatusBarIconList iconList , int [ ] switches , List < IBinder > binders ) { } @ Override public void onPanelRevealed ( boolean clearNotificationEffects , int numItems ) { } @ Override public void clearNotificationEffects ( ) throws RemoteException { } @ Override public void onPanelHidden ( ) throws RemoteException { } @ Override public void onNotificationClick ( String key ) { } @ Override public void onNotificationActionClick ( String key , int actionIndex ) { } @ Override public void onNotificationError ( String pkg , String tag , int id , int uid , int initialPid , String message , int userId ) { } @ Override public void onNotificationClear ( String pkg , String tag , int id , int userId ) { } @ Override public void onNotificationVisibilityChanged ( NotificationVisibility [ ] newlyVisibleKeys , NotificationVisibility [ ] noLongerVisibleKeys ) throws RemoteException { } @ Override public void onNotificationExpansionChanged ( String key , boolean userAction , boolean expanded ) throws RemoteException { } @ Override public void onClearAllNotifications ( int userId ) { } void manageDisableListLocked ( int userId , int what , IBinder token , String pkg , int which ) { } int gatherDisableActionsLocked ( int userId , int which ) { } protected void dump ( FileDescriptor fd , PrintWriter pw , String [ ] args ) { } }
public class Completor { public CompletionResult getCompletions ( String command , int tabPosition , ExecutableLocator executableLocator ) { } private boolean isCompleteMatchWithCompleteAncestry ( CompletionSpecRoot completionSpecRoot , List < String > arguments ) { } private CompletionResult createCompletionResult ( String command , int tabPosition , String argumentToComplete , List < String > completions ) { final boolean onlyOneCompletion = ( completions . size ( ) ) == 1 ; <START_BUG> final int idx = command . lastIndexOf ( argumentToComplete ) ; <END_BUG> final String completion = ( onlyOneCompletion ) ? ( completions . get ( 0 ) ) + "<seq2seq4repair_space>" : getCommonStartOfStrings ( completions ) ; final String newText = ( ( command . substring ( 0 , idx ) ) + completion ) + ( command . substring ( ( idx + ( argumentToComplete . length ( ) ) ) ) ) ; final int newTabPosition = tabPosition + ( ( completion . length ( ) ) - ( argumentToComplete . length ( ) ) ) ; return new CompletionResult ( newTabPosition , newText , ( onlyOneCompletion ? Collections . emptyList ( ) : completions ) ) ; } private Command getCommandToComplete ( String commandUpToTab ) { } private List < String > getArguments ( String commandUpToTab , Command commandToComplete ) { } private boolean lastArgumentIsBlank ( String command , Command commandToComplete ) { } private List < String > getCompletions ( CompletionSpecRoot completionSpecRoot , List < String > arguments ) { } private List < String > findMostDeeplyNestedCompletions ( String argumentToComplete , List < CompletionSpec > complectionSpecs ) { } private List < CompletionSpec > findNodesWithCorrectOccurenceCount ( List < CompletionSpec > completionSpecs , List < String > arguments ) { } private List < CompletionSpec > findNodesWithCompleteAncestry ( List < CompletionSpec > completionSpecs , List < String > arguments ) { } private boolean hasCompleteAncestry ( CompletionSpec completionSpec , List < String > arguments ) { } private List < CompletionSpec > findPartialMatchingNodes ( CompletionSpec completionSpec , String argument ) { } private List < CompletionSpec > findCompleteMatchingNodes ( CompletionSpec completionSpec , String argument ) { } private int getDepth ( CompletionSpec completionSpec ) { } No newline ; at end ; of file ; }
public class JPAAnnotationParseProcessor implements DeploymentUnitProcessor { private static final DotName PERSISTENCE_CONTEXT_ANNOTATION_NAME = DotName . createSimple ( PersistenceContext . class . getName ( ) ) ; private static final DotName PERSISTENCE_UNIT_ANNOTATION_NAME = DotName . createSimple ( PersistenceUnit . class . getName ( ) ) ; private static final String ENTITY_MANAGER_CLASS = "javax.persistence.EntityManager" ; private static final String ENTITY_MANAGERFACTORY_CLASS = "javax.persistence.EntityManagerFactory" ; @ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { } @ Override public void undeploy ( DeploymentUnit context ) { } private void processPersistenceAnnotations ( final DeploymentUnit deploymentUnit , final EEModuleDescription eeModuleDescription , List < AnnotationInstance > persistenceContexts ) throws DeploymentUnitProcessingException { } private void processField ( final DeploymentUnit deploymentUnit , final AnnotationInstance annotation , final FieldInfo fieldInfo , final EEModuleClassDescription eeModuleClassDescription ) throws DeploymentUnitProcessingException { } private void processMethod ( final DeploymentUnit deploymentUnit , final AnnotationInstance annotation , final MethodInfo methodInfo , final EEModuleClassDescription eeModuleClassDescription ) throws DeploymentUnitProcessingException { } private void processClass ( final DeploymentUnit deploymentUnit , final AnnotationInstance annotation , final ClassInfo classInfo , final EEModuleClassDescription eeModuleClassDescription ) throws DeploymentUnitProcessingException { } private InjectionSource getBindingSource ( final DeploymentUnit deploymentUnit , final AnnotationInstance annotation , String injectionTypeName ) throws DeploymentUnitProcessingException { String scopedPuName = getScopedPuName ( deploymentUnit , annotation ) ; ServiceName puServiceName = getPuServiceName ( scopedPuName ) ; if ( isPersistenceContext ( annotation ) ) { AnnotationValue pcType = annotation . value ( "type" ) ; PersistenceContextType type = ( ( pcType == null ) || ( TRANSACTION . name ( ) . equals ( pcType . asString ( ) ) ) ) ? PersistenceContextType . TRANSACTION : PersistenceContextType . EXTENDED ; Map properties ; AnnotationValue value = annotation . value ( "properties" ) ; AnnotationInstance [ ] props = ( value != null ) ? value . asNestedArray ( ) : null ; if ( props != null ) { properties = new HashMap ( ) ; for ( int source = 0 ; source < ( props . length ) ; source ++ ) { properties . put ( props [ source ] . value ( "name" ) , props [ source ] . value ( "value" ) ) ; } } else { properties = null ; } return new org . jboss . as . jpa . injectors . PersistenceContextInjectionSource ( type , properties , puServiceName , deploymentUnit , scopedPuName , injectionTypeName ) ; } else { <START_BUG> return new org . jboss . as . jpa . injectors . PersistenceUnitInjectionSource ( puServiceName , deploymentUnit , scopedPuName , injectionTypeName ) ; <END_BUG> } } private boolean isExtendedPersistenceContext ( final AnnotationInstance annotation ) { } private boolean isPersistenceContext ( final AnnotationInstance annotation ) { } private String getClassLevelInjectionType ( final AnnotationInstance annotation ) { } private String getScopedPuName ( final DeploymentUnit deploymentUnit , final AnnotationInstance annotation ) throws DeploymentUnitProcessingException { } private ServiceName getPuServiceName ( String scopedPuName ) throws DeploymentUnitProcessingException { } private void registerInterceptorsForExtendedPersistenceContext ( SessionBeanComponentDescription componentDescription , AnnotationInstance annotation ) { } }
public class SendAllMessagesCommand extends FolderCommand { protected SendListManager sendListManager = new SendListManager ( ) ; protected OutboxFolder outboxFolder ; public SendAllMessagesCommand ( AbstractFrameController frameController , DefaultCommandReference [ ] references ) { } public void execute ( Worker worker ) throws Exception { FolderCommandReference [ ] r = ( ( FolderCommandReference [ ] ) ( getReferences ( ) ) ) ; worker . setDisplayText ( MailResourceLoader . getString ( "statusbar" , "message" , "send_message" ) ) ; outboxFolder = ( ( OutboxFolder ) ( r [ 0 ] . getFolder ( ) ) ) ; Object [ ] uids = outboxFolder . getUids ( ) ; for ( int i = 0 ; i < ( uids . length ) ; i ++ ) { if ( ( outboxFolder . exists ( uids [ i ] ) ) == true ) { SendableMessage message = ( ( SendableMessage ) ( outboxFolder . getMessage ( uids [ i ] ) ) ) ; sendListManager . add ( message ) ; } } int actAccountUid = - 1 ; List sentList = new Vector ( ) ; boolean open = false ; SMTPServer smtpServer = null ; Folder sentFolder = null ; while ( sendListManager . hasMoreMessages ( ) ) { SendableMessage message = sendListManager . getNextMessage ( ) ; if ( ( message . getAccountUid ( ) ) != actAccountUid ) { actAccountUid = message . getAccountUid ( ) ; AccountItem accountItem = MailConfig . getAccountList ( ) . uidGet ( actAccountUid ) ; sentFolder = ( ( Folder ) ( treeModel . getFolder ( Integer . parseInt ( accountItem . getSpecialFoldersItem ( ) . get ( "sent" ) ) ) ) ) ; smtpServer = new SMTPServer ( accountItem ) ; open = smtpServer . openConnection ( ) ; ( ( StatusObservableImpl ) ( smtpServer . getObservable ( ) ) ) . setWorker ( worker ) ; } if ( open ) { try { smtpServer . sendMessage ( message , worker ) ; <START_BUG> sentList . add ( message . getHeaderInterface ( ) . get ( "columba.uid" ) ) ; <END_BUG> } catch ( SMTPException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "Error<seq2seq4repair_space>while<seq2seq4repair_space>sending" , JOptionPane . ERROR_MESSAGE ) ; } } } worker . clearDisplayTextWithDelay ( ) ; if ( ( sentList . size ( ) ) > 0 ) { moveToSentFolder ( sentList , sentFolder ) ; sentList . clear ( ) ; } } protected void moveToSentFolder ( List v , Folder sentFolder ) { } }
public final class ExtensionCommandRegistry extends AbstractCommandRegistry { private List activeKeyConfigurationDefinitions ; private List contextBindingDefinitions ; private List categoryDefinitions ; private List commandDefinitions ; private IExtensionRegistry extensionRegistry ; private List handlers ; private List imageBindingDefinitions ; private List keyConfigurationDefinitions ; private List keySequenceBindingDefinitions ; public ExtensionCommandRegistry ( IExtensionRegistry extensionRegistry ) { } private String getPluginId ( IConfigurationElement configurationElement ) { String pluginId = null ; if ( configurationElement != null ) { IExtension extension = configurationElement . getDeclaringExtension ( ) ; if ( extension != null ) <START_BUG> pluginId = extension . getParentIdentifier ( ) ; <END_BUG> } return pluginId ; } private void load ( ) throws IOException { } private void readActiveKeyConfigurationDefinition ( IConfigurationElement configurationElement ) { } private void readContextBindingDefinition ( IConfigurationElement configurationElement ) { } private void readCategoryDefinition ( IConfigurationElement configurationElement ) { } private void readCommandDefinition ( IConfigurationElement configurationElement ) { } private final void readHandlerSubmissionDefinition ( final IConfigurationElement configurationElement ) { } private void readImageBindingDefinition ( IConfigurationElement configurationElement ) { } private void readKeyConfigurationDefinition ( IConfigurationElement configurationElement ) { } private void readKeySequenceBindingDefinition ( IConfigurationElement configurationElement ) { } }
public class BasicStrategy implements IStrategy { private ArrayList < BasicStrategy > strategies = new ArrayList < BasicStrategy > ( ) ; private ArrayList < IAction > actions = new ArrayList < IAction > ( ) ; protected BasicStrategy ( ArrayList < BasicStrategy > strategies , ArrayList < IAction > actions ) { } public void apply ( TickDataSet set , Positions positions ) { for ( IAction action : actions ) { ActionResult actionResult = action . run ( set ) ; <START_BUG> if ( actionResult . hasAction ( ) ) <END_BUG> positions . addPosition ( actionResult . getPosition ( ) ) ; } for ( IStrategy strategy : strategies ) { strategy . apply ( set , positions ) ; } } }
public class CachingConnectionFactory extends SingleConnectionFactory { private int sessionCacheSize = 1 ; private boolean cacheProducers = true ; private boolean cacheConsumers = true ; private volatile boolean active = true ; private final Map < Integer , LinkedList < Session > > cachedSessions = new HashMap < Integer , LinkedList < Session > > ( ) ; public CachingConnectionFactory ( ) { } public CachingConnectionFactory ( ConnectionFactory targetConnectionFactory ) { } public void setSessionCacheSize ( int sessionCacheSize ) { } public int getSessionCacheSize ( ) { } public void setCacheProducers ( boolean cacheProducers ) { } public boolean isCacheProducers ( ) { } public void setCacheConsumers ( boolean cacheConsumers ) { } public boolean isCacheConsumers ( ) { } public void resetConnection ( ) { } protected Session getSession ( Connection con , Integer mode ) throws JMSException { } protected Session getCachedSessionProxy ( Session target , LinkedList < Session > sessionList ) { } private class CachedSessionInvocationHandler implements InvocationHandler { private final Session target ; private final LinkedList < Session > sessionList ; private final Map < Destination , MessageProducer > cachedProducers = new HashMap < Destination , MessageProducer > ( ) ; private final Map < CachingConnectionFactory . ConsumerCacheKey , MessageConsumer > cachedConsumers = new HashMap < CachingConnectionFactory . ConsumerCacheKey , MessageConsumer > ( ) ; private boolean transactionOpen = false ; public CachedSessionInvocationHandler ( Session target , LinkedList < Session > sessionList ) { } public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { String methodName = method . getName ( ) ; if ( methodName . equals ( "equals" ) ) { <START_BUG> return proxy == ( args [ 0 ] ) ? Boolean . TRUE : Boolean . FALSE ; <END_BUG> } else if ( methodName . equals ( "hashCode" ) ) { return System . identityHashCode ( proxy ) ; } else if ( methodName . equals ( "toString" ) ) { return "Cached<seq2seq4repair_space>JMS<seq2seq4repair_space>Session:<seq2seq4repair_space>" + ( this . target ) ; } else if ( methodName . equals ( "close" ) ) { if ( active ) { synchronized ( this . sessionList ) { if ( ( this . sessionList . size ( ) ) < ( getSessionCacheSize ( ) ) ) { logicalClose ( ( ( Session ) ( proxy ) ) ) ; return null ; } } } physicalClose ( ) ; return null ; } else if ( methodName . equals ( "getTargetSession" ) ) { return this . target ; } else if ( ( methodName . equals ( "commit" ) ) || ( methodName . equals ( "rollback" ) ) ) { this . transactionOpen = false ; } else { this . transactionOpen = true ; if ( ( ( ( methodName . equals ( "createProducer" ) ) || ( methodName . equals ( "createSender" ) ) ) || ( methodName . equals ( "createPublisher" ) ) ) && ( isCacheProducers ( ) ) ) { return getCachedProducer ( ( ( Destination ) ( args [ 0 ] ) ) ) ; } else if ( ( ( ( methodName . equals ( "createConsumer" ) ) || ( methodName . equals ( "createReceiver" ) ) ) || ( methodName . equals ( "createSubscriber" ) ) ) && ( isCacheConsumers ( ) ) ) { return getCachedConsumer ( ( ( Destination ) ( args [ 0 ] ) ) , ( ( args . length ) > 1 ? ( ( String ) ( args [ 1 ] ) ) : null ) , ( ( ( args . length ) > 2 ) && ( ( Boolean ) ( args [ 2 ] ) ) ) , null ) ; } else if ( ( methodName . equals ( "createDurableSubscriber" ) ) && ( isCacheConsumers ( ) ) ) { return getCachedConsumer ( ( ( Destination ) ( args [ 0 ] ) ) , ( ( args . length ) > 2 ? ( ( String ) ( args [ 2 ] ) ) : null ) , ( ( ( args . length ) > 3 ) && ( ( Boolean ) ( args [ 3 ] ) ) ) , ( ( String ) ( args [ 1 ] ) ) ) ; } } try { return method . invoke ( this . target , args ) ; } catch ( InvocationTargetException ex ) { throw ex . getTargetException ( ) ; } } private MessageProducer getCachedProducer ( Destination dest ) throws JMSException { } private MessageConsumer getCachedConsumer ( Destination dest , String selector , boolean noLocal , String subscription ) throws JMSException { } private void logicalClose ( Session proxy ) throws JMSException { } private void physicalClose ( ) throws JMSException { } } private static class ConsumerCacheKey { private final Destination destination ; private final String selector ; private final boolean noLocal ; private final String subscription ; private ConsumerCacheKey ( Destination destination , String selector , boolean noLocal , String subscription ) { } public boolean equals ( Object other ) { } public int hashCode ( ) { } } }
public class MainActivity extends ActionBarActivity { static final int COST_PER_CUP = 20 ; static int quantity ; static int price ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } public void SubmitOrder ( View view ) { } private String GetToppings ( ) { String selectedToppings = "" ; boolean choice ; CheckBox whippedCreamCheckBox = ( ( CheckBox ) ( findViewById ( whipped_cream_check_box ) ) ) ; choice = whippedCreamCheckBox . isChecked ( ) ; if ( choice ) { <START_BUG> selectedToppings += ( getResources ( ) . getString ( whipped_cream ) ) + "\n" ; <END_BUG> } CheckBox chocolateCheckBox = ( ( CheckBox ) ( findViewById ( chocolate_check_box ) ) ) ; choice = chocolateCheckBox . isChecked ( ) ; if ( choice ) { selectedToppings += ( getResources ( ) . getString ( chocolate ) ) + "\n" ; } if ( selectedToppings . equals ( "" ) ) { return "None\n" ; } return selectedToppings ; } private void display ( String quantity , String price ) { } public void IncreaseQuantity ( View view ) { } public void DecreaseQuantity ( View view ) { } public void ResetOrder ( View view ) { } }
public class SelectionOnSuperReference extends SuperReference { public SelectionOnSuperReference ( int pos , int sourceEnd ) { } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public TypeBinding resolveType ( BlockScope scope ) { TypeBinding binding = super . resolveType ( scope ) ; if ( ( binding == null ) || ( ! ( binding . isValidBinding ( ) ) ) ) throw new SelectionNodeFound ( ) ; else <START_BUG> throw new SelectionNodeFound ( binding ) ; <END_BUG> } }
public class WordbookManager { private String wordbook = "wordbook.xml" ; private String wordList = "wordlist.txt" ; private String rootLocation = "" ; private long insertOffset = 11 ; public WordbookManager ( ) { } public String rootDir ( ) { } public String getRootDir ( ) { } public void addWord ( Word word ) throws IOException { } public boolean hasWord ( String word ) { try { String currentLine ; BufferedReader br = new BufferedReader ( new FileReader ( ( ( rootLocation ) + ( wordList ) ) ) ) ; while ( ( currentLine = br . readLine ( ) ) != null ) { <START_BUG> if ( currentLine . contains ( word ) ) { <END_BUG> return true ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } return false ; } public void numOfWord ( ) { } private void syncWordList ( ) { } public static void main ( String [ ] args ) throws Exception { } }
public class EditorManager implements IExtensionChangeHandler { EditorAreaHelper editorPresentation ; WorkbenchWindow window ; WorkbenchPage page ; private Map actionCache = new HashMap ( ) ; private static final String PIN_EDITOR_KEY = "PIN_EDITOR" ; private static final String PIN_EDITOR = "ovr16/pinned_ovr.gif" ; private IPropertyChangeListener editorPropChangeListnener = null ; private IHandlerActivation pinEditorHandlerActivation = null ; static final String RESOURCES_TO_SAVE_MESSAGE = WorkbenchMessages . EditorManager_saveResourcesMessage ; static final String SAVE_RESOURCES_TITLE = WorkbenchMessages . EditorManager_saveResourcesTitle ; public EditorManager ( WorkbenchWindow window , WorkbenchPage workbenchPage , EditorAreaHelper pres ) { } void checkDeleteEditorResources ( ) { } void checkCreateEditorPropListener ( ) { } void checkCreatePinEditorShortcutKeyHandler ( ) { } ImageDescriptor getEditorPinImageDesc ( ) { } private List collectDirtyEditors ( ) { } public boolean containsEditor ( IEditorReference ref ) { } private EditorActionBars createEditorActionBars ( EditorDescriptor desc , final IEditorSite site ) { } private EditorActionBars createEmptyEditorActionBars ( final IEditorSite site ) { } void disposeEditorActionBars ( EditorActionBars actionBars ) { } public IEditorPart findEditor ( IEditorInput input ) { } public IEditorPart findEditor ( String editorId , IEditorInput input , int matchFlags ) { } public IEditorReference [ ] findEditors ( IEditorInput input , String editorId , int matchFlags ) { } private void findEditors ( List editorList , IEditorInput input , String editorId , int matchFlags , List result ) { } private Display getDisplay ( ) { } public int getEditorCount ( ) { } private IEditorRegistry getEditorRegistry ( ) { } public IEditorPart [ ] getDirtyEditors ( ) { } public IEditorReference [ ] getEditors ( ) { } public IEditorPart getVisibleEditor ( ) { } public boolean isSaveAllNeeded ( ) { } private IEditorReference findReusableEditor ( EditorDescriptor desc ) { } public IEditorReference openEditor ( String editorId , IEditorInput input , boolean setVisible , IMemento editorState ) throws PartInitException { } public IEditorReference openEditorFromDescriptor ( EditorDescriptor desc , IEditorInput input , IMemento editorState ) throws PartInitException { } private IEditorReference openExternalEditor ( final EditorDescriptor desc , IEditorInput input ) throws PartInitException { } IEditorReference [ ] openMultiEditor ( final IEditorReference ref , final AbstractMultiEditor part , final MultiEditorInput input ) throws PartInitException { } private void createEditorTab ( final EditorReference ref , final String workbookId ) throws PartInitException { <START_BUG> editorPresentation . addEditor ( ref , workbookId ) ; <END_BUG> } EditorSite createSite ( final IEditorReference ref , final IEditorPart part , final EditorDescriptor desc , final IEditorInput input ) throws PartInitException { } private IEditorReference reuseInternalEditor ( EditorDescriptor desc , IEditorInput input ) throws PartInitException { } IEditorPart createPart ( final EditorDescriptor desc ) throws PartInitException { } private IEditorReference openSystemExternalEditor ( final IPath location ) throws PartInitException { } ImageDescriptor findImage ( EditorDescriptor desc , IPath path ) { } public IStatus restoreState ( IMemento memento ) { } public boolean saveAll ( boolean confirm , boolean closing , boolean addNonPartSources ) { } public static boolean saveAll ( List dirtyParts , boolean confirm , boolean closing , boolean addNonPartSources , final IWorkbenchWindow window ) { } public static boolean saveAll ( List dirtyParts , final boolean confirm , final boolean closing , boolean addNonPartSources , final IRunnableContext runnableContext , final IShellProvider shellProvider ) { } private static List convertToSaveables ( List parts , boolean closing , boolean addNonPartSources ) { } private static Saveable [ ] getSaveables ( IWorkbenchPart part ) { } private static boolean closingLastPartShowingModel ( Saveable model , List closingParts , IWorkbenchPage page ) { } public boolean savePart ( final ISaveablePart saveable , IWorkbenchPart part , boolean confirm ) { } public IStatus saveState ( final IMemento memento ) { } public boolean setVisibleEditor ( IEditorReference newEd , boolean setFocus ) { } private IPathEditorInput getPathEditorInput ( IEditorInput input ) { } private class InnerEditor extends EditorReference { private IEditorReference outerEditor ; private AbstractMultiEditor outerEditorPart ; public InnerEditor ( IEditorReference outerEditor , AbstractMultiEditor outerEditorPart , IEditorInput input , EditorDescriptor desc ) { } protected void doDisposePart ( ) { } protected PartPane createPane ( ) { } protected Composite getPaneControlContainer ( ) { } } public void restoreEditorState ( IMemento editorMem , ArrayList visibleEditors , IEditorReference [ ] activeEditor , MultiStatus result ) { } protected void saveEditorState ( IMemento mem , IEditorReference ed , MultiStatus res ) { } public IMemento getMemento ( IEditorReference e ) { } public void removeExtension ( IExtension source , Object [ ] objects ) { } public void addExtension ( IExtensionTracker tracker , IExtension extension ) { } IEditorReference openEmptyTab ( ) { } public static boolean useIPersistableEditor ( ) { } }
public abstract class FoundationMove extends Move { Pile foundationPile ; Stack stack ; int rankOfFoundation ; Card cardBeingMoved ; public FoundationMove ( Stack from , Card cardBeingMoved , Pile to , int rankOfFoundation ) { } @ Override public boolean doMove ( Solitaire game ) { } @ Override public boolean undo ( Solitaire game ) { } @ Override public boolean valid ( Solitaire game ) { <START_BUG> if ( ( ( cardBeingMoved . getRank ( ) ) > ( foundationPile . suit ( ) ) ) && ( ! ( cardBeingMoved . oppositeColor ( foundationPile . get ( ) ) ) ) ) { <END_BUG> return true ; } if ( ( ( cardBeingMoved . getRank ( ) ) == ( rankOfFoundation ) ) && ( foundationPile . empty ( ) ) ) { return true ; } return false ; } }
public class OSGiSubsystemSupport { private static final Logger log = Logger . getLogger ( OSGiSubsystemSupport . class ) ; public static final byte [ ] BLANK_SHA1 = new byte [ 20 ] ; private static final AtomicInteger archiveCount = new AtomicInteger ( ) ; private final ServiceContainer serviceContainer ; private OSGiSubsystemState subsystemState ; private DeploymentChain deploymentChain ; private Selector selector ; public OSGiSubsystemSupport ( ) throws Exception { } public OSGiSubsystemSupport ( final OSGiSubsystemState subsystemState ) throws Exception { } public ServiceContainer getServiceContainer ( ) { } public ModuleLoader getClassifyingModuleLoader ( ) { } public OSGiSubsystemSupport . TestModuleLoader getTestModuleLoader ( ) { } public DeploymentChain getDeploymentChain ( ) { } public String getUniqueName ( String prefix ) { } public void assertServiceUp ( ServiceName serviceName ) { } public void assertServiceDown ( ServiceName serviceName ) { } public void shutdown ( ) { } public void removeDeploymentChain ( ) { } public void setupServices ( final BatchBuilder batchBuilder ) throws Exception { } public void setupEnvironmentServices ( final BatchBuilder batchBuilder ) { } public void setupModuleLoaderServices ( final BatchBuilder batchBuilder ) { } public void setupDeploymentServices ( final BatchBuilder batchBuilder ) { } public void setupFrameworkServices ( final BatchBuilder batchBuilder ) { batchBuilder . addService ( SERVICE_NAME , new MBeanServerService ( ) ) ; OSGiSubsystemSupport . TestBundleManagerService . addService ( batchBuilder ) ; <START_BUG> FrameworkService . addService ( batchBuilder , null ) ; <END_BUG> PackageAdminService . addService ( batchBuilder ) ; } private Selector getDeploymentChainSelector ( ) { } public BundleManager getBundleManager ( ) { } public BundleContext getSystemContext ( ) { } public Configuration getSubsystemConfig ( ) { } public void assertLoadClass ( ModuleIdentifier identifier , String className ) throws Exception { } public void assertLoadClass ( ModuleIdentifier identifier , String className , ModuleIdentifier exporterId ) throws Exception { } public void assertLoadClassFails ( ModuleIdentifier identifier , String className ) throws Exception { } public Class < ? > loadClass ( ModuleIdentifier identifier , String className ) throws Exception { } public Module loadModule ( ModuleIdentifier identifier ) throws ModuleLoadException { } public Bundle executeDeploy ( final JavaArchive archive ) throws Exception { } public void executeUndeploy ( final JavaArchive archive ) throws Exception { } List < ServiceName > runWithLatchedBatch ( final OSGiSubsystemSupport . BatchedWork work ) throws Exception { } public interface BatchedWork { void execute ( final BatchBuilder batchBuilder ) throws Exception { } } private static class TestServiceListener extends AbstractServiceListener < Object > { final List < ServiceName > registeredServices = new ArrayList < ServiceName > ( ) ; final List < ServiceName > startedServices = new ArrayList < ServiceName > ( ) ; final List < ServiceName > failedServices = new ArrayList < ServiceName > ( ) ; final Map < Mode , List < ServiceName > > initialModes ; private final AtomicInteger count = new AtomicInteger ( 1 ) ; private final Runnable finishTask ; public TestServiceListener ( Runnable finishTask , Map < Mode , List < ServiceName > > initialModes ) { } public void listenerAdded ( final ServiceController < ? extends Object > controller ) { } public void serviceStarted ( final ServiceController < ? extends Object > controller ) { } public void serviceFailed ( ServiceController < ? extends Object > controller , StartException reason ) { } @ Override public void serviceRemoved ( ServiceController < ? extends Object > controller ) { } public void finishBatch ( ) { } private void batchComplete ( ) { } } public static class TestModuleLoader extends ModuleLoader implements Service < OSGiSubsystemSupport . TestModuleLoader > { public static final ServiceName SERVICE_NAME = JBOSS . append ( "module" , "loader" , "support" ) ; private String prefix ; private Map < ModuleIdentifier , ModuleSpec > modules = new HashMap < ModuleIdentifier , ModuleSpec > ( ) ; private Injector < ClassifyingModuleLoaderService > injector ; TestModuleLoader ( String prefix ) { } public void addModuleSpec ( ModuleSpec moduleSpec ) { } @ Override protected ModuleSpec findModule ( ModuleIdentifier identifier ) throws ModuleLoadException { } public static OSGiSubsystemSupport . TestModuleLoader getServiceValue ( ServiceContainer container ) { } public synchronized void start ( StartContext context ) throws StartException { } public synchronized void stop ( StopContext context ) { } public synchronized OSGiSubsystemSupport . TestModuleLoader getValue ( ) throws IllegalStateException { } @ Override public String toString ( ) { } } static class TestBundleManagerService implements Service < BundleManager > { public static final ServiceName SERVICE_NAME = BundleManagerService . SERVICE_NAME ; private static final Logger log = Logger . getLogger ( "org.jboss.as.osgi" ) ; private InjectedValue < Configuration > injectedConfig = new InjectedValue < Configuration > ( ) ; private InjectedValue < ClassifyingModuleLoaderService > injectedModuleLoader = new InjectedValue < ClassifyingModuleLoaderService > ( ) ; private Injector < ClassifyingModuleLoaderService > moduleLoaderInjector ; private BundleManager bundleManager ; public static void addService ( final BatchBuilder batchBuilder ) { } public static BundleManager getServiceValue ( ServiceContainer container ) { } public synchronized void start ( StartContext context ) throws StartException { } public synchronized void stop ( StopContext context ) { } @ Override public BundleManager getValue ( ) throws IllegalStateException { } } static class TestServerDeploymentRepository implements ServerDeploymentRepository , Service < ServerDeploymentRepository > { private Map < String , JavaArchive > repository = new HashMap < String , JavaArchive > ( ) ; public static OSGiSubsystemSupport . TestServerDeploymentRepository getServiceValue ( ServiceContainer container ) { } public void registerDeploymentArchive ( String name , JavaArchive archive ) { } @ Override public void start ( StartContext context ) throws StartException { } @ Override public void stop ( StopContext context ) { } @ Override public ServerDeploymentRepository getValue ( ) throws IllegalStateException { } @ Override public byte [ ] addDeploymentContent ( String name , String runtimeName , InputStream stream ) throws IOException { } @ Override public Closeable mountDeploymentContent ( String name , String runtimeName , byte [ ] deploymentHash , VirtualFile mountPoint ) throws IOException { } } }
public class Manager { private static Manager instance ; public static Manager getInstance ( ) { } private SequenceMachine gestureMachine ; private SequenceMachine keyMachine ; private Manager ( ) { } public SequenceMachine getGestureMachine ( ) { } public SequenceMachine getKeyMachine ( ) { } public String getGestureTextForCommand ( String command ) throws IllegalArgumentException { String text = null ; Sequence sequence = getGestureMachine ( ) . getFirstSequenceForCommand ( command ) ; if ( sequence != null ) <START_BUG> text = GestureSupport . formatSequence ( sequence ) ; <END_BUG> return text != null ? text : Util . ZERO_LENGTH_STRING ; } public String getKeyTextForCommand ( String command ) throws IllegalArgumentException { } public void reset ( ) { } static boolean validateSequence ( Sequence sequence ) { } static void validateSequenceBindings ( Collection sequenceBindings ) { } }
public class Sync implements Runnable { ListOfFiles files ; SendList toBeSent ; PeerFileList fileList ; ListOfPeers listOfPeers ; Sync ( ListOfPeers listOfPeers ) { } public void run ( ) { boolean ret = false ; ListOfFiles lof = listOfPeers . getSelf ( ) . getListOfFiles ( ) ; ArrayList < String > arrayOfFiles = new ArrayList < String > ( ) ; while ( true ) { PeerNode masterNode = listOfPeers . getMaster ( ) ; lof . getList ( ) ; if ( masterNode != null ) { JSONObject obj = JSONManager . getJSON ( lof . getList ( ) ) ; if ( obj == null ) { System . out . println ( "Sync:run:Obj<seq2seq4repair_space>is<seq2seq4repair_space>null" ) ; try { Thread . sleep ( 3000 ) ; } catch ( Exception e ) { } continue ; } <START_BUG> if ( ( lof . getListOfFiles ( ) ) != null ) { <END_BUG> Thread client = new Thread ( new TcpClient ( masterNode . getIPAddress ( ) . toString ( ) , "60010" , obj ) ) ; client . start ( ) ; } } Set mappingSet = getFilesToRequestPerPeer ( listOfPeers . getSelf ( ) . getHashMapFilePeer ( ) , listOfPeers . getSelf ( ) . getListOfFiles ( ) . getArrayListOfFiles ( ) ) . entrySet ( ) ; System . out . println ( ( "Sync:run:Printing<seq2seq4repair_space>mappingSet:" + mappingSet ) ) ; System . out . println ( "Sync:run:Printing<seq2seq4repair_space>Global<seq2seq4repair_space>HashMap:" ) ; print ( listOfPeers . getSelf ( ) . getHashMapFilePeer ( ) ) ; System . out . println ( ( "Sync:run:Prinintg<seq2seq4repair_space>Array<seq2seq4repair_space>List:" + ( listOfPeers . getSelf ( ) . getListOfFiles ( ) . getArrayListOfFiles ( ) ) ) ) ; Iterator itr = mappingSet . iterator ( ) ; while ( itr . hasNext ( ) ) { Map . Entry < String , ArrayList < String > > entry = ( ( Map . Entry < String , ArrayList < String > > ) ( itr . next ( ) ) ) ; ret = seekFromPeer ( String . valueOf ( entry . getKey ( ) ) , entry . getValue ( ) . get ( 0 ) ) ; if ( ret == false ) { System . out . println ( "Sync:run:Seeking<seq2seq4repair_space>from<seq2seq4repair_space>Peer<seq2seq4repair_space>failed\n" ) ; listOfPeers . printPeerList ( ) ; } } listOfPeers . printPeerList ( ) ; if ( ( listOfPeers . getMaster ( ) ) == null ) { if ( ( listOfPeers . getList ( ) . size ( ) ) != 0 ) System . out . println ( ( "Sync:run:I<seq2seq4repair_space>am<seq2seq4repair_space>the<seq2seq4repair_space>master<seq2seq4repair_space>and<seq2seq4repair_space>number<seq2seq4repair_space>of<seq2seq4repair_space>nodes<seq2seq4repair_space>in<seq2seq4repair_space>the<seq2seq4repair_space>list<seq2seq4repair_space>are" + ( listOfPeers . getList ( ) . size ( ) ) ) ) ; else { System . out . println ( "Sync:run:Looks<seq2seq4repair_space>like<seq2seq4repair_space>I<seq2seq4repair_space>am<seq2seq4repair_space>the<seq2seq4repair_space>only<seq2seq4repair_space>one<seq2seq4repair_space>here!" ) ; try { Thread . sleep ( 3000 ) ; } catch ( Exception e ) { } continue ; } listOfPeers . getSelf ( ) . setHashMapFilePeer ( getFilesToRequestPerPeerMaster ( listOfPeers ) ) ; System . out . println ( "Sync.java:<seq2seq4repair_space>Global<seq2seq4repair_space>Hashmap<seq2seq4repair_space>of<seq2seq4repair_space>controller" ) ; print ( listOfPeers . getSelf ( ) . getHashMapFilePeer ( ) ) ; SortedSet < PeerNode > peerList = listOfPeers . getList ( ) ; Iterator < PeerNode > it = peerList . iterator ( ) ; while ( it . hasNext ( ) ) { PeerNode peerNode = it . next ( ) ; HashMap < String , ArrayList < String > > hmFilesPeers = getFilesToRequestPerPeer ( listOfPeers . getSelf ( ) . getHashMapFilePeer ( ) , peerNode . getListOfFiles ( ) . getArrayListOfFiles ( ) ) ; System . out . print ( ( ( "\nThe<seq2seq4repair_space>File<seq2seq4repair_space>list<seq2seq4repair_space>of<seq2seq4repair_space>" + ( peerNode . getId ( ) ) ) + "is:" ) ) ; peerNode . getListOfFiles ( ) . printFileList ( ) ; System . out . print ( ( "Sync.java:<seq2seq4repair_space>Hashmap<seq2seq4repair_space>from<seq2seq4repair_space>controller<seq2seq4repair_space>to<seq2seq4repair_space>" + ( peerNode . getId ( ) ) ) ) ; print ( hmFilesPeers ) ; if ( hmFilesPeers != null ) { JSONObject obj = JSONManager . getJSON ( hmFilesPeers ) ; Thread client = new Thread ( new TcpClient ( peerNode . getIPAddress ( ) . toString ( ) , "60010" , obj ) ) ; client . start ( ) ; } } System . out . println ( ) ; } try { Thread . sleep ( 3000 ) ; } catch ( Exception e ) { } } } void print ( HashMap < String , ArrayList < String > > hmap ) { } boolean seekFromPeer ( String fileName , String peerId ) { } HashMap < String , ArrayList < String > > getFilesToRequestPerPeerMaster ( ListOfPeers peers ) { } void addToHashMap ( HashMap < String , ArrayList < String > > hmFilesPeers , PeerNode peerNode ) { } HashMap < String , ArrayList < String > > getFilesToRequestPerPeer ( HashMap < String , ArrayList < String > > hmFilesPeers , ArrayList < String > filesWithPeer ) { } void find ( int x ) { } }
public class ReferencesSearchGroup extends ActionGroup { private final IWorkbenchSite site ; private IActionBars actionBars ; private final String groupId ; private SelectionDispatchAction findReferencesAction ; public ReferencesSearchGroup ( final IWorkbenchSite site ) { } protected ReferencesSearchGroup ( final AbstractXtendXpandEditor editor ) { } private void registerAction ( final SelectionDispatchAction action , final ISelectionProvider provider , final ISelection selection ) { } private void addAction ( final IAction action , final IMenuManager manager ) { } @ Override public void fillActionBars ( final IActionBars actionBars ) { } @ Override public void fillContextMenu ( final IMenuManager manager ) { <START_BUG> final IMenuManager menuManager = new org . eclipse . jface . action . MenuManager ( "Re&ferences" , IContextMenuConstants . GROUP_SEARCH ) ; <END_BUG> addAction ( findReferencesAction , menuManager ) ; menuManager . add ( new Separator ( ) ) ; if ( ! ( menuManager . isEmpty ( ) ) ) { manager . appendToGroup ( groupId , menuManager ) ; } } @ Override public void dispose ( ) { } private void updateGlobalActionHandlers ( ) { } private void disposeAction ( final ISelectionChangedListener action , final ISelectionProvider provider ) { } }
public abstract class CreateTypeMemberOperation extends CreateElementInCUOperation { protected String source = null ; protected String alteredName ; protected ASTNode createdNode ; public CreateTypeMemberOperation ( IJavaElement parentElement , String source , boolean force ) { } protected StructuralPropertyDescriptor getChildPropertyDescriptor ( ASTNode parent ) { } protected ASTNode generateElementAST ( ASTRewrite rewriter , ICompilationUnit cu ) throws JavaModelException { } private String removeIndentAndNewLines ( String code , ICompilationUnit cu ) throws JavaModelException { } protected abstract SimpleName rename ( ASTNode node , SimpleName newName ) { } protected String generateSyntaxIncorrectAST ( ) { } protected IType getType ( ) { } protected void setAlteredName ( String newName ) { } public IJavaModelStatus verify ( ) { IJavaModelStatus status = super . verify ( ) ; if ( ! ( status . isOK ( ) ) ) { return status ; } if ( ( this . source ) == null ) { return new JavaModelStatus ( IJavaModelStatusConstants . INVALID_CONTENTS ) ; } <START_BUG> if ( ! ( force ) ) { <END_BUG> try { ICompilationUnit cu = getCompilationUnit ( ) ; generateElementAST ( null , cu ) ; } catch ( JavaModelException jme ) { return jme . getJavaModelStatus ( ) ; } return verifyNameCollision ( ) ; } return JavaModelStatus . VERIFIED_OK ; } protected IJavaModelStatus verifyNameCollision ( ) { } }
public class SignatureFragment extends TraceFragment { private GestureOverlayView gestureView ; private Boolean isTouchHappened = false ; private String TAG = SingleClientConnManager . class . getSimpleName ( ) ; private final SignatureFragment . DataListener dataListener ; private final PriorMonth selectedPriorMonth ; private final Boolean isSubmitSignature ; private Boolean isTouchCleared ; private Drawable tempDrawable ; private View textView ; private int selectedIndex ; public SignatureFragment ( ) { } public SignatureFragment ( PriorMonth selectedPriorMonth , int selectedIndex ) { } public SignatureFragment ( Boolean isSubmitSignature ) { } @ Override public boolean hasRefreshButton ( ) { } @ Override public void onCreate ( Bundle savedInstanceState ) { } @ Override public void refreshData ( ) { } @ Override public void onStart ( ) { } @ Override public void onResume ( ) { } @ Override public void onStop ( ) { } @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { } @ Override public void onViewCreated ( View view , @ Nullable Bundle savedInstanceState ) { } @ Override public void onClick ( View view ) { } private void onSubmitSignatureClick ( View view ) { } private void generateGestureFromBitMap ( String encodedString ) { } private String getEncodedStringFromSignature ( ) { } private void submitSignature ( ) { } private void submitSignatureLogs ( String encodedString ) { } private void clearSignaturePad ( ) { } private void alertDialog ( String message ) { } private void customAlertDialog ( String message ) { } private final class DataListener extends SimpleSyncListener { private ProgressDialog progressDialog ; @ Override public void signatureLoaded ( SignatureResponse signature ) { } @ Override public void signatureLoading ( ) { } @ Override public void submitSignatureForLogsLoaded ( JSONObject signature ) { progressDialog . dismiss ( ) ; if ( signature != null ) { <START_BUG> alertDialog ( "Logs<seq2seq4repair_space>successfully<seq2seq4repair_space>updated" ) ; <END_BUG> } else { Toast . makeText ( getActivity ( ) , "Error<seq2seq4repair_space>in<seq2seq4repair_space>submitting<seq2seq4repair_space>signature." , LENGTH_SHORT ) . show ( ) ; } } @ Override public void submitSignatureForLogsLoading ( ) { } @ Override public void submitSignatureLoading ( ) { } @ Override public void submitSignatureLoaded ( JSONObject signature ) { } @ Override public void onError ( String error ) { } } private final class CustomAlertDialog implements DialogInterface . OnClickListener { @ Override public void onClick ( DialogInterface dialog , int i ) { } } private final class DismissListener implements DialogInterface . OnClickListener { @ Override public void onClick ( DialogInterface dialog , int i ) { } } }
public class WarMain implements Observer { public static final String TEAMS_DIRECTORY_NAME = "teams" ; private LoadingDialog loadingDialog ; private WarGame game ; private WarGameSettings settings ; private WarLauncherInterface launcherInterface ; private Map < String , Team > availableTeams ; public WarMain ( ) { } @ Override public void update ( Observable o , Object arg ) { } public void startGame ( ) { } public void endGame ( ) { } @ SuppressWarnings ( "unchecked" ) public Map < String , Team > getTeamsFromDirectory ( ) { } private ImageIcon getTeamLogo ( JarEntry logoEntry , JarFile jarCurrentFile ) { ImageIcon teamLogo = null ; try { teamLogo = new ImageIcon ( WarIOTools . toByteArray ( jarCurrentFile . getInputStream ( logoEntry ) ) ) ; } catch ( IOException e ) { <START_BUG> System . err . println ( ( ( ( "ERROR<seq2seq4repair_space>loading<seq2seq4repair_space>file<seq2seq4repair_space>" + ( logoEntry . getLastModifiedTime ( ) ) ) + "<seq2seq4repair_space>inside<seq2seq4repair_space>jar<seq2seq4repair_space>file<seq2seq4repair_space>" ) + ( jarCurrentFile . getName ( ) ) ) ) ; <END_BUG> e . printStackTrace ( ) ; } Image tmp = teamLogo . getImage ( ) . getScaledInstance ( 50 , 50 , Image . SCALE_SMOOTH ) ; teamLogo = new ImageIcon ( tmp ) ; return teamLogo ; } private HashMap < String , JarEntry > getAllJarEntry ( JarFile jarFile ) { } public Map < String , Team > getAvailableTeams ( ) { } public static void main ( String [ ] args ) { } protected static class Shared { private static WarGame game ; private static Map < String , Team > availableTeams ; public static WarGame getGame ( ) { } public static Map < String , Team > getAvailableTeams ( ) { } } }
public class GenerateFundamentalDiagramData { static final Logger LOG = Logger . getLogger ( GenerateFundamentalDiagramData . class ) ; private String runDir ; private boolean isDumpingInputFiles = true ; private boolean isWritingEventsFileForEachIteration = false ; private String [ ] travelModes ; private Double [ ] modalSplitInPCU ; private boolean isUsingLiveOTFVis = false ; private boolean isPlottingDistribution = false ; private int reduceDataPointsByFactor = 1 ; private int [ ] flowUnstableWarnCount ; private int [ ] speedUnstableWarnCount ; private InputsForFDTestSetUp inputs ; private PrintStream writer ; private Scenario scenario ; static GlobalFlowDynamicsUpdator globalFlowDynamicsUpdator ; private PassingEventsUpdator passingEventsUpdator ; private Map < Id < VehicleType > , TravelModesFlowDynamicsUpdator > mode2FlowData ; private final Map < Id < Person > , String > person2Mode = new HashMap < Id < Person > , String > ( ) ; private Integer [ ] startingPoint ; private Integer [ ] maxAgentDistribution ; private Integer [ ] stepSize ; public GenerateFundamentalDiagramData ( final InputsForFDTestSetUp inputs ) { } public static void main ( String [ ] args ) { } private void consistencyCheckAndInitialize ( ) { } public void run ( ) { } public void setRunDirectory ( String runDir ) { } public void setReduceDataPointsByFactor ( int reduceDataPointsByFactor ) { } public void setIsPlottingDistribution ( boolean isPlottingDistribution ) { } public void setIsUsingLiveOTFVis ( boolean liveOTFVis ) { } public void setIsWritingEventsFileForEachIteration ( boolean isWritingEventsFileForEachIteration ) { } public void setIsDumpingInputFiles ( boolean isDumpingInputFiles ) { } public Scenario getScenario ( ) { } private void parametricRunAccordingToGivenModalSplit ( ) { } private void parametricRunAccordingToDistribution ( ) { } private List < List < Integer > > createPointsToRun ( ) { } private void singleRun ( List < Integer > pointToRun ) { } private Netsim createModifiedQSim ( Scenario sc , EventsManager events ) { final QSim qSim = new QSim ( sc , events ) ; ActivityEngine activityEngine = new ActivityEngine ( events , qSim . getAgentCounter ( ) ) ; qSim . addMobsimEngine ( activityEngine ) ; qSim . addActivityHandler ( activityEngine ) ; QNetsimEngine netsimEngine = new QNetsimEngine ( qSim ) ; qSim . addMobsimEngine ( netsimEngine ) ; qSim . addDepartureHandler ( netsimEngine . getDepartureHandler ( ) ) ; GenerateFundamentalDiagramData . LOG . info ( "=======================" ) ; GenerateFundamentalDiagramData . LOG . info ( "Mobsim<seq2seq4repair_space>agents'<seq2seq4repair_space>are<seq2seq4repair_space>directly<seq2seq4repair_space>added<seq2seq4repair_space>to<seq2seq4repair_space>AgentSource." ) ; GenerateFundamentalDiagramData . LOG . info ( "=======================" ) ; <START_BUG> if ( sc . getConfig ( ) . network ( ) . isTimeVariantNetwork ( ) ) { <END_BUG> qSim . addMobsimEngine ( new NetworkChangeEventsEngine ( ) ) ; } final Map < String , VehicleType > travelModesTypes = new HashMap < String , VehicleType > ( ) ; for ( Id < VehicleType > id : mode2FlowData . keySet ( ) ) { VehicleType vT = mode2FlowData . get ( id ) . getVehicleType ( ) ; travelModesTypes . put ( id . toString ( ) , vT ) ; } AgentSource agentSource = new AgentSource ( ) { @ Override public void insertAgentsIntoMobsim ( ) { for ( Id < Person > personId : person2Mode . keySet ( ) ) { String travelMode = person2Mode . get ( personId ) ; double randDouble = MatsimRandom . getRandom ( ) . nextDouble ( ) ; double actEndTime = randDouble * ( InputsForFDTestSetUp . MAX_ACT_END_TIME ) ; MobsimAgent agent = new GenerateFundamentalDiagramData . MySimplifiedRoundAndRoundAgent ( personId , actEndTime , travelMode ) ; qSim . insertAgentIntoMobsim ( agent ) ; final Vehicle vehicle = VehicleUtils . getFactory ( ) . createVehicle ( Id . create ( agent . getId ( ) , Vehicle . class ) , travelModesTypes . get ( travelMode ) ) ; final Id < Link > linkId4VehicleInsertion = Id . createLinkId ( "home" ) ; qSim . createAndParkVehicleOnLink ( vehicle , linkId4VehicleInsertion ) ; } } } ; qSim . addAgentSource ( agentSource ) ; if ( isUsingLiveOTFVis ) { final OTFVisConfigGroup otfVisConfig = ConfigUtils . addOrGetModule ( qSim . getScenario ( ) . getConfig ( ) , GROUP_NAME , OTFVisConfigGroup . class ) ; otfVisConfig . setDrawTransitFacilities ( false ) ; OnTheFlyServer server = OTFVis . startServerAndRegisterWithQSim ( sc . getConfig ( ) , sc , events , qSim ) ; OTFClientLive . run ( sc . getConfig ( ) , server ) ; } return qSim ; } private void openFileAndWriteHeader ( String dir ) { } private void closeFile ( ) { } private static String arraytostring ( Integer [ ] list ) { } private int getGCD ( int a , int b ) { } private int getLCM ( int a , int b ) { } private int getGCDOfList ( List < Integer > list ) { } private void createLogFile ( ) { } static class MySimplifiedRoundAndRoundAgent implements MobsimAgent , MobsimDriverAgent { private static final Id < Link > FIRST_LINK_ID_OF_MIDDEL_BRANCH_OF_TRACK = Id . createLinkId ( SUBDIVISION_FACTOR ) ; private static final Id < Link > LAST_LINK_ID_OF_BASE = Id . createLinkId ( ( ( InputsForFDTestSetUp . SUBDIVISION_FACTOR ) - 1 ) ) ; private static final Id < Link > LAST_LINK_ID_OF_TRACK = Id . createLinkId ( ( ( 3 * ( InputsForFDTestSetUp . SUBDIVISION_FACTOR ) ) - 1 ) ) ; private static final Id < Link > FIRST_LINK_LINK_ID_OF_BASE = Id . createLinkId ( 0 ) ; private static final Id < Link > ORIGIN_LINK_ID = Id . createLinkId ( "home" ) ; private static final Id < Link > DESTINATION_LINK_ID = Id . createLinkId ( "work" ) ; private final Id < Person > personId ; private final Id < Vehicle > plannedVehicleId ; private final String mode ; private final double actEndTime ; private MobsimVehicle vehicle ; public boolean isArriving = false ; public MySimplifiedRoundAndRoundAgent ( Id < Person > agentId , double actEndTime , String travelMode ) { } private Id < Link > currentLinkId = GenerateFundamentalDiagramData . MySimplifiedRoundAndRoundAgent . ORIGIN_LINK_ID ; private State agentState = MobsimAgent . State . ACTIVITY ; @ Override public Id < Link > getCurrentLinkId ( ) { }
public class Javah extends Task { private static final String FAIL_MSG = "Compile<seq2seq4repair_space>failed,<seq2seq4repair_space>messages<seq2seq4repair_space>should<seq2seq4repair_space>have<seq2seq4repair_space>been<seq2seq4repair_space>provided." ; private Vector classes = new Vector ( 2 ) ; private String cls ; private File destDir ; private Path classpath = null ; private File outputFile = null ; private boolean verbose = false ; private boolean force = false ; private boolean old = false ; private boolean stubs = false ; private Path bootclasspath ; private static String lSep = System . getProperty ( "line.separator" ) ; public void setClass ( String cls ) { } public Javah . ClassArgument createClass ( ) { } public class ClassArgument { private String name ; public ClassArgument ( ) { } public void setName ( String name ) { } public String getName ( ) { } } public void setDestdir ( File destDir ) { } public void setClasspath ( Path src ) { } public Path createClasspath ( ) { } public void setClasspathRef ( Reference r ) { } public void setBootclasspath ( Path src ) { } public Path createBootclasspath ( ) { } public void setBootClasspathRef ( Reference r ) { } public void setOutputFile ( File outputFile ) { } public void setForce ( boolean force ) { } public void setOld ( boolean old ) { } public void setStubs ( boolean stubs ) { } public void setVerbose ( boolean verbose ) { } public void execute ( ) throws BuildException { } private void doClassicCompile ( ) throws BuildException { } private Commandline setupJavahCommand ( ) { } protected void logAndAddFilesToCompile ( Commandline cmd ) { int n = 0 ; <START_BUG> log ( ( "Compilation<seq2seq4repair_space>args:<seq2seq4repair_space>" + ( cmd . toString ( ) ) ) , MSG_VERBOSE ) ; <END_BUG> StringBuffer niceClassList = new StringBuffer ( ) ; if ( ( cls ) != null ) { StringTokenizer tok = new StringTokenizer ( cls , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { String aClass = tok . nextToken ( ) . trim ( ) ; cmd . createArgument ( ) . setValue ( aClass ) ; niceClassList . append ( ( ( "<seq2seq4repair_space>" + aClass ) + ( Javah . lSep ) ) ) ; n ++ ; } } Enumeration = classes . elements ( ) ; } }
@ Repository public class ClickRepositoryImpl implements ClickRepository { private static final Logger log = LoggerFactory . getLogger ( ClickRepositoryImpl . class ) ; private static final RowMapper < Click > rowMapper = new RowMapper < Click > ( ) { @ Override public Click mapRow ( ResultSet rs , int rowNum ) throws SQLException { } } ; @ Autowired protected JdbcTemplate jdbc ; public ClickRepositoryImpl ( ) { } public ClickRepositoryImpl ( JdbcTemplate jdbc ) { } @ Override public List < Click > findByHash ( String hash ) { } @ Override <START_BUG> public Click save ( Click cl ) { <END_BUG> try { KeyHolder holder = new GeneratedKeyHolder ( ) ; jdbc . update ( new PreparedStatementCreator ( ) { @ Override public PreparedStatement createPreparedStatement ( Connection conn ) throws SQLException { PreparedStatement ps = conn . prepareStatement ( "INSERT<seq2seq4repair_space>INTO<seq2seq4repair_space>CLICK<seq2seq4repair_space>VALUES<seq2seq4repair_space>(?,<seq2seq4repair_space>?,<seq2seq4repair_space>?,<seq2seq4repair_space>?,<seq2seq4repair_space>?,<seq2seq4repair_space>?,<seq2seq4repair_space>?,<seq2seq4repair_space>?)" , Statement . RETURN_GENERATED_KEYS ) ; ps . setNull ( 1 , Types . BIGINT ) ; ps . setString ( 2 , cl . getHash ( ) ) ; ps . setDate ( 3 , cl . getCreated ( ) ) ; ps . setString ( 4 , cl . getReferrer ( ) ) ; ps . setString ( 5 , cl . getBrowser ( ) ) ; ps . setString ( 6 , cl . getPlatform ( ) ) ; ps . setString ( 7 , cl . getIp ( ) ) ; ps . setString ( 8 , cl . getCountry ( ) ) ; return ps ; } } , holder ) ; cl . setId ( holder . getKey ( ) . longValue ( ) ) ; } catch ( DuplicateKeyException e ) { ClickRepositoryImpl . log . debug ( ( "When<seq2seq4repair_space>insert<seq2seq4repair_space>for<seq2seq4repair_space>click<seq2seq4repair_space>with<seq2seq4repair_space>id<seq2seq4repair_space>" + ( cl . getId ( ) ) ) , e ) ; return cl ; } catch ( Exception e ) { ClickRepositoryImpl . log . debug ( "When<seq2seq4repair_space>insert<seq2seq4repair_space>a<seq2seq4repair_space>click" , e ) ; return null ; } return cl ; } }
final class EmbedBlob extends ConnectionChild implements Blob , EngineLOB { private boolean materialized ; private PositionedStoreStream myStream ; private int locator = 0 ; private long streamLength = - 1 ; private final int streamPositionOffset ; private boolean isValid = true ; private LOBStreamControl control ; EmbedBlob ( byte [ ] blobBytes , EmbedConnection con ) throws SQLException { } protected EmbedBlob ( DataValueDescriptor dvd , EmbedConnection con ) throws StandardException { } private int handleStreamValue ( InputStream dvdStream , EmbedConnection con ) throws StandardException { } private long setBlobPosition ( long logicalPos ) throws IOException , StandardException { } private int read ( long pos ) throws IOException , StandardException { } public long length ( ) throws SQLException { } public byte [ ] getBytes ( long startPos , int length ) throws SQLException { } public InputStream getBinaryStream ( ) throws SQLException { } public long position ( byte [ ] pattern , long start ) throws SQLException { } private boolean checkMatch ( byte [ ] pattern , long pos ) throws IOException , StandardException { } public long position ( Blob pattern , long start ) throws SQLException { } private boolean checkMatch ( Blob pattern , long pos ) throws IOException , StandardException { } private SQLException handleMyExceptions ( Throwable t ) throws SQLException { } protected void finalize ( ) { } public int setBytes ( long pos , byte [ ] bytes ) throws SQLException { } public int setBytes ( long pos , byte [ ] bytes , int offset , int len ) throws SQLException { checkValidity ( ) ; if ( ( pos - 1 ) > ( length ( ) ) ) throw Util . generateCsSQLException ( BLOB_POSITION_TOO_LARGE , new Long ( pos ) ) ; if ( pos < 1 ) throw Util . generateCsSQLException ( BLOB_BAD_POSITION , new Long ( pos ) ) ; if ( ( offset < 0 ) || ( offset > ( bytes . length ) ) ) { throw Util . generateCsSQLException ( BLOB_INVALID_OFFSET , new Long ( offset ) ) ; } if ( len < 0 ) { throw Util . generateCsSQLException ( BLOB_NONPOSITIVE_LENGTH , new Long ( len ) ) ; } if ( len == 0 ) { return 0 ; } <START_BUG> if ( ( len + offset ) > ( bytes . length ) ) { <END_BUG> throw Util . generateCsSQLException ( BLOB_LENGTH_TOO_LONG , new Long ( len ) ) ; } try { if ( materialized ) { control . write ( bytes , offset , len , ( pos - 1 ) ) ; } else { control = new LOBStreamControl ( getEmbedConnection ( ) ) ; control . copyData ( myStream , length ( ) ) ; control . write ( bytes , offset , len , ( pos - 1 ) ) ; myStream . close ( ) ; streamLength = - 1 ; materialized = true ; } return len ; } catch ( IOException e ) { throw Util . setStreamFailure ( e ) ; } catch ( StandardException se ) { throw Util . generateCsSQLException ( se ) ; } } public OutputStream setBinaryStream ( long pos ) throws SQLException { } public void truncate ( long len ) throws SQLException { } public void free ( ) throws SQLException { } public InputStream getBinaryStream ( long pos , long length ) throws SQLException { } private void checkValidity ( ) throws SQLException { } boolean isMaterialized ( ) { } public int getLocator ( ) { } }
public class SimpleSortedSetFacetsExample { private final Directory indexDir = new RAMDirectory ( ) ; private final FacetsConfig config = new FacetsConfig ( ) ; public SimpleSortedSetFacetsExample ( ) { } private void index ( ) throws IOException { IndexWriter indexWriter = new IndexWriter ( indexDir , new org . apache . lucene . index . IndexWriterConfig ( FacetExamples . EXAMPLES_VER , new org . apache . lucene . analysis . core . WhitespaceAnalyzer ( FacetExamples . EXAMPLES_VER ) ) ) ; Document doc = new Document ( ) ; doc . add ( new SortedSetDocValuesFacetField ( "Author" , "Bob" ) ) ; doc . add ( new SortedSetDocValuesFacetField ( "Publish<seq2seq4repair_space>Year" , "2010" ) ) ; indexWriter . addDocument ( config . build ( doc ) ) ; doc = new Document ( ) ; doc . add ( new SortedSetDocValuesFacetField ( "Author" , "Lisa" ) ) ; doc . add ( new SortedSetDocValuesFacetField ( "Publish<seq2seq4repair_space>Year" , "2010" ) ) ; indexWriter . addDocument ( config . build ( doc ) ) ; doc = new Document ( ) ; doc . add ( new SortedSetDocValuesFacetField ( "Author" , "Lisa" ) ) ; doc . add ( new SortedSetDocValuesFacetField ( "Publish<seq2seq4repair_space>Year" , "2012" ) ) ; indexWriter . addDocument ( config . build ( doc ) ) ; doc = new Document ( ) ; doc . add ( new SortedSetDocValuesFacetField ( "Author" , "Susan" ) ) ; doc . add ( new SortedSetDocValuesFacetField ( "Publish<seq2seq4repair_space>Year" , "2012" ) ) ; indexWriter . addDocument ( config . build ( doc ) ) ; doc = new Document ( ) ; doc . add ( new SortedSetDocValuesFacetField ( "Author" , "Frank" ) ) ; doc . add ( new SortedSetDocValuesFacetField ( "Publish<seq2seq4repair_space>Year" , "1999" ) ) ; indexWriter . addDocument ( config . build ( doc ) ) ; <START_BUG> indexWriter . close ( ) ; <END_BUG> } private List < FacetResult > search ( ) throws IOException { } private FacetResult drillDown ( ) throws IOException { } public List < FacetResult > runSearch ( ) throws IOException { } public FacetResult runDrillDown ( ) throws IOException { } public static void main ( String [ ] args ) throws Exception { } }
@ Embeddable public class EmployeePK implements Serializable { String name ; Date bDay ; public EmployeePK ( ) { } public EmployeePK ( String name , Date bDay ) { } public String getName ( ) { } public Date getBDay ( ) { } public boolean equals ( Object o ) { if ( ( this ) == o ) return true ; if ( ! ( o instanceof EmployeePK ) ) return false ; EmployeePK pk = ( ( EmployeePK ) ( o ) ) ; <START_BUG> if ( ( pk . name . equals ( name ) ) && ( pk . bDay . equals ( bDay ) ) ) <END_BUG> return true ; return false ; } public int hashCode ( ) { } }
public class PackedFeatures { private String trackName ; private String chr ; private int start ; private int end ; private List < Feature > features ; private List < FeatureTrack . FeatureRow > rows ; private static Logger log = Logger . getLogger ( PackedFeatures . class ) ; PackedFeatures ( String chr , int start , int end ) { } PackedFeatures ( String chr , int start , int end , Iterator < Feature > iter , String trackName ) { } int getRowCount ( ) { } public boolean containsInterval ( String chr , int start , int end ) { } List < FeatureTrack . FeatureRow > packFeatures ( Iterator < Feature > iter ) { List < FeatureTrack . FeatureRow > rows = new ArrayList ( 10 ) ; if ( ( iter == null ) || ( ! ( iter . hasNext ( ) ) ) ) { return rows ; } Comparator lengthComparator = new Comparator < Feature > ( ) { public int compare ( Feature row1 , Feature row2 ) { return ( ( row2 . getEnd ( ) ) - ( row2 . getStart ( ) ) ) - ( ( row1 . getEnd ( ) ) - ( row2 . getStart ( ) ) ) ; } } ; Feature firstFeature = iter . next ( ) ; <START_BUG> getFeatures ( ) . add ( firstFeature ) ; <END_BUG> int totalCount = 1 ; LinkedHashMap < Integer , PriorityQueue < Feature > > bucketArray = new LinkedHashMap ( ) ; while ( iter . hasNext ( ) ) { Feature feature = iter . next ( ) ; features . add ( feature ) ; int bucketNumber = feature . getStart ( ) ; PriorityQueue bucket = bucketArray . get ( bucketNumber ) ; if ( bucket == null ) { bucket = new PriorityQueue ( 5 , lengthComparator ) ; bucketArray . put ( bucketNumber , bucket ) ; } bucket . add ( feature ) ; totalCount ++ ; } FeatureTrack . FeatureRow currentRow = new FeatureTrack . FeatureRow ( ) ; currentRow . addFeature ( firstFeature ) ; int allocatedCount = 1 ; int nextStart = ( currentRow . end ) + ( FeatureTrack . MINIMUM_FEATURE_SPACING ) ; int lastKey = 0 ; int lastAllocatedCount = 0 ; while ( ( allocatedCount < totalCount ) && ( ( rows . size ( ) ) < ( FeatureTrack . maxLevels ) ) ) { if ( lastAllocatedCount == allocatedCount ) { String msg = ( ( "Infinite<seq2seq4repair_space>loop<seq2seq4repair_space>detected<seq2seq4repair_space>while<seq2seq4repair_space>packing<seq2seq4repair_space>features<seq2seq4repair_space>for<seq2seq4repair_space>track:<seq2seq4repair_space>" + ( getTrackName ( ) ) ) + ".<br>Not<seq2seq4repair_space>all<seq2seq4repair_space>features<seq2seq4repair_space>will<seq2seq4repair_space>be<seq2seq4repair_space>shown." ) + "<br>Please<seq2seq4repair_space>contact<seq2seq4repair_space>igv-help@broadinstitute.org" ; PackedFeatures . log . error ( msg ) ; MessageUtils . showMessage ( msg ) ; break ; } lastAllocatedCount = allocatedCount ; PriorityQueue < Feature > bucket = null ; ArrayList < Integer > emptyBucketKeys = new ArrayList ( ) ; for ( Integer key : bucketArray . keySet ( ) ) { lastKey = key ; if ( key >= nextStart ) { bucket = bucketArray . get ( key ) ; Feature feature = bucket . poll ( ) ; if ( bucket . isEmpty ( ) ) { emptyBucketKeys . add ( key ) ; } currentRow . addFeature ( feature ) ; nextStart = ( currentRow . end ) + ( FeatureTrack . MINIMUM_FEATURE_SPACING ) ; allocatedCount ++ ; } } for ( Integer key : emptyBucketKeys ) { bucketArray . remove ( key ) ; } if ( ( currentRow . features . size ( ) ) > 0 ) { rows . add ( currentRow ) ; lastAllocatedCount = 0 ; } currentRow = new FeatureTrack . FeatureRow ( ) ; nextStart = 0 ; lastKey = 0 ; } if ( ( currentRow . features . size ( ) ) > 0 ) { rows . add ( currentRow ) ; } return rows ; } public String getTrackName ( ) { } public String getChr ( ) { } public int getStart ( ) { } public int getEnd ( ) { } public List < Feature > getFeatures ( ) { } public List < FeatureTrack . FeatureRow > getRows ( ) { } }
public class LemmaListActivity extends FragmentActivity implements LemmaListFragment . Callbacks { private boolean mTwoPane ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; <START_BUG> setContentView ( activity_headword_list ) ; <END_BUG> if ( ( findViewById ( lemma_detail_container ) ) != null ) { mTwoPane = true ; ( ( LemmaListFragment ) ( getSupportFragmentManager ( ) . findFragmentById ( R . id . headword_list ) ) ) . setActivateOnItemClick ( true ) ; } } @ Override public void onItemSelected ( int id ) { } }
public class SignUp extends BaseActivity implements ActivityChange , ActivitySettings { @ Override protected void onCreate ( Bundle savedInstanceState ) { } @ Override protected int getLayoutResource ( ) { } @ TargetApi ( VERSION_CODES . JELLY_BEAN ) @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } @ Override public void activitySettingsToolbar ( ) { } @ TargetApi ( VERSION_CODES . JELLY_BEAN ) @ Override public void onBackPressed ( ) { } @ TargetApi ( VERSION_CODES . JELLY_BEAN ) private void loginActivity ( ) { } @ TargetApi ( VERSION_CODES . JELLY_BEAN ) @ Override public Bundle activitiesChanged ( int animateEnter , int animateExit ) { } public static class SignUpFragment extends Fragment { public SignUpFragment ( ) { } private EditText editTxtName ; private EditText editTxtEmail ; private EditText editTxtPassword ; private EditText editTxtPassConfirm ; private Button btnRegisterme ; @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { } private void initializeWidgets ( View rootView ) { editTxtName = ( ( EditText ) ( rootView . findViewById ( edit_txt_name ) ) ) ; editTxtEmail = ( ( EditText ) ( rootView . findViewById ( edit_txt_email ) ) ) ; editTxtPassword = ( ( EditText ) ( rootView . findViewById ( edit_txt_password ) ) ) ; editTxtPassConfirm = ( ( EditText ) ( rootView . findViewById ( edit_txt_password_confirm ) ) ) ; <START_BUG> btnRegisterme = ( ( Button ) ( rootView . findViewById ( btn_register ) ) ) ; <END_BUG> editTxtName . setTypeface ( VerificaCiudadFonts . typefaceRobotoRegular ( getActivity ( ) ) ) ; editTxtEmail . setTypeface ( VerificaCiudadFonts . typefaceRobotoRegular ( getActivity ( ) ) ) ; editTxtPassword . setTypeface ( VerificaCiudadFonts . typefaceRobotoRegular ( getActivity ( ) ) ) ; editTxtPassConfirm . setTypeface ( VerificaCiudadFonts . typefaceRobotoRegular ( getActivity ( ) ) ) ; btnRegisterme . setTypeface ( VerificaCiudadFonts . typefaceRobotoBold ( getActivity ( ) ) ) ; } } }
public class PackageFragment extends Openable implements IPackageFragment , SuffixConstants { protected static final IClassFile [ ] NO_CLASSFILES = new IClassFile [ ] { } ; protected static final ICompilationUnit [ ] NO_COMPILATION_UNITS = new ICompilationUnit [ ] { } ; protected PackageFragment ( PackageFragmentRoot root , String name ) { } protected boolean buildStructure ( OpenableElementInfo info , IProgressMonitor pm , Map newElements , IResource underlyingResource ) throws JavaModelException { } public boolean containsJavaResources ( ) throws JavaModelException { } public void copy ( IJavaElement container , IJavaElement sibling , String rename , boolean force , IProgressMonitor monitor ) throws JavaModelException { } public ICompilationUnit createCompilationUnit ( String cuName , String contents , boolean force , IProgressMonitor monitor ) throws JavaModelException { CreateCompilationUnitOperation op = new CreateCompilationUnitOperation ( this , cuName , contents , force ) ; <START_BUG> runOperation ( op , monitor ) ; <END_BUG> return new CompilationUnit ( this , cuName , DefaultWorkingCopyOwner . PRIMARY ) ; } protected Object createElementInfo ( ) { } public void delete ( boolean force , IProgressMonitor monitor ) throws JavaModelException { } public boolean equals ( Object o ) { } public IClassFile getClassFile ( String classFileName ) { } public IClassFile [ ] getClassFiles ( ) throws JavaModelException { } public ICompilationUnit getCompilationUnit ( String cuName ) { } public ICompilationUnit [ ] getCompilationUnits ( ) throws JavaModelException { } public ICompilationUnit [ ] getCompilationUnits ( WorkingCopyOwner owner ) { } public int getElementType ( ) { } public IJavaElement getHandleFromMemento ( String token , StringTokenizer memento , WorkingCopyOwner owner ) { } protected char getHandleMementoDelimiter ( ) { } public int getKind ( ) throws JavaModelException { } public Object [ ] getNonJavaResources ( ) throws JavaModelException { } public IPath getPath ( ) { } public IResource getResource ( ) { } public IResource getUnderlyingResource ( ) throws JavaModelException { } public boolean hasSubpackages ( ) throws JavaModelException { } public boolean isDefaultPackage ( ) { } public void move ( IJavaElement container , IJavaElement sibling , String rename , boolean force , IProgressMonitor monitor ) throws JavaModelException { } public void rename ( String newName , boolean force , IProgressMonitor monitor ) throws JavaModelException { } protected void toStringChildren ( int tab , StringBuffer buffer , Object info ) { } protected void toStringInfo ( int tab , StringBuffer buffer , Object info ) { } }
class XSDHandler { static final int ATTRIBUTE_TYPE = 1 ; static final int ATTRIBUTEGROUP_TYPE = 2 ; static final int ELEMENT_TYPE = 3 ; static final int GROUP_TYPE = 4 ; static final int IDENTITYCONSTRAINT_TYPE = 5 ; static final int NOTATION_TYPE = 6 ; static final int TYPEDECL_TYPE = 7 ; public static final String REDEF_IDENTIFIER = "_fn3dktizrknc9pi" ; public String EMPTY_STRING ; protected Hashtable fNotationRegistry = new Hashtable ( ) ; private Hashtable fUnparsedAttributeRegistry = new Hashtable ( ) ; private Hashtable fUnparsedAttributeGroupRegistry = new Hashtable ( ) ; private Hashtable fUnparsedElementRegistry = new Hashtable ( ) ; private Hashtable fUnparsedGroupRegistry = new Hashtable ( ) ; private Hashtable fUnparsedIdentityConstraintRegistry = new Hashtable ( ) ; private Hashtable fUnparsedNotationRegistry = new Hashtable ( ) ; private Hashtable fUnparsedTypeRegistry = new Hashtable ( ) ; private Hashtable fXSDocumentInfoRegistry = new Hashtable ( ) ; private Hashtable fDependencyMap = new Hashtable ( ) ; private Vector fTraversed = new Vector ( ) ; private XSDocumentInfo fRoot = null ; private Hashtable fDoc2XSDocumentMap = new Hashtable ( ) ; private Hashtable fRedefine2XSDMap = new Hashtable ( ) ; private Hashtable fRedefinedRestrictedAttributeGroupRegistry = new Hashtable ( ) ; private Hashtable fRedefinedRestrictedGroupRegistry = new Hashtable ( ) ; private XMLErrorReporter fErrorReporter ; private XSAttributeChecker fAttributeChecker ; private SubstitutionGroupHandler fSubGroupHandler ; private XMLEntityResolver fEntityResolver ; private SymbolTable fSymbolTable ; private XSGrammarResolver fGrammarResolver ; XSDAttributeGroupTraverser fAttributeGroupTraverser ; XSDAttributeTraverser fAttributeTraverser ; XSDComplexTypeTraverser fComplexTypeTraverser ; XSDElementTraverser fElementTraverser ; XSDGroupTraverser fGroupTraverser ; XSDKeyrefTraverser fKeyrefTraverser ; XSDNotationTraverser fNotationTraverser ; XSDSimpleTypeTraverser fSimpleTypeTraverser ; XSDUniqueOrKeyTraverser fUniqueOrKeyTraverser ; XSDWildcardTraverser fWildCardTraverser ; DOMParser fSchemaParser ; private static final int INIT_STACK_SIZE = 30 ; private static final int INC_STACK_SIZE = 10 ; private int fLocalElemStackPos ; private XSParticleDecl [ ] fParticle ; private Element [ ] fLocalElementDecl ; private int [ ] fAllContext ; private String [ ] [ ] fLocalElemNamespaceContext ; XSDHandler ( XSGrammarResolver gResolver ) { } SchemaGrammar parseSchema ( String schemaNamespace , String schemaHint ) { } protected XSDocumentInfo constructTrees ( Document schemaRoot ) { if ( schemaRoot == null ) return null ; XSDocumentInfo currSchemaInfo = new XSDocumentInfo ( schemaRoot , fAttributeChecker , fSymbolTable ) ; SchemaGrammar sg = null ; if ( ( sg = fGrammarResolver . getGrammar ( currSchemaInfo . fTargetNamespace ) ) == null ) { sg = new SchemaGrammar ( fSymbolTable , currSchemaInfo . fTargetNamespace ) ; fGrammarResolver . putGrammar ( sg ) ; } Vector dependencies = new Vector ( ) ; <START_BUG> dependencies . add ( currSchemaInfo ) ; <END_BUG> Element rootNode = DOMUtil . getRoot ( schemaRoot ) ; String schemaNamespace = EMPTY_STRING ; String schemaHint = EMPTY_STRING ; Document newSchemaRoot = null ; for ( Element child = DOMUtil . getFirstChildElement ( rootNode ) ; child != null ; child = DOMUtil . getNextSiblingElement ( child ) ) { String localName = DOMUtil . getLocalName ( child ) ; if ( localName . equals ( ELT_ANNOTATION ) ) continue ; else if ( localName . equals ( ELT_IMPORT ) ) { Object [ ] includeAttrs = fAttributeChecker . checkAttributes ( child , true , currSchemaInfo ) ; schemaHint = ( ( String ) ( includeAttrs [ XSAttributeChecker . ATTIDX_SCHEMALOCATION ] ) ) ; schemaNamespace = ( ( String ) ( includeAttrs [ XSAttributeChecker . ATTIDX_NAMESPACE ] ) ) ; fAttributeChecker . returnAttrArray ( includeAttrs , currSchemaInfo ) ; newSchemaRoot = getSchema ( schemaNamespace , schemaHint ) ; } else if ( ( localName . equals ( ELT_INCLUDE ) ) || ( localName . equals ( ELT_REDEFINE ) ) ) { Object [ ] includeAttrs = fAttributeChecker . checkAttributes ( child , true , currSchemaInfo ) ; schemaHint = ( ( String ) ( includeAttrs [ XSAttributeChecker . ATTIDX_SCHEMALOCATION ] ) ) ; fAttributeChecker . returnAttrArray ( includeAttrs , currSchemaInfo ) ; newSchemaRoot = getSchema ( EMPTY_STRING , schemaHint ) ; } else { break ; } XSDocumentInfo newSchemaInfo = constructTrees ( newSchemaRoot ) ; if ( localName . equals ( ELT_REDEFINE ) ) { fRedefine2XSDMap . put ( child , newSchemaInfo ) ; } dependencies . addElement ( newSchemaInfo ) ; fDoc2XSDocumentMap . put ( newSchemaRoot , newSchemaInfo ) ; newSchemaRoot = null ; } fDependencyMap . put ( currSchemaInfo , dependencies ) ; return currSchemaInfo ; } protected void buildGlobalNameRegistries ( ) { } protected void traverseSchemas ( ) { } protected Object getGlobalDecl ( XSDocumentInfo currSchema , int declType , QName declToTraverse ) { } protected void resolveKeyRefs ( ) { } private Document getSchema ( String schemaNamespace , String schemaHint ) { } private void createTraversers ( ) { } protected void reset ( XMLErrorReporter errorReporter , XMLEntityResolver entityResolver , SymbolTable symbolTable ) { } void traverseLocalElements ( ) { } void fillInLocalElemInfo ( Element elmDecl , XSDocumentInfo schemaDoc , int allContextFlags , XSParticleDecl particle ) { } private void checkForDuplicateNames ( String qName , Hashtable registry , Element currComp , XSDocumentInfo currSchema ) { } protected String resolvePrefixToURI ( String prefix ) { } private void renameRedefiningComponents ( XSDocumentInfo currSchema , Element child , String componentType , String oldName , String newName ) { } private String findQName ( String name , SchemaNamespaceSupport currNSMap ) { } private int changeRedefineGroup ( String originalQName , String elementSought , String newName , Element curr , SchemaNamespaceSupport currNSMap ) { } private XSDocumentInfo findXSDocumentForDecl ( XSDocumentInfo currSchema , Element decl ) { } private void setSchemasVisible ( XSDocumentInfo startSchema ) { } public static void main ( String [ ] args ) throws Exception { } public static class DummyResolver implements EntityResolver { public InputSource resolveEntity ( String pubId , String sysId ) throws IOException , SAXException { } } }
public boolean isActive ( ) { } public String toString ( ) { } } public static boolean VERBOSE = false ; public static boolean CP_RESOLVE_VERBOSE = false ; public static boolean ZIP_ACCESS_VERBOSE = false ; private ThreadLocal zipFiles = new ThreadLocal ( ) ; public static class EclipsePreferencesListener implements IEclipsePreferences . IPreferenceChangeListener { public void preferenceChange ( IEclipsePreferences . PreferenceChangeEvent event ) { } } private JavaModelManager ( ) { } private void addDeprecatedOptions ( Hashtable options ) { } public void cacheZipFiles ( ) { } public void closeZipFile ( ZipFile zipFile ) { } public void configurePluginDebugOptions ( ) { } public int discardPerWorkingCopyInfo ( CompilationUnit workingCopy ) throws JavaModelException { } public void doneSaving ( ISaveContext context ) { } public void flushZipFiles ( ) { } public IClasspathContainer getClasspathContainer ( IPath containerPath , IJavaProject project ) throws JavaModelException { } public DeltaProcessor getDeltaProcessor ( ) { } protected HashSet getElementsOutOfSynchWithBuffers ( ) { } public IndexManager getIndexManager ( ) { } public synchronized Object getInfo ( IJavaElement element ) { } public IEclipsePreferences getInstancePreferences ( ) { } public Hashtable getDefaultOptions ( ) { } public IEclipsePreferences getDefaultPreferences ( ) { } public final JavaModel getJavaModel ( ) { } public static final JavaModelManager getJavaModelManager ( ) { } public Object getLastBuiltState ( IProject project , IProgressMonitor monitor ) { } public String getOption ( String optionName ) { } public Hashtable getOptions ( ) { } private Hashtable getDefaultOptionsNoInitialization ( ) { Map defaultOptionsMap = new CompilerOptions ( ) . getMap ( ) ; defaultOptionsMap . put ( JavaCore . COMPILER_LOCAL_VARIABLE_ATTR , JavaCore . GENERATE ) ; defaultOptionsMap . put ( JavaCore . COMPILER_CODEGEN_UNUSED_LOCAL , JavaCore . PRESERVE ) ; defaultOptionsMap . put ( JavaCore . COMPILER_TASK_TAGS , JavaCore . DEFAULT_TASK_TAGS ) ; defaultOptionsMap . put ( JavaCore . COMPILER_TASK_PRIORITIES , JavaCore . DEFAULT_TASK_PRIORITIES ) ; defaultOptionsMap . put ( JavaCore . COMPILER_TASK_CASE_SENSITIVE , JavaCore . ENABLED ) ; defaultOptionsMap . put ( JavaCore . COMPILER_DOC_COMMENT_SUPPORT , JavaCore . ENABLED ) ; defaultOptionsMap . put ( JavaCore . COMPILER_PB_FORBIDDEN_REFERENCE , JavaCore . ERROR ) ; defaultOptionsMap . put ( JavaCore . CORE_JAVA_BUILD_RESOURCE_COPY_FILTER , "" ) ; defaultOptionsMap . put ( JavaCore . CORE_JAVA_BUILD_INVALID_CLASSPATH , JavaCore . ABORT ) ; defaultOptionsMap . put ( JavaCore . CORE_JAVA_BUILD_DUPLICATE_RESOURCE , JavaCore . WARNING ) ; defaultOptionsMap . put ( JavaCore . CORE_JAVA_BUILD_CLEAN_OUTPUT_FOLDER , JavaCore . CLEAN ) ; defaultOptionsMap . put ( JavaCore . CORE_JAVA_BUILD_ORDER , JavaCore . IGNORE ) ; defaultOptionsMap . put ( JavaCore . CORE_INCOMPLETE_CLASSPATH , JavaCore . ERROR ) ; defaultOptionsMap . put ( JavaCore . CORE_CIRCULAR_CLASSPATH , JavaCore . ERROR ) ; defaultOptionsMap . put ( JavaCore . CORE_INCOMPATIBLE_JDK_LEVEL , JavaCore . IGNORE ) ; defaultOptionsMap . put ( JavaCore . CORE_ENABLE_CLASSPATH_EXCLUSION_PATTERNS , JavaCore . ENABLED ) ; defaultOptionsMap . put ( JavaCore . CORE_ENABLE_CLASSPATH_MULTIPLE_OUTPUT_LOCATIONS , JavaCore . ENABLED ) ; defaultOptionsMap . putAll ( DefaultCodeFormatterConstants . getEclipseDefaultSettings ( ) ) ; defaultOptionsMap . put ( JavaCore . CODEASSIST_VISIBILITY_CHECK , JavaCore . DISABLED ) ; defaultOptionsMap . put ( JavaCore . CODEASSIST_DEPRECATION_CHECK , JavaCore . DISABLED ) ; defaultOptionsMap . put ( JavaCore . CODEASSIST_IMPLICIT_QUALIFICATION , JavaCore . DISABLED ) ; defaultOptionsMap . put ( JavaCore . CODEASSIST_FIELD_PREFIXES , "" ) ; defaultOptionsMap . put ( JavaCore . CODEASSIST_STATIC_FIELD_PREFIXES , "" ) ; defaultOptionsMap . put ( JavaCore . CODEASSIST_LOCAL_PREFIXES , "" ) ; defaultOptionsMap . put ( JavaCore . CODEASSIST_ARGUMENT_PREFIXES , "" ) ; defaultOptionsMap . put ( JavaCore . CODEASSIST_FIELD_SUFFIXES , "" ) ; defaultOptionsMap . put ( JavaCore . CODEASSIST_STATIC_FIELD_SUFFIXES , "" ) ; defaultOptionsMap . put ( JavaCore . CODEASSIST_LOCAL_SUFFIXES , "" ) ; defaultOptionsMap . put ( JavaCore . CODEASSIST_ARGUMENT_SUFFIXES , "" ) ; defaultOptionsMap . put ( JavaCore . CODEASSIST_FORBIDDEN_REFERENCE_CHECK , JavaCore . ENABLED ) ; defaultOptionsMap . put ( JavaCore . CODEASSIST_DISCOURAGED_REFERENCE_CHECK , JavaCore . DISABLED ) ; defaultOptionsMap . put ( JavaCore . CODEASSIST_CAMEL_CASE_MATCH , JavaCore . ENABLED ) ; defaultOptionsMap . put ( JavaCore . TIMEOUT_FOR_PARAMETER_NAME_FROM_ATTACHED_JAVADOC , "50" ) ; <START_BUG> defaultOptionsMap . put ( ENABLE_JAVADOC_ATTACHMENTS , JavaCore . ENABLED ) ; <END_BUG> return new Hashtable ( defaultOptionsMap ) ; } public JavaModelManager . PerProjectInfo getPerProjectInfo ( IProject project , boolean create ) { } public JavaModelManager . PerProjectInfo getPerProjectInfoCheckExistence ( IProject project ) throws JavaModelException { } public JavaModelManager . PerWorkingCopyInfo getPerWorkingCopyInfo ( CompilationUnit workingCopy , boolean create , boolean recordUsage , IProblemRequestor problemRequestor ) { } public IClasspathContainer getPreviousSessionContainer ( IPath containerPath , IJavaProject project ) { } public IPath getPreviousSessionVariable ( String variableName ) { } public HashMap getTemporaryCache ( ) { } private File getVariableAndContainersFile ( ) { } public static String [ ] getRegisteredVariableNames ( ) { } public static String [ ] getRegisteredContainerIDs ( ) { } private File getSerializationFile ( IProject project ) { } public ICompilationUnit [ ] getWorkingCopies ( WorkingCopyOwner owner , boolean addPrimary ) { } public JavaWorkspaceScope getWorkspaceScope ( ) { } public ZipFile getZipFile ( IPath path ) throws CoreException { } public boolean hasTemporaryCache ( ) { } private IClasspathContainer initializeAllContainers ( IJavaProject javaProjectToInit , IPath containerToInit ) throws JavaModelException { } IClasspathContainer initializeContainer ( IJavaProject project , IPath containerPath ) throws JavaModelException { } public void initializePreferences ( ) { } public synchronized char [ ] intern ( char [ ] array ) { } public synchronized String intern ( String s ) { } private HashSet getClasspathBeingResolved ( ) { } public boolean isClasspathBeingResolved ( IJavaProject project ) { } private boolean isDeprecatedOption ( String optionName ) { } public void setClasspathBeingResolved ( IJavaProject project , boolean classpathIsResolved ) { } public void loadVariablesAndContainers ( ) throws CoreException { } private void loadVariablesAndContainers ( IEclipsePreferences preferences ) { } private static final class PersistedClasspathContainer implements IClasspathContainer { private final IPath containerPath ; private final IClasspathEntry [ ] entries ; private final IJavaProject project ; PersistedClasspathContainer ( IJavaProject project , IPath containerPath , IClasspathEntry [ ] entries ) { } public IClasspathEntry [ ] getClasspathEntries ( ) { }
public class FastViewManager { private Perspective perspective ; private WorkbenchPage page ; private WorkbenchWindow wbw ; private TrimLayout tbm ; private Map idToFastViewsMap = new HashMap ( ) ; private boolean deferringUpdates = false ; private AnimationEngine batchAnimation = null ; private AnimationEngine oneShotAnimation = null ; private IPerspectiveListener2 perspListener = new IPerspectiveListener2 ( ) { public void perspectiveActivated ( IWorkbenchPage page , IPerspectiveDescriptor perspective ) { } public void perspectiveChanged ( IWorkbenchPage changedPage , IPerspectiveDescriptor perspective , IWorkbenchPartReference partRef , String changeId ) { } public void perspectiveChanged ( IWorkbenchPage changedPage , IPerspectiveDescriptor perspective , String changeId ) { } } ; public FastViewManager ( Perspective perspective , WorkbenchPage page ) { } protected void handlePerspectiveActivation ( IWorkbenchPage activatingPage , IPerspectiveDescriptor activatingPerspective ) { } protected void handlePerspectiveChange ( IWorkbenchPage changedPage , IPerspectiveDescriptor changedPerspective , IWorkbenchPartReference partRef , String changeId ) { if ( ( changedPage != ( page ) ) && ( ( perspective . getDesc ( ) ) != changedPerspective ) ) return ; if ( changeId . equals ( CHANGE_VIEW_HIDE ) ) { <START_BUG> if ( partRef instanceof IViewReference ) { <END_BUG> ViewReference ref = ( ( ViewReference ) ( partRef ) ) ; if ( ( ref . getPane ( ) . getContainer ( ) ) instanceof ViewStack ) { int viewCount = 0 ; LayoutPart [ ] children = ref . getPane ( ) . getContainer ( ) . getChildren ( ) ; for ( int i = 0 ; i < ( children . length ) ; i ++ ) { if ( ( ( children [ i ] ) instanceof ViewPane ) && ( ( children [ i ] ) != ( ref . getPane ( ) ) ) ) viewCount ++ ; } if ( viewCount == 0 ) ref . getPane ( ) . getStack ( ) . setState ( STATE_RESTORED ) ; } } } if ( changeId . equals ( CHANGE_FAST_VIEW_REMOVE ) ) { removeViewReference ( ( ( IViewReference ) ( partRef ) ) , false , true ) ; } } protected void handlePerspectiveChange ( IWorkbenchPage changedPage , IPerspectiveDescriptor changedPerspective , String changeId ) { } public List getFastViews ( String forId ) { } public void addViewReference ( String id , int index , IViewReference ref , boolean update ) { } private ViewStackTrimToolBar getTrimForViewStack ( String id , int suggestedSide , int paneOrientation ) { } public void updateTrim ( String id ) { } public void removeViewReference ( IViewReference ref , boolean makeUnfast , boolean update ) { } private void makeFast ( IViewReference ref , boolean makeFast , boolean activate ) { } boolean isFastView ( IViewReference ref ) { } public String getIdForRef ( IViewReference ref ) { } public int getViewSide ( IViewReference ref ) { } private IWindowTrim getTrimForRef ( IViewReference ref ) { } private List getTrueViewOrder ( ViewStack stack ) { } public void moveToTrim ( ViewStack vs , boolean restoreOnUnzoom ) { } public void restoreToPresentation ( String id ) { } public void restoreZoomedViewStacks ( ) { } public void setFastViewIconSelection ( IViewReference ref , boolean selected ) { } public void activate ( ) { } public void deActivate ( ) { } public boolean restoreAllTrimStacks ( ) { } private void setTrimStackVisibility ( boolean visible ) { } public void saveState ( IMemento memento ) { } public void restoreState ( IMemento memento , MultiStatus result ) { } public ViewStackTrimToolBar getViewStackTrimToolbar ( String id ) { } public void printFVModel ( ) { } public void deferUpdates ( boolean defer ) { } private void deferAnimations ( boolean defer ) { } private AnimationEngine getDeferrableAnimation ( ) { } private void scheduleDeferrableAnimation ( ) { } public ViewStackTrimToolBar getBottomRightTrimStack ( ) { } }
public class HeadTracker implements SensorEventListener { private static final float DEFAULT_NECK_HORIZONTAL_OFFSET = 0.08F ; private static final float DEFAULT_NECK_VERTICAL_OFFSET = 0.075F ; private static final boolean DEFAULT_NECK_MODEL_ENABLED = false ; private final Display mDisplay ; private final float [ ] mEkfToHeadTracker ; private final float [ ] mSensorToDisplay ; private float mDisplayRotation ; private final float [ ] mNeckModelTranslation ; private final float [ ] mTmpHeadView ; private final float [ ] mTmpHeadView2 ; private boolean mNeckModelEnabled ; private volatile boolean mTracking ; private OrientationEKF mTracker ; private SensorEventProvider mSensorEventProvider ; private Clock mClock ; private long mLatestGyroEventClockTimeNs ; private final Vector3d mGyroBias ; private final Vector3d mLatestGyro ; private final Vector3d mLatestAcc ; public static HeadTracker createFromContext ( final Context context ) { } public HeadTracker ( final SensorEventProvider sensorEventProvider , final Clock clock , final Display display ) { } public void onSensorChanged ( final SensorEvent event ) { } public void onAccuracyChanged ( final Sensor sensor , final int accuracy ) { } public void startTracking ( ) { } public void stopTracking ( ) { } public void setGyroBias ( final float [ ] gyroBias ) { } public void setNeckModelEnabled ( final boolean enabled ) { } public void getLastHeadView ( final float [ ] headView , final int offset ) { if ( ( offset + 16 ) > ( headView . length ) ) { throw new IllegalArgumentException ( "Not<seq2seq4repair_space>enough<seq2seq4repair_space>space<seq2seq4repair_space>to<seq2seq4repair_space>write<seq2seq4repair_space>the<seq2seq4repair_space>result" ) ; } float rotation = 0.0F ; switch ( this . mDisplay . getRotation ( ) ) { case 0 : { rotation = 0.0F ; break ; } case 1 : { rotation = 90.0F ; break ; } case 2 : { rotation = 180.0F ; break ; } case 3 : { rotation = 270.0F ; break ; } } if ( rotation != ( this . mDisplayRotation ) ) { this . mDisplayRotation = rotation ; Matrix . setRotateEulerM ( this . mSensorToDisplay , 0 , 0.0F , 0.0F , ( - rotation ) ) ; Matrix . setRotateEulerM ( this . mEkfToHeadTracker , 0 , ( - 90.0F ) , 0.0F , rotation ) ; } synchronized ( this . mTracker ) { final double secondsSinceLastGyroEvent = TimeUnit . NANOSECONDS . toSeconds ( ( ( this . mClock . nanoTime ( ) ) - ( this . mLatestGyroEventClockTimeNs ) ) ) ; <START_BUG> final double secondsToPredictForward = secondsSinceLastGyroEvent + ( 0.0 . GL_PACK_ALIGNMENTGLES20 . GL_PACK_ALIGNMENTGLES20 . GL_PACK_ALIGNMENTGLES20 . GL_PACK_ALIGNMENT ) ; <END_BUG> final double [ ] mat = this . mTracker . getPredictedGLMatrix ( secondsToPredictForward ) ; for ( int i = 0 ; i < ( headView . length ) ; ++ i ) { this . mTmpHeadView [ i ] = ( ( float ) ( mat [ i ] ) ) ; } } Matrix . multiplyMM ( this . mTmpHeadView2 , 0 , this . mSensorToDisplay , 0 , this . mTmpHeadView , 0 ) ; Matrix . multiplyMM ( headView , offset , this . mTmpHeadView2 , 0 , this . mEkfToHeadTracker , 0 ) ; if ( this . mNeckModelEnabled ) { Matrix . multiplyMM ( this . mTmpHeadView , 0 , this . mNeckModelTranslation , 0 , headView , offset ) ; Matrix . translateM ( headView , offset , this . mTmpHeadView , 0 , 0.0F , 0.075F , 0.0F ) ; } } }
public class PageAndComponentProvider extends DefaultPageProvider { private IRequestableComponent component ; private String componentPath ; public PageAndComponentProvider ( IRequestablePage page , String componentPath ) { } public PageAndComponentProvider ( IRequestablePage page , IRequestableComponent component ) { } public PageAndComponentProvider ( Class < ? extends IRequestablePage > pageClass , PageParameters pageParameters , String componentPath ) { } public PageAndComponentProvider ( Class < ? extends IRequestablePage > pageClass , String componentPath ) { } public PageAndComponentProvider ( int pageId , Class < ? extends IRequestablePage > pageClass , Integer renderCount , String componentPath ) { } public PageAndComponentProvider ( int pageId , Class < ? extends IRequestablePage > pageClass , PageParameters pageParameters , Integer renderCount , String componentPath ) { } public PageAndComponentProvider ( int pageId , Integer renderCount , String componentPath ) { } @ Override protected boolean prepareForRenderNewPage ( ) { } public IRequestableComponent getComponent ( ) { } public String getComponentPath ( ) { if ( ( componentPath ) != null ) { return componentPath ; } else { <START_BUG> return component . getPath ( ) ; <END_BUG> } } private void setComponentPath ( String componentPath ) { } }
public class MainActivity extends Activity implements DataManagerInterface , GroupMakerFragment . GroupMakerInterface , SignupFragment . SignupInterface { private static final String TAG = "Interfaces" ; private DataManager dataManager ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( activity_main ) ; if ( savedInstanceState == null ) { <START_BUG> getFragmentManager ( ) . beginTransaction ( ) . add ( container , new MessageFragment ( ) ) . commit ( ) ; <END_BUG> } dataManager = new DataManager ( this , ConnectionType . HTTP ) ; dataManager . setGroupId ( 4543456 ) ; dataManager . startServices ( ) ; } @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { } @ Override protected void onDestroy ( ) { } @ Override public void onSignupClicked ( ) { } @ Override public void onGroupJoin ( ) { } @ Override public DataManager getDataManager ( ) { } }
public class Recurring { private static Logger logger = AtfLogger . getLogger ( Recurring . class . getName ( ) ) ; public static void updateRecurringEvents ( ArrayList < TaskObject > taskList ) { } public static void updateEvent ( TaskObject task ) { } public static void renewEvent ( TaskObject task ) throws IndexOutOfBoundsException { } private static void markAsDone ( TaskObject task ) { } public static void setAllRecurringEventTimes ( TaskObject task ) { } public static void setAllRecurringDeadlineTimes ( TaskObject task ) { } public static void updateRecurringDeadlines ( ArrayList < TaskObject > taskList ) { } public static void updateDeadline ( TaskObject task , ArrayList < TaskObject > taskList , String status ) { } private static void updateDeadlineToOverdue ( TaskObject task , ArrayList < TaskObject > taskList , String status ) { } private static void updateDeadlineToCompleted ( TaskObject task , ArrayList < TaskObject > taskList , String status ) { } private static void renewDeadline ( TaskObject task ) { } private static void splitTaskFromRecurringDeadline ( LocalDateTime deadline , String title , ArrayList < TaskObject > taskList , String status ) { } private static int generateTaskId ( ArrayList < TaskObject > taskList ) { } private static TaskObject createOverdueDeadlineTaskObject ( LocalDateTime deadline , String title , int taskId , String status ) { <START_BUG> TaskObject splitDeadline = new TaskObject ( title , deadline , CATEGORY_EVENT , status , taskId ) ; <END_BUG> splitDeadline . setIsRecurring ( false ) ; splitDeadline . addToTaskDateTimes ( new LocalDateTimePair ( deadline ) ) ; TimeOutput . setDeadlineTimeOutput ( splitDeadline ) ; return splitDeadline ; } private static void updateInfiniteRecurrence ( TaskObject task ) { } private static void setTimingsBasedOnUntil ( TaskObject task , LocalDateTimePair timePair , Interval interval ) { } private static int retrieveMultiplier ( int [ ] byDayArray ) { } private static void setTimingsBasedOnCounts ( TaskObject task , LocalDateTimePair timePair , Interval interval , int count ) { } public static LocalDateTimePair setNextTimePair ( Interval interval , LocalDateTimePair timePair ) { } public static LocalDateTimePair obtainNextTime ( Interval interval , LocalDateTime startDateTime , LocalDateTime endDateTime ) { } private static LocalDateTimePair obtainNextTimeByDay ( Interval interval , LocalDateTime startDateTime , LocalDateTime endDateTime ) { } private static ArrayList < LocalDateTime > generateComparisonList ( Interval interval , LocalDateTime startDateTime ) { } private static LocalDateTime generateNextStartDateTime ( Interval interval , LocalDateTime startDateTime , ArrayList < LocalDateTime > comparisonList ) { } private static boolean checkIfInTheSameWeek ( LocalDateTime startDateTime , LocalDateTime newStartDateTime ) { } private static LocalDateTime modifyStartDateTime ( Interval interval , LocalDateTime newStartDateTime ) { } private static boolean checkIfInfiniteRecurrence ( Interval interval ) { } public static void forceUpdateEvent ( TaskObject task ) { } No newline ; at end ; of file ; }
public class ScorePhrases < E extends Pattern > { Map < String , Boolean > writtenInJustification = new HashMap < String , Boolean > ( ) ; ConstantsAndVariables < E > constVars = null ; @ Option ( name = "phraseScorerClass" ) Class < ? extends PhraseScorer > phraseScorerClass = ScorePhrasesAverageFeatures . class ; PhraseScorer phraseScorer = null ; public ScorePhrases ( Properties props , ConstantsAndVariables cv ) { } public Counter < CandidatePhrase > chooseTopWords ( Counter < CandidatePhrase > newdt , TwoDimensionalCounter < CandidatePhrase , E > terms , Counter < CandidatePhrase > useThresholdNumPatternsForTheseWords , Set < CandidatePhrase > ignoreWords , double thresholdWordExtract ) { Iterator < CandidatePhrase > termIter = Counters . toPriorityQueue ( newdt ) . iterator ( ) ; Counter < CandidatePhrase > finalwords = new edu . stanford . nlp . stats . ClassicCounter < CandidatePhrase > ( ) ; while ( termIter . hasNext ( ) ) { if ( ( finalwords . size ( ) ) >= ( constVars . numWordsToAdd ) ) { break ; } CandidatePhrase w = termIter . next ( ) ; if ( ( newdt . getCount ( w ) ) < thresholdWordExtract ) { Redwood . log ( extremedebug , ( ( ( ( ( "not<seq2seq4repair_space>adding<seq2seq4repair_space>word<seq2seq4repair_space>" + w ) + "<seq2seq4repair_space>and<seq2seq4repair_space>any<seq2seq4repair_space>later<seq2seq4repair_space>words<seq2seq4repair_space>because<seq2seq4repair_space>the<seq2seq4repair_space>score<seq2seq4repair_space>" ) + ( newdt . getCount ( w ) ) ) + "<seq2seq4repair_space>is<seq2seq4repair_space>less<seq2seq4repair_space>than<seq2seq4repair_space>the<seq2seq4repair_space>threshold<seq2seq4repair_space>of<seq2seq4repair_space>" ) + thresholdWordExtract ) ) ; break ; } assert ( newdt . getCount ( w ) ) != ( Double . POSITIVE_INFINITY ) ; if ( ( useThresholdNumPatternsForTheseWords . containsKey ( w ) ) && ( ( numNonRedundantPatterns ( terms , w ) ) < ( constVars . thresholdNumPatternsApplied ) ) ) { Redwood . log ( "extremePatDebug" , ( ( ( ( ( "Not<seq2seq4repair_space>adding<seq2seq4repair_space>" + w ) + "<seq2seq4repair_space>because<seq2seq4repair_space>the<seq2seq4repair_space>number<seq2seq4repair_space>of<seq2seq4repair_space>non<seq2seq4repair_space>redundant<seq2seq4repair_space>patterns<seq2seq4repair_space>are<seq2seq4repair_space>below<seq2seq4repair_space>threshold<seq2seq4repair_space>of<seq2seq4repair_space>" ) + ( constVars . thresholdNumPatternsApplied ) ) + ":" ) + ( terms . getCounter ( w ) . keySet ( ) ) ) ) ; continue ; } CandidatePhrase matchedFuzzy = null ; if ( ( ( constVars . minLen4FuzzyForPattern ) > 0 ) && ( ignoreWords != null ) ) <START_BUG> matchedFuzzy = ConstantsAndVariables . containsFuzzy ( ignoreWords , w . getPhrase ( ) , constVars . minLen4FuzzyForPattern ) ; <END_BUG> if ( matchedFuzzy == null ) { Redwood . log ( "extremePatDebug" , ( "adding<seq2seq4repair_space>word<seq2seq4repair_space>" + w ) ) ; finalwords . setCount ( w , newdt . getCount ( w ) ) ; } else { Redwood . log ( "extremePatDebug" , ( ( ( ( "not<seq2seq4repair_space>adding<seq2seq4repair_space>" + w ) + "<seq2seq4repair_space>because<seq2seq4repair_space>it<seq2seq4repair_space>matched<seq2seq4repair_space>" ) + matchedFuzzy ) + "<seq2seq4repair_space>in<seq2seq4repair_space>common<seq2seq4repair_space>English<seq2seq4repair_space>word" ) ) ; ignoreWords . add ( w ) ; } } String nextFive = "" ; int n = 0 ; while ( termIter . hasNext ( ) ) { n ++ ; if ( n > 5 ) break ; CandidatePhrase w = termIter . next ( ) ; nextFive += ( ( ";\t" + w ) + ":" ) + ( newdt . getCount ( w ) ) ; } Redwood . log ( DBG , ( "Next<seq2seq4repair_space>five<seq2seq4repair_space>phrases<seq2seq4repair_space>were<seq2seq4repair_space>" + nextFive ) ) ; return finalwords ; } public static < E , F > void removeKeys ( TwoDimensionalCounter < E , F > counter , Collection < E > removeKeysCollection ) { } private double numNonRedundantPatterns ( TwoDimensionalCounter < CandidatePhrase , E > terms , CandidatePhrase w ) { } public Counter < CandidatePhrase > learnNewPhrases ( String label , PatternsForEachToken patternsForEachToken , Counter < E > patternsLearnedThisIter , Counter < E > allSelectedPatterns , CollectionValuedMap < E , Triple < String , Integer , Integer > > tokensMatchedPatterns , Counter < CandidatePhrase > scoreForAllWordsThisIteration , TwoDimensionalCounter < CandidatePhrase , E > terms , TwoDimensionalCounter < CandidatePhrase , E > wordsPatExtracted , TwoDimensionalCounter < E , CandidatePhrase > patternsAndWords4Label , String identifier , Set < CandidatePhrase > ignoreWords ) throws IOException , ClassNotFoundException { } void runParallelApplyPats ( Map < String , DataInstance > sents , String label , E pattern , TwoDimensionalCounter < CandidatePhrase , E > wordsandLemmaPatExtracted , CollectionValuedMap < E , Triple < String , Integer , Integer > > matchedTokensByPat ) { } protected Map < E , Map < String , DataInstance > > getSentences ( Map < E , Set < String > > sentids ) { } public void applyPats ( Counter < E > patterns , String label , TwoDimensionalCounter < CandidatePhrase , E > wordsandLemmaPatExtracted , CollectionValuedMap < E , Triple < String , Integer , Integer > > matchedTokensByPat ) { } private void statsWithoutApplyingPatterns ( Map < String , DataInstance > sents , PatternsForEachToken patternsForEachToken , Counter < E > patternsLearnedThisIter , TwoDimensionalCounter < CandidatePhrase , E > wordsandLemmaPatExtracted ) { } private Counter < CandidatePhrase > learnNewPhrasesPrivate ( String label , PatternsForEachToken patternsForEachToken , Counter < E > patternsLearnedThisIter , Counter < E > allSelectedPatterns , Set < CandidatePhrase > alreadyIdentifiedWords , CollectionValuedMap < E , Triple < String , Integer , Integer > > matchedTokensByPat , Counter < CandidatePhrase > scoreForAllWordsThisIteration , TwoDimensionalCounter < CandidatePhrase , E > terms , TwoDimensionalCounter < CandidatePhrase , E > wordsPatExtracted , TwoDimensionalCounter < E , CandidatePhrase > patternsAndWords4Label , String identifier , Set < CandidatePhrase > ignoreWords , boolean computeProcDataFreq ) throws IOException , ClassNotFoundException { } Counter < String > getLearnedScores ( ) { } }
public class CSVParserTest { private static final String CSVINPUT = "a,b,c,d\n" + ( ( "<seq2seq4repair_space>a<seq2seq4repair_space>,<seq2seq4repair_space>b<seq2seq4repair_space>,<seq2seq4repair_space>1<seq2seq4repair_space>2<seq2seq4repair_space>\n" + "\"foo<seq2seq4repair_space>baar\",<seq2seq4repair_space>b,\n" ) + "<seq2seq4repair_space>\"foo\n,,\n\"\",,\n\"\"\",d,e\n" ) ; private static final String [ ] [ ] RESULT = new String [ ] [ ] { new String [ ] { "a" , "b" , "c" , "d" } , new String [ ] { "a" , "b" , "1<seq2seq4repair_space>2" } , new String [ ] { "foo<seq2seq4repair_space>baar" , "b" , "" } , new String [ ] { "foo\n,,\n\",,\n\"" , "d" , "e" } } ; @ Test public void testGetLine ( ) throws IOException { } @ Test public void testGetRecords ( ) throws IOException { } @ Test public void testExcelFormat1 ( ) throws IOException { } @ Test public void testExcelFormat2 ( ) throws Exception { } @ Test public void testEndOfFileBehaviourExcel ( ) throws Exception { } @ Test public void testEndOfFileBehaviorCSV ( ) throws Exception { } @ Test public void testEmptyLineBehaviourExcel ( ) throws Exception { } @ Test public void testEmptyLineBehaviourCSV ( ) throws Exception { } @ Test public void testEmptyFile ( ) throws Exception { } @ Test public void testCSV57 ( ) throws Exception { } @ Test @ Ignore public void testBackslashEscapingOld ( ) throws IOException { } @ Test public void testBackslashEscaping ( ) throws IOException { final String code = "one,two,three\n" + ( ( ( ( ( ( ( ( ( "\'\',\'\'\n" + "/\',/\'\n" ) + "\'/\'\',\'/\'\'\n" ) + "\'\'\'\',\'\'\'\'\n" ) + "/,,/,\n" ) + "//,//\n" ) + "\'//\',\'//\'\n" ) + "<seq2seq4repair_space>8<seq2seq4repair_space>,<seq2seq4repair_space>\"quoted<seq2seq4repair_space>\"\"<seq2seq4repair_space>/\"<seq2seq4repair_space>//<seq2seq4repair_space>string\"<seq2seq4repair_space>\n" ) + "9,<seq2seq4repair_space>/\n<seq2seq4repair_space>\n" ) + "" ) ; final String [ ] [ ] res = new String [ ] [ ] { new String [ ] { "one" , "two" , "three" } , new String [ ] { "" , "" } , new String [ ] { "'" , "'" } , new String [ ] { "'" , "'" } , new String [ ] { "'" , "'" } , new String [ ] { "," , "," } , new String [ ] { "/" , "/" } , new String [ ] { "/" , "/" } , new String [ ] { "<seq2seq4repair_space>8<seq2seq4repair_space>" , "<seq2seq4repair_space>\"quoted<seq2seq4repair_space>\"\"<seq2seq4repair_space>\"<seq2seq4repair_space>/<seq2seq4repair_space>string\"<seq2seq4repair_space>" } , new String [ ] { "9" , "<seq2seq4repair_space>\n<seq2seq4repair_space>" } } ; <START_BUG> final CSVFormat format = PRISTINE . withDelimiter ( ',' ) . withEncapsulator ( '\'' ) . withEscape ( '/' ) . withIgnoreEmptyLines ( true ) . withLineSeparator ( Constants . CRLF ) ; <END_BUG> final CSVParser parser = new CSVParser ( code , format ) ; final List < CSVRecord > records = parser . getRecords ( ) ; assertTrue ( ( ( records . size ( ) ) > 0 ) ) ; for ( int i = 0 ; i < ( res . length ) ; i ++ ) { assertArrayEquals ( res [ i ] , records . get ( i ) . values ( ) ) ; } } @ Test public void testBackslashEscaping2 ( ) throws IOException { } @ Test public void testDefaultFormat ( ) throws IOException { } @ Test public void testCarriageReturnLineFeedEndings ( ) throws IOException { } @ Test public void testCarriageReturnEndings ( ) throws IOException { } @ Test public void testLineFeedEndings ( ) throws IOException { } @ Test public void testIgnoreEmptyLines ( ) throws IOException { } @ Test public void testForEach ( ) throws Exception { } @ Test public void testIterator ( ) throws Exception { } @ Test public void testHeader ( ) throws Exception { } @ Test public void testHeaderComment ( ) throws Exception { } @ Test public void testProvidedHeader ( ) throws Exception { } @ Test public void testMappedButNotSetAsOutlook2007ContactExport ( ) throws Exception { } public void testGetHeaderMap ( ) throws Exception { } @ Test public void testGetLineNumberWithLF ( ) throws Exception { } @ Test public void testGetLineNumberWithCRLF ( ) throws Exception { } @ Test public void testGetLineNumberWithCR ( ) throws Exception { } @ Test public void testGetRecordNumberWithLF ( ) throws Exception { } @ Test public void testGetRecordWithMultiiLineValues ( ) throws Exception { } @ Test public void testGetRecordNumberWithCRLF ( ) throws Exception { } @ Test public void testGetRecordNumberWithCR ( ) throws Exception { } private void validateRecordNumbers ( String lineSeparator ) throws IOException { } private void validateLineNumbers ( String lineSeparator ) throws IOException { } }
public class CliClient extends CliUserHelp { public enum Function { BYTES ( BytesType . instance ) , INTEGER ( IntegerType . instance ) , LONG ( LongType . instance ) , LEXICALUUID ( LexicalUUIDType . instance ) , TIMEUUID ( TimeUUIDType . instance ) , UTF8 ( UTF8Type . instance ) , ASCII ( AsciiType . instance ) ; private AbstractType validator ; Function ( AbstractType validator ) { } public AbstractType getValidator ( ) { } public static String getFunctionNames ( ) { } } private enum AddKeyspaceArgument { REPLICATION_FACTOR , PLACEMENT_STRATEGY , STRATEGY_OPTIONS ; } private static final String DEFAULT_PLACEMENT_STRATEGY = "org.apache.cassandra.locator.SimpleStrategy" ; private Client thriftClient = null ; private CliSessionState sessionState = null ; private String keySpace = null ; private String username = null ; private Map < String , KsDef > keyspacesMap = new HashMap < String , KsDef > ( ) ; private Map < String , AbstractType > cfKeysComparators ; public CliClient ( CliSessionState cliSessionState , Cassandra . Client thriftClient ) { } public void executeCLIStatement ( String statement ) { } private void cleanupAndExit ( ) { } public KsDef getKSMetaData ( String keyspace ) throws InvalidRequestException , NotFoundException , TException { } private void executeCount ( Tree statement ) throws InvalidRequestException , TimedOutException , UnavailableException , TException { } private void executeDelete ( Tree statement ) throws InvalidRequestException , TimedOutException , UnavailableException , TException { } private void doSlice ( String keyspace , ByteBuffer key , String columnFamily , byte [ ] superColumnName ) throws IllegalAccessException , InstantiationException , NoSuchFieldException , InvalidRequestException , NotFoundException , TimedOutException , UnavailableException , TException { } private AbstractType getFormatTypeForColumn ( String compareWith ) { } private void executeGet ( Tree statement ) throws ClassNotFoundException , IllegalAccessException , InstantiationException , NoSuchFieldException , InvalidRequestException , NotFoundException , TimedOutException , UnavailableException , TException { if ( ( ! ( CliMain . isConnected ( ) ) ) || ( ! ( hasKeySpace ( ) ) ) ) return ; Tree columnFamilySpec = statement . getChild ( 0 ) ; String columnFamily = CliCompiler . getColumnFamily ( columnFamilySpec , keyspacesMap . get ( keySpace ) . cf_defs ) ; ByteBuffer key = getKeyAsBytes ( columnFamily , columnFamilySpec . getChild ( 1 ) ) ; int columnSpecCnt = CliCompiler . numColumnSpecifiers ( columnFamilySpec ) ; CfDef cfDef = getCfDef ( columnFamily ) ; <START_BUG> boolean isSuper = cfDef . comparator_type . equals ( "Super" ) ; <END_BUG> byte [ ] superColumnName = null ; ByteBuffer columnName ; if ( columnSpecCnt == 0 ) { doSlice ( keySpace , key , columnFamily , superColumnName ) ; return ; } else if ( columnSpecCnt == 1 ) { columnName = getColumnName ( columnFamily , columnFamilySpec . getChild ( 2 ) ) ; if ( isSuper ) { superColumnName = columnName . array ( ) ; doSlice ( keySpace , key , columnFamily , superColumnName ) ; return ; } } else if ( columnSpecCnt == 2 ) { superColumnName = getColumnName ( columnFamily , columnFamilySpec . getChild ( 2 ) ) . array ( ) ; columnName = getSubColumnName ( columnFamily , columnFamilySpec . getChild ( 3 ) ) ; } else { sessionState . out . println ( "Invalid<seq2seq4repair_space>row,<seq2seq4repair_space>super<seq2seq4repair_space>column,<seq2seq4repair_space>or<seq2seq4repair_space>column<seq2seq4repair_space>specification." ) ; return ; } AbstractType validator = getValidatorForValue ( cfDef , TBaseHelper . byteBufferToByteArray ( columnName ) ) ; ColumnPath path = new ColumnPath ( columnFamily ) ; if ( superColumnName != null ) path . setSuper_column ( superColumnName ) ; path . setColumn ( columnName ) ; Column column ; try { column = thriftClient . get ( key , path , ONE ) . column ; } catch ( NotFoundException e ) { sessionState . out . println ( "Value<seq2seq4repair_space>was<seq2seq4repair_space>not<seq2seq4repair_space>found" ) ; return ; } byte [ ] columnValue = column . getValue ( ) ; String valueAsString ; if ( ( statement . getChildCount ( ) ) == 2 ) { Tree typeTree = statement . getChild ( 1 ) . getChild ( 0 ) ; String typeName = CliUtils . unescapeSQLString ( typeTree . getText ( ) ) ; AbstractType valueValidator = getFormatTypeForColumn ( typeName ) ; valueAsString = valueValidator . getString ( ByteBuffer . wrap ( columnValue ) ) ; updateColumnMetaData ( cfDef , columnName , valueValidator . getClass ( ) . getName ( ) ) ; } else { valueAsString = ( validator == null ) ? new String ( columnValue , Charsets . UTF_8 ) : validator . getString ( ByteBuffer . wrap ( columnValue ) ) ; } sessionState . out . printf ( "=><seq2seq4repair_space>(column=%s,<seq2seq4repair_space>value=%s,<seq2seq4repair_space>timestamp=%d%s)%n" , formatColumnName ( keySpace , columnFamily , column ) , valueAsString , column . timestamp , ( column . isSetTtl ( ) ? String . format ( ",<seq2seq4repair_space>ttl=%d" , column . getTtl ( ) ) : "" ) ) ; } private void executeGetWithConditions ( Tree statement ) { } private void executeSet ( Tree statement ) throws IllegalAccessException , InstantiationException , NoSuchFieldException , InvalidRequestException , TimedOutException , UnavailableException , TException { } private void executeShowClusterName ( ) throws TException { } private void executeAddKeySpace ( Tree statement ) { } private void executeAddColumnFamily ( Tree statement ) { } private void executeUpdateKeySpace ( Tree statement ) { } private void executeUpdateColumnFamily ( Tree statement ) { } private KsDef updateKsDefAttributes ( Tree statement , KsDef ksDefToUpdate ) { } private CfDef updateCfDefAttributes ( Tree statement , CfDef cfDefToUpdate ) { } private void executeDelKeySpace ( Tree statement ) throws InvalidRequestException , NotFoundException , TException { } private void executeDelColumnFamily ( Tree statement ) throws InvalidRequestException , NotFoundException , TException { } private void executeList ( Tree statement ) throws IllegalAccessException , InstantiationException , NoSuchFieldException , InvalidRequestException , NotFoundException , TimedOutException , UnavailableException , TException { } private void executeTruncate ( String columnFamily ) { } private void executeAssumeStatement ( Tree statement ) { } private void executeShowVersion ( ) throws TException { } private void executeShowKeySpaces ( ) throws InvalidRequestException , TException { }
public class CardInfo extends EntityInfo { @ NonSerializable private Card card ; private int hp ; private int summonDelay ; @ NonSerializable private CardStatus status ; @ NonSerializable private Player owner ; @ NonSerializable private List < SkillUseInfo > features ; private int cachedPosition ; private boolean deadOnce ; @ NonSerializable private Map < SkillType , List < SkillEffect > > effects ; public CardInfo ( Card card , Player owner ) { } public CardSkill getExtraFeature ( ) { } public boolean hasDeadOnce ( ) { } void setDeadOnce ( boolean deadOnce ) { } public void addEffect ( SkillEffect effect ) { } public List < SkillEffect > getEffectsCausedBy ( SkillType cause ) { List < SkillEffect > result = effects . get ( cause ) ; if ( result == null ) { return new ArrayList < SkillEffect > ( ) ; } else { <START_BUG> return result ; <END_BUG> } } public int getPosition ( ) { } public Player getOwner ( ) { } private Card getCard ( ) { } public int getInitAT ( ) { } private int getSpecificLevelEffectAT ( SkillTag tag ) { } public int getLevel0AT ( ) { } public int getLevel1AT ( ) { } public int getLevel2AT ( ) { } public int getLevel3AT ( ) { } public int getCurrentAT ( ) { } public int getHP ( ) { } public CardInfo setBasicHP ( int hp ) { } public int getSummonDelay ( ) { } public CardInfo setSummonDelay ( int summonDelay ) { } public CardStatus getStatus ( ) { } public void addStatus ( CardStatusItem statusItem ) { } public boolean removeStatus ( CardStatusType type ) { } @ Override public String getShortDesc ( ) { } public void reset ( ) { } public void resetSummonDelay ( ) { } private List < SkillUseInfo > getAllFeatures ( ) { } public Race getRace ( ) { } public List < SkillUseInfo > getUsableSummonFeatures ( ) { } public List < SkillUseInfo > getUsableDeathFeatures ( ) { } public List < SkillUseInfo > getNormalUsableFeatures ( ) { } public List < SkillUseInfo > getAllUsableFeatures ( ) { } private List < SkillUseInfo > getUsableFeatures ( ) { } public void removeEffect ( SkillEffect effect ) { } public List < SkillEffect > getEffects ( ) { } public List < SkillEffect > getEffectsCausedBy ( SkillUseInfo feature ) { } public int getMaxHP ( ) { } public String getId ( ) { } public String getUniqueName ( ) { } public String getName ( ) { } public int getLevel ( ) { } public String getEffectsDesc ( ) { } public boolean isDead ( ) { } public boolean isWeak ( ) { } public int applyDamage ( int damage ) { } public int getOriginalMaxHP ( ) { } public boolean containsUsableFeaturesWithTag ( SkillTag tag ) { } public static boolean isSameType ( CardInfo victim , CardInfo defender ) { } public int getLostHP ( ) { } public void refreshPosition ( ) { } public boolean isWounded ( ) { } public int getSummonSpeed ( ) { } public boolean containsUsableFeature ( SkillType type ) { } public int getStar ( ) { } public boolean hasUsed ( SkillUseInfo skillUseInfo ) { } public void setUsed ( SkillUseInfo skillUseInfo ) { } No newline ; at end ; of file ; }
public class Node implements Runnable { private int myId ; public List < Finger > fingers ; private int pred ; private List < Integer > keys ; private AtomicBoolean running ; private Manager mngr ; private static final int FINGER_LENGTH = 4 ; private ServerSocket serverSocket ; public Node ( int id , Manager mngr , int port ) { } public Node ( int id , int nPrime , Manager mngr , int port ) { } @ Override public void run ( ) { while ( running . get ( ) ) { String input = null ; try { Socket clientSocket = serverSocket . accept ( ) ; PrintWriter out = new PrintWriter ( clientSocket . getOutputStream ( ) , true ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( clientSocket . getInputStream ( ) ) ) ; if ( ( ( input = in . readLine ( ) ) . compareTo ( STOP ) ) == 0 ) break ; Message msg = new Message ( input ) ; if ( ( msg . getType ( ) ) == ( Message . FIND_SUCCESSOR ) ) { out . println ( findSuccessor ( myId , msg . getId ( ) ) ) ; } else if ( ( msg . getType ( ) ) == ( Message . GET_SUCCESSOR ) ) { out . println ( getSuccessor ( msg . getN ( ) ) ) ; } else if ( ( msg . getType ( ) ) == ( Message . GET_PREDECESSOR ) ) { out . println ( getPredecessor ( msg . getN ( ) ) ) ; } else if ( ( msg . getType ( ) ) == ( Message . SET_PREDECESSOR ) ) { setPredecessor ( msg . getN ( ) , msg . getId ( ) ) ; } else if ( ( msg . getType ( ) ) == ( Message . CLOSEST_PRECEDING ) ) { out . println ( closestPrecedingFinger ( msg . getN ( ) , msg . getId ( ) ) ) ; } else if ( ( msg . getType ( ) ) == ( Message . UPDATE_FINGERS ) ) { updateFingers ( msg . getN ( ) , msg . getId ( ) , msg . getIndex ( ) ) ; } else if ( ( msg . getType ( ) ) == ( Message . UPDATE_OTHERS ) ) { } else if ( ( msg . getType ( ) ) == ( Message . UPDATE_SUCCESSOR ) ) { if ( ( ( msg . getN ( ) ) == ( myId ) ) && ( ( msg . getN ( ) ) != ( msg . getId ( ) ) ) ) { pred = msg . getId ( ) ; for ( int i = 0 ; i < ( Node . FINGER_LENGTH ) ; i ++ ) { if ( inBetweenPB ( new int [ ] { fingers . get ( i ) . getSuccessor ( ) , msg . getId ( ) } , fingers . get ( i ) . getStart ( ) ) ) { fingers . get ( i ) . setSuccessor ( msg . getId ( ) ) ; } updateSuccessor ( fingers . get ( i ) . getStart ( ) , msg . getId ( ) ) ; } } } else if ( ( msg . getType ( ) ) == ( Message . UPDATE_PREDECESSOR ) ) { if ( ( msg . getN ( ) ) == ( myId ) ) { for ( int i = 0 ; i < ( Node . FINGER_LENGTH ) ; i ++ ) { <START_BUG> if ( inBetweenPB ( new int [ ] { myId , msg . getId ( ) } , fingers . get ( i ) . getStart ( ) ) ) { <END_BUG> fingers . get ( i ) . setSuccessor ( msg . getId ( ) ) ; } } } } clientSocket . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } public void initFingers ( int nPrime ) { } public int findSuccessor ( int n , int id ) { } public int findPredecessor ( int n , int id ) { } public int closestPrecedingFinger ( int n , int id ) { } public void updateOthers ( int n ) { } public void updateSuccessor ( int n , int id ) { } public void updatePredecessor ( int n , int id ) { } public void updateFingers ( int n , int s , int i ) { } public int getSuccessor ( int n ) { } public int getPredecessor ( int n ) { } public void setPredecessor ( int n , int id ) { } private boolean inBetween ( int [ ] interval , int id ) { } private boolean inBetweenBP ( int [ ] interval , int id ) { } private boolean inBetweenPB ( int [ ] interval , int id ) { } private boolean inBetweenBB ( int [ ] interval , int id ) { } private void bind ( int port ) { } public void stop ( ) { } }
public class RootwardSynthesisExpander extends SynthesisExpander implements PathExpander { private TopologicalOrder topologicalOrder ; private Map < Long , HashSet < Relationship > > childRels ; private Map < Long , TLongBitArraySet > nodeMrca ; private GraphDatabaseAgent gdb ; private boolean trivialTestCase = false ; private boolean VERBOSE = true ; private boolean USING_RANKS = true ; public RootwardSynthesisExpander ( Node root ) { } private void updateBestRankedRel ( Map < Node , Relationship > bestRelForNode , Relationship rel ) { } private Iterable < Relationship > getALLStreeAndTaxRels ( Node n ) { } private boolean treeRelContainsOther ( Relationship i , Relationship j ) { } private long [ ] mrcaTips ( Relationship rel ) { } private Set < Long > mrcaTipsAndInternal ( Iterable < Long > relIds ) { } private TLongBitArraySet mrcaTipsAndInternal ( Long relId ) { } private Map < Relationship , Set < Integer > > augmentedRanks = new HashMap < Relationship , Set < Integer > > ( ) ; private int rank ( Relationship r ) { } private void uprank ( Relationship i , Relationship j ) { } private static boolean isTaxonomyRel ( Relationship r ) { } public String getDescription ( ) { } public List < Long > findBestNonOverlapping ( Collection < Relationship > rels ) { if ( ( rels . size ( ) ) < 1 ) { if ( VERBOSE ) { System . out . println ( "(no<seq2seq4repair_space>incoming<seq2seq4repair_space>rels)" ) ; } return new ArrayList < Long > ( ) ; } TLongBitArraySet [ ] mrcaSetsForRels = new TLongBitArraySet [ rels . size ( ) ] ; double [ ] weights = new double [ rels . size ( ) ] ; Long [ ] relIds = new Long [ rels . size ( ) ] ; Iterator < Relationship > relsIter = rels . iterator ( ) ; for ( int i = 0 ; relsIter . hasNext ( ) ; i ++ ) { Relationship rel = relsIter . next ( ) ; relIds [ i ] = rel . getId ( ) ; <START_BUG> mrcaSetsForRels [ i ] = new TLongBitArraySet ( mrcaTips ( rel ) ) ; <END_BUG> if ( USING_RANKS ) { weights [ i ] = getScoreRanked ( rel ) ; } else { weights [ i ] = getScoreNodeCount ( rel ) ; } if ( VERBOSE ) { System . out . println ( ( ( ( ( ( ( ( rel . getId ( ) ) + ":<seq2seq4repair_space>nodeMrca(" ) + ( rel . getStartNode ( ) . getId ( ) ) ) + ")<seq2seq4repair_space>=<seq2seq4repair_space>" ) + ( nodeMrca . get ( rel . getStartNode ( ) . getId ( ) ) ) ) + ".<seq2seq4repair_space>score<seq2seq4repair_space>=<seq2seq4repair_space>" ) + ( weights [ i ] ) ) ) ; } } if ( USING_RANKS ) { for ( int i = 0 ; i < ( weights . length ) ; i ++ ) { for ( int j = i + 1 ; j < ( weights . length ) ; j ++ ) { if ( ( weights [ i ] ) == ( weights [ j ] ) ) { double ni = getScoreNodeCount ( gdb . getRelationshipById ( relIds [ i ] ) ) ; double nj = getScoreNodeCount ( gdb . getRelationshipById ( relIds [ j ] ) ) ; if ( ni > nj ) { ( weights [ i ] ) ++ ; } else if ( ni < nj ) { ( weights [ j ] ) ++ ; } } } } } if ( ( relIds . length ) <= ( BruteWeightedIS . MAX_TRACTABLE_N ) ) { return new BruteWeightedIS ( relIds , weights , mrcaSetsForRels ) . best ( ) ; } else { return new opentree . synthesis . mwis . GreedyApproximateWeightedIS ( relIds , weights , mrcaSetsForRels ) . best ( ) ; } } private double getScoreRankedNodeCount ( Relationship rel ) { } private double getScoreNodeCount ( Relationship rel ) { } private double getScoreRanked ( Relationship rel ) { } private long getStartNodeId ( Long relId ) { } @ Override public Iterable < Relationship > expand ( Path arg0 , BranchState arg1 ) { } @ Override public PathExpander reverse ( ) { } public Iterable < Long > findBestNonOverlappingGraph ( Long [ ] relIds ) { } private int getWeight ( long id ) { } }
public class RepositoryMongoTest extends KurentoClientBrowserTest < WebRtcTestPage > { @ ComponentScan ( basePackageClasses = { RepositoryItem . class } ) public static class RepositoryWebServer extends WebServer { @ Bean public RepositoryHttpServlet repositoryHttpServlet ( ) { } @ Bean public ServletRegistrationBean repositoryServletRegistrationBean ( RepositoryHttpServlet repositoryHttpServlet ) { } @ Bean public RepositoryApiConfiguration repositoryApiConfiguration ( ) throws UnknownHostException { log . info ( "Repository<seq2seq4repair_space>for<seq2seq4repair_space>playing<seq2seq4repair_space>test" ) ; RepositoryApiConfiguration config = new RepositoryApiConfiguration ( ) ; <START_BUG> config . setWebappPublicUrl ( ( ( ( ( "http://" + ( InetAddress . getLocalHost ( ) . getHostAddress ( ) ) ) + ":" ) + ( WebServerService . getAppHttpsPort ( ) ) ) + "/" ) ) ; <END_BUG> config . setMongoDatabaseName ( "testfiles" ) ; config . setMongoUrlConnection ( ( ( ( Protocol . MONGODB ) + "://" ) + ( getTestFilesMongoPath ( ) ) ) ) ; config . setRepositoryType ( MONGODB ) ; return config ; } } public Repository repository ; @ Before public void setupRepository ( ) { } public String getMediaUrl ( Protocol protocol , String nameMedia ) { } }
public abstract class PortletApplication extends Application implements ISessionFactory { private String applicationKey ; private IRequestCycleProcessor requestCycleProcessor ; private IRequestCycleProcessor actionRequestCycleProcessor ; private String sessionAttributePrefix ; private ISessionFactory sessionFactory = this ; private RequestLogger requestLogger ; WicketPortlet portlet ; public void setWicketPortlet ( WicketPortlet portlet ) { } public WicketPortletSession getSession ( final WicketPortletRequest request ) { ISessionStore sessionStore = getSessionStore ( ) ; Session session = sessionStore . lookup ( request ) ; if ( session == null ) { <START_BUG> session = getSessionFactory ( ) . newSession ( request ) ; <END_BUG> session . setLocale ( request . getLocale ( ) ) ; sessionStore . bind ( request , session ) ; } WicketPortletSession webSession ; if ( session instanceof WicketPortletSession ) { webSession = ( ( WicketPortletSession ) ( session ) ) ; } else { throw new WicketRuntimeException ( ( "Session<seq2seq4repair_space>created<seq2seq4repair_space>by<seq2seq4repair_space>a<seq2seq4repair_space>PortletApplication<seq2seq4repair_space>session<seq2seq4repair_space>factory<seq2seq4repair_space>" + "must<seq2seq4repair_space>be<seq2seq4repair_space>a<seq2seq4repair_space>subclass<seq2seq4repair_space>of<seq2seq4repair_space>PortletSession" ) ) ; } session . setApplication ( this ) ; webSession . initForRequest ( ) ; return webSession ; } public WicketPortletResponse newPortletResponse ( final PortletResponse res ) { } public WicketPortletRequest newPortletRequest ( PortletRequest req ) { } public String getApplicationKey ( ) { } protected ISessionFactory getSessionFactory ( ) { } protected ISessionStore newSessionStore ( ) { } public Session newSession ( ) { } public void initPortlet ( ) { } protected void internalInit ( ) { } public void destroyPortlet ( ) { } protected IRequestCycleFactory getDefaultRequestCycleFactory ( ) { } protected IRequestCycleProcessor newRenderRequestCycleProcessor ( ) { } protected IRequestCycleProcessor newActionRequestCycleProcessor ( ) { } public IRequestCycleProcessor getActionRequestCycleProcessor ( ) { } protected final IRequestCycleProcessor getRenderRequestCycleProcessor ( ) { } public final RequestLogger getRequestLogger ( ) { } public final void setRequestLogger ( RequestLogger logger ) { } void sessionDestroyed ( String sessionId ) { } public final String getSessionAttributePrefix ( final WicketPortletRequest request ) { } }
public class WarpCommand implements CommandExecutor { public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) { if ( ( args . length ) == 0 ) { HashMap < String , String > values = new HashMap < String , String > ( ) ; Helper . sendParsedMessage ( sender , Settings . getMessage ( "error.no-warp-given" ) , values ) ; return true ; } String perms = "easywarp.command.warpother" ; if ( ( args . length ) >= 1 ) { Player target = null ; String warpName = args [ 0 ] ; if ( ( args . length ) > 1 ) { if ( ! ( sender . hasPermission ( perms ) ) ) { HashMap < String , String > values = new HashMap < String , String > ( ) ; values . put ( "node" , perms ) ; Helper . sendParsedMessage ( sender , Settings . getMessage ( "error.no-permission" ) , values ) ; return true ; } target = Bukkit . getPlayerExact ( args [ 0 ] ) ; warpName = args [ 1 ] ; if ( ! ( WarpManager . isWarp ( warpName ) ) ) { HashMap < String , String > values = new HashMap < String , String > ( ) ; values . put ( "warp" , warpName ) ; Helper . sendParsedMessage ( sender , Settings . getMessage ( "error.no-warp" ) , values ) ; return true ; } if ( ( target == null ) || ( ! ( target . isOnline ( ) ) ) ) { HashMap < String , String > values = new HashMap < String , String > ( ) ; values . put ( "target" , args [ 0 ] ) ; Helper . sendParsedMessage ( sender , Settings . getMessage ( "error.no-player" ) , values ) ; return true ; } } else { if ( ! ( WarpManager . isWarp ( warpName ) ) ) { HashMap < String , String > values = new HashMap < String , String > ( ) ; values . put ( "warp" , warpName ) ; Helper . sendParsedMessage ( sender , Settings . getMessage ( "error.no-warp" ) , values ) ; return true ; } if ( ! ( sender instanceof Player ) ) { HashMap < String , String > values = new HashMap < String , String > ( ) ; Helper . sendParsedMessage ( sender , Settings . getMessage ( "error.not-player" ) , values ) ; return true ; } perms = "easywarp.command.warp" ; if ( ! ( sender . hasPermission ( perms ) ) ) { HashMap < String , String > values = new HashMap < String , String > ( ) ; values . put ( "node" , perms ) ; Helper . sendParsedMessage ( sender , Settings . getMessage ( "error.no-permission" ) , values ) ; return true ; } <START_BUG> if ( ! ( WarpManager . getAvailable ( sender ) . contains ( warpName ) ) ) { <END_BUG> HashMap < String , String > values = new HashMap < String , String > ( ) ; values . put ( "node" , perms ) ; values . put ( "warp" , warpName ) ; Helper . sendParsedMessage ( sender , Settings . getMessage ( "warp.no-permission" ) , values ) ; return true ; } target = ( ( Player ) ( sender ) ) ; } Warp to = WarpManager . getWarp ( warpName ) ; if ( ( ! ( sender instanceof Player ) ) || ( sender != target ) ) { HashMap < String , String > values = new HashMap < String , String > ( ) ; values . put ( "target" , target . getName ( ) ) ; values . put ( "warp" , to . getName ( ) ) ; Helper . sendParsedMessage ( sender , Settings . getMessage ( "warp.other" ) , values ) ; Helper . warpOther ( target , to ) ; } else { Helper . warpSelf ( target , to ) ; } } return true ; } No newline ; at end ; of file ; }
@ Value public class BindThrownStatement implements Statement { private final String name ; private final Expr value ; @ Override public void toString ( SBuilder sb , ExpressionStrategy expressionStrategy , MockStrategy mockStrategy ) { sb . appendln ( "Throwable<seq2seq4repair_space>" , name , ";" ) ; sb . appendln ( "try<seq2seq4repair_space>{" ) ; sb . shift ( ) ; value . < Void > accept ( ( quotedExpr ) -> { sb . appendln ( expressionStrategy . getValue ( quotedExpr ) , ";" ) ; return null ; } , ( stubExpr ) -> { <START_BUG> mockStrategy . stub ( sb , name , stubExpr , expressionStrategy ) ; <END_BUG> return null ; } , ( matcherExpr ) -> { sb . appendln ( matcherExpr . getExpr ( ) , ";" ) ; return null ; } ) ; sb . appendln ( name , "<seq2seq4repair_space>=<seq2seq4repair_space>null;" ) ; sb . unshift ( ) ; if ( expressionStrategy . wrappingException ( ) . isPresent ( ) ) { sb . appendln ( "}<seq2seq4repair_space>catch<seq2seq4repair_space>(" , expressionStrategy . wrappingException ( ) . get ( ) , "<seq2seq4repair_space>e)<seq2seq4repair_space>{" ) ; sb . shift ( ) ; sb . appendln ( name , "<seq2seq4repair_space>=<seq2seq4repair_space>" , expressionStrategy . wrappedException ( "e" ) , ";" ) ; sb . unshift ( ) ; } sb . appendln ( "}<seq2seq4repair_space>catch<seq2seq4repair_space>(Throwable<seq2seq4repair_space>e)<seq2seq4repair_space>{" ) ; sb . shift ( ) ; sb . appendln ( name , "<seq2seq4repair_space>=<seq2seq4repair_space>e;" ) ; sb . unshift ( ) ; sb . appendln ( "}" ) ; } @ Override public Set < ImportedName > importedNames ( ExpressionStrategy expressionStrategy , MockStrategy mockStrategy ) { } @ Override public < T > T accept ( StatementVisitor < T > visitor ) { } }
public final class IOUtils { private static final Logger log = LoggerFactory . getLogger ( IOUtils . class ) ; private static final int DEFAULT_BUFFER_SIZE = 1024 * 4 ; public IOUtils ( ) { } public static void close ( final Closeable closeable ) throws IOException { } public static void closeQuietly ( final Closeable closeable ) { } public static byte [ ] toByteArray ( final InputStream input ) throws IOException { } public static byte [ ] toByteArray ( final Reader input ) throws IOException { } public static byte [ ] toByteArray ( final Reader input , final String encoding ) throws IOException { } public static char [ ] toCharArray ( final InputStream is ) throws IOException { } public static char [ ] toCharArray ( final InputStream is , final String encoding ) throws IOException { } public static char [ ] toCharArray ( final Reader input ) throws IOException { } public static String toString ( final InputStream input ) throws IOException { } public static String toString ( final InputStream input , final String encoding ) throws IOException { } public static String toString ( final Reader input ) throws IOException { } public static void write ( final byte [ ] data , final OutputStream output ) throws IOException { } public static void write ( final byte [ ] data , final Writer output ) throws IOException { } public static void write ( final byte [ ] data , final Writer output , final String encoding ) throws IOException { } public static void write ( final char [ ] data , final Writer output ) throws IOException { } public static void write ( final char [ ] data , final OutputStream output ) throws IOException { } public static void write ( final char [ ] data , final OutputStream output , final String encoding ) throws IOException { } public static void write ( final String data , final Writer output ) throws IOException { } public static void write ( final String data , final OutputStream output ) throws IOException { } public static void write ( final String data , final OutputStream output , final String encoding ) throws IOException { } public static void write ( final StringBuilder data , final Writer output ) throws IOException { } public static void write ( final StringBuilder data , final OutputStream output ) throws IOException { } public static void write ( final StringBuilder data , final OutputStream output , final String encoding ) throws IOException { } public static int copy ( final InputStream input , final OutputStream output ) throws IOException { } public static void copy ( final InputStream input , final Writer output ) throws IOException { } public static void copy ( final InputStream input , final Writer output , final String encoding ) throws IOException { } public static int copy ( final Reader input , final Writer output ) throws IOException { } public static void copy ( final Reader input , final OutputStream output ) throws IOException { } public static void copy ( final Reader input , final OutputStream output , final String encoding ) throws IOException { } public static boolean contentEquals ( InputStream input1 , InputStream input2 ) throws IOException { } public static boolean contentEquals ( Reader input1 , Reader input2 ) throws IOException { } public static Time getLastModified ( File file ) { if ( ( file . exists ( ) ) == false ) { return null ; } long millis = file . lastModified ( ) ; if ( millis == 0 ) { return null ; } <START_BUG> return Time . valueOf ( millis ) ; <END_BUG> } }
public class ParameterizedSingleTypeReference extends ArrayTypeReference { public TypeReference [ ] typeArguments ; private boolean didResolve = false ; public ParameterizedSingleTypeReference ( char [ ] name , TypeReference [ ] typeArguments , int dim , long pos ) { } public void checkBounds ( Scope scope ) { } public TypeReference copyDims ( int dim ) { } public char [ ] [ ] getParameterizedTypeName ( ) { } protected TypeBinding getTypeBinding ( Scope scope ) { } private TypeBinding internalResolveType ( Scope scope , ReferenceBinding enclosingType , boolean checkBounds ) { this . constant = Constant . NotAConstant ; if ( this . didResolve ) { if ( ( ( this . resolvedType ) != null ) && ( ! ( this . resolvedType . isValidBinding ( ) ) ) ) return null ; return this . resolvedType ; } this . didResolve = true ; if ( enclosingType == null ) { this . resolvedType = scope . getType ( token ) ; if ( ! ( this . resolvedType . isValidBinding ( ) ) ) { reportInvalidType ( scope ) ; return null ; } enclosingType = this . resolvedType . enclosingType ( ) ; if ( ( enclosingType != null ) && ( enclosingType . isGenericType ( ) ) ) { ReferenceBinding currentType = ( ( ReferenceBinding ) ( this . resolvedType ) ) ; enclosingType = ( currentType . isStatic ( ) ) ? ( ( ReferenceBinding ) ( scope . environment ( ) . convertToRawType ( enclosingType ) ) ) : scope . environment ( ) . convertToParameterizedType ( enclosingType ) ; } } else { this . resolvedType = scope . getMemberType ( token , ( ( ReferenceBinding ) ( enclosingType . erasure ( ) ) ) ) ; if ( ! ( this . resolvedType . isValidBinding ( ) ) ) { scope . problemReporter ( ) . invalidEnclosingType ( this , this . resolvedType , enclosingType ) ; return null ; } if ( isTypeUseDeprecated ( this . resolvedType , scope ) ) scope . problemReporter ( ) . deprecatedType ( this . resolvedType , this ) ; } boolean isClassScope = ( scope . kind ) == ( Scope . CLASS_SCOPE ) ; TypeReference keep = null ; if ( isClassScope ) { keep = ( ( ClassScope ) ( scope ) ) . superTypeReference ; ( ( ClassScope ) ( scope ) ) . superTypeReference = null ; } ReferenceBinding currentType = ( ( ReferenceBinding ) ( this . resolvedType ) ) ; int argLength = this . typeArguments . length ; TypeBinding [ ] argTypes = new TypeBinding [ argLength ] ; boolean argHasError = false ; for ( int i = 0 ; i < argLength ; i ++ ) { TypeReference typeArgument = this . typeArguments [ i ] ; TypeBinding argType = ( isClassScope ) ? typeArgument . resolveTypeArgument ( ( ( ClassScope ) ( scope ) ) , currentType , i ) : typeArgument . resolveTypeArgument ( ( ( BlockScope ) ( scope ) ) , currentType , i ) ; if ( argType == null ) { argHasError = true ; } else { argTypes [ i ] = argType ; } } if ( argHasError ) return null ; if ( isClassScope ) { ( ( ClassScope ) ( scope ) ) . superTypeReference = keep ; if ( ( ( ClassScope ) ( scope ) ) . detectHierarchyCycle ( currentType , this , argTypes ) ) return null ; } TypeVariableBinding [ ] typeVariables = currentType . typeVariables ( ) ; <START_BUG> if ( typeVariables == ( NoTypeVariables ) ) { <END_BUG> scope . problemReporter ( ) . nonGenericTypeCannotBeParameterized ( this , currentType , argTypes ) ; return null ; } else if ( argLength != ( typeVariables . length ) ) { scope . problemReporter ( ) . incorrectArityForParameterizedType ( this , currentType , argTypes ) ; return null ; } else if ( ( ( ! ( currentType . isStatic ( ) ) ) && ( enclosingType != null ) ) && ( enclosingType . isRawType ( ) ) ) { scope . problemReporter ( ) . rawMemberTypeCannotBeParameterized ( this , scope . environment ( ) . createRawType ( ( ( ReferenceBinding ) ( currentType . erasure ( ) ) ) , enclosingType ) , argTypes ) ; return null ; } ParameterizedTypeBinding parameterizedType = scope . environment ( ) . createParameterizedType ( ( ( ReferenceBinding ) ( currentType . erasure ( ) ) ) , argTypes , enclosingType ) ; if ( checkBounds ) parameterizedType . boundCheck ( scope , this . typeArguments ) ; this . resolvedType = parameterizedType ; if ( isTypeUseDeprecated ( this . resolvedType , scope ) ) reportDeprecatedType ( scope ) ; if ( ( this . dimensions ) > 0 ) { if ( ( dimensions ) > 255 ) scope . problemReporter ( ) . tooManyDimensions ( this ) ; this . resolvedType = scope . createArrayType ( this . resolvedType , dimensions ) ; } return this . resolvedType ; } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public TypeBinding resolveType ( BlockScope scope , boolean checkBounds ) { } public TypeBinding resolveType ( ClassScope scope ) { } public TypeBinding resolveTypeEnclosing ( BlockScope scope , ReferenceBinding enclosingType ) { } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } public void traverse ( ASTVisitor visitor , ClassScope scope ) { } }
public class LocationEditorFragment extends Fragment { CommonLocationFragment fragmentLocationList ; LocationEditorFragment . OnSelectedPlaceModelListener mListener ; @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( editor_edit_locations , container ) ; <START_BUG> fragmentLocationList = ( ( CommonLocationFragment ) ( getFragmentManager ( ) . findFragmentById ( editor_edit_loactions_common ) ) ) ; <END_BUG> AutoCompleteTextView autoCompView = ( ( AutoCompleteTextView ) ( view . findViewById ( editor_edit_locations_autocomplete ) ) ) ; autoCompView . setAdapter ( new LocationEditorFragment . PlacesAutoCompleteAdapter ( getActivity ( ) , layout . element_list_location ) ) ; autoCompView . setOnItemClickListener ( new OnItemClickListener ( ) { @ Override public void onItemClick ( AdapterView < ? > adapterView , View view , int position , long id ) { PlaceResult placeSelected = ( ( PlaceResult ) ( adapterView . getItemAtPosition ( position ) ) ) ; LocationEditorFragment . this . addPlaceToFavourites ( placeSelected ) ; } } ) ; fragmentLocationList . setPlaceOnclick ( new LocationClickListener ( ) { @ Override public void doSomething ( PlaceModel placeSelected ) { mListener . onSelectedPlaceModel ( placeSelected ) ; } } ) ; return view ; } @ Override public void onAttach ( Activity activity ) { } private void addPlaceToFavourites ( final PlaceResult place ) { } private class PlacesAutoCompleteAdapter extends ArrayAdapter < PlaceResult > implements Filterable { private ArrayList < PlaceResult > resultList ; public PlacesAutoCompleteAdapter ( Context context , int textViewResourceId ) { } @ Override public View getView ( int position , View convertView , ViewGroup parent ) { } public View getViewOptimize ( int position , View convertView , ViewGroup parent ) { } private class ViewHolder { public TextView name ; public TextView address ; public TextView country ; } @ Override public int getCount ( ) { } @ Override public PlaceResult getItem ( int index ) { } @ Override public Filter getFilter ( ) { } } public interface OnSelectedPlaceModelListener { public void onSelectedPlaceModel ( PlaceModel place ) { } } }
@ ComponentScan @ EnableAutoConfiguration public class Server { private static Connection c ; public static void main ( String [ ] args ) { } public static boolean checkRegistered ( String feedcode ) { } public static boolean registerUser ( User user , String password ) { } public static User loginUser ( User user , String password ) { try { <START_BUG> String dbpass = DBHandler . getPassword ( user . feedcode . toUpperCase ( ) , Server . c ) ; <END_BUG> String apppass = password ; if ( ( dbpass . equals ( apppass ) ) == true ) { return user ; } else { return null ; } } catch ( SQLException e ) { } return null ; } public static User getUser ( String feedcode ) { } public static User [ ] getAllUsers ( ) { } public static void begin ( ) { } public static boolean checkBegun ( ) { } }
public class CoreHelper { protected static Category cat = Category . getInstance ( CoreHelper . class ) ; private CoreHelper ( ) { } private static CoreHelper SINGLETON = new CoreHelper ( ) ; public static CoreHelper getHelper ( ) { } public Collection getAllSupertypes ( MClassifier cls ) { } public Collection getSupertypes ( Object ogeneralizableelement ) { } public Collection getAssociateEnds ( MClassifier classifier ) { } public Collection getAssociateEndsInh ( MClassifier classifier ) { } public void removeFeature ( Object cls , Object feature ) { } public String getFeatureName ( Object o ) { } public boolean isMethod ( Object o ) { } public boolean isOperation ( Object o ) { } public Collection getOperations ( Object classifier ) { } public Collection getAttributes ( MClassifier classifier ) { } public Collection getAttributesInh ( MClassifier classifier ) { } public Collection getOperationsInh ( MClassifier classifier ) { } public MParameter getReturnParameter ( MOperation operation ) { } public Collection getReturnParameters ( MOperation operation ) { } public MOperation getSpecification ( Object object ) { } public Collection getSpecifications ( MClassifier cls ) { } public Collection getSubtypes ( MClassifier cls ) { } public void setReturnParameter ( MOperation operation , MParameter newReturnParameter ) { } public MDependency buildSupportDependency ( MModelElement from , MModelElement to ) { } public Collection getAllBehavioralFeatures ( MModelElement element ) { } public Collection getAllBehavioralFeatures ( MClassifier clazz ) { } public Collection getAllBehavioralFeatures ( ) { } public Collection getAllInterfaces ( ) { } public Collection getAllInterfaces ( MNamespace ns ) { } public Collection getAllClasses ( ) { } public Collection getAllClasses ( MNamespace ns ) { } public Collection getRealizedInterfaces ( MClassifier clazz ) { } public Collection getExtendedClassifiers ( MGeneralizableElement clazz ) { } public MGeneralization getGeneralization ( MGeneralizableElement child , MGeneralizableElement parent ) { } public Collection getFlows ( MModelElement source , MModelElement target ) { } public Collection getExtendingElements ( MGeneralizableElement clazz ) { } public Collection getExtendingClassifiers ( MClassifier clazz ) { } public Collection getAllComponents ( ) { } public Collection getAllComponents ( MNamespace ns ) { } public Collection getAllDataTypes ( ) { } public Collection getAllDataTypes ( MNamespace ns ) { } public Collection getAllNodes ( ) { } public Collection getAllNodes ( MNamespace ns ) { } public Collection getAssociatedClassifiers ( MClassifier classifier ) { } public Collection getAssociations ( MClassifier from , MClassifier to ) { } public Collection getAllClassifiers ( ) { } public Collection getAllClassifiers ( MNamespace ns ) { } public Collection getAssociations ( Object oclassifier ) { } public MAssociationEnd getAssociationEnd ( MClassifier type , MAssociation assoc ) { } public Collection getAllContents ( MClassifier clazz ) { } public Collection getAllAttributes ( MClassifier clazz ) { } public MModelElement getSource ( MRelationship relation ) { } public MModelElement getDestination ( MRelationship relation ) { } public Collection getDependencies ( MModelElement supplier , MModelElement client ) { } public Collection getRelationships ( MModelElement source , MModelElement dest ) { } public boolean isValidNamespace ( Object mObj , Object nsObj ) { } private boolean isValidNamespace ( MCollaboration collab , MNamespace ns ) { } private boolean isValidNamespace ( MGeneralization gen , MNamespace ns ) { } private boolean isValidNamespace ( MStructuralFeature struc , MNamespace ns ) { } private boolean isValidNamespace ( MAssociation assoc , MNamespace ns ) { } private boolean isValidNamespace ( MGeneralizableElement gen , MNamespace ns ) { } public MNamespace getFirstSharedNamespace ( MNamespace ns1 , MNamespace ns2 ) { } public Collection getAllPossibleNamespaces ( MModelElement m ) { List ret = new ArrayList ( ) ; if ( m == null ) return ret ; <START_BUG> MNamespace model = ProjectManager . getManager ( ) . getCurrentProject ( ) . getModel ( ) ; <END_BUG> if ( isValidNamespace ( m , model ) ) ret . add ( model ) ; Iterator it = ModelManagementHelper . getHelper ( ) . getAllModelElementsOfKind ( model , MNamespace . class ) . iterator ( ) ; while ( it . hasNext ( ) ) { MNamespace ns = ( ( MNamespace ) ( it . next ( ) ) ) ; if ( isValidNamespace ( m , ns ) ) ret . add ( ns ) ; } return ret ; } public Collection getBaseClasses ( Object o ) { } public Collection getChildren ( Object o ) { } private void getChildren ( Collection currentChildren , MGeneralization gen ) throws IllegalStateException { } public Collection getAllRealizedInterfaces ( Object o ) { } }
@ RunWith ( Arquillian . class ) @ RunAsClient public class SimpleStatelessWebserviceEndpointTestCase { @ ArquillianResource URL baseUrl ; private static final Logger log = Logger . getLogger ( SimpleStatelessWebserviceEndpointTestCase . class . getName ( ) ) ; @ Deployment ( testable = false ) public static JavaArchive createDeployment ( ) { final JavaArchive jar = ShrinkWrap . create ( JavaArchive . class , "stateless-ws-endpoint-example.jar" ) ; <START_BUG> jar . addPackage ( SimpleStatelessWebserviceEndpointImpl . class . getPackage ( ) ) ; <END_BUG> SimpleStatelessWebserviceEndpointTestCase . log . info ( jar . toString ( true ) ) ; return jar ; } @ Test public void testSimpleStatelessWebserviceEndpoint ( ) throws Exception { } @ Test public void testRemoteAccess ( ) throws Exception { } }
public class BAMPredicateReducer implements Reducer { final Timer reduceTimer = new Timer ( ) ; final Timer expandTimer = new Timer ( ) ; final Timer extractTimer = new Timer ( ) ; private final PathFormulaManager pmgr ; private final PredicateAbstractionManager pamgr ; private final RelevantPredicatesComputer relevantComputer ; private final LogManager logger ; private final BooleanFormulaManager bfmgr ; public BAMPredicateReducer ( BooleanFormulaManager bfmgr , BAMPredicateCPA cpa , RelevantPredicatesComputer pRelevantPredicatesComputer ) { } @ Override public AbstractState getVariableReducedState ( AbstractState pExpandedState , Block pContext , CFANode pLocation ) { } @ Override public AbstractState getVariableExpandedState ( AbstractState pRootState , Block pReducedContext , AbstractState pReducedState ) { } private Collection < AbstractionPredicate > extractPredicates ( Region pRegion ) { } @ Override public Object getHashCodeForState ( AbstractState pElementKey , Precision pPrecisionKey ) { } private Map < Pair < Integer , Block > , Precision > reduceCache = new HashMap < > ( ) ; public void clearCaches ( ) { } @ Override public Precision getVariableReducedPrecision ( Precision pPrecision , Block pContext ) { } @ Override public Precision getVariableExpandedPrecision ( Precision pRootPrecision , Block pRootContext , Precision pReducedPrecision ) { } private class ReducedPredicatePrecision extends PredicatePrecision { private final PredicatePrecision rootPredicatePrecision ; private final PredicatePrecision expandedPredicatePrecision ; private final Block context ; private ImmutableSetMultimap < CFANode , AbstractionPredicate > evaluatedPredicateMap ; private ImmutableSet < AbstractionPredicate > evaluatedGlobalPredicates ; public ReducedPredicatePrecision ( PredicatePrecision expandedPredicatePrecision , Block context ) { } public PredicatePrecision getRootPredicatePrecision ( ) { } private void computeView ( ) { } private SetMultimap < CFANode , AbstractionPredicate > approximatePredicateMap ( ) { } @ Override public ImmutableSetMultimap < CFANode , AbstractionPredicate > getLocalPredicates ( ) { } @ Override public Set < AbstractionPredicate > getGlobalPredicates ( ) { } @ Override public Set < AbstractionPredicate > getPredicates ( CFANode loc , Integer locInstance ) { if ( ! ( context . getNodes ( ) . contains ( loc ) ) ) { logger . log ( Level . WARNING , context , "was<seq2seq4repair_space>left<seq2seq4repair_space>in<seq2seq4repair_space>an<seq2seq4repair_space>unexpected<seq2seq4repair_space>way.<seq2seq4repair_space>Analysis<seq2seq4repair_space>might<seq2seq4repair_space>be<seq2seq4repair_space>unsound." ) ; } if ( ( evaluatedPredicateMap ) != null ) { Set < AbstractionPredicate > result = evaluatedPredicateMap . get ( loc ) ; if ( result . isEmpty ( ) ) { result = evaluatedGlobalPredicates ; } <START_BUG> String functionName = context . getCallNode ( ) . getFunctionName ( ) ; <END_BUG> return Sets . union ( result , rootPredicatePrecision . getFunctionPredicates ( ) . get ( functionName ) ) . immutableCopy ( ) ; } else { Set < AbstractionPredicate > result = relevantComputer . getRelevantPredicates ( context , rootPredicatePrecision . getPredicates ( loc , locInstance ) ) ; if ( result . isEmpty ( ) ) { result = relevantComputer . getRelevantPredicates ( context , rootPredicatePrecision . getGlobalPredicates ( ) ) ; } return result ; } } @ Override public boolean equals ( Object pObj ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } } @ Override public int measurePrecisionDifference ( Precision pPrecision , Precision pOtherPrecision ) { } @ Override public AbstractState getVariableReducedStateForProofChecking ( AbstractState pExpandedState , Block pContext , CFANode pCallNode ) { } @ Override public AbstractState getVariableExpandedStateForProofChecking ( AbstractState pRootState , Block pReducedContext , AbstractState pReducedState ) { } @ Override public AbstractState rebuildStateAfterFunctionCall ( AbstractState pRootState , AbstractState pEntryState , AbstractState pExpandedState , CFANode exitLocation ) { } protected static SSAMap updateIndices ( final SSAMap rootSSA , final SSAMap expandedSSA ) { } private static boolean isReturnVar ( String var ) { } private static void setFreshValueBasis ( SSAMapBuilder ssa , String name , int idx ) { } }
public class CassandraDaemon extends AbstractCassandraDaemon { private static Logger logger = LoggerFactory . getLogger ( CassandraDaemon . class ) ; private TServer serverEngine ; protected void setup ( ) throws IOException { int listenPort = DatabaseDescriptor . getRpcPort ( ) ; InetAddress listenAddr = DatabaseDescriptor . getRpcAddress ( ) ; if ( listenAddr == null ) listenAddr = FBUtilities . getLocalAddress ( ) ; Thread . setDefaultUncaughtExceptionHandler ( new Thread . UncaughtExceptionHandler ( ) { public void uncaughtException ( Thread t , Throwable e ) { CassandraDaemon . logger . error ( ( "Uncaught<seq2seq4repair_space>exception<seq2seq4repair_space>in<seq2seq4repair_space>thread<seq2seq4repair_space>" + t ) , e ) ; if ( e instanceof OutOfMemoryError ) { System . exit ( 100 ) ; } } } ) ; try { SystemTable . checkHealth ( ) ; } catch ( ConfigurationException e ) { CassandraDaemon . logger . error ( "Fatal<seq2seq4repair_space>exception<seq2seq4repair_space>during<seq2seq4repair_space>initialization" , e ) ; System . exit ( 100 ) ; } try { DatabaseDescriptor . loadSchemas ( ) ; } catch ( IOException e ) { CassandraDaemon . logger . error ( "Fatal<seq2seq4repair_space>exception<seq2seq4repair_space>during<seq2seq4repair_space>initialization" , e ) ; System . exit ( 100 ) ; } for ( String table : DatabaseDescriptor . getTables ( ) ) { if ( CassandraDaemon . logger . isDebugEnabled ( ) ) CassandraDaemon . logger . debug ( ( "opening<seq2seq4repair_space>keyspace<seq2seq4repair_space>" + table ) ) ; Table . open ( table ) ; } CommitLog . recover ( ) ; instance . checkAllColumnFamilies ( ) ; UUID currentMigration = DatabaseDescriptor . getDefsVersion ( ) ; UUID lastMigration = Migration . getLastMigrationId ( ) ; if ( ( lastMigration != null ) && ( ( lastMigration . timestamp ( ) ) > ( currentMigration . timestamp ( ) ) ) ) { MigrationManager . applyMigrations ( currentMigration , lastMigration ) ; } StorageService . instance . initServer ( ) ; final CassandraServer cassandraServer = new CassandraServer ( ) ; Cassandra . Processor processor = new Cassandra . Processor ( cassandraServer ) ; TServerSocket tServerSocket = null ; try { tServerSocket = new TServerSocket ( new InetSocketAddress ( listenAddr , listenPort ) ) ; } catch ( TTransportException e ) { throw new IOException ( String . format ( "Unable<seq2seq4repair_space>to<seq2seq4repair_space>create<seq2seq4repair_space>thrift<seq2seq4repair_space>socket<seq2seq4repair_space>to<seq2seq4repair_space>%s:%s" , listenAddr , listenPort ) , e ) ; } CassandraDaemon . logger . info ( String . format ( "Binding<seq2seq4repair_space>thrift<seq2seq4repair_space>service<seq2seq4repair_space>to<seq2seq4repair_space>%s:%s" , listenAddr , listenPort ) ) ; <START_BUG> TProtocolFactory tProtocolFactory = new org . apache . thrift . protocol . TBinaryProtocol . Factory ( false , true , DatabaseDescriptor . getThriftMaxMessageLength ( ) ) ; <END_BUG> TTransportFactory inTransportFactory ; TTransportFactory outTransportFactory ; if ( DatabaseDescriptor . isThriftFramed ( ) ) { int tFramedTransportSize = DatabaseDescriptor . getThriftFramedTransportSize ( ) ; inTransportFactory = new TFramedTransport . Factory ( tFramedTransportSize ) ; outTransportFactory = new TFramedTransport . Factory ( tFramedTransportSize ) ; CassandraDaemon . logger . info ( "Using<seq2seq4repair_space>TFramedTransport<seq2seq4repair_space>with<seq2seq4repair_space>a<seq2seq4repair_space>max<seq2seq4repair_space>frame<seq2seq4repair_space>size<seq2seq4repair_space>of<seq2seq4repair_space>{}<seq2seq4repair_space>bytes." , tFramedTransportSize ) ; } else { inTransportFactory = new TTransportFactory ( ) ; outTransportFactory = new TTransportFactory ( ) ; } CustomTThreadPoolServer . Options options = new CustomTThreadPoolServer . Options ( ) ; options . minWorkerThreads = 64 ; SynchronousQueue < Runnable > executorQueue = new SynchronousQueue < Runnable > ( ) ; ExecutorService executorService = new ThreadPoolExecutor ( options . minWorkerThreads , options . maxWorkerThreads , 60 , TimeUnit . SECONDS , executorQueue ) { @ Override protected void afterExecute ( Runnable r , Throwable t ) { super . afterExecute ( r , t ) ; cassandraServer . logout ( ) ; } } ; serverEngine = new CustomTThreadPoolServer ( new org . apache . thrift . TProcessorFactory ( processor ) , tServerSocket , inTransportFactory , outTransportFactory , tProtocolFactory , tProtocolFactory , options , executorService ) ; } public void start ( ) { } public void stop ( ) { } public static void main ( String [ ] args ) { } }
public class RootLoggerRemove extends AbstractLoggingSubsystemUpdate < Void > { private static final long serialVersionUID = - 9178350859833986971L ; public RootLoggerRemove ( ) { } protected < P > void applyUpdate ( UpdateContext updateContext , UpdateResultHandler < ? super Void , P > resultHandler , P param ) { final ServiceController < ? > service ; try { <START_BUG> service = updateContext . getServiceContainer ( ) . getRequiredService ( ROOT_LOGGER ) ; <END_BUG> } catch ( ServiceNotFoundException e ) { resultHandler . handleFailure ( e , param ) ; return ; } service . setMode ( REMOVE ) ; service . addListener ( new UpdateResultHandler . ServiceRemoveListener < P > ( resultHandler , param ) ) ; } public RootLoggerAdd getCompensatingUpdate ( LoggingSubsystemElement original ) { } protected void applyUpdate ( LoggingSubsystemElement element ) throws UpdateFailedException { } }
public class AttrImpl extends NodeContainer implements Attr { static final long serialVersionUID = 7277707688218972102L ; protected boolean owned ; protected boolean specified = true ; protected AttrImpl ( DocumentImpl ownerDocument , String name ) { } protected AttrImpl ( ) { } public short getNodeType ( ) { } public void setNodeValue ( String value ) throws DOMException { } public String getNodeValue ( ) { } public Node getParentNode ( ) { } public Node cloneNode ( boolean deep ) { AttrImpl newattr = ( ( AttrImpl ) ( super . cloneNode ( deep ) ) ) ; <START_BUG> newattr . owned = owned ; <END_BUG> newattr . specified = specified ; return newattr ; } public String getName ( ) { } public void setValue ( String value ) { } public String getValue ( ) { } public boolean getSpecified ( ) { } public Element getElement ( ) { } public Element getOwnerElement ( ) { } public void normalize ( ) { } public void setSpecified ( boolean arg ) { } public String toString ( ) { } }
public class TestRecursiveRelationships extends SingleEMFTestCase { private int _l1Nodes = 3 ; private int _l2Nodes = 3 ; public void setUp ( ) { <START_BUG> setUp ( Node . class ) ; <END_BUG> } public void testRecursiveNodes ( ) { } }
public class takeTownMoney implements SignShopOperation { @ Override public Boolean setupOperation ( SignShopArguments ssArgs ) { } @ Override public Boolean checkRequirements ( SignShopArguments ssArgs , Boolean activeCheck ) { SignShopPlayer ssPlayer = ssArgs . getPlayer ( ) . get ( ) ; if ( ! ( ssArgs . isPlayerOnline ( ) ) ) return true ; Double fPrice = MoneyModifierManager . applyModifiers ( ssArgs , TakeFromTown ) ; try { if ( ! ( TownySettings . getTownBankAllowWithdrawls ( ) ) ) { ssPlayer . sendMessage ( SignShopConfig . getError ( "towny_bank_withdrawls_not_allowed" , ssArgs . getMessageParts ( ) ) ) ; return false ; } <START_BUG> Resident resident = TownyUniverse . getDataSource ( ) . getResident ( ssPlayer . getName ( ) ) ; <END_BUG> Town town = resident . getTown ( ) ; if ( ! ( resident . isMayor ( ) ) ) { if ( ! ( town . hasAssistant ( resident ) ) ) { ssPlayer . sendMessage ( SignShopConfig . getError ( "towny_owner_not_mayor_or_assistant" , ssArgs . getMessageParts ( ) ) ) ; return false ; } } if ( ! ( Vault . getEconomy ( ) . has ( town . getEconomyName ( ) , fPrice ) ) ) { ssPlayer . sendMessage ( SignShopConfig . getError ( "no_shop_money" , ssArgs . getMessageParts ( ) ) ) ; return false ; } } catch ( TownyException x ) { ssPlayer . sendMessage ( SignShopConfig . getError ( "towny_owner_not_belong_to_town" , ssArgs . getMessageParts ( ) ) ) ; return false ; } return true ; } @ Override public Boolean runOperation ( SignShopArguments ssArgs ) { } }
public class VTP5 extends JFrame { private static final long serialVersionUID = 1L ; private VTP5 . FramePanel framePanel ; private JPanel buttonPanel ; private JButton importFileButton ; private JButton settingsButton ; private JButton helpButton ; private JButton aboutButton ; private JButton saveButton ; private JButton startAgainButton ; private int questionIndex = 0 ; private JPanel mainPanel ; private JCheckBox switchLanguageCheck ; private JLabel promptLabel ; private JTextField answerField ; private JButton enterButton ; private JButton passButton ; private JList < String > statsList ; private JScrollPane statsScrollPane ; private DefaultListModel < String > statsListModel ; private JList < String > guessedAnswersList ; private JScrollPane guessedAnswersScrollPane ; private DefaultListModel < String > guessedAnswersListModel ; private JProgressBar progressBar ; private JSeparator separator ; private ArrayList < ComponentWithFontData > componentList = new ArrayList < > ( ) ; private JFileChooser txtChooser = new JFileChooser ( ) ; private JFileChooser csvChooser = new JFileChooser ( ) ; private JFileChooser progressOpenChooser = new JFileChooser ( ) ; private JFileChooser progressSaveChooser = new JFileChooser ( ) ; private JDialog settingsDialog ; private JButton changeButtonColour ; private JButton changePromptColour ; private JButton changeForegroundColour ; private JButton checkForUpdateButton ; private JCheckBox experimentalCheck ; private HyperlinkLabel exInfoLabel ; private AboutDialog abtDialog ; private ImageIcon logo = new ImageIcon ( getClass ( ) . getResource ( "/images/vtp.png" ) ) ; private ArrayList < JButton > buttonList = new ArrayList < > ( ) ; private TestFile test ; private Timer experimentalTimer = new Timer ( 750 , new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { } } ) ; private Color bcolour = Color . BLACK ; private Color fcolour = Color . WHITE ; private Color tcolour = Color . BLACK ; private FinishPanel finishPanel = new FinishPanel ( this ) ; public Font font ; public VTP5 ( ) { } public void setTest ( TestFile test ) { } private void setColour ( Color background , Color foreground , Color text ) { } private void updatePrompt ( int index ) { } private void setFontSize ( Component c , int fontSize ) { } private void showChooserDialog ( int fileType ) { } private void displayColorChooser ( int index ) { Color c ; switch ( index ) { case 1 : c = JColorChooser . showDialog ( null , "Choose<seq2seq4repair_space>a<seq2seq4repair_space>colour" , buttonList . get ( 0 ) . getBackground ( ) ) ; if ( c != null ) { <START_BUG> setColour ( c , bcolour , tcolour ) ; <END_BUG> bcolour = c ; c = null ; } break ; case 2 : c = JColorChooser . showDialog ( null , "Choose<seq2seq4repair_space>a<seq2seq4repair_space>colour" , promptLabel . getForeground ( ) ) ; if ( c != null ) { setColour ( bcolour , fcolour , c ) ; tcolour = c ; c = null ; } break ; case 3 : c = JColorChooser . showDialog ( null , "Choose<seq2seq4repair_space>a<seq2seq4repair_space>colour" , buttonList . get ( 0 ) . getForeground ( ) ) ; if ( c != null ) { setColour ( bcolour , c , tcolour ) ; fcolour = c ; c = null ; } break ; } } private void doLogic ( ) { } private void finishTest ( ) { } private void showMainPanel ( ) { } private void updateGuessedAnswersList ( boolean isCorrect , String userAnswer ) { } private void updateStatsList ( ) { } private void checkForUpdate ( ) { } void setUpTest ( ) { } TestFile getTest ( ) { } ArrayList < JButton > getButtonList ( ) { } Color getBcolour ( ) { } Color getFcolour ( ) { } Color getTcolour ( ) { } ArrayList < ComponentWithFontData > getComponentList ( ) { } private class FramePanel extends JPanel { private static final long serialVersionUID = 1L ; @ Override public void paintComponent ( Graphics g ) { } } private class FrameListener extends ComponentAdapter { private JFrame frame ; private Dimension originalSize ; private double scaler ; private Timer recalculateTimer ; private FrameListener ( JFrame frame ) { } @ Override public void componentResized ( ComponentEvent e ) { } private class RescaleListener implements ActionListener { @ Override public void actionPerformed ( ActionEvent arg0 ) { } } } private class EventListener implements ActionListener { @ Override public void actionPerformed ( ActionEvent e ) { } } private class ActionEnter extends AbstractAction { private static final long serialVersionUID = 1L ; @ Override public void actionPerformed ( ActionEvent ae ) { } } private class SwitchLanguageListener implements ItemListener { @ Override public void itemStateChanged ( ItemEvent arg0 ) { } } }
public class EeSubsystemTestCase extends AbstractSubsystemBaseTest { public EeSubsystemTestCase ( ) { } @ Override protected String getSubsystemXml ( ) throws IOException { } @ Test public void testTransformers712 ( ) throws Exception { } @ Test public void testTransformersEAP600 ( ) throws Exception { } private void testTransformers712 ( ModelTestControllerVersion controllerVersion ) throws Exception { } @ Test public void testTransformers713 ( ) throws Exception { } @ Test public void testTransformers720 ( ) throws Exception { } @ Test public void testTransformersEAP601 ( ) throws Exception { } @ Test public void testTransformersEAP610 ( ) throws Exception { } @ Test public void testTransformersEAP611 ( ) throws Exception { } private void testTransformers1_0_0_post712 ( ModelTestControllerVersion controllerVersion ) throws Exception { } @ Test public void testTransformers713Reject ( ) throws Exception { } @ Test public void testTransformers720Reject ( ) throws Exception { } @ Test public void testTransformersEAP601Reject ( ) throws Exception { } @ Test public void testTransformersEAP610Reject ( ) throws Exception { } @ Test public void testTransformersEAP611Reject ( ) throws Exception { } private void testTransformers1_0_0_reject ( ModelTestControllerVersion controllerVersion ) throws Exception { String subsystemXml = readResource ( "subsystem.xml" ) ; ModelVersion modelVersion = ModelVersion . create ( 1 , 0 , 0 ) ; KernelServicesBuilder builder = createKernelServicesBuilder ( MANAGEMENT ) ; List < ModelNode > xmlOps = builder . parseXml ( subsystemXml ) ; builder . createLegacyKernelServicesBuilder ( null , controllerVersion , modelVersion ) . addMavenResourceURL ( ( "org.jboss.as:jboss-as-ee:" + ( controllerVersion . getMavenGavVersion ( ) ) ) ) ; KernelServices mainServices = builder . build ( ) ; Assert . assertTrue ( mainServices . isSuccessfulBoot ( ) ) ; <START_BUG> ModelTestUtils . checkFailedTransformedBootOperations ( mainServices , modelVersion , xmlOps , new FailedOperationTransformationConfig ( ) . addFailedAttribute ( PathAddress . pathAddress ( PATH_SUBSYSTEM ) , new EeSubsystemTestCase . GlobalModulesConfig ( ) ) . addFailedAttribute ( PathAddress . pathAddress ( PATH_SUBSYSTEM , PathElement . pathElement ( CONTEXT_SERVICE ) ) , REJECTED_RESOURCE ) . addFailedAttribute ( PathAddress . pathAddress ( PATH_SUBSYSTEM , PathElement . pathElement ( MANAGED_THREAD_FACTORY ) ) , REJECTED_RESOURCE ) . addFailedAttribute ( PathAddress . pathAddress ( PATH_SUBSYSTEM , PathElement . pathElement ( MANAGED_EXECUTOR_SERVICE ) ) , REJECTED_RESOURCE ) . addFailedAttribute ( PathAddress . pathAddress ( PATH_SUBSYSTEM , PathElement . pathElement ( MANAGED_SCHEDULED_EXECUTOR_SERVICE ) ) , REJECTED_RESOURCE ) . addFailedAttribute ( PathAddress . pathAddress ( PATH_SUBSYSTEM , PathElement . pathElement ( EJB_ANNOTATION_PROPERTY_REPLACEMENT ) ) , REJECTED_RESOURCE ) ) ; <END_BUG> } @ Test public void testTransformersDiscardGlobalModules713 ( ) throws Exception { } @ Test public void testTransformersDiscardGlobalModules720 ( ) throws Exception { } @ Test public void testTransformersDiscardGlobalModulesEAP601 ( ) throws Exception { } @ Test public void testTransformersDiscardGlobalModulesEAP610 ( ) throws Exception { } @ Test public void testTransformersDiscardGlobalModulesEAP611 ( ) throws Exception { } private void testTransformersDiscardGlobalModules1_0_0 ( ModelTestControllerVersion controllerVersion ) throws Exception { } private static final class JBossDescriptorPropertyReplacementConfig extends AttributesPathAddressConfig < EeSubsystemTestCase . JBossDescriptorPropertyReplacementConfig > { public JBossDescriptorPropertyReplacementConfig ( ) { } @ Override protected boolean isAttributeWritable ( String attributeName ) { } @ Override protected boolean checkValue ( String attrName , ModelNode attribute , boolean isWriteAttribute ) { } @ Override protected ModelNode correctValue ( ModelNode toResolve , boolean isWriteAttribute ) { } } private static final class GlobalModulesConfig extends AttributesPathAddressConfig < EeSubsystemTestCase . GlobalModulesConfig > { public GlobalModulesConfig ( ) { } @ Override protected boolean isAttributeWritable ( String attributeName ) { } @ Override protected boolean checkValue ( String attrName , ModelNode attribute , boolean isWriteAttribute ) { } @ Override protected ModelNode correctValue ( ModelNode toResolve , boolean isWriteAttribute ) { } } }
public class JasperReportsUtilsTests extends TestCase { public void testRenderAsCsvWithDataSource ( ) throws Exception { } public void testRenderAsCsvWithCollection ( ) throws Exception { } public void testRenderAsCsvWithExporterParameters ( ) throws Exception { } public void testRenderAsHtmlWithDataSource ( ) throws Exception { } public void testRenderAsHtmlWithCollection ( ) throws Exception { } public void testRenderAsHtmlWithExporterParameters ( ) throws Exception { } public void testRenderAsPdfWithDataSource ( ) throws Exception { } public void testRenderAsPdfWithCollection ( ) throws Exception { } public void testRenderAsPdfWithExporterParameters ( ) throws Exception { } public void testRenderAsXlsWithDataSource ( ) throws Exception { } public void testRenderAsXlsWithCollection ( ) throws Exception { } public void testRenderAsXlsWithExporterParameters ( ) throws Exception { } public void testRenderWithWriter ( ) throws Exception { } public void testRenderWithOutputStream ( ) throws Exception { } private void assertCsvOutputCorrect ( String output ) { } private void assertHtmlOutputCorrect ( String output ) { } private void assertPdfOutputCorrect ( byte [ ] output ) throws Exception { } private void assertXlsOutputCorrect ( byte [ ] output ) throws Exception { HSSFWorkbook workbook = new HSSFWorkbook ( new ByteArrayInputStream ( output ) ) ; HSSFSheet sheet = workbook . getSheetAt ( 0 ) ; assertNotNull ( "Sheet<seq2seq4repair_space>should<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>null" , sheet ) ; HSSFRow row = sheet . getRow ( 3 ) ; HSSFCell cell = row . getCell ( ( ( short ) ( 1 ) ) ) ; assertNotNull ( "Cell<seq2seq4repair_space>should<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>null" , cell ) ; <START_BUG> assertEquals ( "Cell<seq2seq4repair_space>content<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>Dear<seq2seq4repair_space>Lord!" , "Dear<seq2seq4repair_space>Lord!" , cell . getRichStringCellValue ( ) . getString ( ) ) ; <END_BUG> } private JasperReport getReport ( ) throws Exception { } private Map < String , Object > getParameters ( ) { } private JRDataSource getDataSource ( ) { } private List < PersonBean > getData ( ) { } private static class SimpleProgressMonitor implements JRExportProgressMonitor { private boolean invoked = false ; @ Override public void afterPageExport ( ) { } public boolean isInvoked ( ) { } } }
public class IIOPJndiBindingProcessor implements DeploymentUnitProcessor { @ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final EEModuleDescription moduleDescription = deploymentUnit . getAttachment ( EE_MODULE_DESCRIPTION ) ; final Module module = deploymentUnit . getAttachment ( MODULE ) ; if ( moduleDescription == null ) { return ; } <START_BUG> if ( ! ( JdkORBDeploymentMarker . isJacORBDeployment ( deploymentUnit ) ) ) { <END_BUG> return ; } final ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; if ( ( DeploymentTypeMarker . isType ( WAR , deploymentUnit ) ) || ( DeploymentTypeMarker . isType ( APPLICATION_CLIENT , deploymentUnit ) ) ) { final ServiceName moduleContextServiceName = ContextNames . contextServiceNameOfModule ( moduleDescription . getApplicationName ( ) , moduleDescription . getModuleName ( ) ) ; bindService ( serviceTarget , moduleContextServiceName , module ) ; } for ( ComponentDescription component : moduleDescription . getComponentDescriptions ( ) ) { if ( ( component . getNamingMode ( ) ) == ( ComponentNamingMode . CREATE ) ) { final ServiceName compContextServiceName = ContextNames . contextServiceNameOfComponent ( moduleDescription . getApplicationName ( ) , moduleDescription . getModuleName ( ) , component . getComponentName ( ) ) ; bindService ( serviceTarget , compContextServiceName , module ) ; } } } private void bindService ( final ServiceTarget serviceTarget , final ServiceName contextServiceName , final Module module ) { } @ Override public void undeploy ( DeploymentUnit context ) { } }
public class SymbolsTableBuilder implements Visitor { private Queue < ASTNode > nodeHandlingQueue ; private SymbolTable rootSymbolTable ; private SymbolTable currentClassSymbolTablePoint ; private Type currentMethodType ; private IDSymbolsKinds currentMethodKind ; private TypeTable typeTable ; private SemanticErrorThrower semanticErrorThrower ; int blockCounter ; public SymbolsTableBuilder ( TypeTable typeTable , String tableId ) { } public SymbolTable getSymbolTable ( ) { } public void buildSymbolTables ( Program root ) throws SemanticError { } @ Override public Object visit ( Program program ) { } @ Override public Object visit ( ICClass icClass ) { } @ Override public Object visit ( Field field ) { } @ Override public Object visit ( VirtualMethod method ) { } @ Override public Object visit ( StaticMethod method ) { } @ Override public Object visit ( LibraryMethod method ) { } @ Override public Object visit ( Formal formal ) { } @ Override public Object visit ( PrimitiveType type ) { } @ Override public Object visit ( UserType type ) { } @ Override public Object visit ( Assignment assignment ) { } @ Override public Object visit ( CallStatement callStatement ) { } @ Override public Object visit ( Return returnStatement ) { } @ Override public Object visit ( If ifStatement ) { } @ Override public Object visit ( While whileStatement ) { } @ Override public Object visit ( Break breakStatement ) { } @ Override public Object visit ( Continue continueStatement ) { } @ Override public Object visit ( StatementsBlock statementsBlock ) { } @ Override public Object visit ( LocalVariable localVariable ) { } @ Override public Object visit ( VariableLocation location ) { } @ Override public Object visit ( ArrayLocation location ) { } @ Override public Object visit ( StaticCall call ) { } @ Override public Object visit ( VirtualCall call ) { } @ Override public Object visit ( This thisExpression ) { } @ Override public Object visit ( NewClass newClass ) { } @ Override public Object visit ( NewArray newArray ) { } @ Override public Object visit ( Length length ) { } @ Override public Object visit ( MathBinaryOp binaryOp ) { } @ Override public Object visit ( LogicalBinaryOp binaryOp ) { } @ Override public Object visit ( MathUnaryOp unaryOp ) { } @ Override public Object visit ( LogicalUnaryOp unaryOp ) { } @ Override public Object visit ( Literal literal ) { } @ Override public Object visit ( ExpressionBlock expressionBlock ) { } private Object visitMethod ( Method method ) { SymbolTable currentMethodSymbolTable = method . getSymbolsTable ( ) . findChildSymbolTable ( method . getName ( ) ) ; this . currentMethodType = method . getEntryType ( ) ; <START_BUG> this . currentMethodKind = currentMethodSymbolTable . getParentSymbolTable ( ) . getEntry ( method . getName ( ) ) . getKind ( ) ; <END_BUG> for ( Formal formal : method . getFormals ( ) ) { formal . setSymbolsTable ( currentMethodSymbolTable ) ; if ( ! ( ( Boolean ) ( formal . accept ( this ) ) ) ) return false ; } for ( Statement stmnt : method . getStatements ( ) ) { stmnt . setSymbolsTable ( currentMethodSymbolTable ) ; if ( ! ( ( Boolean ) ( stmnt . accept ( this ) ) ) ) return false ; } return true ; } private Boolean addEntryAndCheckDuplication ( SymbolTable table , SymbolEntry entry ) { } private IDSymbolsKinds getMethodKind ( Method method ) { } private SymbolEntry getVariableSymbolEntry ( String name , SymbolTable bottomSymbolTable ) { } private SymbolEntry getMethodSymbolEntry ( String name , IDSymbolsKinds methodKind , SymbolTable bottomClassSymbolTable , Boolean ignoreMethodKind ) { } }
public class SkyBlockWorld { private transient World world ; private String name ; private int segmentSize ; private transient SkyBlockWorld . WorldInfoFile segments ; public SkyBlockWorld ( final World world , final int segmentSize ) { } private SkyBlockWorld ( ) { } public void init ( final SkyBlockPlugin plugin ) { } public void save ( final SkyBlockPlugin plugin ) { } public World getWorld ( ) { } public int getSegmentSize ( ) { } public SkyBlockSegment getSegment ( final Player player ) { } public SkyBlockSegment grant ( final Player player ) { final SkyBlockSegment segment ; synchronized ( this . segments ) { this . segments . checkForExpansion ( this ) ; Collections . shuffle ( this . segments . unclaimedSegments ) ; final Iterator < SkyBlockSegment > iterator = this . segments . unclaimedSegments . iterator ( ) ; segment = iterator . next ( ) ; iterator . remove ( ) ; } this . segments . playerSegments . put ( player . getLoginName ( ) , segment ) ; final int [ ] sizes = schematic . getSizes ( ) ; final int oX = ( ( segment . getX ( ) ) + ( ( this . segmentSize ) / 2 ) ) - ( ( sizes [ 0 ] ) / 2 ) ; final int oY = 60 + ( ( new Random ( ) . nextInt ( 40 ) ) - 20 ) ; final int oZ = ( ( segment . getZ ( ) ) + ( ( this . segmentSize ) / 2 ) ) - ( ( sizes [ 1 ] ) / 2 ) ; for ( int x = 0 ; x < ( sizes [ 0 ] ) ; x ++ ) for ( int y = 0 ; y < ( sizes [ 1 ] ) ; y ++ ) for ( int z = 0 ; z < ( sizes [ 2 ] ) ; z ++ ) { final short id = schematic . getBlock ( x , y , z ) ; if ( ( id & 255 ) == 161 ) segment . setSpawn ( Constructors . newLocation ( this . world , ( oX + x ) , ( oY + y ) , ( oZ + z ) ) ) ; else { this . world . setBlock ( ( oX + x ) , ( oY + y ) , ( oZ + z ) , id ) ; <START_BUG> if ( id == 54 ) { <END_BUG> final Chest chest = ( ( Chest ) ( this . world . getBlock ( ( oX + x ) , ( oY + y ) , ( oZ + z ) ) . getBlockData ( ) ) ) ; int slot = 0 ; chest . setItemSlot ( ( slot ++ ) , Constructors . newItemStack ( ( ( short ) ( 103 ) ) , 1 ) , false ) ; chest . setItemSlot ( ( slot ++ ) , Constructors . newItemStack ( ( ( short ) ( 113 ) ) , 1 ) , false ) ; chest . setItemSlot ( ( slot ++ ) , Constructors . newItemStack ( ( ( short ) ( 59 ) ) , 1 ) , false ) ; chest . setItemSlot ( ( slot ++ ) , Constructors . newItemStack ( ( ( short ) ( 327 ) ) , 1 ) , false ) ; chest . setItemSlot ( ( slot ++ ) , Constructors . newItemStack ( ( ( short ) ( 403 ) ) , 1 ) , false ) ; chest . setItemSlot ( ( slot ++ ) , Constructors . newItemStack ( ( ( short ) ( 300 ) ) , 1 ) , true ) ; } } } return segment ; } public static class WorldInfoFile { private int searchRadius ; private final Map < String , SkyBlockSegment > playerSegments ; private final List < SkyBlockSegment > unclaimedSegments ; public WorldInfoFile ( ) { } public synchronized void checkForExpansion ( final SkyBlockWorld sbWorld ) { } private void checkClear ( final SkyBlockWorld sbWorld , final int ax , final int az ) { } } }
public final class EditBook extends AuthenticatedHtmlPage { static final Book otherBook = new Book ( "Frisbee<seq2seq4repair_space>Techniques" , "Marty<seq2seq4repair_space>van<seq2seq4repair_space>Hoff" , Book . FICTION ) ; public EditBook ( final Book book ) { } public static PageLink link ( final String name , final long id ) { return new PageLink ( name , new IPageLink ( ) { public Page getPage ( ) { return new EditBook ( Book . get ( id ) ) ; } <START_BUG> public Class getIdentity ( ) { <END_BUG> return EditBook . class ; } } ) ; } public static final class EditBookForm extends Form { private Book book ; public EditBookForm ( final String componentName , final Book book , final FeedbackPanel feedback ) { } public final void handleSubmit ( ) { } } }
public class MarkersData extends WorldSavedData { private static final int VERSION = 3 ; private static final String TAG_VERSION = "aaVersion" ; private static final String TAG_DIMENSION_MAP_LIST = "dimMap" ; private static final String TAG_DIMENSION_ID = "dimID" ; private static final String TAG_MARKERS = "markers" ; private static final String TAG_MARKER_ID = "id" ; private static final String TAG_MARKER_TYPE = "markerType" ; private static final String TAG_MARKER_LABEL = "label" ; private static final String TAG_MARKER_X = "x" ; private static final String TAG_MARKER_Y = "y" ; private static final String TAG_MARKER_VISIBLE_AHEAD = "visAh" ; public static final int CHUNK_STEP = 4 ; private final Set < EntityPlayer > playersSentTo = new HashSet < EntityPlayer > ( ) ; private final AtomicInteger largestID = new AtomicInteger ( 0 ) ; protected int getNewID ( ) { } private final Map < Integer , Marker > idMap = new ConcurrentHashMap < Integer , Marker > ( 2 , 0.75F , 2 ) ; private final Map < Integer , DimensionMarkersData > dimensionMap = new ConcurrentHashMap < Integer , DimensionMarkersData > ( 2 , 0.75F , 2 ) ; public MarkersData ( String key ) { } @ Override public void readFromNBT ( NBTTagCompound compound ) { } @ Override public void writeToNBT ( NBTTagCompound compound ) { } public Set < Integer > getVisitedDimensions ( ) { } public Collection < Marker > getMarkersInDimension ( int dimension ) { } public DimensionMarkersData getMarkersDataInDimension ( int dimension ) { DimensionMarkersData data = dimensionMap . get ( dimension ) ; if ( data == null ) { <START_BUG> data = new DimensionMarkersData ( dimension ) ; <END_BUG> dimensionMap . put ( dimension , data ) ; } return data ; } public List < Marker > getMarkersAtChunk ( int dimension , int x , int z ) { } public Marker getMarkerByID ( int id ) { } public Marker removeMarker ( int id ) { } public Marker createAndSaveMarker ( String type , String label , int dimension , int x , int z , boolean visibleAhead ) { } public Marker loadMarker ( Marker marker ) { } public boolean isSyncedOnPlayer ( EntityPlayer player ) { } public void syncOnPlayer ( int atlasID , EntityPlayer player ) { } protected MarkersPacket newMarkersPacket ( int atlasID , int dimension ) { } public boolean isEmpty ( ) { } }
public class MarshallingHttpMessageConverterTests { private MarshallingHttpMessageConverter converter ; private Marshaller marshaller ; private Unmarshaller unmarshaller ; @ Before public void setUp ( ) { } @ Test public void read ( ) throws Exception { } @ Test public void write ( ) throws Exception { String body = "<root>Hello<seq2seq4repair_space>World</root>" ; MockHttpOutputMessage outputMessage = new MockHttpOutputMessage ( ) ; marshaller . marshal ( eq ( body ) , isA ( StreamResult . class ) ) ; replay ( marshaller , unmarshaller ) ; <START_BUG> converter . write ( body , outputMessage ) ; <END_BUG> assertEquals ( "Invalid<seq2seq4repair_space>content-type" , new MediaType ( "application" , "xml" ) , outputMessage . getHeaders ( ) . getContentType ( ) ) ; verify ( marshaller , unmarshaller ) ; } }
public class TestParallelTermEnum extends LuceneTestCase { private AtomicReader ir1 ; private AtomicReader ir2 ; private Directory rd1 ; private Directory rd2 ; @ Override public void setUp ( ) throws Exception { } @ Override public void tearDown ( ) throws Exception { } private void checkTerms ( Terms terms , Bits liveDocs , String ... termsList ) throws IOException { assertNotNull ( terms ) ; final TermsEnum te = terms . iterator ( null ) ; for ( String t : termsList ) { BytesRef b = te . next ( ) ; assertNotNull ( b ) ; assertEquals ( t , b . utf8ToString ( ) ) ; <START_BUG> DocsEnum td = _TestUtil . docs ( random ( ) , te , liveDocs , null , 0 ) ; <END_BUG> assertTrue ( ( ( td . nextDoc ( ) ) != ( DocIdSetIterator . NO_MORE_DOCS ) ) ) ; assertEquals ( 0 , td . docID ( ) ) ; assertEquals ( td . nextDoc ( ) , NO_MORE_DOCS ) ; } assertNull ( te . next ( ) ) ; } public void test1 ( ) throws IOException { } }
public class RemoteDomainControllerTestCase { private ManagementCommunicationService communicationService ; private DomainControllerOperationHandler operationHandler ; private RemoteDomainControllerConnection domainControllerConnection ; @ Before public void setup ( ) throws Exception { final ScheduledExecutorService executorService = Executors . newScheduledThreadPool ( 10 ) ; communicationService = new ManagementCommunicationService ( ) ; communicationService . getThreadFactoryInjector ( ) . inject ( Executors . defaultThreadFactory ( ) ) ; communicationService . getExecutorServiceInjector ( ) . inject ( executorService ) ; <START_BUG> final NetworkInterfaceService networkInterfaceService = new NetworkInterfaceService ( "test" , false , false , true , null ) ; <END_BUG> networkInterfaceService . start ( null ) ; communicationService . getInterfaceInjector ( ) . inject ( networkInterfaceService . getValue ( ) ) ; communicationService . getPortInjector ( ) . inject ( 12345 ) ; operationHandler = new DomainControllerOperationHandler ( ) ; operationHandler . getThreadFactoryInjector ( ) . inject ( Executors . defaultThreadFactory ( ) ) ; operationHandler . getExecutorServiceInjector ( ) . inject ( executorService ) ; operationHandler . getLocalFileRepositoryInjector ( ) . inject ( new org . jboss . as . server . manager . LocalFileRepository ( new ServerManagerEnvironment ( System . getProperties ( ) , false , System . in , System . out , System . err , "test" , InetAddress . getLocalHost ( ) , 3223 , InetAddress . getLocalHost ( ) , 3223 , "java" ) ) ) ; final DomainController domainController = new DomainController ( ) ; domainController . getDomainConfigDirInjector ( ) . inject ( new File ( getClass ( ) . getResource ( "/test/configuration" ) . toURI ( ) ) ) ; File tmpDir = new File ( System . getProperty ( "java.io.tmpdir" ) ) ; File deploymentDir = new File ( tmpDir , ( "domain-deployments-" + ( ( int ) ( Math . random ( ) ) ) ) ) ; deploymentDir . deleteOnExit ( ) ; deploymentDir . mkdirs ( ) ; domainController . getDomainDeploymentsDirInjector ( ) . inject ( deploymentDir ) ; final XMLMapper mapper = Factory . create ( ) ; StandardElementReaderRegistrar . Factory . getRegistrar ( ) . registerStandardDomainReaders ( mapper ) ; domainController . getXmlMapperInjector ( ) . inject ( mapper ) ; domainController . getScheduledExecutorServiceInjector ( ) . inject ( executorService ) ; domainController . start ( null ) ; operationHandler . getDomainControllerInjector ( ) . inject ( domainController ) ; operationHandler . start ( null ) ; communicationService . addHandler ( operationHandler ) ; communicationService . start ( null ) ; domainControllerConnection = new RemoteDomainControllerConnection ( "sm" , InetAddress . getLocalHost ( ) , 12345 , InetAddress . getLocalHost ( ) , 11223 , null , 1000 , Executors . newScheduledThreadPool ( 2 ) , Executors . defaultThreadFactory ( ) ) ; } @ Test public void testRegister ( ) throws Exception { } }
public class WorldTestCase extends AbstractWorldTestCase { public WorldTestCase ( String name ) { } private final BcelWorld world = new BcelWorld ( ( ( BcweaverTests . TESTDATA_PATH ) + "/tracing.jar" ) ) ; protected World getWorld ( ) { } public void xtestTraceJar ( ) { } public void testIterator ( ) { int abstractPublic = ( Modifier . ABSTRACT ) | ( Modifier . PUBLIC ) ; <START_BUG> ResolvedType iter = world . getCoreType ( UnresolvedType . forRawTypeNames ( "java.util.Iterator" ) ) ; <END_BUG> modifiersTest ( iter , ( abstractPublic | ( Modifier . INTERFACE ) ) ) ; fieldsTest ( iter , NONE ) ; methodsTest ( iter , new Member [ ] { Member . method ( iter , 0 , "hasNext" , "()Z" ) , Member . method ( iter , 0 , "remove" , "()V" ) , Member . method ( iter , 0 , "next" , "()Ljava/lang/Object;" ) } ) ; ResolvedMember remove = iter . lookupMethod ( Member . method ( iter , 0 , "remove" , "()V" ) ) ; assertNotNull ( "iterator<seq2seq4repair_space>doesn't<seq2seq4repair_space>have<seq2seq4repair_space>remove" , remove ) ; modifiersTest ( remove , ( abstractPublic | ( Modifier . INTERFACE ) ) ) ; exceptionsTest ( remove , UnresolvedType . NONE ) ; ResolvedMember clone = iter . lookupMethod ( Member . method ( OBJECT , 0 , "clone" , "()Ljava/lang/Object;" ) ) ; assertNotNull ( "iterator<seq2seq4repair_space>doesn't<seq2seq4repair_space>have<seq2seq4repair_space>clone" , clone ) ; modifiersTest ( clone , ( ( Modifier . PROTECTED ) | ( Modifier . NATIVE ) ) ) ; exceptionsTest ( clone , UnresolvedType . forNames ( new String [ ] { "java.lang.CloneNotSupportedException" } ) ) ; interfacesTest ( iter , ResolvedType . NONE ) ; superclassTest ( iter , OBJECT ) ; pointcutsTest ( iter , NONE ) ; mungersTest ( iter , ShadowMunger . NONE ) ; isInterfaceTest ( iter , true ) ; isClassTest ( iter , false ) ; isAspectTest ( iter , false ) ; } public void testObjectCoersion ( ) { } private void assertCouldBeCoercibleFrom ( String a , String b ) { } private void assertCouldNotBeCoercibleFrom ( String a , String b ) { } }
public class PassivatingBackingCacheImpl < K extends Serializable , V extends Cacheable < K > , E extends BackingCacheEntry < K , V > > extends AbstractBackingCache < K , V , E > implements PassivatingBackingCache < K , V , E > { protected final Logger log = Logger . getLogger ( getClass ( ) . getName ( ) ) ; private final StatefulObjectFactory < V > factory ; private final BackingCacheEntryFactory < K , V , E > entryFactory ; private final ReplicationPassivationManager < K , E > passivationManager ; private final BackingCacheEntryStore < K , V , E > store ; private final ThreadFactory threadFactory ; private volatile ScheduledExecutorService executor ; private final Map < K , Future < ? > > expirationFutures = new ConcurrentHashMap < K , Future < ? > > ( ) ; private final Map < K , Future < ? > > passivationFutures = new ConcurrentHashMap < K , Future < ? > > ( ) ; public PassivatingBackingCacheImpl ( StatefulObjectFactory < V > factory , BackingCacheEntryFactory < K , V , E > entryFactory , ReplicationPassivationManager < K , E > passivationManager , BackingCacheEntryStore < K , V , E > store ) { } public PassivatingBackingCacheImpl ( StatefulObjectFactory < V > factory , BackingCacheEntryFactory < K , V , E > entryFactory , ReplicationPassivationManager < K , E > passivationManager , BackingCacheEntryStore < K , V , E > store , ThreadFactory threadFactory ) { } public PassivatingBackingCacheImpl ( StatefulObjectFactory < V > factory , BackingCacheEntryFactory < K , V , E > entryFactory , ReplicationPassivationManager < K , E > passivationManager , BackingCacheEntryStore < K , V , E > store , ScheduledExecutorService executor ) { } private PassivatingBackingCacheImpl ( StatefulObjectFactory < V > factory , BackingCacheEntryFactory < K , V , E > entryFactory , ReplicationPassivationManager < K , E > passivationManager , BackingCacheEntryStore < K , V , E > store , ThreadFactory threadFactory , ScheduledExecutorService executor ) { } @ Override public boolean isClustered ( ) { } @ Override public Affinity getStrictAffinity ( ) { } @ Override public Affinity getWeakAffinity ( K key ) { } @ Override public boolean hasAffinity ( K key ) { } @ Override public E create ( ) { } @ Override public E get ( K key ) throws NoSuchEJBException { } @ Override public void passivate ( K key ) { } @ Override public E peek ( K key ) throws NoSuchEJBException { } @ Override public E release ( K key ) { } @ Override public void discard ( K key ) { } @ Override public void remove ( K key ) { this . trace ( "remove(%s)" , key ) ; this . cancelExpirationPassivation ( key ) ; E entry = store . remove ( key ) ; if ( entry == null ) <START_BUG> throw new NoSuchEJBException ( String . valueOf ( key ) ) ; <END_BUG> entry . lock ( ) ; try { if ( entry . isInUse ( ) ) { entry . setInUse ( false ) ; } entryFactory . destroyEntry ( entry ) ; factory . destroyInstance ( entry . getUnderlyingItem ( ) ) ; } finally { entry . unlock ( ) ; } } private void cancelExpirationPassivation ( K id ) { } private void cancel ( Map < K , Future < ? > > futures , K id ) { } private void scheduleExpirationPassivation ( K id ) { } private void schedule ( Map < K , Future < ? > > futures , K id , PassivatingBackingCacheImpl . TaskFactory < K > factory , long time , TimeUnit unit ) { } @ Override public void start ( ) { } @ Override public void stop ( ) { } @ Override public GroupCompatibilityChecker getCompatibilityChecker ( ) { } interface TaskFactory < K > { Runnable createTask ( K id ) { } } private PassivatingBackingCacheImpl . TaskFactory < K > removeTaskFactory = new PassivatingBackingCacheImpl . TaskFactory < K > ( ) { @ Override public Runnable createTask ( K id ) { } } ; private PassivatingBackingCacheImpl . TaskFactory < K > passivateTaskFactory = new PassivatingBackingCacheImpl . TaskFactory < K > ( ) { @ Override public Runnable createTask ( K id ) { } } ; private void trace ( String pattern , Object ... args ) { } }
public class ValidatorImpl extends AbstractValidator { private static final Localizer _loc = Localizer . forPackage ( ValidatorImpl . class ) ; private ValidatorFactory _validatorFactory = null ; private Validator _validator = null ; private ValidationMode _mode = ValidationMode . AUTO ; private OpenJPAConfiguration _conf = null ; private Map < Integer , Class < ? > [ ] > _validationGroups = new HashMap < Integer , Class < ? > [ ] > ( ) ; private static HashMap < String , Integer > _vgMapping = new HashMap < String , Integer > ( ) ; public static final String VG_PRE_PERSIST = "javax.persistence.validation.group.pre-persist" ; public static final String VG_PRE_REMOVE = "javax.persistence.validation.group.pre-remove" ; public static final String VG_PRE_UPDATE = "javax.persistence.validation.group.pre-update" ; public ValidatorImpl ( ) { } public ValidatorImpl ( Configuration conf ) { } public ValidatorImpl ( ValidatorFactory validatorFactory , ValidationMode mode ) { } private void initialize ( ) { } public void addValidationGroup ( String validationGroupName , Class < ? > ... vgs ) { } public void addValidationGroup ( Integer event , Class < ? > ... validationGroup ) { } public void addValidationGroup ( String validationGroupName , String group ) { } private Class < ? > [ ] getValidationGroup ( String vgName , String group ) { } public Class < ? > [ ] getValidationGroup ( Integer event ) { } public boolean isValidating ( Integer event ) { } public BeanDescriptor getConstraintsForClass ( Class < ? > cls ) { } @ Override public < T > ValidationException validate ( T arg0 , int event ) { } @ Override public < T > ValidationException validateProperty ( T arg0 , String property , int event ) { } @ Override public < T > ValidationException validateValue ( Class < T > arg0 , String arg1 , Object arg2 , int event ) { } @ Override public < T > boolean validating ( T arg0 , int event ) { } private Integer findEvent ( String validationProperty ) { } private ValidatorFactory getDefaultValidatorFactory ( ) { ValidatorFactory factory = null ; try { <START_BUG> factory = Validation . buildDefaultValidatorFactory ( ) ; <END_BUG> } catch ( javax . validation e ) { } return factory ; } private void addDefaultValidationGroups ( ) { } }
public class TreeColumn extends Item { int labelHandle ; int imageHandle ; int buttonHandle ; Tree parent ; int modelIndex ; int lastButton ; int lastTime ; int lastX ; int lastWidth ; boolean customDraw ; boolean useFixedWidth ; String toolTipText ; public TreeColumn ( Tree parent , int style ) { } public TreeColumn ( Tree parent , int style , int index ) { } public void addControlListener ( ControlListener listener ) { } public void addSelectionListener ( SelectionListener listener ) { } static int checkStyle ( int style ) { } protected void checkSubclass ( ) { } void createWidget ( int index ) { } void deregister ( ) { } void destroyWidget ( ) { } public int getAlignment ( ) { } public boolean getMoveable ( ) { } public Tree getParent ( ) { } public boolean getResizable ( ) { } public String getToolTipText ( ) { } public int getWidth ( ) { } int gtk_clicked ( int widget ) { } int gtk_mnemonic_activate ( int widget , int arg1 ) { } int gtk_size_allocate ( int widget , int allocation ) { } void hookEvents ( ) { } public void pack ( ) { checkWidget ( ) ; int width = 0 ; if ( ( buttonHandle ) != 0 ) { GtkRequisition requisition = new GtkRequisition ( ) ; OS . gtk_widget_size_request ( buttonHandle , requisition ) ; width = requisition . width ; } if ( ( ( parent . style ) & ( SWT . VIRTUAL ) ) != 0 ) { } else { int iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ; if ( OS . gtk_tree_model_get_iter_first ( parent . modelHandle , iter ) ) { do { <START_BUG> width = Math . max ( width , parent . calculateWidth ( handle , iter ) ) ; <END_BUG> } while ( OS . gtk_tree_model_iter_next ( parent . modelHandle , iter ) ) ; } OS . g_free ( iter ) ; } setWidth ( width ) ; } void register ( ) { } void releaseHandle ( ) { } void releaseParent ( ) { } public void removeControlListener ( ControlListener listener ) { } public void removeSelectionListener ( SelectionListener listener ) { } public void setAlignment ( int alignment ) { } void setFontDescription ( int font ) { } public void setImage ( Image image ) { } public void setMoveable ( boolean moveable ) { } public void setResizable ( boolean resizable ) { } public void setText ( String string ) { } public void setToolTipText ( String string ) { } void setToolTipText ( Shell shell , String newString ) { } public void setWidth ( int width ) { } }
@ SuppressWarnings ( "rawtypes" ) public class InfinispanBeanManagerFactory < G , I , T > extends AbstractService < BeanManagerFactory < G , I , T > > implements BeanManagerFactory < G , I , T > { public static < G , I , T > ServiceBuilder < BeanManagerFactory < G , I , T > > build ( String name , ServiceTarget target , ServiceName serviceName , BeanManagerFactoryBuilderConfiguration config , BeanContext context ) { } private final BeanContext context ; private final CacheInvoker invoker = new RetryingCacheInvoker ( 10 , 100 ) ; private final InjectedValue < Cache > cache = new InjectedValue ( ) ; private final InjectedValue < KeyAffinityServiceFactory > affinityFactory = new InjectedValue ( ) ; private final InjectedValue < VersionedMarshallingConfiguration > config = new InjectedValue ( ) ; private final InjectedValue < ScheduledExecutorService > scheduler = new InjectedValue ( ) ; private final InjectedValue < Executor > executor = new InjectedValue ( ) ; private final BeanPassivationConfiguration passivationConfig ; private final InjectedValue < NodeFactory > nodeFactory = new InjectedValue ( ) ; private final InjectedValue < Registry > registry = new InjectedValue ( ) ; private final InjectedValue < CommandDispatcherFactory > dispatcherFactory = new InjectedValue ( ) ; private InfinispanBeanManagerFactory ( BeanContext context , BeanPassivationConfiguration passivationConfig ) { } @ Override public BeanManager < G , I , T > createBeanManager ( final IdentifierFactory < G > groupIdentifierFactory , final IdentifierFactory < I > beanIdentifierFactory , final PassivationListener < T > passivationListener , final RemoveListener < T > removeListener ) { MarshallingContext context = new SimpleMarshallingContextFactory ( ) . createMarshallingContext ( this . config . getValue ( ) , this . context . getClassLoader ( ) ) ; MarshalledValueFactory < MarshallingContext > factory = new org . jboss . as . clustering . marshalling . SimpleMarshalledValueFactory ( context ) ; Cache < G , BeanGroupEntry < I , T > > groupCache = this . cache . getValue ( ) ; Configuration config = groupCache . getCacheConfiguration ( ) ; BeanGroupFactory < G , I , T > groupFactory = new org . wildfly . clustering . ejb . infinispan . group . InfinispanBeanGroupFactory ( groupCache , this . invoker , factory , context ) ; Configuration < G , G , BeanGroupEntry < I , T > , BeanGroupFactory < G , I , T > > groupConfiguration = new InfinispanBeanManagerFactory . SimpleConfiguration ( groupCache , groupFactory , groupIdentifierFactory ) ; Cache < BeanKey < I > , BeanEntry < G > > beanCache = this . cache . getValue ( ) ; <START_BUG> final String beanName = this . context . getBeanName ( ) ; <END_BUG> final boolean evictionAllowed = config . persistence ( ) . usingStores ( ) ; final boolean passivationEnabled = evictionAllowed && ( config . persistence ( ) . passivation ( ) ) ; final boolean persistent = ( config . clustering ( ) . cacheMode ( ) . isClustered ( ) ) || ( evictionAllowed && ( ! passivationEnabled ) ) ; BeanFactory < G , I , T > beanFactory = new org . wildfly . clustering . ejb . infinispan . bean . InfinispanBeanFactory ( beanName , groupFactory , beanCache , this . invoker , this . context . getTimeout ( ) , ( persistent ? passivationListener : null ) ) ; Configuration < I , BeanKey < I > , BeanEntry < G > , BeanFactory < G , I , T > > beanConfiguration = new InfinispanBeanManagerFactory . SimpleConfiguration ( beanCache , beanFactory , beanIdentifierFactory ) ; final NodeFactory < Address > nodeFactory = this . nodeFactory . getValue ( ) ; final Registry < String , ? > registry = this . registry . getValue ( ) ; final KeyAffinityServiceFactory affinityFactory = this . affinityFactory . getValue ( ) ; final CommandDispatcherFactory dispatcherFactory = this . dispatcherFactory . getValue ( ) ; final Time timeout = this . context . getTimeout ( ) ; final ScheduledExecutorService scheduler = this . scheduler . getValue ( ) ; final ExpirationConfiguration < T > expiration = new ExpirationConfiguration < T > ( ) { @ Override public Time getTimeout ( ) { return timeout ; } @ Override public RemoveListener < T > getRemoveListener ( ) { return removeListener ; } @ Override public ScheduledExecutorService getExecutor ( ) { return scheduler ; } } ; final Executor executor = this . executor . getValue ( ) ; final BeanPassivationConfiguration passivationConfig = this . passivationConfig ; final PassivationConfiguration < T > passivation = new PassivationConfiguration < T > ( ) { @ Override public PassivationListener < T > getPassivationListener ( ) { return passivationListener ; } @ Override public boolean isEvictionAllowed ( ) { return evictionAllowed ; } @ Override public boolean isPersistent ( ) { return persistent ; } @ Override public BeanPassivationConfiguration getConfiguration ( ) { return passivationConfig ; } @ Override public Executor getExecutor ( ) { return executor ; } } ; InfinispanBeanManagerConfiguration < T > configuration = new InfinispanBeanManagerConfiguration < T > ( ) { @ Override public String getBeanName ( ) { return beanName ; } @ Override public KeyAffinityServiceFactory getAffinityFactory ( ) { return affinityFactory ; } @ Override public Registry < String , ? > getRegistry ( ) { return registry ; } @ Override public NodeFactory < Address > getNodeFactory ( ) { return nodeFactory ; } @ Override public CommandDispatcherFactory getCommandDispatcherFactory ( ) { return dispatcherFactory ; } @ Override public ExpirationConfiguration < T > getExpirationConfiguration ( ) { return expiration ; } @ Override public PassivationConfiguration < T > getPassivationConfiguration ( ) { return passivation ; } } ; return new InfinispanBeanManager ( configuration , beanConfiguration , groupConfiguration ) ; } @ Override public BeanManagerFactory < G , I , T > getValue ( ) { }
public class ParametersProcessor { private HttpServletRequest req ; private Route route ; public ParametersProcessor ( HttpServletRequest req , Route route ) { } private Object getNullOrZero ( Class < ? > clazz ) { } private Object getValue ( Class < ? > clazz , RAFParameter rp , String value ) throws RAFException { String parameterName ; parameterName = rp . getParameterName ( ) ; Object ret = null ; if ( clazz . isPrimitive ( ) ) { if ( clazz . equals ( Byte . TYPE ) ) { ret = NumberProcessor . parseByte ( parameterName , value ) ; } else if ( clazz . equals ( Short . TYPE ) ) { ret = NumberProcessor . parseShort ( parameterName , value ) ; } else if ( clazz . equals ( Integer . TYPE ) ) { ret = NumberProcessor . parseInt ( parameterName , value ) ; } else if ( clazz . equals ( Long . TYPE ) ) { <START_BUG> ret = NumberProcessor . parseShort ( parameterName , value ) ; <END_BUG> } else if ( clazz . equals ( Float . TYPE ) ) { ret = NumberProcessor . parseFloat ( parameterName , value ) ; } else if ( clazz . equals ( Double . TYPE ) ) { ret = NumberProcessor . parseDouble ( parameterName , value ) ; } else if ( clazz . equals ( Boolean . TYPE ) ) { ret = BooleanProcessor . parseBoolean ( parameterName , value ) ; } else if ( clazz . equals ( Character . TYPE ) ) { ret = CharacterProcessor . parseCharacter ( parameterName , value ) ; } } else { if ( clazz . equals ( String . class ) ) { ret = value ; } else if ( clazz . equals ( BigDecimal . class ) ) { ret = NumberProcessor . parseBigDecimal ( parameterName , value ) ; } else if ( clazz . equals ( BigInteger . class ) ) { ret = NumberProcessor . parseBigInteger ( parameterName , value ) ; } else if ( clazz . equals ( Date . class ) ) { ret = DateProcessor . parseUtilDate ( parameterName , rp . getDateFormat ( ) , value ) ; } else if ( clazz . equals ( java . sql . Date . class ) ) { ret = DateProcessor . parseSqlDate ( parameterName , rp . getDateFormat ( ) , value ) ; } else if ( clazz . isAssignableFrom ( Calendar . class ) ) { ret = DateProcessor . parseCalendar ( parameterName , rp . getDateFormat ( ) , value ) ; } } return ret ; } public Object [ ] getParameters ( ) throws RAFException { } }
@ Listener public class CacheRegistry < K , V > implements Registry < K , V > { private final List < Registry . Listener < K , V > > listeners = new CopyOnWriteArrayList < > ( ) ; private final RegistryEntryProvider < K , V > provider ; private final Cache < Node , Map . Entry < K , V > > cache ; private final CacheInvoker invoker ; private final Group group ; private final NodeFactory < Address > factory ; public CacheRegistry ( CacheRegistryFactoryConfiguration < K , V > config , RegistryEntryProvider < K , V > provider ) { } @ Override public void close ( ) { } @ Override public void addListener ( Registry . Listener < K , V > listener ) { } @ Override public void removeListener ( Registry . Listener < K , V > listener ) { } @ Override public Group getGroup ( ) { } @ Override public Map < K , V > getEntries ( ) { } @ Override public Map . Entry < K , V > getEntry ( Node node ) { } @ Override public Map . Entry < K , V > getLocalEntry ( ) { } @ TopologyChanged public void topologyChanged ( TopologyChangedEvent < Address , Node > event ) { if ( event . isPre ( ) ) return ; List < Address > newAddresses = event . getConsistentHashAtEnd ( ) . getMembers ( ) ; if ( ! ( newAddresses . get ( 0 ) . equals ( event . getCache ( ) . getCacheManager ( ) . getAddress ( ) ) ) ) return ; Set < Address > addresses = new java . util . HashSet ( event . getConsistentHashAtStart ( ) . getMembers ( ) ) ; addresses . removeAll ( newAddresses ) ; final List < Node > nodes = new java . util . ArrayList ( addresses . size ( ) ) ; for ( Address address : addresses ) { nodes . add ( this . factory . createNode ( address ) ) ; } CacheRegistry < K , V > . Operation < Map < K , V > > operation = new Operation < Map < K , V > > ( ) { @ Override public Map < K , V > invoke ( Cache < Node , Map . Entry < K , V > > cache ) { Map < K , V > removed = new HashMap < > ( ) ; for ( Node node : nodes ) { Map . Entry < K , V > old = cache . remove ( node ) ; if ( old != null ) { removed . put ( old . getKey ( ) , old . getValue ( ) ) ; } } return removed ; } } ; <START_BUG> Map < K , V > removed = this . invoker . invoke ( this . cache , operation , FORCE_SYNCHRONOUS ) ; <END_BUG> if ( ! ( removed . isEmpty ( ) ) ) { for ( Listener < K , V > listener : this . listeners ) { listener . removedEntries ( removed ) ; } } } @ CacheEntryModified public void modified ( CacheEntryModifiedEvent < Node , Map . Entry < K , V > > event ) { } @ CacheEntryRemoved public void removed ( CacheEntryRemovedEvent < Node , Map . Entry < K , V > > event ) { } abstract class Operation < R > implements CacheInvoker . Operation < Node , Map . Entry < K , V > , R > { } }
public class Packet implements Serializable { public int type = 0 ; public int id = 0 ; public String key = "" ; public Values value = null ; @ Override public String toString ( ) { <START_BUG> return ( ( ( "[Type:" + ( type ) ) + "<seq2seq4repair_space>Value:[" ) + ( value . toString ( ) ) ) + "]]" ; <END_BUG> } No newline ; at end ; of file ; }
public class ReviewActivity extends TestpressFragmentActivity { @ Inject protected TestpressServiceProvider serviceProvider ; String previousActivity ; @ Override public void onCreate ( final Bundle savedInstanceState ) { } @ Override public void onBackPressed ( ) { if ( ( ( previousActivity ) != null ) && ( previousActivity . equals ( "ExamActivity" ) ) ) { <START_BUG> Intent intent = new Intent ( this , MainActivity . class ) ; <END_BUG> intent . setFlags ( FLAG_ACTIVITY_CLEAR_TOP ) ; intent . putExtra ( "currentItem" , "2" ) ; startActivity ( intent ) ; finish ( ) ; } else { super . onBackPressed ( ) ; } } }
public class ViewerController extends ParameterizableViewController { protected static final Log log = LogFactory . getLog ( ViewerController . class ) ; @ Override protected ModelAndView handleRequestInternal ( HttpServletRequest request , HttpServletResponse response ) throws Exception { Map < String , Object > model = new HashMap < String , Object > ( ) ; LogManagerService svc = Context . getService ( LogManagerService . class ) ; Level level = Level . toLevel ( ServletRequestUtils . getIntParameter ( request , "level" , Level . ALL_INT ) ) ; model . put ( "level" , level . toInt ( ) ) ; QueryField queryField = LogManagerUtils . getQueryFieldParameter ( request , "queryField" , LOGGER_NAME ) ; String queryValue = request . getParameter ( "queryValue" ) ; if ( queryValue != null ) { queryValue = queryValue . trim ( ) ; if ( queryValue . isEmpty ( ) ) queryValue = null ; } model . put ( "queryField" , queryField ) ; model . put ( "queryValue" , queryValue ) ; int offset = ServletRequestUtils . getIntParameter ( request , "offset" , 0 ) ; PagingInfo paging = new PagingInfo ( offset , Constants . VIEWER_PAGE_SIZE ) ; model . put ( "paging" , paging ) ; Collection < AppenderProxy > appendersAll = svc . getAppenders ( true ) ; List < AppenderProxy > appenders = new ArrayList < AppenderProxy > ( ) ; for ( AppenderProxy app : appendersAll ) { if ( app . isViewable ( ) ) appenders . add ( app ) ; } int viewId = ServletRequestUtils . getIntParameter ( request , "viewId" , 0 ) ; AppenderProxy appender = null ; if ( viewId != 0 ) appender = svc . getAppender ( viewId ) ; else { Appender target = Logger . getRootLogger ( ) . getAppender ( DEF_APPENDER ) ; if ( target != null ) <START_BUG> appender = new AppenderProxy ( target , true ) ; <END_BUG> else if ( ( appenders . size ( ) ) > 0 ) appender = appenders . get ( 0 ) ; } if ( appender != null ) { if ( appender . isViewable ( ) ) model . put ( "events" , svc . getAppenderEvents ( appender , level , queryField , queryValue , paging ) ) ; else { model . put ( "events" , new ArrayList < org . apache . log4j . spi . LoggingEvent > ( ) ) ; LogManagerUtils . setErrorMessage ( request , getMessageSourceAccessor ( ) , ( ( Constants . MODULE_ID ) + ".error.invalidAppender" ) ) ; } } else { model . put ( "events" , new ArrayList < org . apache . log4j . spi . LoggingEvent > ( ) ) ; LogManagerUtils . setErrorMessage ( request , getMessageSourceAccessor ( ) , ( ( Constants . MODULE_ID ) + ".error.noSuitableAppender" ) ) ; } model . put ( "levelIcons" , IconFactory . getLevelIconMap ( ) ) ; model . put ( "appender" , appender ) ; model . put ( "appenders" , appenders ) ; return new ModelAndView ( getViewName ( ) , model ) ; } }
public class EncounterSequenceGenerator { public static final int MAX_YEARS_BETWEEN_ENCOUNTERS = 10 ; private EncounterGenerator encounterGenerator ; public EncounterSequenceGenerator ( HealthProfessionalPool professionalPool , HealthLocationPool locationPool ) { } public List < Encounter > encountersSince ( LocalDate dateOfBirth ) { ArrayList < Encounter > encounters = new ArrayList < Encounter > ( ) ; LocalDate currentDate = dateOfBirth ; LocalDate today = new LocalDate ( ) ; while ( currentDate . isBefore ( today ) ) { <START_BUG> encounters . add ( encounterGenerator . nextEncounter ( today ) ) ; <END_BUG> currentDate = currentDate . plusDays ( ( ( int ) ( ( ( Math . random ( ) ) * 365 ) * ( EncounterSequenceGenerator . MAX_YEARS_BETWEEN_ENCOUNTERS ) ) ) ) ; } return encounters ; } }
public class ParseError { String activity ; String tag ; String e ; String cause ; String message ; public void sendError ( String activity , String tag , String e , String cause , String message ) { this . activity = activity ; this . tag = tag ; this . e = e ; this . cause = cause ; this . message = message ; ParseObject error = new ParseObject ( "Error" ) ; error . put ( "DeviceName" , GetDeviceName ( ) ) ; error . put ( "OS" , SDK_INT ) ; error . put ( "ExceptionE" , e ) ; error . put ( "TAG" , tag ) ; error . put ( "Activity" , activity ) ; error . put ( "Cause" , cause ) ; error . put ( "Message" , message ) ; <START_BUG> error . saveEventually ( ) ; <END_BUG> } private String GetDeviceName ( ) { } private String Capitalize ( String s ) { } }
public abstract class AbstractServer { static final Logger log = Logger . getLogger ( "org.jboss.as.server" ) ; private ServerModel config ; private ServiceContainer serviceContainer ; private final ServerEnvironment environment ; protected AbstractServer ( final ServerEnvironment environment ) { } public ServerEnvironment getEnvironment ( ) { } public ServerModel getConfig ( ) { } public abstract void start ( ) throws ServerStartException { } void start ( final ServerModel config ) throws ServerStartException { if ( config == null ) { throw new IllegalArgumentException ( "null<seq2seq4repair_space>standalone<seq2seq4repair_space>config" ) ; } this . config = config ; <START_BUG> AbstractServer . log . infof ( "Starting<seq2seq4repair_space>server<seq2seq4repair_space>'%s'" , config . getServerName ( ) ) ; <END_BUG> serviceContainer = Factory . create ( ) ; final ServerStartupListener listener = new ServerStartupListener ( createListenerCallback ( ) ) ; try { final ServerStartBatchBuilder subsystemBatchBuilder = new ServerStartBatchBuilder ( serviceContainer . batchBuilder ( ) , listener ) ; subsystemBatchBuilder . addListener ( listener ) ; final ServiceActivatorContext subsystemActivatorContext = new org . jboss . msc . service . ServiceActivatorContextImpl ( subsystemBatchBuilder ) ; config . activateSubsystems ( subsystemActivatorContext ) ; listener . startBatch ( new Runnable ( ) { @ Override public void run ( ) { final ServerStartBatchBuilder deploymentBatchBuilder = new ServerStartBatchBuilder ( serviceContainer . batchBuilder ( ) , listener ) ; deploymentBatchBuilder . addListener ( listener ) ; final ServiceActivatorContext deploymentActivatorContext = new org . jboss . msc . service . ServiceActivatorContextImpl ( deploymentBatchBuilder ) ; listener . startBatch ( null ) ; config . activateDeployments ( deploymentActivatorContext ) ; listener . finish ( ) ; try { deploymentBatchBuilder . install ( ) ; listener . finishBatch ( ) ; } catch ( ServiceRegistryException e ) { throw new RuntimeException ( e ) ; } } } ) ; subsystemBatchBuilder . install ( ) ; listener . finishBatch ( ) ; } catch ( Throwable t ) { throw new ServerStartException ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>start<seq2seq4repair_space>server" , t ) ; } } public void stop ( ) { } abstract Callback createListenerCallback ( ) { } }
public class SignGui extends GuiEditSign { public SignGui ( TileEntitySign theSign ) { } @ Override public void initGui ( ) { } @ Override protected void actionPerformed ( GuiButton button ) { } @ Override public void drawScreen ( int par1 , int par2 , float par3 ) { } @ Override public void mouseClicked ( int i , int j , int k ) { } public int getEditLine ( ) { try { Class c = GuiEditSign . class ; <START_BUG> Field f = c . getDeclaredField ( ObfuscatedField . fromMcp ( "I" , "editLine" ) . obfName ) ; <END_BUG> f . setAccessible ( true ) ; return ( ( Integer ) ( f . get ( this ) ) ) ; } catch ( Exception exception ) { } return 0 ; } public TileEntitySign sign ; }
public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = - 2362048321261811743L ; private static final int HASH_SEED = 31 ; private static final String DUMMY_PATTERN = "" ; private static final String ESCAPED_QUOTE = "''" ; private static final char START_FMT = ',' ; private static final char END_FE = '}' ; private static final char START_FE = '{' ; private static final char QUOTE = '\'' ; private String toPattern ; private final Map < String , ? extends FormatFactory > registry ; public ExtendedMessageFormat ( String pattern ) { } public ExtendedMessageFormat ( String pattern , Locale locale ) { } public ExtendedMessageFormat ( String pattern , Map < String , ? extends FormatFactory > registry ) { } public ExtendedMessageFormat ( String pattern , Locale locale , Map < String , ? extends FormatFactory > registry ) { } @ Override public String toPattern ( ) { } @ Override public final void applyPattern ( String pattern ) { } @ Override public void setFormat ( int formatElementIndex , Format newFormat ) { } @ Override public void setFormatByArgumentIndex ( int argumentIndex , Format newFormat ) { } @ Override public void setFormats ( Format [ ] newFormats ) { } @ Override public void setFormatsByArgumentIndex ( Format [ ] newFormats ) { } @ Override public boolean equals ( Object obj ) { } @ Override public int hashCode ( ) { } private Format getFormat ( String desc ) { } private int readArgumentIndex ( String pattern , ParsePosition pos ) { int start = pos . getIndex ( ) ; seekNonWs ( pattern , pos ) ; <START_BUG> StringBuffer result = new StringBuffer ( ) ; <END_BUG> boolean error = false ; for ( ; ( ! error ) && ( ( pos . getIndex ( ) ) < ( pattern . length ( ) ) ) ; next ( pos ) ) { char c = pattern . charAt ( pos . getIndex ( ) ) ; if ( Character . isWhitespace ( c ) ) { seekNonWs ( pattern , pos ) ; c = pattern . charAt ( pos . getIndex ( ) ) ; if ( ( c != ( ExtendedMessageFormat . START_FMT ) ) && ( c != ( ExtendedMessageFormat . END_FE ) ) ) { error = true ; continue ; } } if ( ( ( c == ( ExtendedMessageFormat . START_FMT ) ) || ( c == ( ExtendedMessageFormat . END_FE ) ) ) && ( ( result . length ( ) ) > 0 ) ) { try { return Integer . parseInt ( result . toString ( ) ) ; } catch ( NumberFormatException e ) { } } error = ! ( Character . isDigit ( c ) ) ; result . append ( c ) ; } if ( error ) { throw new IllegalArgumentException ( ( ( ( "Invalid<seq2seq4repair_space>format<seq2seq4repair_space>argument<seq2seq4repair_space>index<seq2seq4repair_space>at<seq2seq4repair_space>position<seq2seq4repair_space>" + start ) + ":<seq2seq4repair_space>" ) + ( pattern . substring ( start , pos . getIndex ( ) ) ) ) ) ; } throw new IllegalArgumentException ( ( "Unterminated<seq2seq4repair_space>format<seq2seq4repair_space>element<seq2seq4repair_space>at<seq2seq4repair_space>position<seq2seq4repair_space>" + start ) ) ; } private String parseFormatDescription ( String pattern , ParsePosition pos ) { } private String insertFormats ( String pattern , ArrayList < String > customPatterns ) { } private void seekNonWs ( String pattern , ParsePosition pos ) { } private ParsePosition next ( ParsePosition pos ) { } private StringBuilder appendQuotedString ( String pattern , ParsePosition pos , StringBuilder appendTo , boolean escapingOn ) { } private void getQuotedString ( String pattern , ParsePosition pos , boolean escapingOn ) { } private boolean containsElements ( Collection < ? > coll ) { } }
public class RelationFieldStrategy extends AbstractFieldStrategy implements Embeddable , Joinable { private static final Localizer _loc = Localizer . forPackage ( RelationFieldStrategy . class ) ; private Boolean _fkOid = null ; public void map ( boolean adapt ) { } private void setMappedByIdColumns ( ) { } private List getMappedByIdColumns ( FieldMapping pk ) { } private boolean isTypeUnjoinedSubclass ( ValueMapping mapped ) { } public void initialize ( ) { } public void insert ( OpenJPAStateManager sm , JDBCStore store , RowManager rm ) throws SQLException { } private void setMapKey ( OpenJPAStateManager sm , OpenJPAStateManager rel , JDBCStore store , Row row ) throws SQLException { } private FieldMapping getMapField ( ClassMetaData meta ) { } private Object getMapKeyObj ( Map mapObj , Object value ) { } public void update ( OpenJPAStateManager sm , JDBCStore store , RowManager rm ) throws SQLException { } public void delete ( OpenJPAStateManager sm , JDBCStore store , RowManager rm ) throws SQLException { } private void nullInverse ( OpenJPAStateManager sm , RowManager rm ) throws SQLException { } private void updateInverse ( OpenJPAStateManager sm , OpenJPAStateManager rel , JDBCStore store , RowManager rm ) throws SQLException { } public int supportsSelect ( Select sel , int type , OpenJPAStateManager sm , JDBCStore store , JDBCFetchConfiguration fetch ) { } public void selectEagerParallel ( SelectExecutor sel , final OpenJPAStateManager sm , final JDBCStore store , final JDBCFetchConfiguration fetch , final int eagerMode ) { } private void selectEagerParallel ( Select sel , ClassMapping cls , JDBCStore store , JDBCFetchConfiguration fetch , int eagerMode ) { } public void selectEagerJoin ( Select sel , OpenJPAStateManager sm , JDBCStore store , JDBCFetchConfiguration fetch , int eagerMode ) { } private Joins eagerJoin ( Joins joins , ClassMapping cls , boolean forceInner ) { } private Joins setEmbeddedVariable ( Joins joins ) { } public int select ( Select sel , OpenJPAStateManager sm , JDBCStore store , JDBCFetchConfiguration fetch , int eagerMode ) { } public Object loadEagerParallel ( OpenJPAStateManager sm , JDBCStore store , JDBCFetchConfiguration fetch , Object res ) throws SQLException { } private Map processEagerParallelResult ( OpenJPAStateManager sm , JDBCStore store , JDBCFetchConfiguration fetch , Result res ) throws SQLException { } public void loadEagerJoin ( OpenJPAStateManager sm , JDBCStore store , JDBCFetchConfiguration fetch , Result res ) throws SQLException { } public void load ( OpenJPAStateManager sm , JDBCStore store , JDBCFetchConfiguration fetch , Result res ) throws SQLException { } public void load ( final OpenJPAStateManager sm , final JDBCStore store , final JDBCFetchConfiguration fetch ) throws SQLException { } public Object toDataStoreValue ( Object val , JDBCStore store ) { } public void appendIsNull ( SQLBuffer sql , Select sel , Joins joins ) { } public void appendIsNotNull ( SQLBuffer sql , Select sel , Joins joins ) { } private void testInverseNull ( SQLBuffer sql , Select sel , Joins joins , boolean empty ) { } public Joins join ( Joins joins , boolean forceOuter ) { } public Joins joinRelation ( Joins joins , boolean forceOuter , boolean traverse ) { } public int getFieldIndex ( ) { } public Object getPrimaryKeyValue ( Result res , Column [ ] cols , ForeignKey fk , JDBCStore store , Joins joins ) throws SQLException { ClassMapping relmapping = field . getTypeMapping ( ) ; if ( ( relmapping . getIdentityType ( ) ) == ( ClassMapping . ID_DATASTORE ) ) { Column col = cols [ 0 ] ; if ( fk != null ) col = fk . getColumn ( col ) ; long id = res . getLong ( col , joins ) ; if ( ( field . getObjectIdFieldTypeCode ( ) ) == ( JavaTypes . LONG ) ) <START_BUG> return Numbers . valueOf ( id ) ; <END_BUG> return store . newDataStoreId ( id , relmapping , ( ( field . getPolymorphic ( ) ) != ( ValueMapping . POLY_FALSE ) ) ) ; } if ( relmapping . isOpenJPAIdentity ( ) ) return ( ( Joinable ) ( relmapping . getPrimaryKeyFieldMappings ( ) [ 0 ] . getStrategy ( ) ) ) . getPrimaryKeyValue ( res , cols , fk , store , joins ) ; if ( ( cols == ( getColumns ( ) ) ) && ( fk == null ) ) fk = field . getForeignKey ( ) ; else fk = createTranslatingForeignKey ( relmapping , cols , fk ) ; return relmapping . getObjectId ( store , res , fk , ( ( field . getPolymorphic ( ) ) != ( ValueMapping . POLY_FALSE ) ) , joins ) ; } private ForeignKey createTranslatingForeignKey ( ClassMapping relmapping , Column [ ] gcols , ForeignKey gfk ) { } public Object getJoinValue ( Object fieldVal , Column col , JDBCStore store ) { } public Object getJoinValue ( OpenJPAStateManager sm , Column col , JDBCStore store ) { } public void setAutoAssignedValue ( OpenJPAStateManager sm , JDBCStore store , Column col , Object autoInc ) { } public Column [ ] getColumns ( ) { } public ColumnIO getColumnIO ( ) { } public Object [ ] getResultArguments ( ) { } public Object toEmbeddedDataStoreValue ( Object val , JDBCStore store ) { } public Object toEmbeddedObjectValue ( Object val ) { } public void loadEmbedded ( OpenJPAStateManager sm , JDBCStore store , JDBCFetchConfiguration fetch , Object val ) throws SQLException { } }
public final class KnockoutFXTest extends KnockoutTCK implements Transfer { private static Class < ? > browserClass ; private static Presenter browserContext ; private KO4J ko4j = new KO4J ( ) ; private final Map < String , KnockoutFXTest . Request > urlMap = new HashMap < > ( ) ; public KnockoutFXTest ( ) { } static synchronized ClassLoader getClassLoader ( ) throws InterruptedException { } public static synchronized void initialized ( Class < ? > browserCls ) throws Exception { } public static void initialized ( ) throws Exception { } @ Override public BrwsrCtx createContext ( ) { } @ Override public Object createJSON ( Map < String , Object > values ) { } @ JavaScriptBody ( args = { } , body = "return<seq2seq4repair_space>new<seq2seq4repair_space>Object();" ) private static native Object createJSON ( ) { } @ JavaScriptBody ( args = { "json" , "key" , "value" } , body = "json[key]<seq2seq4repair_space>=<seq2seq4repair_space>value;" ) private static native void setProperty ( Object json , String key , Object value ) { } @ Override @ JavaScriptBody ( args = { "s" , "args" } , body = "var<seq2seq4repair_space>f<seq2seq4repair_space>=<seq2seq4repair_space>new<seq2seq4repair_space>Function(s);<seq2seq4repair_space>" + "return<seq2seq4repair_space>f.apply(null,<seq2seq4repair_space>args);" ) public native Object executeScript ( String s , Object [ ] args ) { } @ JavaScriptBody ( args = { } , body = "var<seq2seq4repair_space>h;" + ( ( ( ( "if<seq2seq4repair_space>(!!window<seq2seq4repair_space>&&<seq2seq4repair_space>!!window.location<seq2seq4repair_space>&&<seq2seq4repair_space>!!window.location.href)\n" + "<seq2seq4repair_space>h<seq2seq4repair_space>=<seq2seq4repair_space>window.location.href;\n" ) + "else<seq2seq4repair_space>" ) + "<seq2seq4repair_space>h<seq2seq4repair_space>=<seq2seq4repair_space>null;" ) + "return<seq2seq4repair_space>h;\n" ) ) private static native String findBaseURL ( ) { } @ Override public URI prepareURL ( String content , String mimeType , String [ ] parameters ) { } @ Override public boolean canFailWebSocketTest ( ) { } @ Override public void extract ( Object obj , String [ ] props , Object [ ] values ) { } @ Override public Object toJSON ( InputStream is ) throws IOException { } @ Override public void loadJSON ( JSONCall call ) { } private static void defineCallback ( String name , JSONCall call ) { KnockoutFXTest . defineFunction ( name , ( data ) -> { removeFunction ( name ) ; HTMLDocument . current ( ) . getElementById ( ( "jsonp-" + name ) ) . delete ( ) ; <START_BUG> call . notifySuccess ( call ) ; <END_BUG> } ) ; } @ JSBody ( params = { "name" , "callback" } , script = "window[name]<seq2seq4repair_space>=<seq2seq4repair_space>callback;" ) private static native void defineFunction ( String name , KnockoutFXTest . JSONPCallback callback ) { } @ JSBody ( params = "name" , script = "delete<seq2seq4repair_space>window[name];" ) private static native void removeFunction ( String name ) { } @ JSFunctor static interface JSONPCallback extends JSObject { void dataReceived ( JSObject dataReceived ) { } } private static final class Request { final String content ; final String mimeType ; final String [ ] parameters ; public Request ( String content , String mimeType , String [ ] parameters ) { } } }
@ SearchProcessorImpl ( id = "HistogramProcessor" ) public class HistogramProcessor extends IpacTablePartProcessor { private static final String SEARCH_REQUEST = "searchRequest" ; private static DataType [ ] columns = new DataType [ ] { new DataType ( "numInBin" , Integer . class ) , new DataType ( "binMin" , Double . class ) , new DataType ( "binMax" , Double . class ) } ; private final String FIXED_SIZE_ALGORITHM = "fixedSizeBins" ; private final String NUMBER_BINS = "numBins" ; private final String COLUMN = "columnExpression" ; private final String MIN = "min" ; private final String MAX = "max" ; private final String FALSEPOSTIVERATE = "falsePositiveRate" ; private final String PRESERVE_EMPTY_BIN = "preserveEmptyBins" ; private String algorithm = null ; private int numBins ; private double min = Double . NaN ; private double max = Double . NaN ; private String columnExpression ; private double falsePostiveRate = 0.05 ; private boolean showEmptyBin = false ; protected File loadDataFile ( TableServerRequest request ) throws DataAccessException , IOException { String searchRequestJson = request . getParam ( HistogramProcessor . SEARCH_REQUEST ) ; if ( searchRequestJson == null ) { throw new DataAccessException ( ( ( "Unable<seq2seq4repair_space>to<seq2seq4repair_space>get<seq2seq4repair_space>statistics:<seq2seq4repair_space>" + ( HistogramProcessor . SEARCH_REQUEST ) ) + "<seq2seq4repair_space>is<seq2seq4repair_space>missing" ) ) ; } JSONObject searchRequestJSON = ( ( JSONObject ) ( JSONValue . parse ( request . getParam ( HistogramProcessor . SEARCH_REQUEST ) ) ) ) ; String searchId = ( ( String ) ( searchRequestJSON . get ( ID ) ) ) ; if ( searchId == null ) { throw new DataAccessException ( ( ( ( "Unable<seq2seq4repair_space>to<seq2seq4repair_space>get<seq2seq4repair_space>statistics:<seq2seq4repair_space>" + ( HistogramProcessor . SEARCH_REQUEST ) ) + "<seq2seq4repair_space>must<seq2seq4repair_space>contain<seq2seq4repair_space>" ) + ( ServerParams . ID ) ) ) ; } TableServerRequest sReq = new TableServerRequest ( searchId ) ; String value ; for ( Object param : searchRequestJSON . keySet ( ) ) { String name = ( ( String ) ( param ) ) ; if ( ! ( name . equalsIgnoreCase ( ID ) ) ) { value = searchRequestJSON . get ( param ) . toString ( ) ; <START_BUG> sReq . setParam ( name , value ) ; <END_BUG> } } FileInfo fi = new SearchManager ( ) . getFileInfo ( sReq ) ; if ( fi == null ) { throw new DataAccessException ( "Unable<seq2seq4repair_space>to<seq2seq4repair_space>get<seq2seq4repair_space>file<seq2seq4repair_space>location<seq2seq4repair_space>info" ) ; } if ( ( fi . getInternalFilename ( ) ) == null ) { throw new DataAccessException ( "File<seq2seq4repair_space>not<seq2seq4repair_space>available" ) ; } if ( ! ( fi . hasAccess ( ) ) ) { throw new SecurityException ( "Access<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>permitted." ) ; } getParameters ( request ) ; DataGroup sourceDataGroup = DataGroupReader . readAnyFormat ( new File ( fi . getInternalFilename ( ) ) ) ; double [ ] columnData = getColumnData ( sourceDataGroup ) ; DataGroup HistogramDataGroup = createHistogramTable ( columnData ) ; File histogramFile = createFile ( request ) ; DataGroupWriter . write ( histogramFile , HistogramDataGroup , 0 ) ; return histogramFile ; } private void getParameters ( TableServerRequest tableServerRequest ) { } public DataGroup createHistogramTable ( double [ ] columnData ) throws DataAccessException { } private Object [ ] calculateFixedBinSizeDataArray ( double [ ] columnData ) { } private int [ ] getSelection ( int [ ] inArray , ArrayList < Integer > list ) { } private double [ ] getSelection ( double [ ] inArray , ArrayList < Integer > list ) { } private boolean isInSelection ( int idx , ArrayList < Integer > list ) { } private DataType [ ] getColumn ( DataGroup dg ) { } private double convertToADoubleValue ( Object data , DataType numericColumn ) { } private double [ ] getColumnData ( DataGroup dg ) { } private static String [ ] getInputFilePath ( String inputFileName ) { } private Object [ ] calculateVariableBinSizeDataArray ( double [ ] columnData ) throws DataAccessException { } private Object [ ] filterEmptyBins ( int [ ] numPointsInBin , double [ ] binMin , double [ ] binMax ) { } public double [ ] getBins ( double [ ] columnData ) throws DataAccessException { } private int getIndexOfTheMaxValue ( double [ ] inArray ) { } private double [ ] calculateFitnessFunction ( double [ ] countVec , double [ ] width , double [ ] best , double ncpPrior ) throws DataAccessException { } private double [ ] getEdges ( double [ ] data ) throws DataAccessException { } private double [ ] getWidth ( double [ ] inArray , int k ) { } private double [ ] reverseArray ( double [ ] inArray ) { } private int [ ] reverseArray ( ArrayList < Integer > inArrayList ) { } private double [ ] getCumulativeSum ( double [ ] nnVec , int k ) { } private double [ ] concatenate ( double [ ] a , double [ ] b ) throws DataAccessException { } public void setBinNumber ( int nBin ) { } private double [ ] multiply ( double [ ] array , double a ) { } public static void main ( String [ ] args ) throws DataAccessException , IOException { } }
public class ServerManager extends AbstractMgmtTestBase { private int mgmtPort ; private String mgmtHostName ; public ServerManager ( ) { } public ServerManager ( String mgmtHostName , int mgmtPort ) { } public ServerManager ( String mgmtHostName ) { } public int getMgmtPort ( ) { } public void addConnector ( Connector conn , int port , String keyPEMFile , String certPEMFile , String keyStoreFile , String password ) throws Exception { } private ModelNode getAddSocketBindingOp ( Connector conn , int port ) { } private ModelNode getAddConnectorOp ( Connector conn , String keyPEMFile , String certPEMFile , String keyStoreFile , String password ) { ModelNode op = createOpNode ( ( ( "subsystem=web/connector=test-" + ( conn . getName ( ) ) ) + "-connector" ) , "add" ) ; op . get ( "socket-binding" ) . set ( ( "test-" + ( conn . getName ( ) ) ) ) ; op . get ( "scheme" ) . set ( conn . getScheme ( ) ) ; <START_BUG> op . get ( "protocol" ) . set ( conn . getProtrocol ( ) ) ; <END_BUG> op . get ( "secure" ) . set ( conn . isSecure ( ) ) ; op . get ( "enabled" ) . set ( true ) ; if ( conn . isSecure ( ) ) { ModelNode ssl = new ModelNode ( ) ; if ( conn . equals ( HTTPSNATIVE ) ) { ssl . get ( "certificate-key-file" ) . set ( keyPEMFile ) ; ssl . get ( "certificate-file" ) . set ( certPEMFile ) ; } else { ssl . get ( "certificate-key-file" ) . set ( keyStoreFile ) ; } ssl . get ( "password" ) . set ( password ) ; op . get ( "ssl" ) . set ( ssl ) ; } return op ; } public void removeConnector ( Connector conn , String checkURL ) throws Exception { } private ModelNode getRemoveSocketBindingOp ( Connector conn ) { } private ModelNode getRemoveConnectorOp ( Connector conn ) { } public HashSet < String > getConnectorList ( ) throws Exception { } public void initModelControllerClient ( ) { } }
public class WorldLoadEvent { @ SubscribeEvent public void loadEvent ( WorldEvent . Load evt ) { } @ SubscribeEvent public void unloadEvent ( WorldEvent . Unload evt ) { int d = evt . world . provider . dimensionId ; if ( d != 0 ) { return ; } if ( ! ( evt . world . isRemote ) ) { if ( MinecraftServer . getServer ( ) . isDedicatedServer ( ) ) { <START_BUG> RfToolsDimensionManager . unregisterDimensions ( ) ; <END_BUG> KnownDimletConfiguration . clean ( ) ; } } } }
@ Repository ( "MovementDao" ) public class MovementDaoImpl implements MovementDao { @ Autowired private JdbcTemplate jdbcTemplate ; private String movementCountSQL = "SELECT<seq2seq4repair_space>COUNT(1)<seq2seq4repair_space>" + ( ( ( "FROM<seq2seq4repair_space>MOVEMENT<seq2seq4repair_space>M<seq2seq4repair_space>INNER<seq2seq4repair_space>JOIN<seq2seq4repair_space>MOVEMENT_DOCUMENT<seq2seq4repair_space>MD<seq2seq4repair_space>" + "ON<seq2seq4repair_space>M.MOVEMENT_ID<seq2seq4repair_space>=<seq2seq4repair_space>MD.MOVEMENT_ID<seq2seq4repair_space>WHERE<seq2seq4repair_space>" ) + "m.MVMT_SCHD_DEPARTURE_DT<seq2seq4repair_space>BETWEEN<seq2seq4repair_space>TRUNC(SYSDATE)<seq2seq4repair_space>-?<seq2seq4repair_space>AND<seq2seq4repair_space>TRUNC(SYSDATE)<seq2seq4repair_space>+?<seq2seq4repair_space>" ) + "AND<seq2seq4repair_space>m.ORI_FAC_ID=?" ) ; private String movementSQL = "SELECT<seq2seq4repair_space>MOVEMENT_NUMBER,M.MOVEMENT_ID,FLEET_TYPE,VEHICLE_ID,M.MVMT_SCHD_DEPARTURE_DT,<seq2seq4repair_space>" + ( ( ( ( "M.DEST_FAC_ID,<seq2seq4repair_space>MOVEMENT_DOCUMENT_ID,<seq2seq4repair_space>MVMT_STATUS_CODE,<seq2seq4repair_space>CLOSE_DT,<seq2seq4repair_space>DEPART_DT,<seq2seq4repair_space>CUT_OFF_TIME<seq2seq4repair_space>" + "FROM<seq2seq4repair_space>MOVEMENT<seq2seq4repair_space>M<seq2seq4repair_space>INNER<seq2seq4repair_space>JOIN<seq2seq4repair_space>MOVEMENT_DOCUMENT<seq2seq4repair_space>MD<seq2seq4repair_space>" ) + "ON<seq2seq4repair_space>M.MOVEMENT_ID<seq2seq4repair_space>=<seq2seq4repair_space>MD.MOVEMENT_ID<seq2seq4repair_space>WHERE<seq2seq4repair_space>" ) + "m.MVMT_SCHD_DEPARTURE_DT<seq2seq4repair_space>BETWEEN<seq2seq4repair_space>TRUNC(SYSDATE)<seq2seq4repair_space>-?<seq2seq4repair_space>AND<seq2seq4repair_space>TRUNC(SYSDATE)<seq2seq4repair_space>+?<seq2seq4repair_space>" ) + "AND<seq2seq4repair_space>m.ORI_FAC_ID=?" ) ; @ Override public Page < Movement > getMovementList ( int minusDate , int plusDate , final int pageNo , final int pageSize , String location ) { PaginationHelper < Movement > ph = new PaginationHelper < Movement > ( ) ; return ph . fetchPage ( jdbcTemplate , movementCountSQL , movementSQL , new Object [ ] { } , pageNo , pageSize , new org . springframework . jdbc . core . RowMapper < Movement > ( ) { @ Override public Movement mapRow ( ResultSet rs , int i ) throws SQLException { Movement movement = new Movement ( ) ; <START_BUG> movement . setMovementId ( rs . getString ( "MOVEMENT_NUMBER" ) ) ; <END_BUG> return movement ; } } ) ; } }
public class ActivityBuilder { private OLCConversionFlyweight flyweight ; private final CombinedTransition ctExecuted ; private Activity activity ; private Collection < DataFlow > incomingDataFlow ; private Collection < DataFlow > outgoingDataFlow ; private Collection < ActivityBuilder > successorActivities ; private Collection < CombinedTransition > concurrentCTs ; private Collection < ActivityBuilder > predecessors ; public Collection < CombinedTransition > getPets ( ) { } public Collection < Activity > getNopActivities ( ) { } public Collection < CombinedTransition > getEnabledCTs ( ) { } private Collection < ControlFlow > incomingControlFlow ; private Collection < ControlFlow > outgoingControlFlow ; private Collection < CombinedTransition > enabledCTs ; private Collection < DataObjectState > availableStates ; private boolean isChecked = false ; private Collection < Activity > nopActivities ; private Collection < CombinedTransition > pets ; public ActivityBuilder ( OLCConversionFlyweight < ActivityCentricProcessModel > flyweight , Collection < DataObjectState > availableStates , CombinedTransition ctExecuted ) { } private void initialize ( ) { } private void initializeActivity ( ) { } private void initializeDataFlow ( ) { } private void addOutgoingDataFlow ( DataObjectState target ) { } private void addIncomingDataFlow ( DataObjectState source ) { } public ActivityBuilder findEnabledCombinedTransitions ( Collection < DataObjectState > availableStates ) { } public ActivityBuilder findEnabledCombinedTransitions ( ) { } public ActivityBuilder findPossibleEnabledCombinedTransitions ( Collection < CombinedTransition > concurrentCTs ) { } private boolean isPossibleEnabledTransition ( CombinedTransition ct ) { } private Collection < DataObjectState > getStatesAfterConcurrentActivities ( Collection < CombinedTransition > concurrentCTs ) { } private Collection < DataObjectState > getStatesAfterConcurrentActivities ( ) { } private boolean activityEnablesCombinedTransition ( CombinedTransition ct ) { } private Collection < StateTransition > getEnabledTransitions ( Collection < DataObjectState > enabledStates ) { } private Collection < DataObjectState > statesAvailableAfterTermination ( ) { } private void initializeNOPActivities ( ) { } public boolean outputSetsAreDisjoint ( ActivityBuilder otherActivity ) { } public boolean inputSetsAreDisjoint ( ActivityBuilder otherActivity ) { } public Activity build ( ) { } public ControlFlow addPredecessor ( Event startEvent ) { } public ControlFlow addPredecessor ( Gateway gateway ) { } private ActivityBuilder getActivityBuilderForActivity ( Activity predecessor ) { } public ControlFlow addPredecessor ( ActivityBuilder builder ) { } public boolean isChecked ( ) { } public void markAsChecked ( ) { } public CombinedTransition getCtExecuted ( ) { } public Collection < ActivityBuilder > getSuccessorActivities ( ) { } private void initSuccessorActivities ( ) { } public void establishOutgoingControlFlow ( ) { assert ( successorActivities ) != null : "The<seq2seq4repair_space>successorActivities<seq2seq4repair_space>have<seq2seq4repair_space>to<seq2seq4repair_space>be<seq2seq4repair_space>initialized" ; if ( ( outgoingControlFlow ) == null ) { outgoingControlFlow = new HashSet ( ) ; } if ( ( ( nopActivities . size ( ) ) + ( successorActivities . size ( ) ) ) == 1 ) { if ( nopActivities . isEmpty ( ) ) { outgoingControlFlow . add ( successorActivities . iterator ( ) . next ( ) . addPredecessor ( this ) ) ; } else { ControlFlow cf = new ControlFlow ( activity , nopActivities . iterator ( ) . next ( ) ) ; flyweight . addIncomingEdgeFor ( nopActivities . iterator ( ) . next ( ) , cf ) ; outgoingControlFlow . add ( cf ) ; } } else if ( ( nopActivities . isEmpty ( ) ) && ( successorsAreDisjoint ( ) ) ) { Gateway and = new Gateway ( ) ; and . setType ( AND ) ; ControlFlow outgoing = new ControlFlow ( activity , and ) ; outgoingControlFlow . add ( outgoing ) ; and . addIncomingEdge ( outgoing ) ; for ( ActivityBuilder successor : successorActivities ) { ControlFlow cf = new ControlFlow ( and , successor . activity ) ; successor . incomingControlFlow . add ( cf ) ; and . addOutgoingEdge ( cf ) ; } flyweight . getModelUnderConstruction ( ) . addNode ( and ) ; } else { Gateway xor = new Gateway ( ) ; xor . setType ( XOR ) ; ControlFlow outgoing = new ControlFlow ( activity , xor ) ; xor . addIncomingEdge ( outgoing ) ; outgoingControlFlow . clear ( ) ; outgoingControlFlow . add ( outgoing ) ; for ( Activity nopActivity : nopActivities ) { ControlFlow cf = new ControlFlow ( xor , nopActivity ) ; flyweight . addIncomingEdgeFor ( nopActivity , cf ) ; xor . addOutgoingEdge ( cf ) ; } for ( ActivityBuilder successor : successorActivities ) { <START_BUG> xor . addOutgoingEdge ( successor . addPredecessor ( xor ) ) ; <END_BUG> } flyweight . getModelUnderConstruction ( ) . addNode ( xor ) ; } } private boolean successorsAreDisjoint ( ) { } public void establishIncomingControlFlow ( ) { } private boolean incomingControlFlowHasDisjointDataOutput ( ) { } No newline ; at end ; of file ; }
public class IndexManager extends JobManager implements IIndexConstants { public IWorkspace workspace ; public SimpleLookupTable indexNames = new SimpleLookupTable ( ) ; private Map indexes = new HashMap ( 5 ) ; private boolean needToSave = false ; private static final CRC32 checksumCalculator = new CRC32 ( ) ; private IPath javaPluginLocation = null ; private SimpleLookupTable indexStates = null ; private File savedIndexNamesFile = new File ( getJavaPluginWorkingLocation ( ) . append ( "savedIndexNames.txt" ) . toOSString ( ) ) ; public static Integer SAVED_STATE = new Integer ( 0 ) ; public static Integer UPDATING_STATE = new Integer ( 1 ) ; public static Integer UNKNOWN_STATE = new Integer ( 2 ) ; public static Integer REBUILDING_STATE = new Integer ( 3 ) ; public synchronized void aboutToUpdateIndex ( IPath path , Integer newIndexState ) { } public void addBinary ( IFile resource , IPath indexPath ) { } public void addSource ( IFile resource , IPath indexPath ) { } String computeIndexName ( IPath path ) { } public synchronized Index getIndex ( IPath path , boolean reuseExistingFile , boolean createIfMissing ) { } public synchronized Index getIndexForUpdate ( IPath path , boolean reuseExistingFile , boolean createIfMissing ) { } private SimpleLookupTable getIndexStates ( ) { } private IPath getJavaPluginWorkingLocation ( ) { } public void indexDocument ( SearchDocument searchDocument , SearchParticipant searchParticipant , Index index , IPath indexPath ) throws IOException { } public void indexAll ( IProject project ) { } public void indexLibrary ( IPath path , IProject requestingProject ) { } public void indexSourceFolder ( JavaProject javaProject , IPath sourceFolder , final char [ ] [ ] exclusionPattern ) { } public void jobWasCancelled ( IPath path ) { } protected synchronized void moveToNextJob ( ) { } protected void notifyIdle ( long idlingTime ) { } public Index peekAtIndex ( IPath path ) { } public String processName ( ) { } private void rebuildIndex ( String indexName , IPath path ) { } public synchronized Index recreateIndex ( IPath path ) { try { Index index = ( ( Index ) ( this . indexes . get ( path ) ) ) ; <START_BUG> ReadWriteMonitor monitor = index . monitor ; <END_BUG> String indexPath = computeIndexName ( path ) ; if ( JobManager . VERBOSE ) JobManager . verbose ( ( ( ( "-><seq2seq4repair_space>recreating<seq2seq4repair_space>index:<seq2seq4repair_space>" + indexPath ) + "<seq2seq4repair_space>for<seq2seq4repair_space>path:<seq2seq4repair_space>" ) + ( path . toOSString ( ) ) ) ) ; index = new Index ( indexPath , ( "Index<seq2seq4repair_space>for<seq2seq4repair_space>" + ( path . toOSString ( ) ) ) , false ) ; indexes . put ( path , index ) ; index . monitor = monitor ; return index ; } catch ( IOException e ) { if ( JobManager . VERBOSE ) { JobManager . verbose ( ( "-><seq2seq4repair_space>failed<seq2seq4repair_space>to<seq2seq4repair_space>recreate<seq2seq4repair_space>index<seq2seq4repair_space>for<seq2seq4repair_space>path:<seq2seq4repair_space>" + ( path . toOSString ( ) ) ) ) ; e . printStackTrace ( ) ; } return null ; } } public void remove ( String resourceName , IPath indexedContainer ) { } public synchronized void removeIndex ( IPath path ) { } public synchronized void removeIndexFamily ( IPath path ) { } public void removeSourceFolderFromIndex ( JavaProject javaProject , IPath sourceFolder , char [ ] [ ] exclusionPatterns ) { } public void reset ( ) { } public void saveIndex ( Index index ) throws IOException { } public void saveIndexes ( ) { } public void scheduleDocumentIndexing ( final SearchDocument searchDocument , final IPath indexPath , final SearchParticipant searchParticipant ) { } public void shutdown ( ) { } public String toString ( ) { } private char [ ] readIndexState ( ) { } private void updateIndexState ( String indexName , Integer indexState ) { } }
public class RemoteProxyControllerProtocolTestCase { final RemoteProxyControllerProtocolTestCase . DelegatingChannelHandler handler = new RemoteProxyControllerProtocolTestCase . DelegatingChannelHandler ( ) ; RemoteChannelPairSetup channels ; @ Before public void start ( ) throws Exception { channels = new RemoteChannelPairSetup ( ) ; channels . setupRemoting ( handler ) ; <START_BUG> channels . startChannels ( ) ; <END_BUG> } @ After public void stop ( ) throws Exception { } @ Test @ Ignore ( "OperationMessageHandlerProxy<seq2seq4repair_space>turned<seq2seq4repair_space>off<seq2seq4repair_space>temporarily" ) public void testOperationMessageHandler ( ) throws Exception { } @ Test public void testOperationControlFailed ( ) throws Exception { } @ Test public void testOperationControlExceptionInController ( ) throws Exception { } @ Test public void testTransactionCommit ( ) throws Exception { } @ Test public void testTransactionRollback ( ) throws Exception { } @ Test public void testAttachmentInputStreams ( ) throws Exception { } @ Test public void testClosesBeforePrepare ( ) throws Exception { } private void assertArrays ( byte [ ] expected , byte [ ] actual ) { } private RemoteProxyController setupProxyHandlers ( RemoteProxyControllerProtocolTestCase . MockModelController controller ) { } private abstract static class MockModelController implements ModelController { protected volatile ModelNode operation ; ModelNode getOperation ( ) { } @ Override public ModelControllerClient createClient ( Executor executor ) { } } private static class CommitProxyOperationControl implements ProxyOperationControl { final AtomicInteger txCompletionStatus = new AtomicInteger ( ( - 1 ) ) ; OperationTransaction tx ; @ Override public void operationPrepared ( OperationTransaction transaction , ModelNode result ) { } @ Override public void operationFailed ( ModelNode response ) { } @ Override public void operationCompleted ( ModelNode response ) { } } private static class TestFuture < T > extends AsyncFutureTask < T > { protected TestFuture ( ) { } void done ( T result ) { } } static class DelegatingChannelHandler implements ManagementMessageHandler { private ManagementMessageHandler delegate ; @ Override public synchronized void handleMessage ( Channel channel , DataInput input , ManagementProtocolHeader header ) throws IOException { } public synchronized void setDelegate ( ManagementMessageHandler delegate ) { } @ Override public void shutdown ( ) { } @ Override public boolean awaitCompletion ( long timeout , TimeUnit unit ) throws InterruptedException { } @ Override public void shutdownNow ( ) { } } }
public abstract class AbstractMavenRepoContentTests extends NexusAppTestSupport { protected RepositoryRegistry repositoryRegistry ; protected MavenRepository snapshots ; protected MavenRepository releases ; protected MavenRepository apacheSnapshots ; protected M2Repository central ; protected DefaultTargetRegistry targetRegistry ; @ Override protected void setUp ( ) throws Exception { } @ Override protected boolean runWithSecurityDisabled ( ) { } public void fillInRepo ( ) throws Exception { } protected File retrieveFile ( MavenRepository repo , String path ) throws Exception { } protected void copyDirectory ( final File from , final File to ) throws IOException { DirectoryWalker w = new DirectoryWalker ( ) ; w . setBaseDir ( from ) ; w . addSCMExcludes ( ) ; w . addDirectoryWalkListener ( new DirectoryWalkListener ( ) { public void debug ( String message ) { } public void directoryWalkStarting ( File basedir ) { } public void directoryWalkStep ( int percentage , File file ) { if ( ! ( file . isFile ( ) ) ) { return ; } try { String path = file . getAbsolutePath ( ) . substring ( from . getAbsolutePath ( ) . length ( ) ) ; <START_BUG> FileUtils . copyFile ( file , new File ( to , path ) ) ; <END_BUG> } catch ( IOException e ) { throw new IllegalStateException ( "Cannot<seq2seq4repair_space>copy<seq2seq4repair_space>dirtree." , e ) ; } } public void directoryWalkFinished ( ) { } } ) ; w . scan ( ) ; } }
class InternalSpelExpressionParser extends TemplateAwareExpressionParser { private String expressionString ; private List < Token > tokenStream ; private int tokenStreamLength ; private int tokenStreamPointer ; private Stack < SpelNodeImpl > constructedNodes = new Stack < SpelNodeImpl > ( ) ; private SpelParserConfiguration configuration ; public InternalSpelExpressionParser ( SpelParserConfiguration configuration ) { } @ Override protected SpelExpression doParseExpression ( String expressionString , ParserContext context ) throws ParseException { } private SpelNodeImpl eatExpression ( ) { } private SpelNodeImpl eatLogicalOrExpression ( ) { } private SpelNodeImpl eatLogicalAndExpression ( ) { } private SpelNodeImpl eatRelationalExpression ( ) { } private SpelNodeImpl eatSumExpression ( ) { } private SpelNodeImpl eatProductExpression ( ) { } private SpelNodeImpl eatPowerExpression ( ) { } private SpelNodeImpl eatUnaryExpression ( ) { } private SpelNodeImpl eatPrimaryExpression ( ) { } private boolean maybeEatNode ( ) { } private SpelNodeImpl maybeEatNonDottedNode ( ) { } private SpelNodeImpl eatDottedNode ( ) { } private boolean maybeEatFunctionOrVar ( ) { } private SpelNodeImpl [ ] maybeEatMethodArgs ( ) { } private void eatConstructorArgs ( List < SpelNodeImpl > accumulatedArguments ) { } private void consumeArguments ( List < SpelNodeImpl > accumulatedArguments ) { } private int positionOf ( Token t ) { } private SpelNodeImpl eatStartNode ( ) { } private boolean maybeEatBeanReference ( ) { } private boolean maybeEatTypeReference ( ) { } private boolean maybeEatNullReference ( ) { if ( peekToken ( IDENTIFIER ) ) { Token nullToken = peekToken ( ) ; <START_BUG> if ( ! ( nullToken . stringValue ( ) . equals ( "null" ) ) ) { <END_BUG> return false ; } nextToken ( ) ; constructedNodes . push ( new org . springframework . expression . spel . ast . NullLiteral ( toPos ( nullToken ) ) ) ; return true ; } return false ; } private boolean maybeEatProjection ( boolean nullSafeNavigation ) { } private boolean maybeEatInlineList ( ) { } private boolean maybeEatIndexer ( ) { } private boolean maybeEatSelection ( boolean nullSafeNavigation ) { } private SpelNodeImpl eatPossiblyQualifiedId ( ) { } private boolean maybeEatMethodOrProperty ( boolean nullSafeNavigation ) { } private boolean maybeEatConstructorReference ( ) { } private void push ( SpelNodeImpl newNode ) { } private SpelNodeImpl pop ( ) { } private boolean maybeEatLiteral ( ) { } private boolean maybeEatParenExpression ( ) { } private Token maybeEatRelationalOperator ( ) { } private Token eatToken ( TokenKind expectedKind ) { } private boolean peekToken ( TokenKind desiredTokenKind ) { } private boolean peekToken ( TokenKind desiredTokenKind , boolean consumeIfMatched ) { } private boolean peekToken ( TokenKind possible1 , TokenKind possible2 ) { } private boolean peekToken ( TokenKind possible1 , TokenKind possible2 , TokenKind possible3 ) { } private boolean peekIdentifierToken ( String identifierString ) { } private boolean peekSelectToken ( ) { } private boolean moreTokens ( ) { } private Token nextToken ( ) { } private Token peekToken ( ) { } private void raiseInternalException ( int pos , SpelMessage message , Object ... inserts ) { } public String toString ( Token t ) { } private void checkRightOperand ( Token token , SpelNodeImpl operandExpression ) { } private int toPos ( Token t ) { } private int toPos ( int start , int end ) { } }
public class FilePoller extends AbstractComponentRuntime { public static final String TYPE = "File<seq2seq4repair_space>Poller" ; public static final String ACTION_NONE = "None" ; public static final String ACTION_DELETE = "Delete" ; public static final String ACTION_ARCHIVE = "Archive" ; public static final String SETTING_FILE_PATTERN = "file.pattern" ; public static final String SETTING_RECURSE = "recurse" ; public static final String SETTING_CANCEL_ON_NO_FILES = "cancel.on.no.files" ; public static final String SETTING_ACTION_ON_SUCCESS = "action.on.success" ; public static final String SETTING_ARCHIVE_ON_SUCCESS_PATH = "archive.on.success.path" ; public static final String SETTING_ACTION_ON_ERROR = "action.on.error" ; public static final String SETTING_ARCHIVE_ON_ERROR_PATH = "archive.on.error.path" ; public static final String SETTING_USE_TRIGGER_FILE = "use.trigger.file" ; public static final String SETTING_MAX_FILES_TO_POLL = "max.files.to.poll" ; public static final String SORT_NAME = "Name" ; public static final String SORT_MODIFIED = "Last<seq2seq4repair_space>Modified" ; public static final String SETTING_FILE_SORT_ORDER = "file.sort.order" ; @ SettingDefinition ( order = 70 , type = Type . TEXT , label = "Relative<seq2seq4repair_space>Trigger<seq2seq4repair_space>File<seq2seq4repair_space>Path" ) public static final String SETTING_TRIGGER_FILE_PATH = "trigger.file.path" ; String filePattern ; String triggerFilePath ; boolean useTriggerFile = false ; boolean recurse = false ; boolean cancelOnNoFiles = true ; int maxFilesToPoll ; String actionOnSuccess = FilePoller . ACTION_NONE ; String archiveOnSuccessPath ; String actionOnError = FilePoller . ACTION_NONE ; String archiveOnErrorPath ; String fileSortOption = FilePoller . SORT_MODIFIED ; int filesPerMessage = 1000 ; ArrayList < File > filesSent = new ArrayList < File > ( ) ; @ Override protected void start ( ) { } @ Override public boolean supportsStartupMessages ( ) { } @ Override public void handle ( Message inputMessage , ISendMessageCallback callback , boolean unitOfWorkBoundaryReached ) { } protected void pollForFiles ( String path , Message inputMessage , ISendMessageCallback callback , boolean unitOfWorkLastMessage ) { File pathDir = getNewFile ( path ) ; ArrayList < File > fileReferences = new ArrayList < File > ( ) ; String [ ] includes = ( StringUtils . isNotBlank ( filePattern ) ) ? filePattern . split ( "," ) : new String [ ] { "*" } ; DirectoryScanner scanner = getDirectoryScanner ( ) ; scanner . setIncludes ( includes ) ; scanner . setBasedir ( pathDir ) ; scanner . setCaseSensitive ( false ) ; scanner . scan ( ) ; String [ ] files = scanner . getIncludedFiles ( ) ; if ( ( files . length ) > 0 ) { for ( int i = 0 ; ( i < ( files . length ) ) && ( i < ( maxFilesToPoll ) ) ; i ++ ) { File file = getNewFile ( path , files [ i ] ) ; filesSent . add ( file ) ; fileReferences . add ( file ) ; } Collections . sort ( fileReferences , new Comparator < File > ( ) { @ Override public int compare ( File o1 , File o2 ) { int cmpr = 0 ; if ( FilePoller . SORT_NAME . equals ( fileSortOption ) ) { cmpr = new String ( o1 . getName ( ) ) . compareTo ( new String ( o2 . getName ( ) ) ) ; } else if ( FilePoller . SORT_MODIFIED . equals ( fileSortOption ) ) { cmpr = new Long ( o1 . lastModified ( ) ) . compareTo ( new Long ( o2 . lastModified ( ) ) ) ; } return cmpr ; } } ) ; ArrayList < String > filePaths = new ArrayList < > ( ) ; for ( File file : fileReferences ) { log ( INFO , ( "File<seq2seq4repair_space>polled:<seq2seq4repair_space>" + ( file . getAbsolutePath ( ) ) ) ) ; getComponentStatistics ( ) . incrementNumberEntitiesProcessed ( threadNumber ) ; filePaths . add ( file . getAbsolutePath ( ) ) ; if ( ( filePaths . size ( ) ) <= ( filesPerMessage ) ) { <START_BUG> callback . sendMessage ( null , filePaths , unitOfWorkLastMessage ) ; <END_BUG> filePaths = new ArrayList < > ( ) ; } } if ( ( filePaths . size ( ) ) > 0 ) { callback . sendMessage ( null , filePaths , unitOfWorkLastMessage ) ; } } else if ( cancelOnNoFiles ) { callback . sendShutdownMessage ( true ) ; } } File getNewFile ( String path ) { } File getNewFile ( String path , String child ) { } DirectoryScanner getDirectoryScanner ( ) { } @ Override public void flowCompletedWithErrors ( Throwable myError ) { } @ Override public void flowCompleted ( boolean cancelled ) { } protected void deleteFiles ( ) { } protected void archive ( String archivePath ) { } }
public class RuntimeMXBeanAttributeHandler extends AbstractPlatformMBeanAttributeHandler { public static RuntimeMXBeanAttributeHandler INSTANCE = new RuntimeMXBeanAttributeHandler ( ) ; private RuntimeMXBeanAttributeHandler ( ) { } @ Override protected void executeReadAttribute ( OperationContext context , ModelNode operation ) throws OperationFailedException { } @ Override protected void executeWriteAttribute ( OperationContext context , ModelNode operation ) throws OperationFailedException { } @ Override protected void register ( ManagementResourceRegistration registration ) { } static void storeResult ( final String name , final ModelNode store ) { if ( ( ( PlatformMBeanUtil . JVM_MAJOR_VERSION ) > 6 ) && ( OBJECT_NAME . equals ( name ) ) ) { store . set ( ManagementFactory . RUNTIME_MXBEAN_NAME ) ; } else if ( NAME . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ) ; } else if ( VM_NAME . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getVmName ( ) ) ; } else if ( VM_VENDOR . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getVmVendor ( ) ) ; } else if ( VM_VERSION . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getVmVersion ( ) ) ; } else if ( SPEC_NAME . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getSpecName ( ) ) ; } else if ( SPEC_VENDOR . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getSpecVendor ( ) ) ; } else if ( SPEC_VERSION . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getSpecVersion ( ) ) ; } else if ( MANAGEMENT_SPEC_VERSION . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getManagementSpecVersion ( ) ) ; } else if ( CLASS_PATH . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getClassPath ( ) ) ; } else if ( LIBRARY_PATH . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getLibraryPath ( ) ) ; } else if ( BOOT_CLASS_PATH_SUPPORTED . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . isBootClassPathSupported ( ) ) ; } else if ( BOOT_CLASS_PATH . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getBootClassPath ( ) ) ; } else if ( INPUT_ARGUMENTS . equals ( name ) ) { store . setEmptyList ( ) ; for ( String arg : ManagementFactory . getRuntimeMXBean ( ) . getInputArguments ( ) ) { store . add ( arg ) ; } } else if ( UPTIME . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getUptime ( ) ) ; } else if ( START_TIME . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getStartTime ( ) ) ; } else if ( SYSTEM_PROPERTIES . equals ( name ) ) { store . setEmptyObject ( ) ; final TreeMap < String , String > sorted = new TreeMap < String , String > ( ManagementFactory . getRuntimeMXBean ( ) . getSystemProperties ( ) ) ; for ( Map . Entry < String , String > prop : sorted . entrySet ( ) ) { final ModelNode propNode = store . get ( prop . getKey ( ) ) ; if ( ( prop . getValue ( ) ) != null ) { propNode . set ( prop . getValue ( ) ) ; } } } else if ( ( RUNTIME_READ_ATTRIBUTES . contains ( name ) ) || ( RUNTIME_METRICS . contains ( name ) ) ) { <START_BUG> throw new IllegalStateException ( String . format ( "Read<seq2seq4repair_space>support<seq2seq4repair_space>for<seq2seq4repair_space>attribute<seq2seq4repair_space>%s<seq2seq4repair_space>was<seq2seq4repair_space>not<seq2seq4repair_space>properly<seq2seq4repair_space>implemented" , name ) ) ; <END_BUG> } } }
public class TarArchiveInputStream extends ArchiveInputStream { private static final int SMALL_BUFFER_SIZE = 256 ; private static final int BUFFER_SIZE = 8 * 1024 ; private boolean hasHitEOF ; private long entrySize ; private long entryOffset ; private byte [ ] readBuf ; protected final TarBuffer buffer ; private TarArchiveEntry currEntry ; public TarArchiveInputStream ( InputStream is ) { } public TarArchiveInputStream ( InputStream is , int blockSize ) { } public TarArchiveInputStream ( InputStream is , int blockSize , int recordSize ) { } public void close ( ) throws IOException { } public int getRecordSize ( ) { } public int available ( ) throws IOException { } public long skip ( long numToSkip ) throws IOException { } public void reset ( ) { } public TarArchiveEntry getNextTarEntry ( ) throws IOException { } public ArchiveEntry getNextEntry ( ) throws IOException { } public int read ( byte [ ] buf , int offset , int numToRead ) throws IOException { int totalRead = 0 ; if ( ( entryOffset ) >= ( entrySize ) ) { return - 1 ; } if ( ( numToRead + ( entryOffset ) ) > ( entrySize ) ) { numToRead = ( ( int ) ( ( entrySize ) - ( entryOffset ) ) ) ; } if ( ( readBuf ) != null ) { int sz = ( numToRead > ( readBuf . length ) ) ? readBuf . length : numToRead ; System . arraycopy ( readBuf , 0 , buf , offset , sz ) ; if ( sz >= ( readBuf . length ) ) { readBuf = null ; } else { int newLen = ( readBuf . length ) - sz ; byte [ ] newBuf = new byte [ newLen ] ; System . arraycopy ( readBuf , sz , newBuf , 0 , newLen ) ; readBuf = newBuf ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } while ( numToRead > 0 ) { byte [ ] rec = buffer . readRecord ( ) ; if ( rec == null ) { <START_BUG> throw new IOException ( ( ( ( "unexpected<seq2seq4repair_space>EOF<seq2seq4repair_space>with<seq2seq4repair_space>" + numToRead ) + "<seq2seq4repair_space>bytes<seq2seq4repair_space>unread.<seq2seq4repair_space>Occured<seq2seq4repair_space>at<seq2seq4repair_space>byte:<seq2seq4repair_space>" ) + ( getCount ( ) ) ) ) ; <END_BUG> } count ( rec . length ) ; int sz = numToRead ; int recLen = rec . length ; if ( recLen > sz ) { System . arraycopy ( rec , 0 , buf , offset , sz ) ; readBuf = new byte [ recLen - sz ] ; System . arraycopy ( rec , sz , readBuf , 0 , ( recLen - sz ) ) ; } else { sz = recLen ; System . arraycopy ( rec , 0 , buf , offset , recLen ) ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } entryOffset += totalRead ; return totalRead ; } protected final TarArchiveEntry getCurrentEntry ( ) { } protected final void setCurrentEntry ( TarArchiveEntry e ) { } protected final boolean isAtEOF ( ) { } protected final void setAtEOF ( boolean b ) { } public static boolean matches ( byte [ ] signature , int length ) { } }
public abstract class AbstractMoveFolderAction extends AbstractColumbaAction implements Observer , ISelectionListener { private AbstractFolder lastSelectedFolder ; public AbstractMoveFolderAction ( FrameMediator frameMediator , String name ) { } protected abstract boolean isActionEnabledByIndex ( int folderIndex ) { } private void registerSortingObserver ( ) { } public void update ( Observable o , Object arg ) { } private void enableAction ( ) { } private void reenableActionFromSelectedFolder ( ) { if ( ( lastSelectedFolder ) == null ) { setEnabled ( false ) ; } else { IFolderItem item = lastSelectedFolder . getConfiguration ( ) ; <START_BUG> if ( item . get ( "property" , "accessrights" ) . equals ( "user" ) ) { <END_BUG> int index = lastSelectedFolder . getParent ( ) . getIndex ( lastSelectedFolder ) ; setEnabled ( isActionEnabledByIndex ( index ) ) ; } else { setEnabled ( false ) ; } } } public void selectionChanged ( SelectionChangedEvent e ) { } protected AbstractFolder getLastSelectedFolder ( ) { } }
public class ContextPreferencesRepositoryImpl extends AbstractJongoRepository < ContextPreferences > implements ContextPreferencesRepository { private I10nLogger logger = LoggerFactory . getLogger ( ContextPreferencesRepositoryImpl . class ) ; @ Override public Map findEmailPreference ( final String contextId ) throws SocialException { } @ Override public String findNotificationTemplate ( final String contextId , final String notificationType ) throws SocialException { } @ Override public Map < String , Object > getContextPreferences ( final String contextId ) { } @ Override public boolean setContextPreferences ( final Map < String , Object > preferences , final String contextId ) { try { final String preferencesString = new ObjectMapper ( ) . writeValueAsString ( preferences ) ; final String byId = getQueryFor ( "social.system.preferences.emailPreferencesByContextId" ) ; <START_BUG> getCollection ( ) . findAndModify ( byId , contextId ) . with ( ( ( "{$set:<seq2seq4repair_space>" + preferencesString ) + "}" ) ) ; <END_BUG> return true ; } catch ( MongoException | JsonProcessingException e ) { return false ; } } public void saveEmailPreference ( final String contextId , Map < String , Object > emailPreferences ) throws SocialException { } No newline ; at end ; of file ; }
public abstract class Form extends HtmlContainer implements IFormSubmitListener { private static Log log = LogFactory . getLog ( Form . class ) ; private IValuePersister persister = null ; private IFormValidationDelegate validationDelegate = Form . DefaultFormValidationDelegate . getInstance ( ) ; private final IValidationFeedback validationFeedback ; private static final class DefaultFormValidationDelegate implements IFormValidationDelegate { private static final Form . DefaultFormValidationDelegate instance = new Form . DefaultFormValidationDelegate ( ) ; private static final Log log = LogFactory . getLog ( Form . DefaultFormValidationDelegate . class ) ; private static Form . DefaultFormValidationDelegate getInstance ( ) { } public void validate ( final Form form ) { } } public Form ( String name , IModel model , final IValidationFeedback validationFeedback ) { } public Form ( String name , IModel model , String expression , final IValidationFeedback validationFeedback ) { } public Form ( final String name , final IValidationFeedback validationFeedback ) { } public Form ( String name , Serializable object , final IValidationFeedback validationFeedback ) { } public Form ( String name , Serializable object , String expression , final IValidationFeedback validationFeedback ) { } public final void formSubmitted ( ) { } public IFormValidationDelegate getValidationDelegate ( ) { } public void removePersistedFormComponentData ( final boolean disablePersistence ) { } public final void setFormComponentValuesFromPersister ( ) { } public void setValidationDelegate ( IFormValidationDelegate validationDelegate ) { } protected void handleComponentTag ( final ComponentTag tag ) { <START_BUG> checkTag ( tag , "form" ) ; <END_BUG> super . handleComponentTag ( tag ) ; tag . put ( "method" , "POST" ) ; String url = getRequestCycle ( ) . urlFor ( this , IFormSubmitListener . class ) ; url = url . replaceAll ( "&" , "&amp;" ) ; tag . put ( "action" , url ) ; } protected final void handleErrors ( ) { } protected abstract void handleSubmit ( ) { } protected void setFormComponentPersistenceManager ( IValuePersister persister ) { } private IValuePersister getValuePersister ( ) { } private boolean hasError ( ) { } private void persistFormComponentData ( ) { } private void updateFormComponentModels ( ) { } }
public class IMAPMailCheckingAction extends AbstractMailCheckingAction { private int accountUid ; public IMAPMailCheckingAction ( AccountItem accountItem ) { } public void check ( ) { } public boolean isCheckAll ( ) { IMAPRootFolder imapRootFolder = ( ( IMAPRootFolder ) ( FolderTreeModel . getInstance ( ) . getImapFolder ( accountUid ) ) ) ; <START_BUG> return ! ( imapRootFolder . getAccountItem ( ) . getImapItem ( ) . getBoolean ( "exclude_from_checkall" , false ) ) ; <END_BUG> } }
public class Album extends SDirectory implements ADirectory { private static final Logger log = LoggerFactory . getLogger ( Album . class . getCanonicalName ( ) ) ; @ File public List < Photo > photos = new LinkedList < > ( ) ; @ Directory @ File public List < SDirectory > subdirs = new LinkedList < > ( ) ; public Map < Integer , SDirectory > phototags = new HashMap < > ( ) ; private final String name ; private final Theme theme ; private final Launch aThis ; private final int albumId ; private boolean wantTags = true ; private boolean wantYearAgo = true ; private final Root root ; public Album ( Root root , XmlDate date , String name , int albumId , Theme theme , Launch aThis ) { } public void noTags ( ) { } public void noYears ( ) { } @ Override public String getShortname ( ) { } @ Override public void load ( ) throws VFSException { final Session session = new Session ( theme , this . root ) ; session . setAlbum ( albumId ) ; XmlPhotoDisplay photodisp ; try { photodisp = aThis . photoService . treatPhotoDISPLAY ( session . getSessionPhotoDisplay ( ) , null ) ; } catch ( WebAlbumsServiceException ex ) { throw new VFSException ( ex ) ; } for ( XmlPhoto photo : photodisp . photoList . photo ) { Photo photofile = new Photo ( this . root , photo . details ) ; photos . add ( photofile ) ; if ( ! ( this . wantTags ) ) { continue ; } for ( XmlTag tag : photo . details . tag_used . getAllTags ( ) ) { BasicDirectory tagdir ; if ( ! ( phototags . containsKey ( tag . id ) ) ) { tagdir = new BasicDirectory ( tag . name ) ; phototags . put ( tag . id , tagdir ) ; subdirs . add ( tagdir ) ; } else { tagdir = ( ( BasicDirectory ) ( phototags . get ( tag . id ) ) ) ; } tagdir . addFileInside ( photofile ) ; } } if ( ! ( this . wantYearAgo ) ) { return ; } XmlAlbumAgo albumAgo ; try { final XmlAlbum album = photodisp . album ; ViewSessionAlbumAgo asession = new ViewSessionAlbum . ViewSessionAlbumAgo ( ) { @ Override public Integer getYear ( ) { return null ; } @ Override public Integer getMonth ( ) { return Integer . parseInt ( album . date . date . split ( "-" ) [ 1 ] ) ; } @ Override public Integer getDay ( ) { return Integer . parseInt ( album . date . day ) ; } @ Override public boolean getAll ( ) { return true ; } @ Override public Integer getExceptAlbm ( ) { return album . id ; } @ Override public ViewSession getVSession ( ) { return session ; } } ; albumAgo = aThis . albumService . treatAGO ( asession ) ; } catch ( WebAlbumsServiceException ex ) { throw new VFSException ( ex ) ; } Album . log . debug ( "Album<seq2seq4repair_space>{}<seq2seq4repair_space>has<seq2seq4repair_space>{}<seq2seq4repair_space>years-ago<seq2seq4repair_space>albums." , albumId , albumAgo . album . size ( ) ) ; BasicDirectory ago = new BasicDirectory ( "Years<seq2seq4repair_space>before" ) ; for ( XmlAlbum album : albumAgo . album ) { Album albumagodir = new Album ( this . root , album . date , album . name , album . id , theme , aThis ) ; <START_BUG> albumagodir . wantYearAgo = true ; <END_BUG> ago . addDirInside ( albumagodir ) ; } if ( ! ( ago . dirs . isEmpty ( ) ) ) { subdirs . add ( ago ) ; } } @ Override public String toString ( ) { } @ Override public void moveIn ( IFile srcFile , String filename ) { } }
public class Inspection { public static List < Class < ? > > types ( final DataFrame < ? > df ) { } public static BitSet numeric ( final DataFrame < ? > df ) { } public static BitSet nonnumeric ( final DataFrame < ? > df ) { final BitSet nonnumeric = Inspection . numeric ( df ) ; <START_BUG> nonnumeric . flip ( 0 , nonnumeric . length ( ) ) ; <END_BUG> return nonnumeric ; } }
class AppClientServerConfiguration { private AppClientServerConfiguration ( ) { } public static List < ModelNode > serverConfiguration ( final String filePath , final String deploymentName , final String globalModules , final String hostUrl , final List < String > parameters ) { } private static void webservices ( final List < ModelNode > nodes ) { } private static void appclient ( List < ModelNode > nodes , final String filePath , final String deploymentName , final String hostUrl , final List < String > parameters ) { } private static void naming ( List < ModelNode > nodes ) { } private static void ee ( List < ModelNode > nodes , final String globalModules ) { } private static void ejb3 ( List < ModelNode > nodes ) { } private static void security ( List < ModelNode > nodes ) { } private static void jacorb ( List < ModelNode > nodes ) { } private static void transactions ( List < ModelNode > nodes ) { } private static void socketBindings ( List < ModelNode > nodes ) { } private static void interfaces ( List < ModelNode > nodes ) { ModelNode add = new ModelNode ( ) ; add . get ( OP_ADDR ) . set ( new ModelNode ( ) . setEmptyList ( ) ) . add ( INTERFACE , "public" ) ; add . get ( OP ) . set ( ADD ) ; <START_BUG> add . get ( CRITERIA ) . add ( ) . set ( "inet-address" , "127.0.0.1" ) ; <END_BUG> nodes . add ( add ) ; } private static void loadExtension ( List < ModelNode > nodes , String moduleName ) { } }
public class AnnotationMethodHandlerAdapter extends WebContentGenerator implements BeanFactoryAware , Ordered , HandlerAdapter { public static final String PAGE_NOT_FOUND_LOG_CATEGORY = "org.springframework.web.servlet.PageNotFound" ; protected static final Log pageNotFoundLogger = LogFactory . getLog ( AnnotationMethodHandlerAdapter . PAGE_NOT_FOUND_LOG_CATEGORY ) ; private UrlPathHelper urlPathHelper = new UrlPathHelper ( ) ; private PathMatcher pathMatcher = new AntPathMatcher ( ) ; private MethodNameResolver methodNameResolver = new InternalPathMethodNameResolver ( ) ; private WebBindingInitializer webBindingInitializer ; private SessionAttributeStore sessionAttributeStore = new DefaultSessionAttributeStore ( ) ; private int cacheSecondsForSessionAttributeHandlers = 0 ; private boolean synchronizeOnSession = false ; private ParameterNameDiscoverer parameterNameDiscoverer = new LocalVariableTableParameterNameDiscoverer ( ) ; private WebArgumentResolver [ ] customArgumentResolvers ; private ModelAndViewResolver [ ] customModelAndViewResolvers ; private HttpMessageConverter < ? > [ ] messageConverters = new HttpMessageConverter [ ] { new ByteArrayHttpMessageConverter ( ) , new StringHttpMessageConverter ( ) , new FormHttpMessageConverter ( ) , new SourceHttpMessageConverter ( ) } ; private int order = Ordered . LOWEST_PRECEDENCE ; private ConfigurableBeanFactory beanFactory ; private BeanExpressionContext expressionContext ; private final Map < Class < ? > , AnnotationMethodHandlerAdapter . ServletHandlerMethodResolver > methodResolverCache = new ConcurrentHashMap < Class < ? > , AnnotationMethodHandlerAdapter . ServletHandlerMethodResolver > ( ) ; public AnnotationMethodHandlerAdapter ( ) { } public void setAlwaysUseFullPath ( boolean alwaysUseFullPath ) { } public void setUrlDecode ( boolean urlDecode ) { } public void setUrlPathHelper ( UrlPathHelper urlPathHelper ) { } public void setPathMatcher ( PathMatcher pathMatcher ) { } public void setMethodNameResolver ( MethodNameResolver methodNameResolver ) { } public void setWebBindingInitializer ( WebBindingInitializer webBindingInitializer ) { } public void setSessionAttributeStore ( SessionAttributeStore sessionAttributeStore ) { } public void setCacheSecondsForSessionAttributeHandlers ( int cacheSecondsForSessionAttributeHandlers ) { } public void setSynchronizeOnSession ( boolean synchronizeOnSession ) { } public void setParameterNameDiscoverer ( ParameterNameDiscoverer parameterNameDiscoverer ) { } public void setCustomArgumentResolver ( WebArgumentResolver argumentResolver ) { } public void setCustomArgumentResolvers ( WebArgumentResolver [ ] argumentResolvers ) { } public void setCustomModelAndViewResolver ( ModelAndViewResolver customModelAndViewResolver ) { } public void setCustomModelAndViewResolvers ( ModelAndViewResolver [ ] customModelAndViewResolvers ) { } public void setMessageConverters ( HttpMessageConverter < ? > [ ] messageConverters ) { } public HttpMessageConverter < ? > [ ] getMessageConverters ( ) { } public void setOrder ( int order ) { } public int getOrder ( ) { } public void setBeanFactory ( BeanFactory beanFactory ) { } public boolean supports ( Object handler ) { } public ModelAndView handle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { } protected ModelAndView invokeHandlerMethod ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { } public long getLastModified ( HttpServletRequest request , Object handler ) { } private AnnotationMethodHandlerAdapter . ServletHandlerMethodResolver getMethodResolver ( Object handler ) { } protected ServletRequestDataBinder createBinder ( HttpServletRequest request , Object target , String objectName ) throws Exception { } protected HttpInputMessage createHttpInputMessage ( HttpServletRequest servletRequest ) throws Exception { } protected HttpOutputMessage createHttpOutputMessage ( HttpServletResponse servletResponse ) throws Exception { } private class ServletHandlerMethodResolver extends HandlerMethodResolver { private ServletHandlerMethodResolver ( Class < ? > handlerType ) { } public Method resolveHandlerMethod ( HttpServletRequest request ) throws ServletException { } private String getMatchedPattern ( String methodLevelPattern , String lookupPath , HttpServletRequest request ) { } private boolean isPathMatchInternal ( String pattern , String lookupPath ) { } @ SuppressWarnings ( "unchecked" ) private void extractHandlerMethodUriTemplates ( String mappedPattern , String lookupPath , HttpServletRequest request ) { } } private class ServletHandlerMethodInvoker extends HandlerMethodInvoker { private boolean responseArgumentUsed = false ; private ServletHandlerMethodInvoker ( HandlerMethodResolver resolver ) { } @ Override protected void raiseMissingParameterException ( String paramName , Class paramType ) throws Exception { <START_BUG> throw new MissingServletRequestParameterException ( paramName , paramType . getName ( ) ) ; <END_BUG> } @ Override protected void raiseSessionRequiredException ( String message ) throws Exception { } @ Override protected WebDataBinder createBinder ( NativeWebRequest webRequest , Object target , String objectName ) throws Exception { } @ Override protected void doBind ( WebDataBinder binder , NativeWebRequest webRequest ) throws Exception { } @ Override protected HttpInputMessage createHttpInputMessage ( NativeWebRequest webRequest ) throws Exception { } @ Override protected HttpOutputMessage createHttpOutputMessage ( NativeWebRequest webRequest ) throws Exception { } @ Override protected Object resolveDefaultValue ( String value ) { } @ Override protected Object resolveCookieValue ( String cookieName , Class paramType , NativeWebRequest webRequest ) throws Exception { } @ Override @ SuppressWarnings ( { "unchecked" } ) protected String resolvePathVariable ( String pathVarName , Class paramType , NativeWebRequest webRequest ) throws Exception { } @ Override protected Object resolveStandardArgument ( Class parameterType , NativeWebRequest webRequest ) throws Exception { } @ SuppressWarnings ( "unchecked" ) public ModelAndView getModelAndView ( Method handlerMethod , Class handlerType , Object returnValue , ExtendedModelMap implicitModel , ServletWebRequest webRequest ) throws Exception { } private void handleResponseBody ( Object returnValue , ServletWebRequest webRequest ) throws Exception { } private void handleHttpEntityResponse ( HttpEntity < ? > responseEntity , ServletWebRequest webRequest ) throws Exception { } @ SuppressWarnings ( "unchecked" ) private void writeWithMessageConverters ( Object returnValue , HttpInputMessage inputMessage , HttpOutputMessage outputMessage ) throws IOException , HttpMediaTypeNotAcceptableException { } } static class RequestMappingInfo { String [ ] paths = new String [ 0 ] ; List < String > matchedPaths = Collections . emptyList ( ) ; RequestMethod [ ] methods = new RequestMethod [ 0 ] ; String [ ] params = new String [ 0 ] ; String [ ] headers = new String [ 0 ] ; public String bestMatchedPath ( ) { } public boolean matches ( HttpServletRequest request ) { } @ Override public boolean equals ( Object obj ) { } @ Override public int hashCode ( ) { } } static class RequestMappingInfoComparator implements Comparator < AnnotationMethodHandlerAdapter . RequestMappingInfo > { private final Comparator < String > pathComparator ; private final ServerHttpRequest request ; RequestMappingInfoComparator ( Comparator < String > pathComparator , HttpServletRequest request ) { } public int compare ( AnnotationMethodHandlerAdapter . RequestMappingInfo info1 , AnnotationMethodHandlerAdapter . RequestMappingInfo info2 ) { }
@ Deprecated public class LengthNormModifier { public static void main ( String [ ] args ) throws IOException { } private Directory dir ; private Similarity sim ; public LengthNormModifier ( Directory d , Similarity s ) { } public void reSetNorms ( String field ) throws IOException { String fieldName = StringHelper . intern ( field ) ; int [ ] termCounts = new int [ 0 ] ; IndexReader reader = IndexReader . open ( dir , false ) ; try { termCounts = new int [ reader . maxDoc ( ) ] ; Bits delDocs = MultiFields . getDeletedDocs ( reader ) ; DocsEnum docs = null ; Terms terms = MultiFields . getTerms ( reader , field ) ; if ( terms != null ) { TermsEnum termsEnum = terms . iterator ( ) ; while ( ( termsEnum . next ( ) ) != null ) { docs = termsEnum . docs ( delDocs , docs ) ; int doc ; while ( ( doc = docs . nextDoc ( ) ) != ( DocsEnum . NO_MORE_DOCS ) ) { termCounts [ doc ] += docs . freq ( ) ; } } } for ( int d = 0 ; d < ( termCounts . length ) ; d ++ ) { <START_BUG> if ( ! ( reader . isDeleted ( d ) ) ) { <END_BUG> byte norm = Similarity . encodeNorm ( sim . lengthNorm ( fieldName , termCounts [ d ] ) ) ; reader . setNorm ( d , fieldName , norm ) ; } } } finally { reader . close ( ) ; } } }
public class MockImageSupport extends AbstractImageSupport < MockCloud > implements MachineImageSupport { private static final Map < String , Map < String , Collection < MachineImage > > > customImages = new HashMap < String , Map < String , Collection < MachineImage > > > ( ) ; private static final Map < String , Map < String , Collection < MachineImage > > > publicImages = new HashMap < String , Map < String , Collection < MachineImage > > > ( ) ; private static final Random random = new Random ( ) ; private static void addCustomImage ( @ Nonnull String endpoint , @ Nonnull String regionId , @ Nonnull MachineImage img ) { } @ Nonnull private static Collection < MachineImage > getCustomImages ( @ Nonnull ProviderContext ctx ) { } @ Nonnull private static Collection < MachineImage > getPublicImages ( @ Nonnull ProviderContext ctx ) { } public MockImageSupport ( MockCloud provider ) { } protected MachineImage capture ( @ Nonnull ImageCreateOptions options , @ Nullable AsynchronousTask < MachineImage > task ) throws CloudException , InternalException { } @ Override public MachineImage getImage ( @ Nonnull String providerImageId ) throws CloudException , InternalException { } @ Nonnull private MachineImage image ( @ Nonnull ProviderContext ctx , @ Nonnull ImageCreateOptions options , @ Nullable AsynchronousTask < MachineImage > optionalTask ) throws CloudException , InternalException { } @ Override public boolean isSubscribed ( ) throws CloudException , InternalException { } private Collection < MachineImage > filterByAccountNumber ( Collection < MachineImage > machineImages , String accountNumber ) { } private Collection < MachineImage > filterByArchitecture ( Collection < MachineImage > machineImages , Architecture architecture ) { } private Collection < MachineImage > filterByImageClass ( Collection < MachineImage > machineImages , ImageClass imageClass ) { } private boolean matches ( MachineImage img , Platform platform ) { } private Collection < MachineImage > filterByPlatform ( Collection < MachineImage > machineImages , Platform platform ) { } private Collection < MachineImage > filterByNameRegex ( Collection < MachineImage > machineImages , String regex ) { } @ Override @ Nonnull public Iterable < MachineImage > listImages ( @ Nullable ImageFilterOptions options ) throws CloudException , InternalException { } @ Override @ Nonnull public Iterable < MachineImage > searchPublicImages ( @ Nonnull ImageFilterOptions options ) throws CloudException , InternalException { <START_BUG> return listImages ( options . withAccountNumber ( "--cloud--" ) ) ; <END_BUG> } @ Override public boolean isImageSharedWithPublic ( @ Nonnull String providerImageId ) throws CloudException , InternalException { } @ Override public void remove ( @ Nonnull String providerImageId , boolean checkState ) throws CloudException , InternalException { } private boolean matches ( MachineImage img , @ Nullable String accountNumber , @ Nullable String keyword , @ Nullable Platform platform , @ Nullable Architecture architecture ) { } @ Override public ImageCapabilities getCapabilities ( ) throws CloudException , InternalException { } No newline ; at end ; of file ; }
public class ClassMapping extends ClassMetaData implements ClassStrategy { public static final ClassMapping [ ] EMPTY_MAPPINGS = new ClassMapping [ 0 ] ; private static final Localizer _loc = Localizer . forPackage ( ClassMapping . class ) ; private final ClassMappingInfo _info ; private final Discriminator _discrim ; private final Version _version ; private ClassStrategy _strategy = null ; private Table _table = null ; private ColumnIO _io = null ; private Column [ ] _cols = Schemas . EMPTY_COLUMNS ; private ForeignKey _fk = null ; private int _subclassMode = Integer . MAX_VALUE ; private ClassMapping [ ] _joinSubMaps = null ; private ClassMapping [ ] _assignMaps = null ; private final Map _joinables = Collections . synchronizedMap ( new HashMap ( ) ) ; protected ClassMapping ( Class type , MappingRepository repos ) { } protected ClassMapping ( ValueMetaData vmd ) { } public Discriminator getDiscriminator ( ) { } public Version getVersion ( ) { } public Object getObjectId ( JDBCStore store , Result res , ForeignKey fk , boolean subs , Joins joins ) throws SQLException { } private Object getObjectId ( ClassMapping cls , JDBCStore store , Result res , ForeignKey fk , boolean subs , Joins joins ) throws SQLException { if ( ! ( isPrimaryKeyObjectId ( true ) ) ) return getPCSuperclassMapping ( ) . getObjectId ( cls , store , res , fk , subs , joins ) ; if ( ( getIdentityType ( ) ) == ( ID_UNKNOWN ) ) throw new InternalException ( ) ; Column [ ] pks = getPrimaryKeyColumns ( ) ; if ( ( getIdentityType ( ) ) == ( ID_DATASTORE ) ) { Column col = ( fk == null ) ? pks [ 0 ] : fk . getColumn ( pks [ 0 ] ) ; long id = res . getLong ( col , joins ) ; return ( id == 0 ) && ( res . wasNull ( ) ) ? null : store . newDataStoreId ( id , cls , subs ) ; } Object [ ] vals = new Object [ getPrimaryKeyFields ( ) . length ] ; FieldMapping fm ; Joinable join ; int pkIdx ; for ( int i = 0 ; i < ( pks . length ) ; i ++ ) { join = assertJoinable ( pks [ i ] ) ; fm = getFieldMapping ( join . getFieldIndex ( ) ) ; pkIdx = fm . getPrimaryKeyIndex ( ) ; if ( ( vals [ pkIdx ] ) == null ) { res . startDataRequest ( fm ) ; <START_BUG> vals [ pkIdx ] = join . getPrimaryKeyValue ( res , join . getColumns ( ) , fk , joins ) ; <END_BUG> res . endDataRequest ( ) ; if ( ( vals [ pkIdx ] ) == null ) return null ; } } Object oid = ApplicationIds . fromPKValues ( vals , cls ) ; if ( ( ! subs ) && ( oid instanceof OpenJPAId ) ) ( ( OpenJPAId ) ( oid ) ) . setManagedInstanceType ( cls . getDescribedType ( ) ) ; return oid ; } public Object toDataStoreValue ( Object obj , Column [ ] cols , JDBCStore store ) { } public Joinable assertJoinable ( Column col ) { } public Joinable getJoinable ( Column col ) { } public void setJoinable ( Column col , Joinable joinable ) { } public Boolean isForeignKeyObjectId ( ForeignKey fk ) { } public ClassMappingInfo getMappingInfo ( ) { } public ClassStrategy getStrategy ( ) { } public void setStrategy ( ClassStrategy strategy , Boolean adapt ) { } public Table getTable ( ) { } public void setTable ( Table table ) { } public Column [ ] getPrimaryKeyColumns ( ) { } public void setPrimaryKeyColumns ( Column [ ] cols ) { } public ColumnIO getColumnIO ( ) { } public void setColumnIO ( ColumnIO io ) { } public ForeignKey getJoinForeignKey ( ) { } public void setJoinForeignKey ( ForeignKey fk ) { } public void refSchemaComponents ( ) { } public void clearMapping ( ) { } public void syncMappingInfo ( ) { } protected void setDescribedType ( Class type ) { } public int getSubclassFetchMode ( ) { } public void setSubclassFetchMode ( int mode ) { } public MappingRepository getMappingRepository ( ) { } public ValueMapping getEmbeddingMapping ( ) { } public boolean isMapped ( ) { } public ClassMapping getPCSuperclassMapping ( ) { } public ClassMapping getMappedPCSuperclassMapping ( ) { } public ClassMapping getJoinablePCSuperclassMapping ( ) { } public ClassMapping [ ] getPCSubclassMappings ( ) { } public ClassMapping [ ] getMappedPCSubclassMappings ( ) { } public ClassMapping [ ] getJoinablePCSubclassMappings ( ) { } private boolean isSubJoinable ( ClassMapping sub ) { } public ClassMapping [ ] getIndependentAssignableMappings ( ) { } public FieldMapping [ ] getFieldMappings ( ) { } public FieldMapping [ ] getDeclaredFieldMappings ( ) { } public FieldMapping [ ] getPrimaryKeyFieldMappings ( ) { } public FieldMapping getVersionFieldMapping ( ) { } public FieldMapping [ ] getDefaultFetchGroupFieldMappings ( ) { } public FieldMapping [ ] getDefinedFieldMappings ( ) { } public FieldMapping [ ] getFieldMappingsInListingOrder ( ) { } public FieldMapping [ ] getDefinedFieldMappingsInListingOrder ( ) { } public FieldMapping getFieldMapping ( int index ) { } public FieldMapping getDeclaredFieldMapping ( int index ) { } public FieldMapping getFieldMapping ( String name ) { } public FieldMapping getDeclaredFieldMapping ( String name ) { } public FieldMapping [ ] getDeclaredUnmanagedFieldMappings ( ) { } public FieldMapping addDeclaredFieldMapping ( String name , Class type ) { } protected void resolveMapping ( boolean runtime ) { } void resolveNonRelationMappings ( ) { } protected void initializeMapping ( ) { } protected void clearDefinedFieldCache ( ) { } protected void clearSubclassCache ( ) { } public void copy ( ClassMetaData cls ) { } protected boolean validateDataStoreExtensionPrefix ( String prefix ) { } public String getAlias ( ) { }
public abstract class DefaultRmicAdapter implements RmicAdapter { private Rmic attributes ; private FileNameMapper mapper ; public DefaultRmicAdapter ( ) { } public void setRmic ( Rmic attributes ) { } public Rmic getRmic ( ) { } public String getStubClassSuffix ( ) { } public String getSkelClassSuffix ( ) { } public FileNameMapper getMapper ( ) { } public Path getClasspath ( ) { } protected Path getCompileClasspath ( ) { } protected Commandline setupRmicCommand ( ) { } protected void logAndAddFilesToCompile ( Commandline cmd ) { Vector compileList = attributes . getCompileList ( ) ; attributes . log ( ( "Compilation<seq2seq4repair_space>args:<seq2seq4repair_space>" + ( cmd . toString ( ) ) ) , MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( ( compileList . size ( ) ) != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( "<seq2seq4repair_space>to<seq2seq4repair_space>be<seq2seq4repair_space>compiled:" ) ; for ( int i = 0 ; i < ( compileList . size ( ) ) ; i ++ ) { <START_BUG> String arg = ( ( String ) ( compileList . get ( i ) ) ) ; <END_BUG> cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( ( "<seq2seq4repair_space>" + arg ) ) ; } attributes . log ( niceSourceList . toString ( ) , MSG_VERBOSE ) ; } protected void addExtdirsToClasspath ( Path classpath ) { } private class RmicFileNameMapper implements FileNameMapper { private GlobPatternMapper stubMapper ; private GlobPatternMapper skelMapper ; RmicFileNameMapper ( ) { } public void setFrom ( String s ) { } public void setTo ( String s ) { } public String [ ] mapFileName ( String name ) { } } }
public class WolfPayEntityListener extends EntityListener { public static WolfPay plugin ; @ Override public void onEntityTame ( EntityTameEvent event ) { if ( ( ( ! ( event . isCancelled ( ) ) ) && ( ( event . getEntity ( ) ) instanceof Wolf ) ) && ( ( event . getOwner ( ) ) instanceof Player ) ) { Wolf wolf = ( ( Wolf ) ( event . getEntity ( ) ) ) ; Player tamer = ( ( Player ) ( event . getOwner ( ) ) ) ; if ( Util . permission ( tamer , "wolfpay.tame" ) ) { List < Wolf > wolves = Util . getWolves ( tamer ) ; wolves . add ( wolf ) ; int allowedwolves = WolfPay . freewolves ; if ( WolfPay . savebought ) { Account account = WolfPayEntityListener . plugin . getDatabase ( ) . find ( Account . class ) . where ( ) . ieq ( "playerName" , tamer . getName ( ) ) . findUnique ( ) ; if ( account != null ) { allowedwolves += account . getBoughtwolves ( ) ; } } <START_BUG> if ( ( wolves . size ( ) ) <= ( ( WolfPay . freewolves ) + allowedwolves ) ) { <END_BUG> tamer . sendMessage ( ( ( GREEN . toString ( ) ) + ( WolfPay . getMessage ( "havenow" ) . replaceAll ( "x" , String . valueOf ( wolves . size ( ) ) ) . replaceAll ( "y" , String . valueOf ( allowedwolves ) ) ) ) ) ; if ( ( wolves . size ( ) ) == allowedwolves ) tamer . sendMessage ( ( ( YELLOW . toString ( ) ) + ( WolfPay . getMessage ( "nextpay" ) ) ) ) ; wolf . setOwner ( tamer ) ; } else { Holdings balance = iConomy . getAccount ( tamer . getName ( ) ) . getHoldings ( ) ; if ( balance . hasEnough ( price ) ) { balance . subtract ( price ) ; tamer . sendMessage ( ( ( ChatColor . GREEN ) + ( WolfPay . getMessage ( "successpay" ) . replaceAll ( "money" , iConomy . format ( price ) ) ) ) ) ; wolf . setOwner ( tamer ) ; if ( WolfPay . savebought ) { Account account = WolfPayEntityListener . plugin . getDatabase ( ) . find ( Account . class ) . where ( ) . ieq ( "playerName" , tamer . getName ( ) ) . findUnique ( ) ; if ( account == null ) { account = new Account ( ) ; account . setBoughtwolves ( 1 ) ; account . setPlayerName ( tamer . getName ( ) ) ; } else { account . setBoughtwolves ( ( ( account . getBoughtwolves ( ) ) + 1 ) ) ; } WolfPayEntityListener . plugin . getDatabase ( ) . save ( account ) ; } } else { tamer . sendMessage ( ( ( RED . toString ( ) ) + ( WolfPay . getMessage ( "notenoughmoney" ) ) ) ) ; event . setCancelled ( true ) ; } } } else { tamer . sendMessage ( ( ( RED . toString ( ) ) + ( WolfPay . getMessage ( "nopermission" ) ) ) ) ; event . setCancelled ( true ) ; } } } }
public class PageResource extends WizardPage implements Listener { public static final String PAGE_NAME = "DecryptPageResource" ; private Button bOpen = null ; private Button bEchoKeyPassword = null ; private Button bEchoKeystorePassword = null ; private Combo cEncryptionId = null ; private Text tKeystore = null ; private Text tKeystorePassword = null ; private Text tKeyName = null ; private Text tKeyPassword = null ; private IFile file ; private Decryption decryption = null ; private static final int LABELWIDTH = 120 ; public PageResource ( final Decryption decryption , final IFile file ) { } public void createControl ( final Composite parent ) { } private void createPageContent ( final Composite parent ) { } private void determineIds ( ) { String [ ] ids = null ; try { <START_BUG> ids = Utils . getIds ( file , "encryption" ) ; <END_BUG> } catch ( Exception ex ) { ids = new String [ ] { } ; } cEncryptionId . setItems ( ids ) ; cEncryptionId . select ( 0 ) ; } private void addListeners ( ) { } private void updateStatus ( final String message , final int status ) { } private void dialogChanged ( ) { } public void handleEvent ( final Event e ) { } private void echoPassword ( final Event e ) { } private void openKeystore ( ) { } public boolean isPageComplete ( ) { } private void saveDataToModel ( ) { } private void loadSettings ( ) { } private void storeSettings ( ) { } }
public class Server { static Log LOG = LogFactory . getLog ( Server . class ) ; public static final String APPLICATION_PATH = "http://spotlight.dbpedia.org/rest" ; protected static SpotlightConfiguration configuration ; protected static Map < SpotterPolicy , Spotter > spotters = new HashMap < org . dbpedia . spotlight . model . SpotterConfiguration . SpotterPolicy , Spotter > ( ) ; protected static Map < DisambiguationPolicy , ParagraphDisambiguatorJ > disambiguators = new HashMap < SpotlightConfiguration . DisambiguationPolicy , ParagraphDisambiguatorJ > ( ) ; private static volatile Boolean running = true ; static String usage = "usage:<seq2seq4repair_space>java<seq2seq4repair_space>-jar<seq2seq4repair_space>dbpedia-spotlight.jar<seq2seq4repair_space>org.dbpedia.spotlight.web.rest.Server<seq2seq4repair_space>[config<seq2seq4repair_space>file]" + "<seq2seq4repair_space>or:<seq2seq4repair_space>mvn<seq2seq4repair_space>scala:run<seq2seq4repair_space>\"-DaddArgs=[config<seq2seq4repair_space>file]\"" ; private static TextTokenizer tokenizer ; private static String namespacePrefix = SpotlightConfiguration . DEFAULT_NAMESPACE ; private static SparqlQueryExecuter sparqlExecuter = null ; private static List < Double > similarityThresholds = new ArrayList < Double > ( ) ; public static void main ( String [ ] args ) throws IOException , ClassNotFoundException , InterruptedException , URISyntaxException , InitializationException { } private static void setSpotters ( Map < SpotterPolicy , Spotter > s ) throws InitializationException { } private static void setDisambiguators ( Map < SpotlightConfiguration . DisambiguationPolicy , ParagraphDisambiguatorJ > s ) throws InitializationException { } public static Spotter getSpotter ( String name ) throws InputException { } public static ParagraphDisambiguatorJ getDisambiguator ( String name ) throws InputException { } public static SpotlightConfiguration getConfiguration ( ) { } public static TextTokenizer getTokenizer ( ) { } public static void setTokenizer ( TextTokenizer tokenizer ) { } public static String getPrefixedDBpediaURL ( DBpediaResource resource ) { } public static void setNamespacePrefix ( String namespacePrefix ) { } private static void setSparqlExecuter ( String endpoint , String graph ) { if ( ( endpoint == null ) || ( endpoint . equals ( "" ) ) ) endpoint = "http://dbpedia.org/sparql" ; if ( ( graph == null ) || ( graph . equals ( "" ) ) ) <START_BUG> endpoint = "http://dbpedia.org" ; <END_BUG> Server . sparqlExecuter = new SparqlQueryExecuter ( graph , endpoint ) ; } public static SparqlQueryExecuter getSparqlExecute ( ) { } private static void setSimilarityThresholds ( List < Double > similarityThresholds ) { } public static List < Double > getSimilarityThresholds ( ) { } public static void initSpotlightConfiguration ( String configFileName ) throws InitializationException { } private static void initByPropertiesFile ( String configFileName ) throws InitializationException { } private static void initByModel ( String folder ) throws InitializationException { } }
public class AboutActivity extends ActionBarActivity { private WebView aboutWebView ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { } @ Override public boolean onNavigateUp ( ) { if ( aboutWebView . canGoBack ( ) ) { <START_BUG> onBackPressed ( ) ; <END_BUG> return false ; } return super . onNavigateUp ( ) ; } @ Override public boolean onSupportNavigateUp ( ) { } @ Override public void onSaveInstanceState ( Bundle outState ) { } @ Override public void onBackPressed ( ) { } }
public class InverseIndex { public static class IndexMapper extends Mapper < LongWritable , Text , Text , Text > { private Text k = new Text ( ) ; private Text v = new Text ( ) ; @ Override protected void map ( LongWritable key , Text value , Context context ) throws IOException , InterruptedException { } } public static class IndexCombiner extends Reducer < Text , Text , Text , Text > { private Text k = new Text ( ) ; private Text v = new Text ( ) ; @ Override protected void reduce ( Text key , Iterable < Text > values , Context context ) throws IOException , InterruptedException { String [ ] wordsAndPath = key . toString ( ) . split ( "->" ) ; String word = wordsAndPath [ 0 ] ; String path = wordsAndPath [ 1 ] ; int counter = 0 ; for ( Text t : values ) { counter += Integer . parseInt ( t . toString ( ) ) ; } k . set ( word ) ; v . set ( ( ( path + "->" ) + counter ) ) ; <START_BUG> context . write ( v , v ) ; <END_BUG> } } public static class IndexReducer extends Reducer < Text , Text , Text , Text > { private Text v = new Text ( ) ; @ Override protected void reduce ( Text key , Iterable < Text > values , Context context ) throws IOException , InterruptedException { StringBuilder result = new StringBuilder ( ) ; for ( Text t : values ) { result = result . append ( ( ( t . toString ( ) ) + "\t" ) ) ; } v . set ( result . toString ( ) ) ; context . write ( key , v ) ; } } public static void main ( String [ ] args ) throws Exception { } }
public class ControlPanel implements Listener { private static YamlConfiguration miniShopFile ; private static HashMap < Integer , MiniShopItem > store = new HashMap < Integer , MiniShopItem > ( ) ; private static YamlConfiguration cpFile ; private ASkyBlock plugin ; private static boolean allowSelling ; private static String defaultPanelName ; public ControlPanel ( ASkyBlock plugin ) { } private static HashMap < String , HashMap < Integer , CPItem > > panels = new HashMap < String , HashMap < Integer , CPItem > > ( ) ; public static HashMap < String , Inventory > controlPanel = new HashMap < String , Inventory > ( ) ; public static Inventory miniShop ; public static void loadShop ( ) { } public static void loadControlPanel ( ) { } <START_BUG> @ EventHandler ( priority = EventPriority . LOWEST ) <END_BUG> public void onInventoryClick ( InventoryClickEvent event ) { Player player = ( ( Player ) ( event . getWhoClicked ( ) ) ) ; ItemStack clicked = event . getCurrentItem ( ) ; Inventory inventory = event . getInventory ( ) ; int slot = event . getRawSlot ( ) ; if ( inventory . getName ( ) . equalsIgnoreCase ( plugin . myLocale ( ) . igsTitle ) ) { if ( ( event . getSlotType ( ) ) == ( SlotType . OUTSIDE ) ) { player . closeInventory ( ) ; return ; } event . setCancelled ( true ) ; return ; } if ( inventory . getName ( ) . equals ( plugin . myLocale ( player . getUniqueId ( ) ) . challengesguiTitle ) ) { event . setCancelled ( true ) ; if ( ( event . getSlotType ( ) ) == ( SlotType . OUTSIDE ) ) { player . closeInventory ( ) ; return ; } List < CPItem > challenges = plugin . getChallenges ( ) . getCP ( player ) ; if ( challenges == null ) { plugin . getLogger ( ) . warning ( "Player<seq2seq4repair_space>was<seq2seq4repair_space>accessing<seq2seq4repair_space>Challenge<seq2seq4repair_space>Inventory,<seq2seq4repair_space>but<seq2seq4repair_space>it<seq2seq4repair_space>had<seq2seq4repair_space>lost<seq2seq4repair_space>state<seq2seq4repair_space>-<seq2seq4repair_space>was<seq2seq4repair_space>server<seq2seq4repair_space>restarted?" ) ; player . closeInventory ( ) ; player . performCommand ( CHALLENGECOMMAND ) ; return ; } if ( ( slot >= 0 ) && ( slot < ( challenges . size ( ) ) ) ) { CPItem item = challenges . get ( slot ) ; if ( clicked . equals ( item . getItem ( ) ) ) { if ( ( item . getNextSection ( ) ) != null ) { player . closeInventory ( ) ; player . openInventory ( plugin . getChallenges ( ) . challengePanel ( player , item . getNextSection ( ) ) ) ; } else if ( ( item . getCommand ( ) ) != null ) { player . performCommand ( item . getCommand ( ) ) ; player . closeInventory ( ) ; player . openInventory ( plugin . getChallenges ( ) . challengePanel ( player ) ) ; } } } } if ( ( ( ControlPanel . miniShop ) != null ) && ( inventory . getName ( ) . equals ( ControlPanel . miniShop . getName ( ) ) ) ) { String message = "" ; event . setCancelled ( true ) ; if ( ( ! ( Settings . useEconomy ) ) || ( slot == ( - 999 ) ) ) { player . closeInventory ( ) ; return ; } if ( ControlPanel . store . containsKey ( slot ) ) { MiniShopItem item = ControlPanel . store . get ( slot ) ; if ( clicked . equals ( item . getItem ( ) ) ) { if ( event . getClick ( ) . equals ( LEFT ) ) { if ( ( item . getPrice ( ) ) > 0.0 ) { if ( ! ( econ . has ( player , worldName , item . getPrice ( ) ) ) ) { message = plugin . myLocale ( ) . minishopYouCannotAfford . replace ( "[description]" , item . getDescription ( ) ) ; } else { EconomyResponse r = econ . withdrawPlayer ( player , worldName , item . getPrice ( ) ) ; if ( r . transactionSuccess ( ) ) { message = plugin . myLocale ( ) . minishopYouBought . replace ( "[number]" , Integer . toString ( item . getQuantity ( ) ) ) ; message = message . replace ( "[description]" , item . getDescription ( ) ) ; message = message . replace ( "[price]" , econ . format ( item . getPrice ( ) ) ) ; player . getInventory ( ) . addItem ( item . getItemClean ( ) ) ; } else { message = plugin . myLocale ( ) . minishopBuyProblem . replace ( "[description]" , item . getDescription ( ) ) ; } } } } else if ( ( ( event . getClick ( ) . equals ( RIGHT ) ) && ( ControlPanel . allowSelling ) ) && ( ( item . getSellPrice ( ) ) > 0.0 ) ) { if ( player . getInventory ( ) . containsAtLeast ( item . getItemClean ( ) , item . getQuantity ( ) ) ) { player . getInventory ( ) . removeItem ( item . getItemClean ( ) ) ; econ . depositPlayer ( player , worldName , item . getSellPrice ( ) ) ; message = plugin . myLocale ( ) . minishopYouSold . replace ( "[number]" , Integer . toString ( item . getQuantity ( ) ) ) ; message = message . replace ( "[description]" , item . getDescription ( ) ) ; message = message . replace ( "[price]" , econ . format ( item . getSellPrice ( ) ) ) ; } else { message = plugin . myLocale ( ) . minishopSellProblem . replace ( "[description]" , item . getDescription ( ) ) ; } }
public class HtmlTest { @ Test public void testRegexSelector ( ) { } @ Test public void testDisableJsoupHtmlEntityEscape ( ) throws Exception { } @ Test public void testEnableJsoupHtmlEntityEscape ( ) throws Exception { } @ Test public void testAHrefExtract ( ) { } <START_BUG> @ Test ( expected = NullPointerException ) <END_BUG> public void testNthNodesGet ( ) { Html html = new Html ( "<a<seq2seq4repair_space>data-tip=\"p$t$xxx\"<seq2seq4repair_space>href=\"/xx/xx\">xx</a>" ) ; assertThat ( html . xpath ( "//a[1]/@href" ) . get ( ) ) . isEqualTo ( "/xx/xx" ) ; Selectable selectable = html . xpath ( "//a[1]" ) . nodes ( ) . get ( 0 ) ; assertThat ( selectable . xpath ( "@href" ) . get ( ) ) . isEqualTo ( "/xx/xx" ) ; } }
public class ExampleRunner implements Runnable { private static final PrintStream stdout = System . out ; private static int addCount ; private static final Map < String , ExampleRunner . MainMenu > mainMenuByCmd = new HashMap < String , ExampleRunner . MainMenu > ( ) ; private static final Map < String , ExampleRunner . DeploymentActionsMenu > deploymentActionMenuByCmd = new HashMap < String , ExampleRunner . DeploymentActionsMenu > ( ) ; private static final Map < String , ExampleRunner . DeploymentPlanMenu > deploymentPlanMenuByCmd = new HashMap < String , ExampleRunner . DeploymentPlanMenu > ( ) ; private final DomainClient client ; private final Reader stdin ; private String swingLAF ; private ExampleRunner ( InetAddress address , int port ) { } @ Override public void run ( ) { } private boolean mainMenu ( ) throws Exception { } private void writeMenu ( EnumSet < ? extends ExampleRunner . MenuItem > menu ) { } private Map < String , Object > writeMenuBody ( List < ? > choices ) { } private boolean continuePrompt ( ) throws IOException { } private boolean dumpDomainConfig ( ) throws Exception { } private boolean listHostControllers ( ) throws Exception { } private boolean dumpHostController ( ) throws Exception { } private void writeHostController ( String hc ) throws Exception { } private boolean listServers ( ) throws Exception { } private boolean dumpServer ( ) throws Exception { } private boolean stopServer ( ) throws Exception { } private boolean startServer ( ) throws Exception { } private boolean restartServer ( ) throws Exception { } private boolean addServer ( ) throws Exception { } private List < String > getServerGroupNames ( ) { } private ModelNode getDomainModel ( ) { } private boolean removeServer ( ) throws Exception { ServerIdentity server = chooseServer ( STOPPED , DISABLED ) ; if ( server != null ) { ExampleRunner . stdout . println ( ( "Removing<seq2seq4repair_space>server<seq2seq4repair_space>" + ( server . getServerName ( ) ) ) ) ; ModelNode op = new ModelNode ( ) ; op . get ( "operation" ) . set ( "remove" ) ; ModelNode address = op . get ( "address" ) ; address . add ( "host" , server . getHostName ( ) ) ; <START_BUG> address . add ( "server-config" , server . getServerGroupName ( ) ) ; <END_BUG> boolean success = true ; try { executeForResult ( Factory . create ( op ) . build ( ) ) ; } catch ( Exception e ) { success = false ; } ExampleRunner . stdout . println ( ( "Remove<seq2seq4repair_space>success:<seq2seq4repair_space>" + success ) ) ; } return continuePrompt ( ) ; } private ServerIdentity chooseServer ( ServerStatus valid , ServerStatus ... alsoValid ) throws IOException { } private SortedMap < String , ServerIdentity > getValidServers ( ServerStatus valid , ServerStatus ... alsoValid ) { } private boolean runDeploymentPlan ( ) throws Exception { } private String chooseServerGroup ( ModelNode model , Set < String > existingGroups ) throws IOException { } private DeploymentActionsCompleteBuilder deploymentSetBuilder ( DeploymentPlanBuilder builder , ModelNode model ) throws Exception { } private DeploymentPlanBuilder addContent ( DeploymentPlanBuilder builder , Set < String > addedContent , Set < String > deployedContent , Set < String > undeployedContent , Set < String > removedContent , ModelNode model , ExampleRunner . DeploymentActionsMenu cmd ) throws Exception { } private DeploymentPlanBuilder deployContent ( DeploymentPlanBuilder builder , Set < String > addedContent , Set < String > deployedContent , Set < String > undeployedContent , Set < String > removedContent , ModelNode domainModel ) throws IOException { } private String chooseUndeployedContent ( String message , Set < String > addedContent , Set < String > deployedContent , Set < String > undeployedContent , Set < String > removedContent , ModelNode domainModel ) throws IOException { } private String chooseDeployment ( TreeSet < String > deployments , String message ) throws IOException { } private DeploymentPlanBuilder replaceContent ( DeploymentPlanBuilder builder , Set < String > addedContent , Set < String > deployedContent , Set < String > undeployedContent , Set < String > removedContent , ModelNode domainModel ) throws IOException { } private String chooseDeployedContent ( String message , Set < String > deployedContent , Set < String > undeployedContent , ModelNode domainModel ) throws IOException { } private DeploymentPlanBuilder undeployContent ( DeploymentPlanBuilder builder , Set < String > addedContent , Set < String > deployedContent , Set < String > undeployedContent , Set < String > removedContent , ModelNode domainModel , ExampleRunner . DeploymentActionsMenu cmd ) throws IOException { } private DeploymentPlanBuilder removeContent ( DeploymentPlanBuilder builder , Set < String > addedContent , Set < String > deployedContent , Set < String > undeployedContent , Set < String > removedContent , ModelNode domainModel ) throws IOException { } private boolean deploymentPlanCancelPrompt ( ) throws IOException { } private DeploymentPlan completeDeploymentPlan ( ServerGroupDeploymentPlanBuilder groupPlanBuilder , ModelNode model , Set < String > includedGroups ) throws IOException { } private void writeDeploymentPlanResult ( DeploymentPlanResult deploymentPlanResult ) { } private File chooseFile ( ) throws IOException { } private synchronized void initializeSwing ( ) { } private boolean addJmsQueue ( ) throws Exception { } private void exerciseQueueOnServer ( final String queueName , final ServerIdentity server ) throws Exception { } private String readStdIn ( ) throws IOException { } private < T > T lookup ( ServerIdentity server , String name , Class < T > expected ) throws Exception { } private MBeanServerConnection getMBeanServerConnection ( ServerIdentity server ) throws Exception { } private static interface MenuItem { String getPrompt ( ) { } }
public abstract class Driver20 extends InternalDriver implements Driver { private static final String [ ] BOOLEAN_CHOICES = new String [ ] { "false" , "true" } ; private Class antiGCDriverManager ; public void boot ( boolean create , Properties properties ) throws StandardException { } public void stop ( ) { } public EmbedResultSet newEmbedResultSet ( EmbedConnection conn , ResultSet results , boolean forMetaData , EmbedStatement statement , boolean isAtomic ) throws SQLException { } public abstract BrokeredConnection newBrokeredConnection ( BrokeredConnectionControl control ) { } public DriverPropertyInfo [ ] getPropertyInfo ( String url , Properties info ) throws SQLException { if ( info != null ) { if ( Boolean . valueOf ( info . getProperty ( SHUTDOWN_ATTR ) ) . booleanValue ( ) ) { return new DriverPropertyInfo [ 0 ] ; } } String dbname = InternalDriver . getDatabaseName ( url , info ) ; FormatableProperties finfo = getAttributes ( url , info ) ; info = null ; boolean encryptDB = Boolean . valueOf ( finfo . getProperty ( DATA_ENCRYPTION ) ) . booleanValue ( ) ; String encryptpassword = finfo . getProperty ( BOOT_PASSWORD ) ; <START_BUG> if ( ( ( dbname . length ( ) ) == 0 ) || ( encryptDB = true && ( encryptpassword == null ) ) ) { <END_BUG> String [ ] [ ] connStringAttributes = new String [ ] [ ] { new String [ ] { Attribute . DBNAME_ATTR , MessageId . CONN_DATABASE_IDENTITY } , new String [ ] { Attribute . CRYPTO_PROVIDER , MessageId . CONN_CRYPTO_PROVIDER } , new String [ ] { Attribute . CRYPTO_ALGORITHM , MessageId . CONN_CRYPTO_ALGORITHM } , new String [ ] { Attribute . CRYPTO_KEY_LENGTH , MessageId . CONN_CRYPTO_KEY_LENGTH } , new String [ ] { Attribute . CRYPTO_EXTERNAL_KEY , MessageId . CONN_CRYPTO_EXTERNAL_KEY } , new String [ ] { Attribute . TERRITORY , MessageId . CONN_LOCALE } , new String [ ] { Attribute . COLLATION , MessageId . CONN_COLLATION } , new String [ ] { Attribute . USERNAME_ATTR , MessageId . CONN_USERNAME_ATTR } , new String [ ] { Attribute . LOG_DEVICE , MessageId . CONN_LOG_DEVICE } , new String [ ] { Attribute . ROLL_FORWARD_RECOVERY_FROM , MessageId . CONN_ROLL_FORWARD_RECOVERY_FROM } , new String [ ] { Attribute . CREATE_FROM , MessageId . CONN_CREATE_FROM } , new String [ ] { Attribute . RESTORE_FROM , MessageId . CONN_RESTORE_FROM } } ; String [ ] [ ] connBooleanAttributes = new String [ ] [ ] { new String [ ] { Attribute . SHUTDOWN_ATTR , MessageId . CONN_SHUT_DOWN_CLOUDSCAPE } , new String [ ] { Attribute . DEREGISTER_ATTR , MessageId . CONN_DEREGISTER_AUTOLOADEDDRIVER } , new String [ ] { Attribute . CREATE_ATTR , MessageId . CONN_CREATE_DATABASE } , new String [ ] { Attribute . DATA_ENCRYPTION , MessageId . CONN_DATA_ENCRYPTION } , new String [ ] { Attribute . UPGRADE_ATTR , MessageId . CONN_UPGRADE_DATABASE } } ; String [ ] [ ] connStringSecretAttributes = new String [ ] [ ] { new String [ ] { Attribute . BOOT_PASSWORD , MessageId . CONN_BOOT_PASSWORD } , new String [ ] { Attribute . PASSWORD_ATTR , MessageId . CONN_PASSWORD_ATTR } } ; DriverPropertyInfo [ ] optionsNoDB = new DriverPropertyInfo [ ( ( connStringAttributes . length ) + ( connBooleanAttributes . length ) ) + ( connStringSecretAttributes . length ) ] ; int attrIndex = 0 ; for ( int i = 0 ; i < ( connStringAttributes . length ) ; i ++ , attrIndex ++ ) { optionsNoDB [ attrIndex ] = new DriverPropertyInfo ( connStringAttributes [ i ] [ 0 ] , finfo . getProperty ( connStringAttributes [ i ] [ 0 ] ) ) ; optionsNoDB [ attrIndex ] . description = MessageService . getTextMessage ( connStringAttributes [ i ] [ 1 ] ) ; } optionsNoDB [ 0 ] . choices = Monitor . getMonitor ( ) . getServiceList ( DATABASE_MODULE ) ; optionsNoDB [ 0 ] . value = dbname ; for ( int i = 0 ; i < ( connStringSecretAttributes . length ) ; i ++ , attrIndex ++ ) { optionsNoDB [ attrIndex ] = new DriverPropertyInfo ( connStringSecretAttributes [ i ] [ 0 ] , ( ( finfo . getProperty ( connStringSecretAttributes [ i ] [ 0 ] ) ) == null ? "" : "****" ) ) ; optionsNoDB [ attrIndex ] . description = MessageService . getTextMessage ( connStringSecretAttributes [ i ] [ 1 ] ) ; } for ( int i = 0 ; i < ( connBooleanAttributes . length ) ; i ++ , attrIndex ++ ) { optionsNoDB [ attrIndex ] = new DriverPropertyInfo ( connBooleanAttributes [ i ] [ 0 ] , Boolean . valueOf ( ( finfo == null ? "" : finfo . getProperty ( connBooleanAttributes [ i ] [ 0 ] ) ) ) . toString ( ) ) ; optionsNoDB [ attrIndex ] . description = MessageService . getTextMessage ( connBooleanAttributes [ i ] [ 1 ] ) ; optionsNoDB [ attrIndex ] . choices = Driver20 . BOOLEAN_CHOICES ; } return optionsNoDB ; } return new DriverPropertyInfo [ 0 ] ; } public void checkSystemPrivileges ( String user , Permission perm ) throws Exception { } }
public abstract class AbstractUnenhancedClassTest extends SingleEMFTestCase { public void setUp ( ) { } protected abstract Class < ? extends UnenhancedType > getUnenhancedClass ( ) { } protected abstract UnenhancedType newUnenhancedInstance ( ) { } protected abstract Class < ? extends UnenhancedSubtype > getUnenhancedSubclass ( ) { } protected abstract UnenhancedSubtype newUnenhancedSubclassInstance ( ) { } private UnenhancedType newInstance ( boolean sub ) { } public void testMetaData ( ) { } public void testImplHelperCalls ( ) { <START_BUG> assertTrue ( ImplHelper . isManagedType ( getUnenhancedClass ( ) ) ) ; <END_BUG> UnenhancedType un = newUnenhancedInstance ( ) ; assertFalse ( ( un instanceof PersistenceCapable ) ) ; PersistenceCapable pc = ImplHelper . toPersistenceCapable ( un , emf . getConfiguration ( ) ) ; assertNotNull ( pc ) ; assertTrue ( ImplHelper . isManageable ( un ) ) ; } public void testBasicPersistenceCapableBehavior ( ) { } public void testPCRegistry ( ) { } public void testClearingOnSubtypeInstance ( ) { } public void testGetObjectIdOnOpenJPAType ( ) { } public void testGetObjectIdOnOpenJPATypeSubclass ( ) { } public void testGetObjectIdOnUserDefined ( ) { } public void testGetObjectIdOnUserDefinedSubclass ( ) { } private void getObjectIdHelper ( boolean sub , boolean userDefined ) { } public void testOperationsOnUserDefined ( ) { } public void testSubclassOperationsOnUserDefined ( ) { } public void testOperationsOnOpenJPADefined ( ) { } public void testSubclassOperationsOnOpenJPADefined ( ) { } private void opsHelper ( boolean sub , boolean userDefined ) { } private void assertPersistenceContext ( OpenJPAEntityManager em , UnenhancedType un , boolean transactional , boolean dirty , boolean sub ) { } public void testRelations ( ) { } public void testEnhancer ( ) throws IOException { } public void testPCSubclassName ( ) { } public void testEvictionInUserCreatedInstance ( ) throws IllegalAccessException , NoSuchFieldException { } public void testEvictionInOpenJPACreatedInstance ( ) throws IllegalAccessException , NoSuchFieldException { } private void evictionHelper ( boolean userDefined ) throws IllegalAccessException , NoSuchFieldException { } protected abstract boolean isFieldAccessTest ( ) { } public void testLazyLoading ( ) throws IllegalAccessException , NoSuchFieldException { } public void testSerializationOfUserDefinedInstance ( ) throws IOException , ClassNotFoundException { } public void testSerializationOfUserDefinedSubclassInstance ( ) throws IOException , ClassNotFoundException { } public void testSerializationOfOpenJPADefinedInstance ( ) throws IOException , ClassNotFoundException { } public void testSerializationOfOpenJPADefinedSubclassInstance ( ) throws IOException , ClassNotFoundException { } private void serializationHelper ( boolean userDefined , boolean sub ) throws IOException , ClassNotFoundException { } public void testCloningOfUserDefinedInstance ( ) throws IOException , ClassNotFoundException , CloneNotSupportedException { } public void testCloningOfUserDefinedSubclassInstance ( ) throws IOException , ClassNotFoundException , CloneNotSupportedException { } public void testCloningOfOpenJPADefinedInstance ( ) throws IOException , ClassNotFoundException , CloneNotSupportedException { } public void testCloningOfOpenJPADefinedSubclassInstance ( ) throws IOException , ClassNotFoundException , CloneNotSupportedException { } private void cloneHelper ( boolean userDefined , boolean sub ) throws IOException , ClassNotFoundException , CloneNotSupportedException { } private void copiedInstanceHelper ( boolean sub , OpenJPAEntityManager em , UnenhancedType un , UnenhancedType copy , boolean viaClone ) { } public void testListenersOnUserDefinedInstance ( ) throws IOException , ClassNotFoundException , CloneNotSupportedException { } public void testListenersOnUserDefinedSubclassInstance ( ) throws IOException , ClassNotFoundException , CloneNotSupportedException { } public void testListenersOnOpenJPADefinedInstance ( ) throws IOException , ClassNotFoundException , CloneNotSupportedException { } public void testListenersOnOpenJPADefinedSubclassInstance ( ) throws IOException , ClassNotFoundException , CloneNotSupportedException { } private void listenerHelper ( boolean userDefined , boolean sub ) throws IOException , ClassNotFoundException , CloneNotSupportedException { } public void testGetMetaDataOfSubtype ( ) { } private class ListenerImpl extends AbstractLifecycleListener { String stringField ; boolean invoked ; @ Override public void afterStore ( LifecycleEvent event ) { } } }
public class CutTimeAddActivity extends ActionBarActivity implements AdapterView . OnItemSelectedListener { EditText cutName ; Spinner genderSpinner ; String chosenEvent ; String errorMsg ; int chosenPosition ; Dialog dial ; ListView lv ; ArrayList < HashMap < String , String > > cutList = new ArrayList < > ( ) ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { View curView = this . findViewById ( content ) . getRootView ( ) ; new RumbleAction ( curView ) ; <START_BUG> new MenuOptions ( ) . MenuOption ( curView , item , this , MainActivity . class ) ; <END_BUG> return super . onOptionsItemSelected ( item ) ; } @ Override public boolean onKeyDown ( int keyCode , KeyEvent event ) { } public void populatePage ( ) { } private void updateList ( ) { } private void showNumberDial ( ) { } private static String pad ( int c ) { } private class WeightFormatter implements NumberPicker . Formatter { @ Override public String format ( int value ) { } } public void saveCut ( View v ) { } public void addNewLine ( ) { } @ Override public void onItemSelected ( AdapterView < ? > parent , View view , int position , long id ) { } @ Override public void onNothingSelected ( AdapterView < ? > parent ) { } }
public class XFormsStateManagerTest extends ResourceManagerTestBase { private XFormsStateLifecycle stateManager = XFormsStateManager . instance ( ) ; @ Test public void testClientNoCache ( ) { } @ Test public void testClientDoCache ( ) { } @ Test public void testServerNoCache ( ) { } @ Test public void testServerDoCache ( ) { } @ Test public void testDocumentCacheSessionListener ( ) { } private static class State { public XFormsContainingDocument document ; public String uuid ; public String staticStateString ; public String dynamicStateString ; } private interface EventCallback { List < XFormsEvent > createEvents ( XFormsContainingDocument document ) { } } private void testClient ( boolean isCache , String formFile ) { } private void testServer ( boolean isCache , String formFile ) { } private XFormsStateManagerTest . State doUpdate ( boolean isCache , final XFormsStateManagerTest . State state1 , XFormsStateManagerTest . EventCallback callback ) { final XFormsStateLifecycle . RequestParameters parameters = new XFormsStateLifecycle . RequestParameters ( ) { public String getUUID ( ) { return state1 . uuid ; } public String getEncodedClientStaticState ( ) { return state1 . staticStateString ; } public String getEncodedClientDynamicState ( ) { return state1 . dynamicStateString ; } } ; final XFormsStateManagerTest . State state2 = new XFormsStateManagerTest . State ( ) ; <START_BUG> final Lock lock = stateManager . acquireDocumentLock ( parameters ) ; <END_BUG> if ( lock == null ) fail ( "Ajax<seq2seq4repair_space>update<seq2seq4repair_space>lock<seq2seq4repair_space>timeout<seq2seq4repair_space>exceeded" ) ; try { state2 . document = stateManager . beforeUpdate ( parameters ) ; if ( isCache ) assertSame ( state1 . document , state2 . document ) ; else assertNotSame ( state1 . document , state2 . document ) ; state2 . document . beforeExternalEvents ( null ) ; if ( callback != null ) { for ( final XFormsEvent event : callback . createEvents ( state2 . document ) ) { ClientEvents . processEvent ( state2 . document , event ) ; } } state2 . document . afterExternalEvents ( ) ; stateManager . beforeUpdateResponse ( state2 . document , false ) ; state2 . uuid = state2 . document . getUUID ( ) ; state2 . staticStateString = stateManager . getClientEncodedStaticState ( state2 . document ) ; state2 . dynamicStateString = stateManager . getClientEncodedDynamicState ( state2 . document ) ; stateManager . afterUpdateResponse ( state2 . document ) ; stateManager . afterUpdate ( state2 . document , true ) ; } finally { stateManager . releaseDocumentLock ( lock ) ; } return state2 ; } private XFormsStateManagerTest . State getInitialState ( final XFormsStateManagerTest . State state1 ) { } private String stripSequenceNumber ( String serializedState ) { } private long getSequenceNumber ( String serializedState ) { } }
abstract class AbstractTrie < K , V > extends AbstractMap < K , V > implements Serializable , Trie < K , V > { private static final long serialVersionUID = 5826987063535505652L ; protected final KeyAnalyzer < ? super K > keyAnalyzer ; public AbstractTrie ( final KeyAnalyzer < ? super K > keyAnalyzer ) { } public KeyAnalyzer < ? super K > getKeyAnalyzer ( ) { } public K selectKey ( final K key ) { } public V selectValue ( final K key ) { } @ Override public String toString ( ) { } @ SuppressWarnings ( "unchecked" ) final K castKey ( final Object key ) { } final int lengthInBits ( final K key ) { } final int bitsPerElement ( ) { } final boolean isBitSet ( final K key , final int bitIndex , final int lengthInBits ) { } final int bitIndex ( final K key , final K foundKey ) { } final boolean compareKeys ( final K key , final K other ) { if ( key == null ) { return other == null ; } else if ( other == null ) { <START_BUG> return key == null ; <END_BUG> } return ( keyAnalyzer . compare ( key , other ) ) == 0 ; } static boolean compare ( final Object a , final Object b ) { } abstract static class BasicEntry < K , V > implements Serializable , Map . Entry < K , V > { private static final long serialVersionUID = - 944364551314110330L ; protected K key ; protected V value ; private final int hashCode ; public BasicEntry ( final K key ) { } public BasicEntry ( final K key , final V value ) { } public V setKeyValue ( final K key , final V value ) { } public K getKey ( ) { } public V getValue ( ) { } public V setValue ( final V value ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( final Object o ) { } @ Override public String toString ( ) { } } }
public class CassandraServer implements Cassandra { private static Logger logger = LoggerFactory . getLogger ( CassandraServer . class ) ; private static final GenericArray < Column > EMPTY_SUBCOLUMNS = new GenericData . Array < Column > ( 0 , Schema . createArray ( Column . SCHEMA$ ) ) ; private static final GenericArray < ColumnOrSuperColumn > EMPTY_COLUMNS = new GenericData . Array < ColumnOrSuperColumn > ( 0 , Schema . createArray ( ColumnOrSuperColumn . SCHEMA$ ) ) ; private static final Utf8 API_VERSION = new Utf8 ( "0.0.0" ) ; private static final String D_CF_CFTYPE = "Standard" ; private static final String D_CF_CFCLOCKTYPE = "Timestamp" ; private static final String D_CF_COMPTYPE = "BytesType" ; private static final String D_CF_SUBCOMPTYPE = "" ; private static final String D_CF_RECONCILER = null ; public static final String D_COLDEF_INDEXTYPE = "KEYS" ; public static final String D_COLDEF_INDEXNAME = null ; public final ThreadLocal < ClientState > clientState = new ThreadLocal < ClientState > ( ) { @ Override public ClientState initialValue ( ) { } } ; private final IRequestScheduler requestScheduler ; public CassandraServer ( ) { } public Void login ( AuthenticationRequest auth_request ) throws AuthenticationException , AuthorizationException { } public ClientState state ( ) { } @ Override public ColumnOrSuperColumn get ( ByteBuffer key , ColumnPath columnPath , ConsistencyLevel consistencyLevel ) throws AvroRemoteException , InvalidRequestException , NotFoundException , TimedOutException , UnavailableException { } protected Map < DecoratedKey < ? > , ColumnFamily > readColumnFamily ( List < ReadCommand > commands , ConsistencyLevel consistency ) throws InvalidRequestException , TimedOutException , UnavailableException { } private List < Column > avronateSubColumns ( Collection < IColumn > columns ) { } private GenericArray < ColumnOrSuperColumn > avronateColumns ( Collection < IColumn > columns , boolean reverseOrder ) { } private GenericArray < ColumnOrSuperColumn > avronateSuperColumns ( Collection < IColumn > columns , boolean reverseOrder ) { } private GenericArray < ColumnOrSuperColumn > avronateColumnFamily ( ColumnFamily cf , boolean subColumnsOnly , boolean reverseOrder ) { } public List < ColumnOrSuperColumn > get_slice ( ByteBuffer key , ColumnParent columnParent , SlicePredicate predicate , ConsistencyLevel consistencyLevel ) throws AvroRemoteException , InvalidRequestException , TimedOutException , UnavailableException { } private List < CoscsMapEntry > multigetSliceInternal ( String keyspace , List < ByteBuffer > keys , ColumnParent columnParent , SlicePredicate predicate , ConsistencyLevel consistencyLevel ) throws InvalidRequestException , TimedOutException , UnavailableException { } private List < CoscsMapEntry > getSlice ( List < ReadCommand > commands , ConsistencyLevel consistencyLevel ) throws InvalidRequestException , TimedOutException , UnavailableException { } public int get_count ( ByteBuffer key , ColumnParent columnParent , SlicePredicate predicate , ConsistencyLevel consistencyLevel ) throws AvroRemoteException , InvalidRequestException , TimedOutException , UnavailableException { } public List < CoscsMapEntry > multiget_slice ( List < ByteBuffer > keys , ColumnParent columnParent , SlicePredicate predicate , ConsistencyLevel consistencyLevel ) throws AvroRemoteException , InvalidRequestException , TimedOutException , UnavailableException { } public Void insert ( ByteBuffer key , ColumnParent parent , Column column , ConsistencyLevel consistencyLevel ) throws AvroRemoteException , InvalidRequestException , TimedOutException , UnavailableException { } public Void remove ( ByteBuffer key , ColumnPath columnPath , long timestamp , ConsistencyLevel consistencyLevel ) throws AvroRemoteException , InvalidRequestException , TimedOutException , UnavailableException { } private void doInsert ( ConsistencyLevel consistency , RowMutation rm ) throws TimedOutException , UnavailableException { } public Void batch_mutate ( List < MutationsMapEntry > mutationMap , ConsistencyLevel consistencyLevel ) throws AvroRemoteException , InvalidRequestException , TimedOutException , UnavailableException { } private static RowMutation getRowMutationFromMutations ( String keyspace , ByteBuffer key , Map < CharSequence , List < Mutation > > cfMap ) { } private static void addColumnOrSuperColumnToRowMutation ( RowMutation rm , String cfName , ColumnOrSuperColumn cosc ) { } private static void deleteColumnOrSuperColumnToRowMutation ( RowMutation rm , String cfName , Deletion del ) { } private static void applyMigrationOnStage ( final Migration m ) throws InvalidRequestException { } private org . apache . cassandra . thrift . ConsistencyLevel thriftConsistencyLevel ( ConsistencyLevel consistency ) { } public Void set_keyspace ( CharSequence keyspace ) throws InvalidRequestException { } public CharSequence system_add_keyspace ( KsDef ksDef ) throws AvroRemoteException , InvalidRequestException { } public CharSequence system_add_column_family ( CfDef cfDef ) throws AvroRemoteException , InvalidRequestException { } public CharSequence system_update_column_family ( CfDef cf_def ) throws AvroRemoteException , InvalidRequestException { checkKeyspaceAndLoginAuthorized ( WRITE ) ; if ( ( ( cf_def . keyspace ) == null ) || ( ( cf_def . name ) == null ) ) throw newInvalidRequestException ( "Keyspace<seq2seq4repair_space>and<seq2seq4repair_space>CF<seq2seq4repair_space>name<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>set." ) ; CFMetaData oldCfm = DatabaseDescriptor . getCFMetaData ( CFMetaData . getId ( cf_def . keyspace . toString ( ) , cf_def . name . toString ( ) ) ) ; if ( oldCfm == null ) throw newInvalidRequestException ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>find<seq2seq4repair_space>column<seq2seq4repair_space>family<seq2seq4repair_space>definition<seq2seq4repair_space>to<seq2seq4repair_space>modify." ) ; try { <START_BUG> oldCfm . apply ( cf_def ) ; <END_BUG> UpdateColumnFamily update = new UpdateColumnFamily ( cf_def ) ; CassandraServer . applyMigrationOnStage ( update ) ; return DatabaseDescriptor . getDefsVersion ( ) . toString ( ) ; } catch ( ConfigurationException e ) { InvalidRequestException ex = newInvalidRequestException ( e . getMessage ( ) ) ; ex . initCause ( e ) ; throw ex ; } catch ( IOException e ) { InvalidRequestException ex = newInvalidRequestException ( e . getMessage ( ) ) ; ex . initCause ( e ) ; throw ex ; } } public CharSequence system_update_keyspace ( KsDef ks_def ) throws AvroRemoteException , InvalidRequestException { } public GenericArray < CharSequence > describe_keyspaces ( ) throws AvroRemoteException { } public Utf8 describe_cluster_name ( ) throws AvroRemoteException { } public Utf8 describe_version ( ) throws AvroRemoteException { } public Map < CharSequence , List < CharSequence > > check_schema_agreement ( ) { } protected void checkKeyspaceAndLoginAuthorized ( Permission perm ) throws InvalidRequestException { } private void schedule ( ) { } private void release ( ) { } private CFMetaData convertToCFMetaData ( CfDef cf_def ) throws InvalidRequestException , ConfigurationException { } public KsDef describe_keyspace ( CharSequence keyspace ) throws AvroRemoteException , NotFoundException { } public CharSequence system_drop_column_family ( CharSequence column_family ) throws AvroRemoteException , InvalidRequestException { }
public class GaussNewtonOptimizerTest extends AbstractLeastSquaresOptimizerAbstractTest { @ Override public int getMaxIterations ( ) { } @ Test public void testGaussNewtonLU ( ) throws Exception { } @ Test public void testGaussNewtonQR ( ) throws Exception { } @ Override public void check ( LeastSquaresOptimizer optimizer ) throws Exception { } @ Override public void testMoreEstimatedParametersSimple ( LeastSquaresOptimizer optimizer ) { } @ Override public void testMoreEstimatedParametersUnsorted ( LeastSquaresOptimizer optimizer ) { } public void testMaxEvaluations ( LeastSquaresOptimizer optimizer ) throws Exception { try { CircleVectorial circle = new CircleVectorial ( ) ; circle . addPoint ( 30.0 , 68.0 ) ; circle . addPoint ( 50.0 , ( - 6.0 ) ) ; circle . addPoint ( 110.0 , ( - 20.0 ) ) ; circle . addPoint ( 35.0 , 15.0 ) ; circle . addPoint ( 45.0 , 97.0 ) ; <START_BUG> LeastSquaresProblem lsp = builder ( circle ) . checker ( new SimpleVectorValueChecker ( 1.0E-30 , 1.0E-30 ) ) . maxIterations ( Integer . MAX_VALUE ) . start ( new double [ ] { 98.68 , 47.345 } ) . build ( ) ; <END_BUG> optimizer . optimize ( lsp ) ; fail ( optimizer ) ; } catch ( TooManyEvaluationsException e ) { } } @ Override public void testCircleFittingBadInit ( LeastSquaresOptimizer optimizer ) { } @ Override public void testHahn1 ( LeastSquaresOptimizer optimizer ) throws IOException { } }
public class Submitter { public static final int STOCK_LEVEL = 0 ; public static final int ORDER_STATUS_BY_NAME = 1 ; public static final int ORDER_STATUS_BY_ID = 2 ; public static final int PAYMENT_BY_NAME = 3 ; public static final int PAYMENT_BY_ID = 4 ; public static final int DELIVERY_SCHEDULE = 5 ; public static final int NEW_ORDER = 6 ; public static final int NEW_ORDER_ROLLBACK = 7 ; private final Display display ; private final Operations ops ; private final OERandom rand ; private final short maxW ; private final int [ ] transactionCount ; public static OERandom getRuntimeRandom ( Connection conn ) throws SQLException { } public static Submitter stockLevelOnly ( Display display , Operations ops , OERandom rand , short maxW ) { } public static Submitter orderStatusByIdOnly ( Display display , Operations ops , OERandom rand , short maxW ) { } public static Submitter orderStatusByNameOnly ( Display display , Operations ops , OERandom rand , short maxW ) { } public static Submitter paymentByIdOnly ( Display display , Operations ops , OERandom rand , short maxW ) { } public static Submitter paymentByNameOnly ( Display display , Operations ops , OERandom rand , short maxW ) { } public static Submitter newOrderOnly ( Display display , Operations ops , OERandom rand , short maxW ) { } public Submitter ( Display display , Operations ops , OERandom rand , short maxW ) { } public void clearTransactionCount ( ) { } public long runTransactions ( final Object displayData , final int count ) throws Exception { } public void runTransaction ( final Object displayData ) throws Exception { } protected int mixType ( final int chooseType ) { } protected void runNewOrder ( Object displayData , boolean forRollback ) throws Exception { short homeWarehouse = warehouse ( ) ; final int orderItemCount = rand . randomInt ( 5 , 15 ) ; int [ ] items = new int [ orderItemCount ] ; short [ ] quantities = new short [ orderItemCount ] ; short [ ] supplyW = new short [ orderItemCount ] ; for ( int i = 0 ; i < orderItemCount ; i ++ ) { items [ i ] = rand . NURand8191 ( ) ; if ( ( ( maxW ) == 1 ) || ( ( rand . randomInt ( 1 , 100 ) ) > 1 ) ) { supplyW [ i ] = homeWarehouse ; } else { short sw = warehouse ( ) ; while ( sw == homeWarehouse ) sw = warehouse ( ) ; supplyW [ i ] = sw ; } supplyW [ i ] = ( ( rand . randomInt ( 1 , 100 ) ) > 1 ) ? homeWarehouse : warehouse ( ) ; quantities [ i ] = ( ( short ) ( rand . randomInt ( 1 , 10 ) ) ) ; } if ( forRollback ) { <START_BUG> items [ orderItemCount ] = 2334432 ; <END_BUG> } ops . newOrder ( display , displayData , homeWarehouse , rand . district ( ) , rand . NURand1023 ( ) , items , quantities , supplyW ) ; } protected void runScheduleDelivery ( Object displayData ) { } protected void runPayment ( Object displayData , boolean byName ) throws Exception { } private final short warehouse ( ) { } protected void runStockLevel ( Object displayData ) throws Exception { } protected void runOrderStatus ( Object displayData , boolean byName ) throws Exception { } public void printReport ( PrintStream out ) { } private String transactionCount ( String name , int count , int total ) { } private String percent ( int count , int total ) { } public int [ ] getTransactionCount ( ) { } }
public class TestCalendarFields extends BaseKernelTest { public TestCalendarFields ( String name ) { } public void setUp ( ) { } public void testFieldDefaultTimeZone ( ) { } public void testTimeZoneEquals ( ) { CalendarFields c1 = new CalendarFields ( ) ; CalendarFields c2 = new CalendarFields ( ) ; assertTimeZonesEquals ( c1 , c2 ) ; OpenJPAEntityManager pm ; pm = getPM ( ) ; startTx ( pm ) ; pm . persist ( c2 ) ; int id2 = c2 . getId ( ) ; assertTimeZonesEquals ( c1 , c2 ) ; endTx ( pm ) ; assertTimeZonesEquals ( c1 , c2 ) ; endEm ( pm ) ; pm = getPM ( ) ; c2 = ( ( CalendarFields ) ( pm . find ( CalendarFields . class , id2 ) ) ) ; assertTimeZonesEquals ( c1 , c2 ) ; <START_BUG> assertTimeZonesEquals ( c1 , ( ( CalendarFields ) ( pm . detach ( c2 ) ) ) ) ; <END_BUG> endEm ( pm ) ; } public void testCalendarQuery ( ) { } private static Calendar newCalendar ( Date date , String tz ) { } public void testMutateCalendarDirties ( ) { } private static void setTimeInMillis ( Calendar cal , long millis ) { } private void assertTimeZonesEquals ( CalendarFields c1 , CalendarFields c2 ) { } }
@ ThreadLeakScope ( Scope . NONE ) public class HdfsLockFactoryTest extends SolrTestCaseJ4 { private static MiniDFSCluster dfsCluster ; @ BeforeClass public static void beforeClass ( ) throws Exception { } @ AfterClass public static void afterClass ( ) throws Exception { } @ Before public void setUp ( ) throws Exception { } @ After public void tearDown ( ) throws Exception { } @ Test public void testBasic ( ) throws IOException { URI uri = HdfsLockFactoryTest . dfsCluster . getURI ( ) ; Path lockPath = new Path ( uri . toString ( ) , "/basedir/lock" ) ; HdfsLockFactory lockFactory = new HdfsLockFactory ( lockPath , new Configuration ( ) ) ; Lock lock = lockFactory . makeLock ( "testlock" ) ; boolean success = lock . obtain ( ) ; assertTrue ( "We<seq2seq4repair_space>could<seq2seq4repair_space>not<seq2seq4repair_space>get<seq2seq4repair_space>the<seq2seq4repair_space>lock<seq2seq4repair_space>when<seq2seq4repair_space>it<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>available" , success ) ; success = lock . obtain ( ) ; assertFalse ( "We<seq2seq4repair_space>got<seq2seq4repair_space>the<seq2seq4repair_space>lock<seq2seq4repair_space>but<seq2seq4repair_space>it<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>unavailble" , success ) ; <START_BUG> lock . release ( ) ; <END_BUG> success = lock . obtain ( ) ; assertTrue ( "We<seq2seq4repair_space>could<seq2seq4repair_space>not<seq2seq4repair_space>get<seq2seq4repair_space>the<seq2seq4repair_space>lock<seq2seq4repair_space>when<seq2seq4repair_space>it<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>available" , success ) ; success = lock . obtain ( ) ; assertFalse ( "We<seq2seq4repair_space>got<seq2seq4repair_space>the<seq2seq4repair_space>lock<seq2seq4repair_space>but<seq2seq4repair_space>it<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>unavailble" , success ) ; } }
public class CategoryFragment extends VerticalGridFragment { private static final String TAG = CategoryFragment . class . getSimpleName ( ) ; private static final int NUM_COLUMNS = 5 ; private ArrayObjectAdapter mAdapter ; @ Override public void onActivityCreated ( Bundle savedInstanceState ) { } private void setupFragment ( ) { } private void loadCategory ( String categoryId ) { Map < String , Object > options = new HashMap < > ( ) ; <START_BUG> options . put ( COUNTRY , SpotifyTvApplication . getInstance ( ) . getCurrentUserCountry ( ) ) ; <END_BUG> SpotifyTvApplication . getInstance ( ) . getSpotifyService ( ) . getPlaylistsForCategory ( categoryId , options , new retrofit . Callback < PlaylistsPager > ( ) { @ Override public void success ( PlaylistsPager playlistsPager , Response response ) { mAdapter . addAll ( mAdapter . size ( ) , playlistsPager . playlists . items ) ; } @ Override public void failure ( RetrofitError error ) { } } ) ; } @ Override public void onCreate ( Bundle savedInstanceState ) { } @ Override public void onDestroy ( ) { } }
public class AddonVanillaEntities implements IWailaEntityProvider { @ Override public Entity getWailaOverride ( IWailaEntityAccessor data , IWailaConfigHandler cfg ) { } @ Override public List < String > getWailaHead ( Entity entity , List < String > tip , IWailaEntityAccessor data , IWailaConfigHandler cfg ) { } @ Override public List < String > getWailaBody ( Entity entity , List < String > tip , IWailaEntityAccessor data , IWailaConfigHandler cfg ) { } @ Override public List < String > getWailaTail ( Entity entity , List < String > tip , IWailaEntityAccessor data , IWailaConfigHandler cfg ) { } @ Override public NBTTagCompound getNBTData ( EntityPlayerMP player , Entity entity , NBTTagCompound tag , World world ) { } public static void registerAddon ( IWailaRegistrar register ) { AddonVanillaEntities dataProvider = new AddonVanillaEntities ( ) ; register . registerBodyProvider ( dataProvider , EntityHorse . class ) ; register . registerNBTProvider ( dataProvider , EntityHorse . class ) ; register . registerBodyProvider ( dataProvider , EntityVillager . class ) ; <START_BUG> register . registerBodyProvider ( dataProvider , EntityVillager . class ) ; <END_BUG> } private String showHorseJump = "wawla.horse.showJump" ; private String showHorseSpeed = "wawla.horse.showSpeed" ; private String showZombieType = "wawla.villagerZombie" ; }
public class PortletHeaderContainer extends HeaderContainer { public PortletHeaderContainer ( MarkupContainer parent , String id ) { } private static final long serialVersionUID = 1L ; @ Override protected final void onComponentTagBody ( MarkupStream markupStream , ComponentTag openTag ) { super . onComponentTagBody ( markupStream , openTag ) ; MarkupContainer parent = getParent ( ) ; while ( parent instanceof Border ) { parent = parent . getParent ( ) ; } if ( parent instanceof Page ) { <START_BUG> renderHeaderSections ( ( ( Page ) ( parent ) ) , this ) ; <END_BUG> } else { throw new WicketRuntimeException ( "Programming<seq2seq4repair_space>error:<seq2seq4repair_space>'parent'<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>a<seq2seq4repair_space>Page<seq2seq4repair_space>or<seq2seq4repair_space>a<seq2seq4repair_space>Border." ) ; } } }
public class GestActivity extends MyActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { } private void buildConsole ( LinearLayout container ) { } private View buildPrimaryViews ( ) { } private void setConsoleText ( String text ) { } private void addButton ( LinearLayout container , String label , OnClickListener listener ) { } private CheckBox addCheckBox ( LinearLayout container , String label , OnClickListener listener ) { } private LinearLayout buildControlView ( ) { } private String dumpStrokeSet ( StrokeSet set ) { } private void dumpSamples ( String name ) { } private GestureSet readSamples ( ) { } private ArrayList < String > sortedGestureNames ( GestureSet gestures ) { } private void runSamplesExperiment ( ) { pr ( "\nRunning<seq2seq4repair_space>Samples<seq2seq4repair_space>Experiment" ) ; GestureSet sampledGestures = readSamples ( ) ; ArrayList < String > names = sortedGestureNames ( sampledGestures ) ; String prevRootName = "" ; int totalProblems = 0 ; for ( String name : names ) { String name1 = rootName ( name ) ; if ( ! ( name1 . equals ( prevRootName ) ) ) { prevRootName = name1 ; pr ( ( "Samples:<seq2seq4repair_space>" + name1 ) ) ; } StrokeSet sampleStrokeSet = sampledGestures . get ( name ) ; List < Match > results = new ArrayList ( ) ; MatcherParameters p = new MatcherParameters ( ) ; p . setSkewMax ( 0.2F , 1 ) ; p . setFeaturePointPenalty ( 0 ) ; mGestureLibrary . setTraceStatus ( false ) ; mGestureLibrary . findMatch ( sampleStrokeSet , p , results ) ; Match result = null ; if ( ! ( results . isEmpty ( ) ) ) result = results . get ( 0 ) ; boolean success = false ; String name2 = null ; if ( result != null ) { <START_BUG> name2 = result . strokeSet ( ) . name ( ) ; <END_BUG> if ( name1 . equals ( name2 ) ) success = true ; } if ( success ) continue ; pr ( ( "<seq2seq4repair_space>***<seq2seq4repair_space>Problem<seq2seq4repair_space>matching:<seq2seq4repair_space>" + name ) ) ; if ( result == null ) { pr ( "<seq2seq4repair_space>no<seq2seq4repair_space>match<seq2seq4repair_space>found" ) ; continue ; } pr ( ( "<seq2seq4repair_space>Matched<seq2seq4repair_space>with:<seq2seq4repair_space>" + name2 ) ) ; if ( totalProblems == ( mMatchProblemIndex ) ) { setConsoleText ( ( ( ( "***<seq2seq4repair_space>Problem:\n<seq2seq4repair_space>" + name ) + "\n<seq2seq4repair_space>...matched...\n<seq2seq4repair_space>" ) + name2 ) ) ; mGesturePanel . setDisplayedGesture ( result . strokeSet ( ) . name ( ) , false ) ; mTouchView . setDisplayStrokeSet ( sampleStrokeSet ) ; } totalProblems ++ ; } pr ( ( ( "Total<seq2seq4repair_space>problems<seq2seq4repair_space>found:<seq2seq4repair_space>" + totalProblems ) + "\n" ) ) ; if ( totalProblems != 0 ) mMatchProblemIndex = ( 1 + ( mMatchProblemIndex ) ) % totalProblems ; } private String rootName ( String name ) { } private void addGestureToLibrary ( StrokeSet set ) { } private View buildContentView ( ) { } private void clearRegisteredSet ( ) { } private String performMatchWithLibrary ( StrokeSet sourceSet , GestureSet library ) { } private void performMatch ( StrokeSet strokeSet ) { } private void prepareGestureLibrary ( ) { } private GestureSet mGestureLibrary ; private TouchView mTouchView ; private StrokeSet mNormalizedStrokeSet ; private TextView mConsole ; private EditText mNameWidget ; private GesturePanel mGesturePanel ; private CheckBox mAddSamplesCheckBox ; private List < StrokeSet > mSamples = new ArrayList ( ) ; private int mMatchProblemIndex ; }
public final class AutoLinkResolver implements IComponentResolver { public abstract static class AbstractAutolinkResolverDelegate implements AutoLinkResolver . IAutolinkResolverDelegate { protected final Component newPackageResourceReferenceAutoComponent ( final MarkupContainer container , final String autoId , final AutoLinkResolver . PathInfo pathInfo , final String attribute ) { } } public static final class AutolinkBookmarkablePageLink < T > extends BookmarkablePageLink < T > implements IComponentResolver { private static final long serialVersionUID = 1L ; private final String anchor ; public static boolean autoEnable = true ; public < C extends Page > AutolinkBookmarkablePageLink ( final String id , final Class < C > pageClass , final PageParameters parameters , final String anchor ) { } @ Override protected CharSequence getURL ( ) { } public Component resolve ( final MarkupContainer container , final MarkupStream markupStream , ComponentTag tag ) { } } public static interface IAutolinkResolverDelegate { Component newAutoComponent ( final MarkupContainer container , final String autoId , final AutoLinkResolver . PathInfo pathInfo ) { } } public static final class PathInfo { private final boolean absolute ; private final String anchor ; private final String extension ; private final PageParameters pageParameters ; private final String path ; private final String reference ; public PathInfo ( final String reference ) { } public final String getAnchor ( ) { } public final String getExtension ( ) { } public final PageParameters getPageParameters ( ) { } public final String getPath ( ) { } public final String getReference ( ) { } public final boolean isAbsolute ( ) { } } private static final class AnchorResolverDelegate extends AutoLinkResolver . AbstractAutolinkResolverDelegate { private static final String attribute = "href" ; private final Set < String > supportedPageExtensions = new HashSet < String > ( 4 ) ; public AnchorResolverDelegate ( ) { } @ SuppressWarnings ( "unchecked" ) public Component newAutoComponent ( final MarkupContainer container , final String autoId , AutoLinkResolver . PathInfo pathInfo ) { } } private static final class AutolinkExternalLink extends ExternalLink implements IComponentResolver { private static final long serialVersionUID = 1L ; public AutolinkExternalLink ( final String id , final String href ) { } public Component resolve ( MarkupContainer container , MarkupStream markupStream , ComponentTag tag ) { } } private static interface ITagReferenceResolver { String getReference ( final ComponentTag tag ) { } } private static final class ResourceReferenceAutolink extends WebMarkupContainer implements IComponentResolver { private static final long serialVersionUID = 1L ; private final String attribute ; private final ResourceReference resourceReference ; private final MarkupContainer parent ; public ResourceReferenceAutolink ( final String id , final Class < ? > clazz , final String href , final String attribute , MarkupContainer parent ) { } @ Override public String getVariation ( ) { } @ Override protected final void onComponentTag ( final ComponentTag tag ) { super . onComponentTag ( tag ) ; if ( ( resourceReference ) != null ) { ResourceReferenceRequestHandler handler = new ResourceReferenceRequestHandler ( resourceReference ) ; <START_BUG> CharSequence url = getRequestCycle ( ) . renderUrlFor ( handler ) ; <END_BUG> tag . put ( attribute , Strings . replaceAll ( url , "&" , "&amp;" ) ) ; } } public Component resolve ( MarkupContainer container , MarkupStream markupStream , ComponentTag tag ) { } } private static final class ResourceReferenceResolverDelegate extends AutoLinkResolver . AbstractAutolinkResolverDelegate { private final String attribute ; public ResourceReferenceResolverDelegate ( final String attribute ) { } public Component newAutoComponent ( final MarkupContainer container , final String autoId , final AutoLinkResolver . PathInfo pathInfo ) { } } private static final class TagReferenceResolver implements AutoLinkResolver . ITagReferenceResolver { private final String attribute ; public TagReferenceResolver ( final String attribute ) { } public String getReference ( final ComponentTag tag ) { } } private static final AutoLinkResolver . TagReferenceResolver DEFAULT_ATTRIBUTE_RESOLVER = new AutoLinkResolver . TagReferenceResolver ( "href" ) ; private static final Logger log = LoggerFactory . getLogger ( AutoLinkResolver . class ) ; private static final long serialVersionUID = 1L ; private final Map < String , AutoLinkResolver . IAutolinkResolverDelegate > tagNameToAutolinkResolverDelegates = new HashMap < String , AutoLinkResolver . IAutolinkResolverDelegate > ( ) ; private final Map < String , AutoLinkResolver . ITagReferenceResolver > tagNameToTagReferenceResolvers = new HashMap < String , AutoLinkResolver . ITagReferenceResolver > ( ) ; public AutoLinkResolver ( ) { } public final void addTagReferenceResolver ( final String tagName , final String attributeName , final AutoLinkResolver . IAutolinkResolverDelegate resolver ) { } public final AutoLinkResolver . IAutolinkResolverDelegate getAutolinkResolverDelegate ( final String tagName ) { } public final Component resolve ( final MarkupContainer container , final MarkupStream markupStream , final ComponentTag tag ) { } private final Component resolveAutomaticLink ( final MarkupContainer container , final String id , final ComponentTag tag ) { } }
public class AssJob extends Skill { public AssJob ( Character self ) { } @ Override public boolean requirements ( Combat c , Character user , Character target ) { } @ Override public boolean usable ( Combat c , Character target ) { } @ Override public String describe ( Combat c ) { } @ Override public boolean resolve ( Combat c , Character target ) { } @ Override public Skill copy ( Character user ) { } @ Override public Tactics type ( Combat c ) { } private boolean selfNakedOrUnderwear ( ) { } private boolean selfWearingUnderwear ( ) { } @ Override public String deal ( Combat c , int damage , Result modifier , Character target ) { switch ( modifier ) { case special : if ( ( getSelf ( ) . crotchAvailable ( ) ) && ( target . crotchAvailable ( ) ) ) { return String . format ( ( "You<seq2seq4repair_space>push<seq2seq4repair_space>your<seq2seq4repair_space>naked<seq2seq4repair_space>ass<seq2seq4repair_space>back<seq2seq4repair_space>against" + "<seq2seq4repair_space>%s<seq2seq4repair_space>%s,<seq2seq4repair_space>rubbing<seq2seq4repair_space>it<seq2seq4repair_space>with<seq2seq4repair_space>vigor." ) , target . nameOrPossessivePronoun ( ) , target . body . getRandomCock ( ) . describe ( target ) ) ; } else { <START_BUG> return String . format ( ( "You<seq2seq4repair_space>relax<seq2seq4repair_space>slightly<seq2seq4repair_space>in<seq2seq4repair_space>%s<seq2seq4repair_space>arms<seq2seq4repair_space>and<seq2seq4repair_space>rub<seq2seq4repair_space>your<seq2seq4repair_space>ass" + "<seq2seq4repair_space>into<seq2seq4repair_space>%s<seq2seq4repair_space>crotch." ) , target . nameOrPossessivePronoun ( ) , target . name ( ) ) ; <END_BUG> } case strong : if ( ! ( target . crotchAvailable ( ) ) ) { return String . format ( "You<seq2seq4repair_space>hump<seq2seq4repair_space>your<seq2seq4repair_space>ass<seq2seq4repair_space>against<seq2seq4repair_space>%s<seq2seq4repair_space>covered<seq2seq4repair_space>groin." , target . nameOrPossessivePronoun ( ) ) ; } else if ( target . body . getRandomCock ( ) . isReady ( getSelf ( ) ) ) { return String . format ( ( "You<seq2seq4repair_space>wedge<seq2seq4repair_space>%s<seq2seq4repair_space>%s<seq2seq4repair_space>in<seq2seq4repair_space>your<seq2seq4repair_space>soft<seq2seq4repair_space>crack<seq2seq4repair_space>and" + ( "<seq2seq4repair_space>firmly<seq2seq4repair_space>rub<seq2seq4repair_space>it<seq2seq4repair_space>up<seq2seq4repair_space>against<seq2seq4repair_space>you,<seq2seq4repair_space>eliciting<seq2seq4repair_space>a<seq2seq4repair_space>quiet<seq2seq4repair_space>moan<seq2seq4repair_space>from" + "<seq2seq4repair_space>%s." ) ) , target . nameOrPossessivePronoun ( ) , target . body . getRandomCock ( ) . describe ( target ) , target . directObject ( ) ) ; } else { return String . format ( ( "You<seq2seq4repair_space>lean<seq2seq4repair_space>back<seq2seq4repair_space>and<seq2seq4repair_space>rub<seq2seq4repair_space>your<seq2seq4repair_space>ass<seq2seq4repair_space>against<seq2seq4repair_space>%s,<seq2seq4repair_space>but" + "<seq2seq4repair_space>%s<seq2seq4repair_space>%s<seq2seq4repair_space>is<seq2seq4repair_space>still<seq2seq4repair_space>too<seq2seq4repair_space>soft<seq2seq4repair_space>to<seq2seq4repair_space>really<seq2seq4repair_space>get<seq2seq4repair_space>into<seq2seq4repair_space>it." ) , target . name ( ) , target . possessivePronoun ( ) , target . body . getRandomCock ( ) . describe ( target ) ) ; } case normal : return String . format ( ( "You<seq2seq4repair_space>back<seq2seq4repair_space>up<seq2seq4repair_space>against<seq2seq4repair_space>%s<seq2seq4repair_space>and<seq2seq4repair_space>grab<seq2seq4repair_space>%s<seq2seq4repair_space>by<seq2seq4repair_space>the<seq2seq4repair_space>waist." + ( "<seq2seq4repair_space>Before<seq2seq4repair_space>%s<seq2seq4repair_space>has<seq2seq4repair_space>a<seq2seq4repair_space>chance<seq2seq4repair_space>to<seq2seq4repair_space>push<seq2seq4repair_space>you<seq2seq4repair_space>away,<seq2seq4repair_space>you<seq2seq4repair_space>rub<seq2seq4repair_space>your<seq2seq4repair_space>ass<seq2seq4repair_space>against" + "<seq2seq4repair_space>%s<seq2seq4repair_space>crotch." ) ) , target . name ( ) , target . directObject ( ) , target . pronoun ( ) , target . possessivePronoun ( ) ) ; case miss : default : return String . format ( ( "You<seq2seq4repair_space>try<seq2seq4repair_space>to<seq2seq4repair_space>mash<seq2seq4repair_space>your<seq2seq4repair_space>ass<seq2seq4repair_space>against<seq2seq4repair_space>%s<seq2seq4repair_space>crotch,<seq2seq4repair_space>but<seq2seq4repair_space>%s" + "<seq2seq4repair_space>pushes<seq2seq4repair_space>you<seq2seq4repair_space>away." ) , target . nameOrPossessivePronoun ( ) , target . pronoun ( ) ) ; } } @ Override public String receive ( Combat c , int damage , Result modifier , Character target ) { } }
public final class RemotingExtension implements Extension { private static final SubsystemFactory < RemotingSubsystemElement > FACTORY = new SubsystemFactory < RemotingSubsystemElement > ( ) { public RemotingSubsystemElement createSubsystemElement ( ) { } } ; public void initialize ( ExtensionContext context ) { <START_BUG> context . registerSubsystem ( REMOTING_1_0 . getUriString ( ) , RemotingExtension . FACTORY , RemotingSubsystemParser . getInstance ( ) ) ; <END_BUG> } public void activate ( final ServiceActivatorContext context ) { } }
class SingleSignOnAdd extends AbstractAddStepHandler { @ Override protected void populateModel ( ModelNode operation , ModelNode model ) throws OperationFailedException { } @ Override protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode model ) throws OperationFailedException { final PathAddress address = PathAddress . pathAddress ( operation . get ( OP_ADDR ) ) ; final PathAddress hostAddress = address . subAddress ( 0 , ( ( address . size ( ) ) - 1 ) ) ; final PathAddress serverAddress = hostAddress . subAddress ( 0 , ( ( hostAddress . size ( ) ) - 1 ) ) ; final ModelNode domainModelNode = DOMAIN . resolveModelAttribute ( context , model ) ; final ModelNode pathNode = PATH . resolveModelAttribute ( context , model ) ; final String domain = ( domainModelNode . isDefined ( ) ) ? domainModelNode . asString ( ) : null ; final String path = ( pathNode . isDefined ( ) ) ? pathNode . asString ( ) : null ; final boolean secure = SECURE . resolveModelAttribute ( context , model ) . asBoolean ( ) ; final boolean httpOnly = HTTP_ONLY . resolveModelAttribute ( context , model ) . asBoolean ( ) ; final String cookieName = COOKIE_NAME . resolveModelAttribute ( context , model ) . asString ( ) ; final String serverName = serverAddress . getLastElement ( ) . getValue ( ) ; final String hostName = hostAddress . getLastElement ( ) . getValue ( ) ; final ServiceName serviceName = UndertowService . ssoServiceName ( serverName , hostName ) ; final ServiceName virtualHostServiceName = UndertowService . virtualHostName ( serverName , hostName ) ; final ServiceTarget target = context . getServiceTarget ( ) ; ServiceName managerServiceName = serviceName . append ( "manager" ) ; <START_BUG> SingleSignOnManagerService . build ( target , managerServiceName , virtualHostServiceName ) . setInitialMode ( ON_DEMAND ) . install ( ) ; <END_BUG> final SingleSignOnService service = new SingleSignOnService ( domain , path , httpOnly , secure , cookieName ) ; target . addService ( serviceName , service ) . addDependency ( virtualHostServiceName , Host . class , service . getHost ( ) ) . addDependency ( managerServiceName , SingleSignOnManager . class , service . getSingleSignOnSessionManager ( ) ) . setInitialMode ( ACTIVE ) . install ( ) ; } }
public final class FeedbackPanel extends Panel implements IValidationFeedback { private static final long serialVersionUID = - 3385823935971399988L ; private final FeedbackPanel . MessageListView messageListView ; private static final class MessageListView extends ListView { public MessageListView ( final String name ) { } protected void populateItem ( final ListItem listItem ) { } } public FeedbackPanel ( final String componentName ) { } public void setMaxMessages ( int maxMessages ) { } public void updateValidationFeedback ( final Form form ) { messageListView . setModel ( getPage ( ) . getFeedbackMessages ( ) . model ( form ) ) ; <START_BUG> messageListView . invalidateModel ( ) ; <END_BUG> } }
public class DynamicFilterTest extends BuildFileTest { public DynamicFilterTest ( String name ) { } public void setUp ( ) { } public void tearDown ( ) { } public void testCustomFilter ( ) throws IOException { } private void assertStringContains ( String string , String contains ) { } private void assertStringNotContains ( String string , String contains ) { } private String getFileString ( String filename ) throws IOException { Reader r = null ; try { r = new FileReader ( getProject ( ) . resolveFile ( filename ) ) ; <START_BUG> return FileUtils . newFileUtils ( ) . readFully ( r ) ; <END_BUG> } finally { try { r . close ( ) ; } catch ( Throwable ignore ) { } } } private String getFileString ( String target , String filename ) throws IOException { } private void expectFileContains ( String name , String contains ) throws IOException { } private void expectFileContains ( String target , String name , String contains ) throws IOException { } public static class CustomFilter implements ChainableReader { char replace = 'x' ; char with = 'y' ; public void setReplace ( char replace ) { } public void setWith ( char with ) { } public Reader chain ( final Reader rdr ) { } } }
public class Util { private static final char [ ] DOUBLE_QUOTES = "''" . toCharArray ( ) ; private static final char [ ] SINGLE_QUOTE = "'" . toCharArray ( ) ; private static final String ARGUMENTS_DELIMITER = "#" ; private static final String EMPTY_ARGUMENT = "<seq2seq4repair_space>" ; public interface Comparable { int compareTo ( Util . Comparable c ) { } } public interface Comparer { int compare ( Object a , Object b ) { } } public static final String [ ] fgEmptyStringArray = new String [ 0 ] ; private static boolean JDK1_1 = false ; protected static ResourceBundle bundle ; private static final String bundleName = "org.eclipse.jdt.internal.core.messages" ; public static final char [ ] SUFFIX_class = ".class" . toCharArray ( ) ; public static final char [ ] SUFFIX_CLASS = ".CLASS" . toCharArray ( ) ; public static final char [ ] SUFFIX_java = ".java" . toCharArray ( ) ; public static final char [ ] SUFFIX_JAVA = ".JAVA" . toCharArray ( ) ; private static int checkTypeSignature ( String sig , int start , int end , boolean allowVoid ) { } public static int combineHashCodes ( int hashCode1 , int hashCode2 ) { } public static int compare ( byte [ ] a , byte [ ] b ) { } public static int compare ( char [ ] v1 , char [ ] v2 ) { } public static String concat ( String s1 , char c , String s2 ) { } public static String concat ( String s1 , String s2 ) { } public static String concat ( String s1 , String s2 , String s3 ) { } public static String convertTypeSignature ( char [ ] sig ) { } public static boolean equalArraysOrNull ( int [ ] a , int [ ] b ) { } public static boolean equalArraysOrNull ( Object [ ] a , Object [ ] b ) { } public static boolean equalArraysOrNullSortFirst ( String [ ] a , String [ ] b ) { } public static boolean equalArraysOrNullSortFirst ( Util . Comparable [ ] a , Util . Comparable [ ] b ) { } public static boolean equalOrNull ( Object a , Object b ) { } public static String extractLastName ( String qualifiedName ) { } public static String [ ] extractParameterTypes ( char [ ] sig ) { } public static String extractReturnType ( String sig ) { } private static String findLineSeparator ( char [ ] text ) { } private static String getLineSeparator ( char [ ] text , char [ ] buffer ) { } public static int getParameterCount ( char [ ] sig ) { } public static byte [ ] getResourceContentsAsByteArray ( IFile file ) throws JavaModelException { } public static char [ ] getResourceContentsAsCharArray ( IFile file ) throws JavaModelException { InputStream stream = null ; try { stream = new BufferedInputStream ( file . getContents ( true ) ) ; } catch ( CoreException e ) { <START_BUG> throw new JavaModelException ( e ) ; <END_BUG> } try { String encoding = JavaCore . create ( file . getProject ( ) ) . getOption ( JavaCore . CORE_ENCODING , true ) ; return org . eclipse . jdt . internal . compiler . util . Util . getInputStreamAsCharArray ( stream , ( - 1 ) , encoding ) ; } catch ( IOException e ) { throw new JavaModelException ( e , IJavaModelStatusConstants . IO_EXCEPTION ) ; } finally { try { stream . close ( ) ; } catch ( IOException e ) { } } } public static boolean isValidMethodSignature ( String sig ) { } public static boolean isValidTypeSignature ( String sig , boolean allowVoid ) { } public static boolean isValidFolderNameForPackage ( String folderName ) { } public static void log ( Throwable e , String message ) { } public static char [ ] normalizeCRs ( char [ ] text , char [ ] buffer ) { } public static String normalizeCRs ( String text , String buffer ) { } private static void quickSort ( Object [ ] sortedCollection , int left , int right , int [ ] sortOrder ) { } private static void quickSort ( Object [ ] sortedCollection , int left , int right , Util . Comparer comparer ) { } private static void quickSort ( String [ ] sortedCollection , int left , int right ) { } public static String packageName ( IPath pkgPath ) { } private static void quickSort ( Util . Comparable [ ] sortedCollection , int left , int right ) { } private static void quickSortReverse ( String [ ] sortedCollection , int left , int right ) { } public static void sort ( Object [ ] objects , int [ ] sortOrder ) { } public static void sort ( Object [ ] objects , Util . Comparer comparer ) { } public static void sort ( String [ ] strings ) { } public static void sort ( Util . Comparable [ ] objects ) { } public static Object [ ] sortCopy ( Object [ ] objects , Util . Comparer comparer ) { } public static String [ ] sortCopy ( String [ ] objects ) { } public static Util . Comparable [ ] sortCopy ( Util . Comparable [ ] objects ) { } public static void sortReverseOrder ( String [ ] strings ) { } public static char [ ] [ ] toCharArrays ( String [ ] a ) { } public static char [ ] toChars ( String s ) { } public static char [ ] [ ] toCompoundChars ( String s ) { } public static String toString ( char [ ] [ ] c ) { } public static String toString ( char [ ] [ ] c , char [ ] d ) { }
public class BoundedQueueThreadPoolService implements Service < ManagedQueueExecutorService > { private final InjectedValue < ThreadFactory > threadFactoryValue = new InjectedValue < ThreadFactory > ( ) ; private final InjectedValue < Executor > handoffExecutorValue = new InjectedValue < Executor > ( ) ; private ManagedQueueExecutorService executor ; private int coreThreads ; private int maxThreads ; private int queueLength ; private boolean blocking ; private TimeSpec keepAlive ; private boolean allowCoreTimeout ; public BoundedQueueThreadPoolService ( int coreThreads , int maxThreads , int queueLength , boolean blocking , TimeSpec keepAlive , boolean allowCoreTimeout ) { } public synchronized void start ( final StartContext context ) throws StartException { } public synchronized void stop ( final StopContext context ) { } public synchronized ManagedQueueExecutorService getValue ( ) throws IllegalStateException { final ManagedQueueExecutorService value = this . executor ; if ( value == null ) { <START_BUG> throw ROOT_LOGGER . boundedQueueThreadPoolExecutorUninitialized ( ) ; <END_BUG> } return value ; } public Injector < ThreadFactory > getThreadFactoryInjector ( ) { } public Injector < Executor > getHandoffExecutorInjector ( ) { } public synchronized void setCoreThreads ( int coreThreads ) { } public synchronized void setMaxThreads ( int maxThreads ) { } public synchronized void setKeepAlive ( TimeSpec keepAlive ) { } public synchronized void setAllowCoreTimeout ( boolean allowCoreTimeout ) { } public int getCurrentThreadCount ( ) { } public int getLargestThreadCount ( ) { } TimeUnit getKeepAliveUnit ( ) { } public int getRejectedCount ( ) { } public int getQueueSize ( ) { } }
public void setJvm ( String value ) { } public Argument createJvmarg ( ) { } public void setDir ( File dir ) { } public void addSysproperty ( Environment . Variable sysp ) { } public void addConfiguredSysproperty ( Environment . Variable sysp ) { } public void addSyspropertyset ( PropertySet sysp ) { } public Path createClasspath ( ) { } public Path createBootclasspath ( ) { } public void addEnv ( Environment . Variable var ) { } public void setNewenvironment ( boolean newenv ) { } private void preConfigure ( BaseTest test ) { } public void addTest ( JUnitTest test ) { } public BatchTest createBatchTest ( ) { } public void addFormatter ( FormatterElement fe ) { } public void setIncludeantruntime ( boolean b ) { } public void setShowOutput ( boolean showOutput ) { } public void setOutputToFormatters ( boolean outputToFormatters ) { } public void setLogFailedTests ( boolean logFailedTests ) { } public void addAssertions ( Assertions asserts ) { } public Permissions createPermissions ( ) { } public void setCloneVm ( boolean cloneVm ) { } public JUnitTask ( ) throws Exception { } public void setTempdir ( File tmpDir ) { } public void setEnableTestListenerEvents ( boolean b ) { } public boolean getEnableTestListenerEvents ( ) { } public void init ( ) { } private static JUnitTaskMirror createMirror ( JUnitTask task , ClassLoader loader ) { } protected void setupJUnitDelegate ( ) { } public void execute ( ) throws BuildException { } protected void execute ( JUnitTest arg ) throws BuildException { } private void validateTestName ( String testName ) throws BuildException { } protected void execute ( List testList ) throws BuildException { } private JUnitTask . TestResultHolder executeAsForked ( JUnitTest test , ExecuteWatchdog watchdog , File casesFile ) throws BuildException { } private void checkIncludeAntRuntime ( CommandlineJava cmd ) { } private boolean equalsWithOutAndErr ( String summaryOption ) { } private void checkIncludeSummary ( CommandlineJava cmd ) { } private void checkForkedPath ( CommandlineJava cmd ) { } private static boolean urlEquals ( URL u1 , URL u2 ) { } private static String maybeStripJarAndClass ( URL u ) { } private File createTempPropertiesFile ( String prefix ) { } protected void handleOutput ( String output ) { } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { } protected void handleFlush ( String output ) { } public void handleErrorOutput ( String output ) { } public void handleErrorFlush ( String output ) { } private JUnitTask . TestResultHolder executeInVM ( JUnitTest arg ) throws BuildException { } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { } protected OutputStream getDefaultOutput ( ) { } protected Enumeration getIndividualTests ( ) { } private void checkMethodLists ( ) throws BuildException { } protected Enumeration allTests ( ) { } private FormatterElement [ ] mergeFormatters ( JUnitTest test ) { } protected File getOutput ( FormatterElement fe , JUnitTest test ) { } protected void addClasspathEntry ( String resource ) { } private boolean addClasspathResource ( String resource ) { } static final String TIMEOUT_MESSAGE = "Timeout<seq2seq4repair_space>occurred.<seq2seq4repair_space>Please<seq2seq4repair_space>note<seq2seq4repair_space>the<seq2seq4repair_space>time<seq2seq4repair_space>in<seq2seq4repair_space>the<seq2seq4repair_space>report<seq2seq4repair_space>does" + "<seq2seq4repair_space>not<seq2seq4repair_space>reflect<seq2seq4repair_space>the<seq2seq4repair_space>time<seq2seq4repair_space>until<seq2seq4repair_space>the<seq2seq4repair_space>timeout." ; private void logTimeout ( FormatterElement [ ] feArray , JUnitTest test , String testCase ) { } private void logVmCrash ( FormatterElement [ ] feArray , JUnitTest test , String testCase ) { } private void logVmExit ( FormatterElement [ ] feArray , JUnitTest test , String message , String testCase ) { } private void createClassLoader ( ) { } protected void cleanup ( ) { } private void deleteClassLoader ( ) { } protected CommandlineJava getCommandline ( ) { } private static final class ForkedTestConfiguration { private boolean filterTrace ; private boolean haltOnError ; private boolean haltOnFailure ; private String errorProperty ; private String failureProperty ; ForkedTestConfiguration ( boolean filterTrace , boolean haltOnError , boolean haltOnFailure , String errorProperty , String failureProperty ) { } ForkedTestConfiguration ( JUnitTest test ) { } public boolean equals ( Object other ) { } public int hashCode ( ) { } } public static final class ForkMode extends EnumeratedAttribute { public static final String ONCE = "once" ; public static final String PER_TEST = "perTest" ; public static final String PER_BATCH = "perBatch" ; public ForkMode ( ) { } public ForkMode ( String value ) { } public String [ ] getValues ( ) { } } protected Collection executeOrQueue ( Enumeration testList , boolean runIndividual ) { } protected void actOnTestResult ( int exitValue , boolean wasKilled , JUnitTest test , String name ) { } protected void actOnTestResult ( JUnitTask . TestResultHolder result , JUnitTest test , String name ) { } protected static class TestResultHolder { public int exitCode = JUnitTestRunnerMirror . ERRORS ; public boolean timedOut = false ; public boolean crashed = false ; } protected static class JUnitLogOutputStream extends LogOutputStream { private Task task ; public JUnitLogOutputStream ( Task task , int level ) { } protected void processLine ( String line , int level ) { } } protected static class JUnitLogStreamHandler extends PumpStreamHandler { public JUnitLogStreamHandler ( Task task , int outlevel , int errlevel ) { } } static final String NAME_OF_DUMMY_TEST = "Batch-With-Multiple-Tests" ; private static JUnitTest createDummyTestForBatchTest ( JUnitTest test ) { JUnitTest t = ( ( JUnitTest ) ( test . clone ( ) ) ) ; <START_BUG> int index = test . getName ( ) . indexOf ( '.' ) ; <END_BUG> String pack = ( index > 0 ) ? test . getName ( ) . substring ( 0 , ( index + 1 ) ) : "" ; t . setName ( ( pack + ( JUnitTask . NAME_OF_DUMMY_TEST ) ) ) ; return t ; } private static void printDual ( BufferedWriter w , PrintStream s , String text ) throws IOException { } private static void printlnDual ( BufferedWriter w , PrintStream s , String text ) throws IOException { } }
public abstract class WebApplication extends Application { private final Map bufferedResponses = new HashMap ( ) ; private IRequestCycleProcessor requestCycleProcessor ; private String sessionAttributePrefix ; private ISessionFactory sessionFactory = new ISessionFactory ( ) { private static final long serialVersionUID = 1L ; public Session newSession ( ) { } } ; private WicketServlet wicketServlet ; public WebApplication ( ) { } public final String getSessionAttributePrefix ( final WebRequest request ) { } public final WicketServlet getWicketServlet ( ) { } public final void mount ( String path , IRequestTargetUrlCodingStrategy encoder ) { } public final void mount ( String path , Package p ) { } public final void mount ( String path , PackageName packageName ) { } public final void mountBookmarkablePage ( String path , Class bookmarkablePageClass ) { } public final void mountBookmarkablePage ( String path , Class bookmarkablePageClass , String pageMapName ) { } public final void setSessionFactory ( final ISessionFactory sessionFactory ) { } public final void setWicketServlet ( final WicketServlet wicketServlet ) { } public final void unmount ( String path ) { } protected IRequestCycleFactory getDefaultRequestCycleFactory ( ) { } protected IRequestCycleProcessor getDefaultRequestCycleProcessor ( ) { } protected ISessionFactory getSessionFactory ( ) { } protected void init ( ) { } protected void internalDestroy ( ) { } protected void internalInit ( ) { } protected WebRequest newWebRequest ( final HttpServletRequest servletRequest ) { } protected WebResponse newWebResponse ( final HttpServletResponse servletResponse ) { } final void addBufferedResponse ( String sessionId , String bufferId , BufferedHttpServletResponse renderedResponse ) { } final void clearBufferedResponses ( String sessionId ) { } final WebSession getSession ( final WebRequest request ) { final HttpSession httpSession = request . getHttpServletRequest ( ) . getSession ( false ) ; final String sessionAttribute = ( getSessionAttributePrefix ( request ) ) + ( Session . SESSION_ATTRIBUTE_NAME ) ; WebSession webSession = null ; if ( httpSession != null ) { webSession = ( ( WebSession ) ( httpSession . getAttribute ( sessionAttribute ) ) ) ; } if ( webSession == null ) { final Session session = getSessionFactory ( ) . newSession ( ) ; if ( session instanceof WebSession ) { webSession = ( ( WebSession ) ( session ) ) ; } else { throw new WicketRuntimeException ( "Session<seq2seq4repair_space>created<seq2seq4repair_space>by<seq2seq4repair_space>a<seq2seq4repair_space>WebApplication<seq2seq4repair_space>session<seq2seq4repair_space>factory<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>a<seq2seq4repair_space>subclass<seq2seq4repair_space>of<seq2seq4repair_space>WebSession" ) ; } webSession . setLocale ( request . getLocale ( ) ) ; if ( httpSession != null ) { httpSession . setAttribute ( sessionAttribute , webSession ) ; } } webSession . setApplication ( this ) ; <START_BUG> webSession . init ( getSessionAttributePrefix ( request ) ) ; <END_BUG> return webSession ; } final BufferedHttpServletResponse popBufferedResponse ( String sessionId , String bufferId ) { } private void checkMountPath ( String path ) { } }
public class GuiModCanned extends GuiScreen { public String chatmessage = "" ; Properties p = new Properties ( ) ; File configDir = new File ( Minecraft . getMinecraftDir ( ) , "/config/" ) ; File config = new File ( configDir , "FogHelperConfig.cfg" ) ; boolean grabbed = false ; String [ ] cannedButtonName = new String [ 25 ] ; String [ ] cannedButtonMessage = new String [ 25 ] ; public GuiModCanned ( GuiScreen guiscreen ) { } public void grabdata ( ) { } public void initGui ( ) { } protected void actionPerformed ( GuiButton guibutton ) { } public void chatgo ( ) { <START_BUG> mc . getSendQueue ( ) . addToSendQueue ( new Packet3Chat ( chatmessage ) ) ; <END_BUG> mc . displayGuiScreen ( null ) ; mc . setIngameFocus ( ) ; } public void drawScreen ( int i , int j , float f ) { } protected String screenTitle ; protected GuiScreen guiScreen ; }
public class ClobTest extends BaseJDBCTestCase { private Clob clob = null ; private static final ExemptClobMD [ ] emd = new ExemptClobMD [ ] { new ExemptClobMD ( "getCharacterStream" , new Class [ ] { long . class , long . class } , true , true ) , new ExemptClobMD ( "setString" , new Class [ ] { long . class , String . class } , false , true ) , new ExemptClobMD ( "truncate" , new Class [ ] { long . class } , false , true ) , new ExemptClobMD ( "free" , null , true , true ) } ; private HashMap < Method , ExemptClobMD > excludedMethodSet = new HashMap < Method , ExemptClobMD > ( ) ; public ClobTest ( String name ) { } public void setUp ( ) throws SQLException { } protected void tearDown ( ) throws Exception { } void buildHashSet ( ) { } public void testFreeandMethodsAfterCallingFree ( ) throws IllegalAccessException , InvocationTargetException , SQLException { } void buildMethodList ( Object LOB ) throws IllegalAccessException , InvocationTargetException { } boolean checkIfExempted ( Method m ) { } boolean checkIfMethodThrowsSQLException ( Object LOB , Method method ) throws IllegalAccessException , InvocationTargetException { } Object [ ] getNullValues ( Class < ? > [ ] params ) { } Object getNullValueForType ( Class type ) { } public void testGetCharacterStreamLong ( ) throws Exception { } public void testGetCharacterStreamLongOnLargeClob ( ) throws Exception { } public void testGetCharacterStreamLongExceptionConditions ( ) throws SQLException { } public void testGetAsciiStreamCreateClob ( ) throws Exception { String str = "Hi<seq2seq4repair_space>I<seq2seq4repair_space>am<seq2seq4repair_space>the<seq2seq4repair_space>insert<seq2seq4repair_space>String" ; <START_BUG> ByteArrayInputStream str_is = new ByteArrayInputStream ( str . getBytes ( ) ) ; <END_BUG> Clob clob = getConnection ( ) . createClob ( ) ; InputStream is = clob . getAsciiStream ( ) ; clob . setString ( 1 , str ) ; assertEquals ( str_is , is ) ; } public void testGetCharacterStreamCreateClob ( ) throws Exception { } public void testGetAsciiStreamClobUpdates ( ) throws Exception { } public void testGetCharacterStreamClobUpdates ( ) throws Exception { } public void testLockingAfterFree ( ) throws SQLException { } public void testLockingAfterFreeWithRR ( ) throws SQLException { } public void testLockingAfterFreeWithDirtyReads ( ) throws SQLException { } private int initializeLongClob ( ) throws SQLException { } private void executeParallelUpdate ( int id , boolean timeoutExpected ) throws SQLException { } public static Test suite ( ) { } private static final String LOCK_TIMEOUT = "40XL1" ; }
public class StationController { public static final int CONNECTION_LINE_WIDTH = 5 ; private static Context context ; private static Tooltip tooltip ; private static List < StationClickListener > stationClickListeners = new CopyOnWriteArrayList < StationClickListener > ( ) ; private static Group stationActors ; private Group connectionActors ; public StationController ( final Context context , Tooltip tooltip ) { } public static void subscribeStationClick ( StationClickListener listener ) { } public static void unsubscribeStationClick ( StationClickListener listener ) { } private static void stationClicked ( Station station ) { } public void renderStations ( ) { } public static StationActor renderStation ( final Station station ) { } public static CollisionStationActor renderCollisionStation ( final CollisionStation collisionStation ) { final CollisionStationActor collisionStationActor = new CollisionStationActor ( collisionStation . getPosition ( ) , collisionStation ) ; collisionStationActor . addListener ( new ClickListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { if ( ( Game . getInstance ( ) . getState ( ) ) == ( GameState . NORMAL ) ) { ArrayList < Train > trains = new ArrayList < Train > ( ) ; for ( Player player : StationController . context . getGameLogic ( ) . getPlayerManager ( ) . getAllPlayers ( ) ) { for ( Resource resource : player . getResources ( ) ) { if ( resource instanceof Train ) { if ( ( ( ( Train ) ( resource ) ) . getPosition ( ) ) == ( collisionStation . getPosition ( ) ) ) { trains . add ( ( ( Train ) ( resource ) ) ) ; } } } } if ( ( trains . size ( ) ) == 1 ) { TrainClicked clicker = new TrainClicked ( StationController . context , trains . get ( 0 ) ) ; clicker . clicked ( null , ( - 1 ) , 0 ) ; } else if ( ( trains . size ( ) ) > 1 ) { DialogStationMultitrain dia = new DialogStationMultitrain ( trains , StationController . context . getSkin ( ) , StationController . context ) ; dia . show ( StationController . context . getStage ( ) ) ; } } StationController . stationClicked ( collisionStation ) ; } @ Override public void enter ( InputEvent event , float x , float y , int pointer , Actor fromActor ) { StationController . tooltip . setPosition ( ( ( collisionStationActor . getX ( ) ) + 10 ) , ( ( collisionStationActor . getY ( ) ) + 10 ) ) ; <START_BUG> StationController . tooltip . show ( ( "Junction:<seq2seq4repair_space>" + ( collisionStation . getName ( ) ) ) ) ; <END_BUG> } @ Override public void exit ( InputEvent event , float x , float y , int pointer , Actor toActor ) { StationController . tooltip . hide ( ) ; } } ) ; collisionStation . setActor ( collisionStationActor ) ; StationController . stationActors . addActor ( collisionStationActor ) ; return collisionStationActor ; } public static Color [ ] colours = new Color [ ] { Color . ORANGE , Color . PINK , Color . PURPLE } ; public void renderStationGoalHighlights ( ) { } class StationHighlight implements Comparable < StationController . StationHighlight > { private final Station station ; private final int radius ; private final Color colour ; StationHighlight ( Station station , int radius , Color colour ) { } @ Override public int compareTo ( StationController . StationHighlight o ) { } public Color getColour ( ) { } public int getRadius ( ) { } public Station getStation ( ) { } } public void addConnections ( List < Connection > connections , final Color color ) { } public void drawRoutingInfo ( List < Connection > connections ) { } public void displayNumberOfTrainsAtStations ( ) { } private int trainsAtStation ( Station station ) { } }
public class FileListActivity extends ListActivity { private SocketClient clientSocket = null ; private Map < String , String > MACIPMap = null ; private ArrayAdapter < String > listing = null ; private FileListActivity This = this ; private EditText statusText = null ; private Handler handle = new Handler ( ) ; public void onCreate ( Bundle b ) { } @ Override protected void onListItemClick ( ListView l , View v , int position , long id ) { super . onListItemClick ( l , v , position , id ) ; Object o = this . getListAdapter ( ) . getItem ( position ) ; if ( ( ( clientSocket ) == null ) || ( clientSocket . hasQuit ( ) ) ) { <START_BUG> clientSocket = new SocketClient ( null ) ; <END_BUG> clientSocket . execute ( MACIPMap . get ( o . toString ( ) ) ) ; } statusText . setText ( "Getting<seq2seq4repair_space>File<seq2seq4repair_space>List" ) ; this . setListAdapter ( new ArrayAdapter < String > ( this , layout . simple_list_item_1 , new ArrayList < String > ( ) ) ) ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { String filelist ; try { filelist = ( ( String ) ( clientSocket . get ( ) ) ) ; final List < String > files = Arrays . asList ( filelist . split ( "\\n" ) ) ; handle . post ( new Runnable ( ) { @ Override public void run ( ) { This . setListAdapter ( new ArrayAdapter < String > ( This , layout . simple_list_item_1 , files ) ) ; } } ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( ExecutionException e ) { e . printStackTrace ( ) ; } } } ) . start ( ) ; } }
public class Fast { public static void main ( String [ ] args ) { StdDraw . setXscale ( 0 , 32768 ) ; StdDraw . setYscale ( 0 , 32768 ) ; In in = new In ( args [ 0 ] ) ; Point [ ] pointList = new Point [ in . readInt ( ) ] ; Point [ ] pointListNotSorted = new Point [ pointList . length ] ; int x ; int y ; for ( int i = 0 ; i < ( pointList . length ) ; i ++ ) { x = in . readInt ( ) ; y = in . readInt ( ) ; pointList [ i ] = new Point ( x , y ) ; pointListNotSorted [ i ] = new Point ( x , y ) ; pointList [ i ] . draw ( ) ; } <START_BUG> for ( int i = 0 ; i < ( pointList . length ) ; i ++ ) { <END_BUG> Arrays . sort ( pointList , pointListNotSorted [ i ] . SLOPE_ORDER ) ; int index = 0 ; int count = 1 ; for ( int j = 1 ; j < ( pointList . length ) ; j ++ ) { if ( ( pointListNotSorted [ i ] . SLOPE_ORDER . compare ( pointList [ index ] , pointList [ j ] ) ) == 0 ) { count ++ ; if ( count == 3 ) { StdOut . println ( ( ( ( ( ( ( ( pointListNotSorted [ i ] . toString ( ) ) + "<seq2seq4repair_space>-><seq2seq4repair_space>" ) + ( pointList [ index ] . toString ( ) ) ) + "<seq2seq4repair_space>-><seq2seq4repair_space>" ) + ( pointList [ ( index + 1 ) ] . toString ( ) ) ) + "<seq2seq4repair_space>-><seq2seq4repair_space>" ) + ( pointList [ ( index + 2 ) ] . toString ( ) ) ) ) ; pointListNotSorted [ i ] . drawTo ( pointList [ ( ( index + count ) - 1 ) ] ) ; } else if ( count > 3 ) { pointListNotSorted [ i ] . drawTo ( pointList [ ( ( index + count ) - 1 ) ] ) ; } } else { count = 1 ; index = j ; } } } } }
public final Optional < ExecutorService > sharedExecutor ( final C context ) { } public final Optional < Map < String , Probe < ? > > > probeMappings ( final C context ) { } public final Optional < Predicate < Map . Entry < String , Probe < ? > > > > probeFilter ( final C context ) { } public final Optional < ExecutorService > probeExecutor ( final C context ) { } public final Optional < RegularEventListener . DataInjector > dataInjector ( final C context ) { } public final Optional < RegularEventListener . EventValidator > eventValidator ( final C context ) { } public final Optional < RegularEventListener . PersistenceStore > persistenceStore ( final C context ) { } public final Optional < RegularEventListener . SendFailureHandler > sendFailureHandler ( final C context ) { } public final Optional < RegularEventListener . RegisterFailureHandler > registerFailureHandler ( final C context ) { } public final Optional < RegularEventListener . DisposalHook > disposalHook ( final C context ) { } } public static final class RegularConfiguration < C > extends RegularEventListener . AbstractConfiguration < C > { RegularConfiguration ( final RegularEventListener . RegularConfiguration . Builder < C > builder ) { } public static final class Builder < C > extends RegularEventListener . AbstractConfiguration . AbstractBuilder < RegularEventListener . RegularConfiguration . Builder < C > , C > { public Builder ( ) { } @ Override protected RegularEventListener . RegularConfiguration . Builder < C > asSubtype ( ) { } @ Override public RegularEventListener . RegularConfiguration < C > build ( ) { } } public static < C > RegularEventListener . RegularConfiguration . Builder < C > builder ( ) { } } protected final Options defaultOptions ( ) { } protected final Options customOptions ( ) { } protected final Options effectiveOptions ( ) { } protected final void reloadOptions ( ) { } public interface OptionsLoader { public Options loadCustomOptions ( RegularEventListener listener ) { } } public static final class UpdatingOptionsLoader implements RegularEventListener . OptionsLoader { private final ListenerPreferences preferences ; final RegularEventListener . UpdatingOptionsLoader . OptionsReloader reloader ; private UpdatingOptionsLoader ( final ListenerPreferences preferences , final RegularEventListener listener ) { } private static void hook ( final ListenerPreferences preferences , final RegularEventListener listener , final RegularEventListener . UpdatingOptionsLoader . OptionsReloader reloader ) { } public static RegularEventListener . UpdatingOptionsLoader of ( final ListenerPreferences preferences , final RegularEventListener listener ) { } private static final class OptionsReloader implements IEclipsePreferences . IPreferenceChangeListener { private final RegularEventListener listener ; OptionsReloader ( final RegularEventListener listener ) { } public void preferenceChange ( final IEclipsePreferences . PreferenceChangeEvent event ) { } } public Options loadCustomOptions ( final RegularEventListener listener ) { } @ Override public String toString ( ) { } protected Objects . ToStringHelper toStringHelper ( ) { } } private static final class OptionsProvider { private final RegularEventListener . OptionsProvider . DefaultOptions defaults ; private final RegularEventListener . OptionsProvider . CustomOptions custom ; private final RegularEventListener . OptionsProvider . EffectiveOptions effective ; OptionsProvider ( final RegularEventListener listener , final Options defaults ) { } void load ( ) { this . custom . load ( ) ; this . effective . load ( ) ; } private static abstract class AbstractOptions extends ForwardingOptions { AbstractOptions ( ) { } static Options secure ( @ Nullable final Options untrusted ) { } @ Override public final String toString ( ) { } } private static final class DefaultOptions extends RegularEventListener . OptionsProvider . AbstractOptions { private final Options delegate ; DefaultOptions ( final Options untrusted ) { } @ Override protected Options delegate ( ) { } } private static final class CustomOptions extends RegularEventListener . OptionsProvider . AbstractOptions { private final RegularEventListener listener ; @ Nullable private Options delegate ; CustomOptions ( final RegularEventListener listener ) { } void load ( ) { this . delegate = RegularEventListener . OptionsProvider . AbstractOptions . secure ( this . listener . optionsLoader . loadCustomOptions ( this . listener ) ) ; } @ Override protected Options delegate ( ) { } } private static final class EffectiveOptions extends RegularEventListener . OptionsProvider . AbstractOptions { private final RegularEventListener listener ; @ Nullable private Options delegate ; EffectiveOptions ( final RegularEventListener listener ) { } final void load ( ) { <START_BUG> this . delegate = compound ( this . listener . effectiveOptions ( ) , this . listener . defaultOptions ( ) ) ; <END_BUG> } @ Override protected Options delegate ( ) { } } Options defaultOptions ( ) { } Options customOptions ( ) { } Options effectiveOptions ( ) { } } protected void onOptionsReload ( ) { } public interface TimeHelper { public long currentTime ( ) { } public TimeSource wallTimeSource ( ) { } public Stopwatch createStopwatch ( ) { } public Ticker elapsedTimeTicker ( ) { } } private enum SystemTimeHelper implements RegularEventListener . TimeHelper { instance ; public long currentTime ( ) { } public TimeSource wallTimeSource ( ) { } public Stopwatch createStopwatch ( ) { } public Ticker elapsedTimeTicker ( ) { } @ Override public String toString ( ) { } } protected final long currentTime ( ) { } protected final TimeSource wallTimeSource ( ) { } protected final Stopwatch createStopwatch ( ) { } protected final Ticker elapsedTimeTicker ( ) { } @ Override protected final < V > V execute ( final DisplayTask < V > task ) { } @ Override protected final void execute ( final Runnable command ) { } public interface RegisterFailureHandler { public void preRegisterFailure ( RegularEventListener listener , Runnable task , Exception failure ) { } public void postRegisterFailure ( RegularEventListener listener , Runnable task , Exception failure ) { } public void preUnregisterFailure ( RegularEventListener listener , Runnable task , Exception failure ) { } public void postUnregisterFailure ( RegularEventListener listener , Runnable task , Exception failure ) { } }
public class ServerSOContainer extends SOContainer implements ISharedObjectContainerGroupManager { protected IConnectHandlerPolicy connectHandlerPolicy ; public ServerSOContainer ( ISharedObjectContainerConfig config ) { } public boolean isGroupManager ( ) { } public ID getConnectedID ( ) { } public void disconnect ( ) { } public void ejectGroupMember ( ID memberID , Serializable reason ) { } public void ejectAllGroupMembers ( Serializable reason ) { } public void dispose ( ) { } public void connect ( ID groupID , IConnectContext joinContext ) throws ContainerConnectException { } public void setConnectPolicy ( IConnectHandlerPolicy policy ) { } protected void queueContainerMessage ( ContainerMessage message ) throws IOException { } protected void forwardToRemote ( ID from , ID to , ContainerMessage data ) throws IOException { } protected void forwardExcluding ( ID from , ID excluding , ContainerMessage data ) throws IOException { } protected void handleViewChangeMessage ( ContainerMessage mess ) throws IOException { } protected ContainerMessage acceptNewClient ( Socket socket , String target , Serializable data , ISynchAsynchConnection conn ) { } protected Object checkJoin ( SocketAddress saddr , ID fromID , String target , Serializable data ) throws Exception { } protected void handleLeaveGroupMessage ( ContainerMessage mess ) { } protected ID getIDForConnection ( IAsynchConnection conn ) { } protected IAsynchConnection getConnectionForID ( ID memberID ) { } protected ISynchConnection getSynchConnectionForID ( ID memberID ) { } private final void queueToAll ( ContainerMessage message ) { } protected void processDisconnect ( DisconnectEvent e ) { final IAsynchConnection conn = ( ( IAsynchConnection ) ( e . getConnection ( ) ) ) ; ID fromID = null ; synchronized ( getGroupMembershipLock ( ) ) { fromID = getIDForConnection ( conn ) ; if ( fromID == null ) return ; handleLeave ( fromID , conn ) ; } if ( fromID != null ) <START_BUG> fireContainerEvent ( new ContainerDisconnectedEvent ( getID ( ) , fromID ) ) ; <END_BUG> } }
public class SignInFragment extends AbstractFragment implements TextWatcher { private static final String DOT_COM_BASE_URL = "https://wordpress.com" ; private static final String FORGOT_PASSWORD_RELATIVE_URL = "/wp-login.php?action=lostpassword" ; private static final int WPCOM_ERRONEOUS_LOGIN_THRESHOLD = 3 ; private static final String FROM_LOGIN_SCREEN_KEY = "FROM_LOGIN_SCREEN_KEY" ; public static final String ENTERED_URL_KEY = "ENTERED_URL_KEY" ; public static final String ENTERED_USERNAME_KEY = "ENTERED_USERNAME_KEY" ; private EditText mUsernameEditText ; private EditText mPasswordEditText ; private EditText mUrlEditText ; private EditText mTwoStepEditText ; private WPTextView mSignInButton ; private WPTextView mCreateAccountButton ; private WPTextView mAddSelfHostedButton ; private WPTextView mProgressTextSignIn ; private WPTextView mForgotPassword ; private WPTextView mJetpackAuthLabel ; private LinearLayout mBottomButtonsLayout ; private RelativeLayout mUsernameLayout ; private RelativeLayout mPasswordLayout ; private RelativeLayout mProgressBarSignIn ; private RelativeLayout mUrlButtonLayout ; private RelativeLayout mTwoStepLayout ; private LinearLayout mTwoStepFooter ; private ImageView mInfoButton ; private ImageView mInfoButtonSecondary ; private final EmailChecker mEmailChecker ; private boolean mSelfHosted ; private boolean mEmailAutoCorrected ; private boolean mShouldSendTwoStepSMS ; private int mErroneousLogInCount ; private String mUsername ; private String mPassword ; private String mTwoStepCode ; private String mHttpUsername ; private String mHttpPassword ; private Blog mJetpackBlog ; public SignInFragment ( ) { } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { } @ Override public void onResume ( ) { } public void forceSelfHostedMode ( ) { } @ Override public void onConfigurationChanged ( Configuration newConfig ) { } private void initInfoButtons ( View rootView ) { OnClickListener infoButtonListener = new OnClickListener ( ) { @ Override public void onClick ( View v ) { Intent intent = new Intent ( getActivity ( ) , HelpActivity . class ) ; intent . putExtra ( SignInFragment . ENTERED_URL_KEY , EditTextUtils . getText ( mUrlEditText ) ) ; intent . putExtra ( SignInFragment . ENTERED_USERNAME_KEY , EditTextUtils . getText ( mUsernameEditText ) ) ; <START_BUG> intent . putExtra ( ORIGIN_KEY , ORIGIN_SETTINGS_SCREEN_HELP ) ; <END_BUG> startActivity ( intent ) ; } } ; mInfoButton = ( ( ImageView ) ( rootView . findViewById ( info_button ) ) ) ; mInfoButtonSecondary = ( ( ImageView ) ( rootView . findViewById ( info_button_secondary ) ) ) ; mInfoButton . setOnClickListener ( infoButtonListener ) ; mInfoButtonSecondary . setOnClickListener ( infoButtonListener ) ; } private void setSecondaryButtonVisible ( boolean visible ) { } private void moveBottomButtons ( ) { } private final OnClickListener mOnLoginFormClickListener = new OnClickListener ( ) { @ Override public void onClick ( View v ) { } } ; private void autocorrectUsername ( ) { } private boolean isWPComLogin ( ) { } private boolean isJetpackAuth ( ) { } public void setBlog ( Blog blog ) { } private final OnClickListener mCreateAccountListener = new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { } } ; private String getForgotPasswordURL ( ) { } private final OnClickListener mForgotPasswordListener = new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { } } ; protected void onDoneAction ( ) { } private final OnEditorActionListener mEditorAction = new TextView . OnEditorActionListener ( ) { @ Override public boolean onEditorAction ( TextView v , int actionId , KeyEvent event ) { } } ; private void setPrimaryBlog ( JSONObject jsonObject ) { } private void wpcomPostLoginActions ( ) { } private void trackAnalyticsSignIn ( ) { } private void finishCurrentActivity ( final List < Map < String , Object > > userBlogList ) { } private final Callback mFetchBlogListCallback = new Callback ( ) { @ Override public void onSuccess ( final List < Map < String , Object > > userBlogList ) { } @ Override public void onError ( final int messageId , final boolean twoStepCodeRequired , final boolean httpAuthRequired , final boolean erroneousSslCertificate , final String clientResponse ) { } } ; public void showAuthErrorMessage ( ) { } private void setTwoStepAuthVisibility ( boolean isVisible ) { } private void signInAndFetchBlogListWPCom ( ) { } private void signInAndFetchBlogListWPOrg ( ) { } private boolean checkNetworkConnectivity ( ) { } private void signIn ( ) { } private void requestSMSTwoStepCode ( ) { } private final OnClickListener mSignInClickListener = new OnClickListener ( ) { @ Override public void onClick ( View v ) { } } ; @ Override public void afterTextChanged ( Editable s ) { } @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { } private boolean fieldsFilled ( ) { } protected boolean isUserDataValid ( ) { } private void showPasswordError ( int messageId ) { } private void showUsernameError ( int messageId ) { } private void showUrlError ( int messageId ) { } private void showTwoStepCodeError ( int messageId ) { } protected boolean specificShowError ( int messageId ) { } public void signInDotComUser ( String username , String password ) { } protected void startProgress ( String message ) { } protected void endProgress ( ) { } public void askForSslTrust ( ) { } private void askForHttpAuthCredentials ( ) { } protected void showInvalidUsernameOrPasswordDialog ( ) { } protected void handleInvalidUsernameOrPassword ( int messageId ) { } protected void signInError ( int messageId , String clientResponse ) { } private void refreshBlogContent ( Map < String , Object > blogMap ) { } private void refreshFirstBlogContent ( ) { } }
public class SMTPMin { static Category cat = Category . getInstance ( SMTPMin . class ) ; public static void main ( String [ ] argv ) { } static void usage ( String msg ) { } static void init ( String configFile ) { } static void test ( ) { int i = 0 ; SMTPMin . cat . debug ( ( "Message<seq2seq4repair_space>" + ( i ++ ) ) ) ; SMTPMin . cat . debug ( ( "Message<seq2seq4repair_space>" + ( i ++ ) ) , new Exception ( "Just<seq2seq4repair_space>testing." ) ) ; SMTPMin . cat . info ( ( "Message<seq2seq4repair_space>" + ( i ++ ) ) ) ; SMTPMin . cat . warn ( ( "Message<seq2seq4repair_space>" + ( i ++ ) ) ) ; SMTPMin . cat . error ( ( "Message<seq2seq4repair_space>" + ( i ++ ) ) ) ; SMTPMin . cat . log ( Priority . FATAL , ( "Message<seq2seq4repair_space>" + ( i ++ ) ) ) ; <START_BUG> Category . shutdown ( ) ; <END_BUG> Thread . currentThread ( ) . getThreadGroup ( ) . list ( ) ; } }
public class EclipseWorld extends World { public static boolean DEBUG = false ; public AjBuildManager buildManager ; private LookupEnvironment lookupEnvironment ; private Map addedTypeBindings = new HashMap ( ) ; public static EclipseWorld forLookupEnvironment ( LookupEnvironment env ) { } public static EclipseWorld fromScopeLookupEnvironment ( Scope scope ) { } public EclipseWorld ( LookupEnvironment lookupEnvironment , IMessageHandler handler ) { } public Advice concreteAdvice ( AjAttribute . AdviceAttribute attribute , Pointcut pointcut , Member signature ) { } public ConcreteTypeMunger concreteTypeMunger ( ResolvedTypeMunger munger , ResolvedTypeX aspectType ) { } protected ResolvedTypeX resolveObjectType ( TypeX ty ) { } public ResolvedTypeX fromEclipse ( ReferenceBinding binding ) { } public ResolvedTypeX [ ] fromEclipse ( ReferenceBinding [ ] bindings ) { } private static String getName ( TypeBinding binding ) { } public static TypeX fromBinding ( TypeBinding binding ) { } public static TypeX [ ] fromBindings ( TypeBinding [ ] bindings ) { } public static AstNode astForLocation ( IHasPosition location ) { } public Collection getTypeMungers ( ) { } public static ResolvedMember makeResolvedMember ( MethodBinding binding ) { } public static ResolvedMember makeResolvedMember ( FieldBinding binding ) { } public TypeBinding makeTypeBinding ( TypeX typeX ) { TypeBinding ret = ( ( TypeBinding ) ( addedTypeBindings . get ( typeX ) ) ) ; if ( ret != null ) return ret ; if ( typeX . isPrimitive ( ) ) { if ( typeX == ( ResolvedTypeX . BOOLEAN ) ) return BaseTypes . BooleanBinding ; if ( typeX == ( ResolvedTypeX . BYTE ) ) return BaseTypes . ByteBinding ; if ( typeX == ( ResolvedTypeX . CHAR ) ) return BaseTypes . CharBinding ; if ( typeX == ( ResolvedTypeX . DOUBLE ) ) return BaseTypes . DoubleBinding ; if ( typeX == ( ResolvedTypeX . FLOAT ) ) return BaseTypes . FloatBinding ; if ( typeX == ( ResolvedTypeX . INT ) ) return BaseTypes . IntBinding ; if ( typeX == ( ResolvedTypeX . LONG ) ) return BaseTypes . LongBinding ; if ( typeX == ( ResolvedTypeX . SHORT ) ) return BaseTypes . ShortBinding ; if ( typeX == ( ResolvedTypeX . VOID ) ) return BaseTypes . VoidBinding ; throw new RuntimeException ( ( "weird<seq2seq4repair_space>primitive<seq2seq4repair_space>type<seq2seq4repair_space>" + typeX ) ) ; } else if ( typeX . isArray ( ) ) { int dim = 0 ; while ( typeX . isArray ( ) ) { dim ++ ; typeX = typeX . getComponentType ( ) ; } <START_BUG> return new ArrayBinding ( makeTypeBinding ( typeX ) , dim ) ; <END_BUG> } else { ResolvedTypeX rt = typeX . resolve ( this ) ; if ( rt == ( ResolvedTypeX . MISSING ) ) { throw new RuntimeException ( ( "shouldn't<seq2seq4repair_space>be<seq2seq4repair_space>missing:<seq2seq4repair_space>" + typeX ) ) ; } return ( ( EclipseObjectType ) ( rt ) ) . getBinding ( ) ; } } public TypeBinding [ ] makeTypeBindings ( TypeX [ ] types ) { } private ReferenceBinding [ ] makeReferenceBindings ( TypeX [ ] types ) { } public FieldBinding makeFieldBinding ( ResolvedMember member ) { } public MethodBinding makeMethodBinding ( ResolvedMember member ) { } public MethodBinding makeMethodBindingForCall ( Member member ) { } public void finishedCompilationUnit ( CompilationUnitDeclaration unit ) { } public void addTypeBinding ( TypeBinding binding ) { } public Shadow makeShadow ( AstNode location , ReferenceContext context ) { } public Shadow makeShadow ( ReferenceContext context ) { } }
public class ConcurrentFuture < T > implements FutureDone < T > , ResolvableFuture < T > { private static final int MAX_SPINS = 10 ; private AtomicReference < List < ConcurrentFuture . CallbackEntry < T > > > callbacks = new AtomicReference < List < ConcurrentFuture . CallbackEntry < T > > > ( new ArrayList < ConcurrentFuture . CallbackEntry < T > > ( ) ) ; private ConcurrentFuture . Sync result = new ConcurrentFuture . Sync ( ) ; private final AsyncFramework async ; private final AsyncCaller caller ; public ConcurrentFuture ( final AsyncFramework async , final AsyncCaller caller ) { } @ Override public void failed ( Throwable cause ) throws Exception { } @ Override public void resolved ( T result ) throws Exception { } @ Override public void cancelled ( ) throws Exception { } @ Override public boolean resolve ( T result ) { } @ Override public boolean fail ( Throwable cause ) { } @ Override public boolean cancel ( ) { } @ Override public boolean cancel ( boolean mayInterruptIfRunning ) { } @ SuppressWarnings ( "unchecked" ) @ Override public AsyncFuture < T > on ( final FutureDone < ? super T > done ) { } @ SuppressWarnings ( "unchecked" ) @ Override public AsyncFuture < T > onAny ( FutureDone < ? > handle ) { } @ Override public AsyncFuture < T > on ( FutureCancelled cancelled ) { } @ Override public AsyncFuture < T > on ( FutureFinished finishable ) { } @ Override public boolean isDone ( ) { } @ Override public boolean isCancelled ( ) { } @ Override public T get ( ) throws InterruptedException , ExecutionException { } @ Override public T getNow ( ) throws ExecutionException { } @ Override public T get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { } @ SuppressWarnings ( "unchecked" ) private T checkState ( ) throws CancellationException , ExecutionException { } @ Override public < C > AsyncFuture < C > transform ( Transform < ? super T , ? extends C > transform ) { } @ Override public < C > AsyncFuture < C > transform ( final LazyTransform < ? super T , ? extends C > transform ) { } @ Override public AsyncFuture < T > error ( Transform < Throwable , ? extends T > transform ) { } @ Override public AsyncFuture < T > error ( LazyTransform < Throwable , ? extends T > transform ) { } @ Override public AsyncFuture < T > cancelled ( Transform < Void , ? extends T > transform ) { } @ Override public AsyncFuture < T > cancelled ( LazyTransform < Void , ? extends T > transform ) { } private boolean add ( byte type , Object callback ) { } @ AllArgsConstructor private static class CallbackEntry < T > { private static final byte DONE = 0 ; private static final byte FINISHED = 1 ; private static final byte CANCELLED = 2 ; private final byte type ; private final Object callback ; @ SuppressWarnings ( "unchecked" ) private void resolved ( AsyncCaller caller , T result ) { } @ SuppressWarnings ( "unchecked" ) private void failed ( AsyncCaller caller , Throwable error ) { } @ SuppressWarnings ( "unchecked" ) private void cancelled ( AsyncCaller caller ) { } } private static class Sync extends AbstractQueuedSynchronizer { private static final int RUNNING = 0 ; private static final int RESULT = 1 ; private static final int RESOLVED = 16 ; private static final int FAILED = 17 ; private static final int CANCELLED = 18 ; private static final long serialVersionUID = - 5044031197562766649L ; private Object result ; @ Override protected int tryAcquireShared ( int ignored ) { <START_BUG> return ( getState ( ) ) != 0 ? 1 : - 1 ; <END_BUG> } @ Override protected boolean tryReleaseShared ( int state ) { } private boolean complete ( int state , Object result ) { } public boolean acquire ( long nanos ) throws InterruptedException { } public void acquire ( ) throws InterruptedException { } public int state ( ) { } public int poll ( ) { } public Object result ( ) { } } }
public abstract class Evaluator { EvaluationContext context ; INameEnvironment environment ; Map options ; IRequestor requestor ; IProblemFactory problemFactory ; Evaluator ( EvaluationContext context , INameEnvironment environment , Map options , IRequestor requestor , IProblemFactory problemFactory ) { } protected abstract void addEvaluationResultForCompilationProblem ( Map resultsByIDs , IProblem problem , char [ ] cuSource ) { } protected EvaluationResult [ ] evaluationResultsForCompilationProblems ( CompilationResult result , char [ ] cuSource ) { } ClassFile [ ] getClasses ( ) { final char [ ] source = getSource ( ) ; final ArrayList classDefinitions = new ArrayList ( ) ; class CompilerRequestor implements ICompilerRequestor { boolean hasErrors = false ; public void acceptResult ( CompilationResult result ) { if ( result . hasProblems ( ) ) { EvaluationResult [ ] evalResults = evaluationResultsForCompilationProblems ( result , source ) ; for ( int i = 0 ; i < ( evalResults . length ) ; i ++ ) { EvaluationResult evalResult = evalResults [ i ] ; IProblem [ ] problems = evalResult . getProblems ( ) ; for ( int j = 0 ; j < ( problems . length ) ; j ++ ) { Evaluator . this . requestor . acceptProblem ( problems [ j ] , evalResult . getEvaluationID ( ) , evalResult . getEvaluationType ( ) ) ; } } } if ( result . hasErrors ( ) ) { <START_BUG> hasErrors = true ; <END_BUG> } else { ClassFile [ ] classFiles = result . getClassFiles ( ) ; for ( int i = 0 ; i < ( classFiles . length ) ; i ++ ) { ClassFile classFile = classFiles [ i ] ; classDefinitions . add ( classFile ) ; } } } } CompilerRequestor compilerRequestor = new CompilerRequestor ( ) ; Compiler compiler = getCompiler ( compilerRequestor ) ; compiler . compile ( new ICompilationUnit [ ] { new ICompilationUnit ( ) { public char [ ] getFileName ( ) { return CharOperation . concat ( Evaluator . this . getClassName ( ) , SuffixConstants . SUFFIX_java ) ; } public char [ ] getContents ( ) { return source ; } public char [ ] getMainTypeName ( ) { return Evaluator . this . getClassName ( ) ; } public char [ ] [ ] getPackageName ( ) { return null ; } } } ) ; if ( compilerRequestor . hasErrors ) { return null ; } else { ClassFile [ ] result = new ClassFile [ classDefinitions . size ( ) ] ; classDefinitions . toArray ( result ) ; return result ; } } protected abstract char [ ] getClassName ( ) { } Compiler getCompiler ( ICompilerRequestor compilerRequestor ) { } protected abstract char [ ] getSource ( ) { } }
@ ServiceProvider ( service = CategoryBuilder . class ) public class PartitionCountBuilder implements CategoryBuilder { private static final Category PARTITION_COUNT = new Category ( NbBundle . getMessage ( PartitionCountBuilder . class , "PartitionCountBuilder.name" ) , null , FilterLibrary . ATTRIBUTES ) ; @ Override public Category getCategory ( ) { } @ Override public FilterBuilder [ ] getBuilders ( ) { } private static class PartitionCountFilterBuilder extends AbstractAttributeFilterBuilder { private final AppearanceModel model ; public PartitionCountFilterBuilder ( Column column , AppearanceModel model ) { } @ Override public PartitionCountBuilder . PartitionCountFilter getFilter ( ) { } @ Override public JPanel getPanel ( Filter filter ) { } } public static class PartitionCountFilter extends AbstractAttributeFilter implements RangeFilter { protected AppearanceModel appearanceModel ; private Range range ; protected Partition partition ; public PartitionCountFilter ( Column column , AppearanceModel model ) { } @ Override public boolean init ( Graph graph ) { } @ Override public boolean evaluate ( Graph graph , Element element ) { <START_BUG> Object p = partition . getValue ( element ) ; <END_BUG> if ( p != null ) { int partCount = partition . count ( p ) ; return range . isInRange ( partCount ) ; } return false ; } @ Override public void finish ( ) { } @ Override public Number [ ] getValues ( Graph graph ) { } @ Override public FilterProperty getRangeProperty ( ) { } public Range getRange ( ) { } public void setRange ( Range range ) { } } }
public class LocalVariable extends JavaElement implements ILocalVariable , ISourceReference { public int declarationSourceStart ; public int declarationEnd ; public int nameStart ; public int nameEnd ; public LocalVariable ( JavaElement parent , String name , int declarationSourceStart , int declarationEnd , int nameStart , int nameEnd ) { } protected void closing ( Object info ) throws JavaModelException { } protected Object createElementInfo ( ) { } public boolean equals ( Object o ) { } protected void generateInfos ( Object info , HashMap newElements , IProgressMonitor pm ) throws JavaModelException { } public IJavaElement getHandleFromMemento ( String token , StringTokenizer memento , WorkingCopyOwner owner ) { } public String getHandleMemento ( ) { } protected char getHandleMementoDelimiter ( ) { } public IResource getCorrespondingResource ( ) throws JavaModelException { } public int getElementType ( ) { } public ISourceRange getNameRange ( ) { } public IPath getPath ( ) { } public IResource getResource ( ) { } public String getSource ( ) throws JavaModelException { <START_BUG> IOpenable openable = getOpenableParent ( ) ; <END_BUG> IBuffer buffer = openable . getBuffer ( ) ; if ( buffer == null ) { return null ; } ISourceRange range = getSourceRange ( ) ; int offset = range . getOffset ( ) ; int length = range . getLength ( ) ; if ( ( offset == ( - 1 ) ) || ( length == 0 ) ) { return null ; } try { return buffer . getText ( offset , length ) ; } catch ( RuntimeException e ) { return null ; } } public ISourceRange getSourceRange ( ) throws JavaModelException { } public IResource getUnderlyingResource ( ) throws JavaModelException { } public int hashCode ( ) { } }
public class DropTargetEffect extends DropTargetAdapter { Control control ; public DropTargetEffect ( Control control ) { } public Control getControl ( ) { } public Widget getItem ( int x , int y ) { } Widget getItem ( Table table , int x , int y ) { } Widget getItem ( Tree tree , int x , int y ) { Point point = new Point ( x , y ) ; point = tree . toControl ( point ) ; TreeItem item = tree . getItem ( point ) ; if ( item == null ) { Rectangle area = tree . getClientArea ( ) ; if ( area . contains ( point ) ) { int treeBottom = ( area . y ) + ( area . height ) ; item = tree . getTopItem ( ) ; while ( item != null ) { Rectangle rect = item . getBounds ( ) ; int itemBottom = ( rect . y ) + ( rect . height ) ; <START_BUG> if ( ( ( rect . y ) <= ( point . y ) ) && ( ( point . y ) <= itemBottom ) ) <END_BUG> return item ; if ( itemBottom > treeBottom ) break ; item = nextItem ( tree , item ) ; } return null ; } } return item ; } TreeItem nextItem ( Tree tree , TreeItem item ) { } TreeItem previousItem ( Tree tree , TreeItem item ) { } }
public class DivertRemove extends AbstractRemoveStepHandler implements DescriptionProvider { public static final DivertRemove INSTANCE = new DivertRemove ( ) ; private DivertRemove ( ) { } @ Override protected void performRemove ( OperationContext context , ModelNode operation , ModelNode model ) throws OperationFailedException { } @ Override protected void recoverServices ( OperationContext context , ModelNode operation , ModelNode model ) throws OperationFailedException { final ServiceRegistry registry = context . getServiceRegistry ( true ) ; final ServiceName hqServiceName = MessagingServices . getHornetQServiceName ( PathAddress . pathAddress ( operation . get ( OP_ADDR ) ) ) ; final ServiceController < ? > hqService = registry . getService ( hqServiceName ) ; if ( ( hqService != null ) && ( ( hqService . getState ( ) ) == ( State . UP ) ) ) { final String name = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) . getLastElement ( ) . getValue ( ) ; <START_BUG> final DivertConfiguration divertConfiguration = DivertAdd . createDivertConfiguration ( name , model ) ; <END_BUG> HornetQServer server = HornetQServer . class . cast ( hqService . getValue ( ) ) ; DivertAdd . createDivert ( name , divertConfiguration , server . getHornetQServerControl ( ) ) ; } } @ Override public ModelNode getModelDescription ( Locale locale ) { } }
public class Hashtable { private int size ; private int [ ] table ; private int collisionMethod ; private int collision ; private int objects ; public Hashtable ( int size , int collisionM ) { } public boolean input ( int in ) { } public int getCollision ( ) { } public long [ ] search ( int in ) { long startTime ; int hash ; int j ; int i ; long [ ] time = new long [ 3 ] ; startTime = System . nanoTime ( ) ; hash = in % ( size ) ; if ( ( collisionMethod ) == 0 ) { j = 0 ; time [ 0 ] = ( linSearch ( j , in , hash ) ) - startTime ; } else if ( ( collisionMethod ) == 1 ) { startTime = System . nanoTime ( ) ; j = 0 ; i = 0 ; <START_BUG> time [ 1 ] = ( quadSearch ( j , i , in , hash ) ) - startTime ; <END_BUG> } else if ( ( collisionMethod ) == 2 ) { startTime = System . nanoTime ( ) ; j = 0 ; time [ 2 ] = ( doubleHashSearch ( j , in , hash ) ) - startTime ; } return time ; } public int linSon ( int j , int hash ) { } public int quadSon ( int i , int hash ) { } public int doubleHashSon ( int j , int in , int hash ) { } public long linSearch ( int j , int in , int hash ) { } public long quadSearch ( int i , int in , int hash ) { } public long doubleHashSearch ( int j , int in , int hash ) { } @ Override public String toString ( ) { } }
public class TextChatComposite extends Composite { public static final Trace trace = Trace . create ( "textchatcomposite" ) ; protected static final int DEFAULT_INPUT_HEIGHT = 25 ; protected static final int DEFAULT_INPUT_SEPARATOR = 5 ; protected String TEXT_INPUT_INIT = MessageLoader . getString ( "TextChatComposite.textinputinit" ) ; protected Color meColor = null ; protected Color otherColor = null ; protected Color systemColor = null ; protected StyledText styledText ; protected TextViewer textoutput ; protected Text textinput ; protected int [ ] sashWeights = new int [ ] { 90 , 10 } ; protected ChatLayout cl = null ; protected boolean isTyping ; protected String initText ; protected ITextInputHandler inputHandler ; SimpleDateFormat df = new SimpleDateFormat ( "hh:mm<seq2seq4repair_space>a" ) ; protected IUser localUser ; protected IUser remoteUser ; protected boolean showTimestamp = true ; private Action outputClear = null ; private Action outputCopy = null ; private Action outputPaste = null ; private Action outputSelectAll = null ; public TextChatComposite ( Composite parent , int style , String initText , ITextInputHandler handler , IUser localUser , IUser remoteUser ) { } private void makeActions ( ) { } protected void outputClear ( ) { } protected void outputCopy ( ) { } protected void outputPaste ( ) { } protected void outputSelectAll ( ) { } private void hookContextMenu ( ) { } private void fillContextMenu ( IMenuManager manager ) { } public void setLocalUser ( IUser newUser ) { } public void setRemoteUser ( IUser remoteUser ) { } public IUser getRemoteUser ( ) { } protected String getCurrentDateTime ( ) { } private String makeLineWithTimestamp ( String line ) { } public IUser getLocalUser ( ) { } public void appendText ( ChatLine text ) { } protected void handleKeyPressed ( KeyEvent evt ) { <START_BUG> if ( ( evt . keyCode ) == ( SWT . CR ) ) { <END_BUG> handleEnter ( ) ; } } protected void handleEnter ( ) { } protected void clearInput ( ) { } protected void sendTextLineInput ( String text ) { } protected void sendStartedTyping ( ) { } protected String getShellName ( ) { } public void dispose ( ) { } protected void setDisposed ( ) { } protected void checkSubclass ( ) { } }
public class PreuTipusHabitacio { private float preu ; private ITipusHabPricingStrategy strategy ; private TipusHabitacio tipusHab ; public PreuTipusHabitacio ( ) { } public PreuTipusHabitacio ( float preu , ITipusHabPricingStrategy strategy , TipusHabitacio tipusHab ) { } public float getPreu ( ) { } public void setPreu ( float preu ) { } public ITipusHabPricingStrategy getStrategy ( ) { } public void setStrategy ( ITipusHabPricingStrategy strategy ) { } public TipusHabitacio getTipusHab ( ) { } public void setTipusHab ( TipusHabitacio tipusHab ) { } public float obtePreu ( ) { } public boolean esDelTipus ( String tipusHab ) { } public TipusHabInformation obteDisponiblesDelTipus ( Date dIni , Date dFi , int numOcup , String nomH ) { <START_BUG> TipusHabInformation thi = this . tipusHab . obteDisponibles ( dIni , dFi , nomH ) ; <END_BUG> thi . setPreu ( strategy . obtePreuReal ( this ) ) ; return thi ; } public int obteHabitacio ( Date dIni , Date dFi , String nomH ) { } }
public class RequestHandlerStackTest extends BaseRequestHandlerStackTest { public RequestHandlerStackTest ( ) { } private boolean testFlag1 ; private boolean testFlag2 ; private boolean testFlag3 ; private boolean testFlag4 ; private boolean detachedFlag1 ; private boolean detachedFlag2 ; private boolean detachedFlag3 ; private boolean detachedFlag4 ; private void initFlags ( ) { } public void test1 ( ) { initFlags ( ) ; final Response originalResponse = newResponse ( ) ; final RequestHandlerStack stack = newStack ( originalResponse ) ; final IRequestHandler handler3 = new IRequestHandler ( ) { public void respond ( IRequestCycle requestCycle ) { testFlag3 = false ; } public void detach ( IRequestCycle requestCycle ) { detachedFlag3 = true ; } } ; final IRequestHandler handler2 = new IRequestHandler ( ) { public void respond ( IRequestCycle requestCycle ) { testFlag2 = false ; stack . replaceAllRequestHandlers ( handler3 ) ; testFlag2 = true ; } public void detach ( IRequestCycle requestCycle ) { detachedFlag2 = true ; } } ; final IRequestHandler handler1 = new IRequestHandler ( ) { public void respond ( IRequestCycle requestCycle ) { testFlag1 = false ; Response resp = newResponse ( ) ; stack . setResponse ( resp ) ; stack . executeRequestHandler ( handler2 ) ; assertEquals ( stack . getResponse ( ) , resp ) ; testFlag1 = true ; } public void detach ( IRequestCycle requestCycle ) { detachedFlag1 = true ; } } ; stack . executeRequestHandler ( handler1 ) ; assertEquals ( stack . getResponse ( ) , originalResponse ) ; stack . detach ( ) ; <START_BUG> assertTrue ( testFlag1 ) ; <END_BUG> assertFalse ( testFlag2 ) ; assertFalse ( testFlag3 ) ; assertTrue ( detachedFlag1 ) ; assertTrue ( detachedFlag2 ) ; assertTrue ( detachedFlag3 ) ; } public void test2 ( ) { } public void test3 ( ) { } }
public class GetBinary implements DataDownloader { private int maxRetry = 3 ; private int readTimeoutInMilli = 10000 ; private static final Logger logger = LoggerFactory . getLogger ( GetBinary . class ) ; private static final String GET_METHOD = "GET" ; private static final String HEAD_METHOD = "HEAD" ; public GetBinary ( ) { } public Long getLenght ( URL url ) throws PageLoadException , IOException { } public Map < String , List < String > > getHeader ( URL url ) throws IOException { } public byte [ ] getRange ( URL url , int start , long l ) throws PageLoadException , IOException { } public byte [ ] getViaHttp ( String url ) throws PageLoadException , IOException { } public byte [ ] getViaHttp ( URL url ) throws PageLoadException , IOException { } private HttpURLConnection connect ( URL url , String method , boolean isOutput ) throws IOException , ProtocolException { } private void closeHttpConnection ( HttpURLConnection httpCon ) { } protected boolean retry ( URL url , ByteBuffer buffer , long contentLength ) throws PageLoadException , IOException { int failCount = 0 ; while ( failCount < ( maxRetry ) ) { Object [ ] logData = new Object [ ] { url , ( maxRetry ) - failCount , buffer . position ( ) , buffer . limit ( ) } ; GetBinary . logger . info ( "Retrying<seq2seq4repair_space>{},<seq2seq4repair_space>{}<seq2seq4repair_space>tries<seq2seq4repair_space>left,<seq2seq4repair_space>got<seq2seq4repair_space>{}<seq2seq4repair_space>of<seq2seq4repair_space>{}<seq2seq4repair_space>bytes" , logData ) ; try { failCount ++ ; <START_BUG> byte [ ] data = getRange ( url , buffer . position ( ) , ( contentLength - 1 ) ) ; <END_BUG> buffer . put ( data ) ; failCount -- ; } catch ( PageLoadException ple ) { GetBinary . logger . warn ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>load<seq2seq4repair_space>page<seq2seq4repair_space>with<seq2seq4repair_space>{}<seq2seq4repair_space>during<seq2seq4repair_space>retry<seq2seq4repair_space>for<seq2seq4repair_space>{}" , ple . getMessage ( ) , url ) ; } catch ( IOException ioe ) { GetBinary . logger . warn ( "Connection<seq2seq4repair_space>issue<seq2seq4repair_space>({})<seq2seq4repair_space>during<seq2seq4repair_space>retry<seq2seq4repair_space>for<seq2seq4repair_space>{}" , ioe . getMessage ( ) , url ) ; } if ( ! ( buffer . hasRemaining ( ) ) ) { break ; } if ( failCount >= ( maxRetry ) ) { GetBinary . logger . warn ( "Out<seq2seq4repair_space>of<seq2seq4repair_space>retries<seq2seq4repair_space>for<seq2seq4repair_space>{},<seq2seq4repair_space>giving<seq2seq4repair_space>up..." , url ) ; return false ; } } return true ; } public int getMaxRetry ( ) { } public void setMaxRetry ( int maxRetry ) { } public boolean setReadTimeout ( int milliSeconds ) { } @ Override public byte [ ] download ( URL url ) throws PageLoadException , IOException { } }
public class VirtualFolder extends MessageFolder { protected int nextUid ; protected HeaderList headerList ; public VirtualFolder ( FolderItem item , String path ) { } public VirtualFolder ( String name , String type , String path ) { } protected Object generateNextUid ( ) { } public void setNextUid ( int next ) { } public JDialog showFilterDialog ( AbstractMailFrameController frameController ) { } public boolean exists ( Object uid ) throws Exception { } public HeaderList getHeaderList ( ) throws Exception { } public void addSearchToHistory ( ) throws Exception { VirtualFolder searchFolder = ( ( VirtualFolder ) ( treeModel . getFolder ( 106 ) ) ) ; if ( ! ( searchFolder . equals ( this ) ) ) { return ; } if ( ( searchFolder . getChildCount ( ) ) >= 10 ) { MessageFolder child = ( ( MessageFolder ) ( searchFolder . getChildAt ( 0 ) ) ) ; child . removeFromParent ( ) ; } String name = "search<seq2seq4repair_space>result" ; VirtualFolder newFolder = null ; try { newFolder = ( ( VirtualFolder ) ( FolderFactory . getInstance ( ) . createChild ( searchFolder , name , "VirtualFolder" ) ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return ; } if ( newFolder == null ) { return ; } int uid = getFolderItem ( ) . getInteger ( "property" , "source_uid" ) ; boolean includes = getFolderItem ( ) . getBoolean ( "property" , "include_subfolders" ) ; FolderItem newFolderItem = newFolder . getFolderItem ( ) ; newFolderItem . set ( "property" , "source_uid" , uid ) ; newFolderItem . set ( "property" , "include_subfolders" , includes ) ; newFolderItem . getElement ( "filter" ) . removeFromParent ( ) ; newFolderItem . getRoot ( ) . addElement ( ( ( XmlElement ) ( getFolderItem ( ) . getElement ( "filter" ) . clone ( ) ) ) ) ; FilterCriteria newc = new Filter ( getFolderItem ( ) . getElement ( "filter" ) ) . getFilterRule ( ) . get ( 0 ) ; StringBuffer buf = new StringBuffer ( ) ; if ( newc . getType ( ) . equalsIgnoreCase ( "flags" ) ) { System . out . println ( "flags<seq2seq4repair_space>found" ) ; buf . append ( newc . getType ( ) ) ; buf . append ( "<seq2seq4repair_space>(" ) ; buf . append ( newc . getCriteriaString ( ) ) ; buf . append ( "<seq2seq4repair_space>" ) ; buf . append ( newc . getPattern ( ) ) ; buf . append ( ")" ) ; } else if ( newc . getType ( ) . equalsIgnoreCase ( "custom<seq2seq4repair_space>headerfield" ) ) { buf . append ( newc . getHeaderItemString ( ) ) ; buf . append ( "<seq2seq4repair_space>(" ) ; buf . append ( newc . getCriteriaString ( ) ) ; buf . append ( "<seq2seq4repair_space>" ) ; buf . append ( newc . getPattern ( ) ) ; buf . append ( ")" ) ; } else { buf . append ( newc . getType ( ) ) ; buf . append ( "<seq2seq4repair_space>(" ) ; buf . append ( newc . getCriteriaString ( ) ) ; buf . append ( "<seq2seq4repair_space>" ) ; buf . append ( newc . getPattern ( ) ) ; buf . append ( ")" ) ; } <START_BUG> newFolder . renameFolder ( buf . toString ( ) ) ; <END_BUG> treeModel . nodeStructureChanged ( searchFolder ) ; treeModel . nodeChanged ( newFolder ) ; } protected void applySearch ( ) throws Exception { } protected void applySearch ( MessageFolder parent , Filter filter ) throws Exception { } public DefaultSearchEngine getSearchEngine ( ) { } public Filter getFilter ( ) { } public Object getVirtualUid ( MessageFolder parent , Object uid ) throws Exception { } public void add ( ColumbaHeader header , MessageFolder f , Object uid ) throws Exception { } public void markMessage ( Object [ ] uids , int variant ) throws Exception { } protected void removeMessage ( Object uid ) throws Exception { } public MimePart getMimePart ( Object uid , Integer [ ] address ) throws Exception { } public MimeTree getMimePartTree ( Object uid ) throws Exception { } public ColumbaHeader getMessageHeader ( Object uid ) throws Exception { } public ColumbaMessage getMessage ( Object uid , WorkerStatusController worker ) throws Exception { } public Object [ ] searchMessages ( Filter filter , Object [ ] uids ) throws Exception { } public Object [ ] searchMessages ( Filter filter ) throws Exception { } public String getDefaultChild ( ) { } public static XmlElement getDefaultProperties ( ) { } public FolderCommandReference [ ] getCommandReference ( FolderCommandReference [ ] r ) { } public boolean tryToGetLock ( Object locker ) { } public Object [ ] getUids ( ) throws Exception { } public Object addMessage ( InputStream in ) throws Exception { } public Object getAttribute ( Object uid , String key ) throws Exception { } public Flags getFlags ( Object uid ) throws Exception { } public Header getHeaderFields ( Object uid , String [ ] keys ) throws Exception { } public InputStream getMessageSourceStream ( Object uid ) throws Exception { } public InputStream getMimePartBodyStream ( Object uid , Integer [ ] address ) throws Exception { } public InputStream getMimePartSourceStream ( Object uid , Integer [ ] address ) throws Exception { } public boolean supportsAddMessage ( ) { } public boolean supportsAddFolder ( AbstractFolder newFolder ) { } public void innerCopy ( MailboxInterface destFolder , Object [ ] uids ) { } public void setAttribute ( Object uid , String key , Object value ) throws Exception { } public Attributes getAttributes ( Object uid ) throws Exception { } public Object addMessage ( InputStream in , Attributes attributes ) throws Exception { } public HeaderListStorage getHeaderListStorage ( ) { } }
class WebConnectorMetrics implements OperationStepHandler { static WebConnectorMetrics INSTANCE = new WebConnectorMetrics ( ) ; protected static final SimpleAttributeDefinition BYTES_SENT = new org . jboss . as . controller . SimpleAttributeDefinitionBuilder ( Constants . BYTES_SENT , org . jboss . dmr . ModelType . INT , true ) . setStorageRuntime ( ) . build ( ) ; protected static final SimpleAttributeDefinition BYTES_RECEIVED = new org . jboss . as . controller . SimpleAttributeDefinitionBuilder ( Constants . BYTES_RECEIVED , org . jboss . dmr . ModelType . INT , true ) . setStorageRuntime ( ) . build ( ) ; protected static final SimpleAttributeDefinition PROCESSING_TIME = new org . jboss . as . controller . SimpleAttributeDefinitionBuilder ( Constants . PROCESSING_TIME , org . jboss . dmr . ModelType . INT , true ) . setStorageRuntime ( ) . build ( ) ; protected static final SimpleAttributeDefinition ERROR_COUNT = new org . jboss . as . controller . SimpleAttributeDefinitionBuilder ( Constants . ERROR_COUNT , org . jboss . dmr . ModelType . INT , true ) . setStorageRuntime ( ) . build ( ) ; protected static final SimpleAttributeDefinition MAX_TIME = new org . jboss . as . controller . SimpleAttributeDefinitionBuilder ( Constants . MAX_TIME , org . jboss . dmr . ModelType . INT , true ) . setStorageRuntime ( ) . build ( ) ; protected static final SimpleAttributeDefinition REQUEST_COUNT = new org . jboss . as . controller . SimpleAttributeDefinitionBuilder ( Constants . REQUEST_COUNT , org . jboss . dmr . ModelType . INT , true ) . setStorageRuntime ( ) . build ( ) ; @ Deprecated static final String [ ] ATTRIBUTES_OLD = new String [ ] { Constants . BYTES_SENT , Constants . BYTES_RECEIVED , Constants . PROCESSING_TIME , Constants . ERROR_COUNT , Constants . MAX_TIME , Constants . REQUEST_COUNT } ; static final SimpleAttributeDefinition [ ] ATTRIBUTES = new SimpleAttributeDefinition [ ] { WebConnectorMetrics . BYTES_SENT , WebConnectorMetrics . BYTES_RECEIVED , WebConnectorMetrics . PROCESSING_TIME , WebConnectorMetrics . ERROR_COUNT , WebConnectorMetrics . MAX_TIME , WebConnectorMetrics . REQUEST_COUNT } ; @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { if ( context . isNormalServer ( ) ) { context . addStep ( new OperationStepHandler ( ) { @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { final PathAddress address = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) ; final String name = address . getLastElement ( ) . getValue ( ) ; final String attributeName = operation . require ( NAME ) . asString ( ) ; final ServiceController < ? > controller = context . getServiceRegistry ( false ) . getService ( JBOSS_WEB_CONNECTOR . append ( name ) ) ; if ( controller != null ) { try { final Connector connector = ( ( Connector ) ( controller . getValue ( ) ) ) ; final ModelNode result = context . getResult ( ) ; if ( ( ( connector . getProtocolHandler ( ) ) != null ) && ( ( connector . getProtocolHandler ( ) . getRequestGroupInfo ( ) ) != null ) ) { RequestGroupInfo info = connector . getProtocolHandler ( ) . getRequestGroupInfo ( ) ; if ( Constants . BYTES_SENT . equals ( attributeName ) ) { result . set ( ( "" + ( info . getBytesSent ( ) ) ) ) ; } else if ( Constants . BYTES_RECEIVED . equals ( attributeName ) ) { result . set ( ( "" + ( info . getBytesReceived ( ) ) ) ) ; } else if ( Constants . PROCESSING_TIME . equals ( attributeName ) ) { result . set ( ( "" + ( info . getProcessingTime ( ) ) ) ) ; } else if ( Constants . ERROR_COUNT . equals ( attributeName ) ) { result . set ( ( "" + ( info . getErrorCount ( ) ) ) ) ; } else if ( Constants . MAX_TIME . equals ( attributeName ) ) { result . set ( ( "" + ( info . getMaxTime ( ) ) ) ) ; } else if ( Constants . REQUEST_COUNT . equals ( attributeName ) ) { result . set ( ( "" + ( info . getRequestCount ( ) ) ) ) ; } } } catch ( Exception e ) { throw new OperationFailedException ( new ModelNode ( ) . set ( WebMessages . MESSAGES . failedToGetMetrics ( e . getMessage ( ) ) ) ) ; } } else { context . getResult ( ) . set ( WebMessages . MESSAGES . noMetricsAvailable ( ) ) ; } context . completeStep ( NOOP_ROLLBACK_HANDLER ) ; } } , RUNTIME ) ; } else { context . getResult ( ) . set ( WebMessages . MESSAGES . noMetricsAvailable ( ) ) ; } <START_BUG> context . completeStep ( NOOP_ROLLBACK_HANDLER ) ; <END_BUG> } }
public class Route implements Serializable { private static final long serialVersionUID = 1L ; protected LinkedList < RouteWaypoint > waypoints = new LinkedList < RouteWaypoint > ( ) ; protected String name ; protected String departure ; protected String destination ; protected boolean visible = true ; protected Date starttime = null ; protected long [ ] ttgs = null ; protected double [ ] dtgs = null ; protected Long totalTtg = null ; protected Double totalDtg = null ; protected List < Date > etas = null ; protected MetocForecast metocForecast ; protected Date metocStarttime = null ; protected Date metocEta = null ; protected RouteMetocSettings routeMetocSettings ; public Route ( ) { } public Route ( Route orig ) { } public Route copy ( ) { } public Route reverse ( ) { } public Double getWpRng ( int index ) { } public double getWpRngSum ( int index ) { } public Double getWpBrg ( RouteWaypoint routeWaypoint ) { } public Long getWpTtg ( int index ) { } public Date getWpEta ( int index ) { } public LinkedList < RouteWaypoint > getWaypoints ( ) { } public void setWaypoints ( LinkedList < RouteWaypoint > waypoints ) { } public String getName ( ) { } public void setName ( String name ) { } public String getDeparture ( ) { } public void setDeparture ( String departure ) { } public String getDestination ( ) { } public void setDestination ( String destination ) { } public boolean isVisible ( ) { } public void setVisible ( boolean visible ) { } public Date getStarttime ( ) { } public void setStarttime ( Date starttime ) { } public void adjustStartTime ( ) { } public MetocForecast getMetocForecast ( ) { } public void setMetocForecast ( MetocForecast metocForecast ) { } public boolean isMetocValid ( long tolerance ) { } protected boolean isMetocValid ( Date eta , long tolerance ) { } public void removeMetoc ( ) { } public RouteMetocSettings getRouteMetocSettings ( ) { } public void setRouteMetocSettings ( RouteMetocSettings routeMetocSettings ) { } public Long getTtg ( ) { } public Date getEta ( Date starttime ) { } public Double getDtg ( ) { } public Date getEta ( ) { } protected boolean isLastWaypoint ( int index ) { <START_BUG> return index == ( ( waypoints . size ( ) ) - 1 ) ; <END_BUG> } public void calcValues ( boolean force ) { } protected void calcValues ( ) { } public void calcAllWpEta ( ) { } public boolean saveToFile ( File file ) { } public boolean deleteWaypoint ( int index ) { } public void createWaypoint ( RouteLeg routeLeg , GeoLocation position ) { } public RouteWaypoint createWaypoint ( RouteWaypoint waypoint , GeoLocation position ) { } public void appendWaypoint ( ) { } public boolean isPointWithingBBox ( GeoLocation point ) { } @ Override public String toString ( ) { } }
public class Wandler implements Spell , ContentHandler { private XMLReader parser ; private Locator locator ; private BufferedWriter out ; private boolean xhtml = false ; private boolean preserve = false ; private boolean startUnderConstruction = false ; private boolean hideEntitiesAndCharacterReferencesFromSax = false ; private long calls = 0 ; private long lastStart = - 1 ; private static final Set < String > emptyElements = new HashSet < String > ( Arrays . asList ( "area" , "base" , "basefont" , "br" , "col" , "hr" , "img" , "input" , "isindex" , "link" , "meta" , "param" ) ) ; private ArchSpell rootSpell = new ArchSpell ( new Scroll ( ) ) ; private Resources resources = new Resources ( ) { public Reader open ( String file ) throws IOException { } } ; private MagicReader magic = new MagicReader ( null ) ; public static volatile boolean debug = false ; protected Wandler ( XMLReader xmlReader ) { } protected Wandler ( ) { } public static Wandler forXHTML ( ) { } public static Wandler forHTML ( ) { } public static XMLReader getXHTMLParser ( ) throws SAXException { } public static XMLReader getHTMLParser ( ) { } public XMLReader getParser ( ) { } public void reset ( ) { } @ Override public Spell clone ( ) { } public void setResources ( Resources resources ) { } public Resources getResources ( ) { } public Wandler getWandler ( ) { } public boolean hierarchyContains ( Spell spell ) { } protected boolean preserveSpace ( String localName ) { } public void wandle ( Reader in , Writer out ) { } public void startElement ( String name , Attribute ... attributes ) { } public void startElement ( String name , Attributes attributes ) { } public void endElement ( String name ) { } public void writeCharacters ( char [ ] characters , int offset , int length , boolean safe ) { } protected void writeSanitized ( char [ ] chars , int offset , int length ) { } protected String sanitize ( char ch ) { } public void writeString ( String string , boolean safe ) { } public void startDocument ( ) throws SAXException { } public void endDocument ( ) throws SAXException { } public void startElement ( String uri , String localName , String qName , Attributes atts ) throws SAXException { try { <START_BUG> rootSpell . startElement ( localName , atts ) ; <END_BUG> } catch ( Exception e ) { throw new SAXException ( ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>start<seq2seq4repair_space>" + ( stringFor ( localName , atts ) ) ) , e ) ; } } protected String stringFor ( String label , Attributes attr ) { } public void endElement ( String uri , String localName , String qName ) throws SAXException { } public void characters ( char [ ] ch , int start , int length ) throws SAXException { } private boolean noNestedElement ( ) { } protected void openElement ( String name , Attributes atts ) { } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { } public void setDocumentLocator ( Locator locator ) { } public final void startPrefixMapping ( String prefix , String uri ) throws SAXException { } public final void endPrefixMapping ( String prefix ) throws SAXException { } public void processingInstruction ( String target , String data ) throws SAXException { } public void skippedEntity ( String name ) throws SAXException { } protected final void write ( String s ) { } protected final void write ( char [ ] characters , int offset , int length ) { } public void setParent ( Spell transformation ) { } public Spell getParent ( ) { } public void startTransformedElement ( String name , Attributes attributes ) { } public void endTransformedElement ( String name ) { } public Scroll usedScroll ( ) { } public void useScroll ( Scroll scroll ) { } public void ignoreBounds ( boolean ignoreBounds ) { } public boolean ignoreBounds ( ) { } public void setHideEntitiesAndCharacterReferencesFromSax ( boolean hide ) { } public boolean isHideEntitiesAndCharacterReferencesFromSax ( ) { } protected void setXHTML ( boolean xhtml ) { } public boolean isXHTML ( ) { } }
public class SimplePagedResultsSearchStrategy extends SearchStrategy { private static final Log LOG = Log . getLog ( SimplePagedResultsSearchStrategy . class ) ; private int lastListSize = - 1 ; private byte [ ] cookie = null ; public SimplePagedResultsSearchStrategy ( LdapNetworkConnection connection , LdapConfiguration configuration , SchemaTranslator schemaTranslator , ObjectClass objectClass , org . apache . directory . api . ldap . model . schema . ObjectClass ldapObjectClass , ResultsHandler handler , OperationOptions options ) { } @ Override public void search ( String baseDn , ExprNode filterNode , SearchScope scope , String [ ] attributes ) throws LdapException { SortRequest sortReqControl = createSortControl ( null , null ) ; int pageSize = getDefaultPageSize ( ) ; int offset = 0 ; if ( ( ( getOptions ( ) ) != null ) && ( ( getOptions ( ) . getPagedResultsOffset ( ) ) != null ) ) { <START_BUG> offset = getOptions ( ) . getPagedResultsOffset ( ) ; <END_BUG> if ( offset != 0 ) { SimplePagedResultsSearchStrategy . LOG . info ( "Inefficient<seq2seq4repair_space>search<seq2seq4repair_space>using<seq2seq4repair_space>SimplePaged<seq2seq4repair_space>control<seq2seq4repair_space>and<seq2seq4repair_space>offset<seq2seq4repair_space>{0}" , offset ) ; } } boolean proceed = true ; int numberOfResutlsHandled = 0 ; int numberOfResultsSkipped = 0 ; do { SearchRequest req = new SearchRequestImpl ( ) ; req . setBase ( new Dn ( baseDn ) ) ; req . setFilter ( filterNode ) ; req . setScope ( scope ) ; applyCommonConfiguration ( req ) ; if ( attributes != null ) { req . addAttributes ( attributes ) ; } if ( sortReqControl != null ) { req . addControl ( sortReqControl ) ; } if ( ( ( ( getOptions ( ) ) != null ) && ( ( getOptions ( ) . getPageSize ( ) ) != null ) ) && ( ( ( numberOfResutlsHandled + numberOfResultsSkipped ) + pageSize ) > ( offset + ( getOptions ( ) . getPageSize ( ) ) ) ) ) { pageSize = ( offset + ( getOptions ( ) . getPageSize ( ) ) ) - ( numberOfResutlsHandled + numberOfResultsSkipped ) ; } PagedResults pagedResultsControl = new PagedResultsImpl ( ) ; pagedResultsControl . setCookie ( cookie ) ; pagedResultsControl . setCritical ( true ) ; pagedResultsControl . setSize ( pageSize ) ; if ( SimplePagedResultsSearchStrategy . LOG . isOk ( ) ) { SimplePagedResultsSearchStrategy . LOG . ok ( "LDAP<seq2seq4repair_space>search<seq2seq4repair_space>request:<seq2seq4repair_space>PagedResults(<seq2seq4repair_space>pageSize<seq2seq4repair_space>=<seq2seq4repair_space>{0},<seq2seq4repair_space>cookie<seq2seq4repair_space>=<seq2seq4repair_space>{1}<seq2seq4repair_space>)" , pageSize , Base64 . encode ( cookie ) ) ; } req . addControl ( pagedResultsControl ) ; int responseResultCount = 0 ; SearchCursor searchCursor = executeSearch ( req ) ; try { while ( proceed && ( searchCursor . next ( ) ) ) { Response response = searchCursor . get ( ) ; if ( response instanceof SearchResultEntry ) { responseResultCount ++ ; if ( offset > numberOfResultsSkipped ) { numberOfResultsSkipped ++ ; } else { numberOfResutlsHandled ++ ; Entry entry = ( ( SearchResultEntry ) ( response ) ) . getEntry ( ) ; logSearchResult ( entry ) ; proceed = handleResult ( entry ) ; if ( ! proceed ) { SimplePagedResultsSearchStrategy . LOG . ok ( "Ending<seq2seq4repair_space>search<seq2seq4repair_space>because<seq2seq4repair_space>handler<seq2seq4repair_space>returned<seq2seq4repair_space>false" ) ; } } } else { SimplePagedResultsSearchStrategy . LOG . warn ( "Got<seq2seq4repair_space>unexpected<seq2seq4repair_space>response:<seq2seq4repair_space>{0}" , response ) ; } } SearchResultDone searchResultDone = searchCursor . getSearchResultDone ( ) ; if ( searchResultDone != null ) { LdapResult ldapResult = searchResultDone . getLdapResult ( ) ; PagedResults pagedResultsResponseControl = ( ( PagedResults ) ( searchResultDone . getControl ( OID ) ) ) ; String extra = "no<seq2seq4repair_space>paged<seq2seq4repair_space>response<seq2seq4repair_space>control" ; if ( pagedResultsResponseControl != null ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "paged<seq2seq4repair_space>control<seq2seq4repair_space>size=" ) ; sb . append ( pagedResultsResponseControl . getSize ( ) ) ; if ( ( pagedResultsResponseControl . getCookie ( ) ) != null ) { sb . append ( "<seq2seq4repair_space>cookie=" ) ; sb . append ( Base64 . encode ( pagedResultsResponseControl . getCookie ( ) ) ) ; } extra = sb . toString ( ) ; cookie = pagedResultsResponseControl . getCookie ( ) ; lastListSize = pagedResultsResponseControl . getSize ( ) ; if ( ( lastListSize ) == 0 ) { lastListSize = - 1 ; } } else { SimplePagedResultsSearchStrategy . LOG . ok ( "no<seq2seq4repair_space>paged<seq2seq4repair_space>result<seq2seq4repair_space>control<seq2seq4repair_space>in<seq2seq4repair_space>the<seq2seq4repair_space>response" ) ; cookie = null ; lastListSize = - 1 ; } logSearchResult ( "Done" , ldapResult , extra ) ; if ( ( ldapResult . getResultCode ( ) ) != ( ResultCodeEnum . SUCCESS ) ) { String msg = "LDAP<seq2seq4repair_space>error<seq2seq4repair_space>during<seq2seq4repair_space>search:<seq2seq4repair_space>" + ( LdapUtil . formatLdapMessage ( ldapResult ) ) ; if ( ( ( ( ( ldapResult . getResultCode ( ) ) == ( ResultCodeEnum . SIZE_LIMIT_EXCEEDED ) ) && ( ( getOptions ( ) ) != null ) ) && ( ( getOptions ( ) . getAllowPartialResults ( ) ) != null ) ) && ( getOptions ( ) . getAllowPartialResults ( ) ) ) { SimplePagedResultsSearchStrategy . LOG . ok ( "{0}<seq2seq4repair_space>(allowed<seq2seq4repair_space>error)" , msg ) ; setCompleteResultSet ( false ) ; } else { SimplePagedResultsSearchStrategy . LOG . error ( "{0}" , msg ) ; throw LdapUtil . processLdapResult ( "LDAP<seq2seq4repair_space>error<seq2seq4repair_space>during<seq2seq4repair_space>search" , ldapResult ) ; } searchCursor . close ( ) ; break ; } } searchCursor . close ( ) ; } catch ( CursorException e ) { SimplePagedResultsSearchStrategy . LOG . error ( "Error:" , e ) ; throw new org . identityconnectors . framework . common . exceptions . ConnectorIOException ( e . getMessage ( ) , e ) ; } if ( responseResultCount == 0 ) { SimplePagedResultsSearchStrategy . LOG . warn ( "Zero<seq2seq4repair_space>results<seq2seq4repair_space>returned<seq2seq4repair_space>from<seq2seq4repair_space>paged<seq2seq4repair_space>search" ) ; break ; } if ( ! proceed ) { break ; } if ( ( ( ( getOptions ( ) ) != null ) && ( ( getOptions ( ) . getPageSize ( ) ) != null ) ) && ( ( numberOfResutlsHandled + numberOfResultsSkipped ) >= ( offset + ( getOptions ( ) . getPageSize ( ) ) ) ) ) { break ; } } while ( ( cookie ) != null ) ; }
public class RaActivate implements OperationStepHandler { static final RaActivate INSTANCE = new RaActivate ( ) ; public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { final ModelNode address = operation . require ( OP_ADDR ) ; final String idName = PathAddress . pathAddress ( address ) . getLastElement ( ) . getValue ( ) ; final String raName = context . readResource ( EMPTY_ADDRESS ) . getModel ( ) . get ( "archive" ) . asString ( ) ; if ( context . isNormalServer ( ) ) { context . addStep ( new OperationStepHandler ( ) { public void execute ( final OperationContext context , ModelNode operation ) throws OperationFailedException { final ServiceVerificationHandler svh = new ServiceVerificationHandler ( ) ; ServiceName restartedServiceName = RaOperationUtil . restartIfPresent ( context , raName , idName , svh ) ; if ( restartedServiceName == null ) { RaOperationUtil . activate ( context , idName , svh ) ; } context . addStep ( svh , VERIFY ) ; context . completeStep ( new OperationContext . RollbackHandler ( ) { @ Override public void handleRollback ( OperationContext context , ModelNode operation ) { try { <START_BUG> RaOperationUtil . removeIfActive ( context , raName ) ; <END_BUG> } catch ( OperationFailedException e ) { } } } ) ; } } , RUNTIME ) ; } context . stepCompleted ( ) ; } }
public class ImportDeclaration extends SourceRefElement implements IImportDeclaration { protected String name ; protected boolean isOnDemand ; protected ImportDeclaration ( ImportContainer parent , String name , boolean isOnDemand ) { } public boolean equals ( Object o ) { } public String getElementName ( ) { } public String getNameWithoutStar ( ) { } public int getElementType ( ) { } public int getFlags ( ) throws JavaModelException { } protected void getHandleMemento ( StringBuffer buff ) { } protected char getHandleMementoDelimiter ( ) { } public IJavaElement getPrimaryElement ( boolean checkOwner ) { } public boolean isOnDemand ( ) { } public String readableName ( ) { } protected void toStringInfo ( int tab , StringBuffer buffer , Object info , boolean showResolvedInfo ) { <START_BUG> buffer . append ( this . tabString ( tab ) ) ; <END_BUG> buffer . append ( "import<seq2seq4repair_space>" ) ; toStringName ( buffer ) ; if ( info == null ) { buffer . append ( "<seq2seq4repair_space>(not<seq2seq4repair_space>open)" ) ; } } }
public abstract class Summarizer { public int numFile ; public int numTotalLine ; public int numCommentLine ; public int numBlankLine ; public int numFunction ; public int numFunctionDecl ; public int numBlock ; public int numDeclstmt ; public int numDecl ; public int numExprstmt ; public int numExpr ; public int numIf ; public int numElse ; public int numWhile ; public int numFor ; public int numContinue ; public int numBreak ; public int numDo ; public int numSwitch ; public int numCase ; public int numReturn ; public int numCall ; public int numParamList ; public int numParam ; public int numArguList ; public int numArgu ; public int numAssignment ; public int numLocalFunctionCall = 0 ; public int numLibFunctionCall = 0 ; public int numLocalGetterSetterCall = 0 ; public int numLibGetterSetterCall = 0 ; public int numZeroOpAssign = 0 ; public int numZeroOpCallAssign = 0 ; public int numConstAssign = 0 ; public int numExecuteLine = 0 ; public int numLoop = 0 ; public int numDeclInDeclStmt = 0 ; public int numDeclInFor = 0 ; public int numParamDecl = 0 ; public int numDeclStmtWithInit = 0 ; CsvWriter totalWriter ; String fdir ; File folder ; File [ ] listOfFiles ; FileInputStream fstream ; DataInputStream in ; BufferedReader br ; int numProject ; String resulttype ; public void writeStatistics ( ) { } private void writeSameStatNumber ( int proNum , String fileName ) { try { totalWriter . write ( String . valueOf ( proNum ) ) ; totalWriter . write ( String . valueOf ( fileName . substring ( 0 , fileName . indexOf ( ".txt" ) ) ) ) ; totalWriter . write ( String . valueOf ( numCall ) ) ; totalWriter . write ( String . valueOf ( numIf ) ) ; totalWriter . write ( String . valueOf ( numAssignment ) ) ; totalWriter . write ( String . valueOf ( numFunction ) ) ; totalWriter . write ( String . valueOf ( numReturn ) ) ; totalWriter . write ( String . valueOf ( numDeclstmt ) ) ; <START_BUG> totalWriter . write ( String . valueOf ( "numDeclStmtWithInit" ) ) ; <END_BUG> totalWriter . write ( String . valueOf ( numContinue ) ) ; totalWriter . write ( String . valueOf ( numBreak ) ) ; totalWriter . write ( String . valueOf ( numFunctionDecl ) ) ; totalWriter . write ( String . valueOf ( numFor ) ) ; totalWriter . write ( String . valueOf ( numElse ) ) ; totalWriter . write ( String . valueOf ( numWhile ) ) ; totalWriter . write ( String . valueOf ( numDo ) ) ; totalWriter . write ( String . valueOf ( numSwitch ) ) ; totalWriter . write ( String . valueOf ( numCase ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } private void writeSameStatColumnName ( ) { } public void writeSameColumnName ( ) { } private void getSameNumber ( String name , int number ) { } private void writeSameNumber ( int proNum , String filename ) { } public abstract void createFile ( ) { } public abstract void writeDiffColumnName ( ) { } public abstract void writeDiffNumber ( int i , String s ) { } public abstract void getDiffNumber ( String name , int number ) { } public abstract void writeDiffStatColumnName ( ) { } public abstract void writeDiffStatNumber ( int proNum , String fileName ) { } }
public class AddressbookTreeModel extends DefaultTreeModel implements TreeModel { protected DefaultXmlConfig folderXmlConfig ; private static AddressbookTreeModel instance = new AddressbookTreeModel ( AddressbookConfig . getInstance ( ) . get ( "tree" ) . getElement ( "/tree" ) ) ; public AddressbookTreeModel ( XmlElement root ) { } public static AddressbookTreeModel getInstance ( ) { } public ISelectFolderDialog getSelectAddressbookFolderDialog ( ) { } public void createDirectories ( XmlElement parentTreeNode , AddressbookTreeNode parentFolder ) { } public AddressbookTreeNode add ( XmlElement childNode , AddressbookTreeNode parentFolder ) { FolderItem item = new FolderItem ( childNode ) ; if ( item == null ) { return null ; } int uid = item . getInteger ( "uid" ) ; if ( ( AddressbookTreeNode . getNextFolderUid ( ) ) <= uid ) AddressbookTreeNode . setNextFolderUid ( ( uid + 1 ) ) ; String type = item . get ( "type" ) ; Object [ ] args = new Object [ ] { item } ; IExtensionHandler handler = null ; try { <START_BUG> handler = PluginManager . getInstance ( ) . getHandler ( ORG_COLUMBA_CONTACT_FOLDER ) ; <END_BUG> } catch ( PluginHandlerNotFoundException ex ) { ErrorDialog . createDialog ( ex . getMessage ( ) , ex ) ; } AddressbookTreeNode folder = null ; try { IExtension extension = handler . getExtension ( type ) ; folder = ( ( AddressbookTreeNode ) ( extension . instanciateExtension ( args ) ) ) ; parentFolder . add ( folder ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return folder ; } public AddressbookTreeNode getFolder ( int uid ) { } public IFolder getFolder ( String name ) { } }
public class MethodInvokingJobDetailFactoryBean extends ArgumentConvertingMethodInvoker implements BeanClassLoaderAware , BeanFactoryAware , BeanNameAware , FactoryBean < Object > , InitializingBean { private String name ; private String group = Scheduler . DEFAULT_GROUP ; private boolean concurrent = true ; private String targetBeanName ; private String [ ] jobListenerNames ; private String beanName ; private ClassLoader beanClassLoader = ClassUtils . getDefaultClassLoader ( ) ; private BeanFactory beanFactory ; private JobDetail jobDetail ; public void setName ( String name ) { } public void setGroup ( String group ) { } public void setConcurrent ( boolean concurrent ) { } public void setTargetBeanName ( String targetBeanName ) { } public void setJobListenerNames ( String [ ] names ) { } public void setBeanName ( String beanName ) { } public void setBeanClassLoader ( ClassLoader classLoader ) { } public void setBeanFactory ( BeanFactory beanFactory ) { } @ Override protected Class resolveClassName ( String className ) throws ClassNotFoundException { } public void afterPropertiesSet ( ) throws ClassNotFoundException , NoSuchMethodException { } protected void postProcessJobDetail ( JobDetail jobDetail ) { } @ Override public Class getTargetClass ( ) { } @ Override public Object getTargetObject ( ) { } public Object getObject ( ) { } public Class < ? > getObjectType ( ) { } public boolean isSingleton ( ) { } public static class MethodInvokingJob extends QuartzJobBean { protected static final Log logger = LogFactory . getLog ( MethodInvokingJobDetailFactoryBean . MethodInvokingJob . class ) ; private MethodInvoker methodInvoker ; public void setMethodInvoker ( MethodInvoker methodInvoker ) { } @ Override protected void executeInternal ( JobExecutionContext context ) throws JobExecutionException { try { <START_BUG> this . methodInvoker . invoke ( ) ; <END_BUG> } catch ( InvocationTargetException ex ) { if ( ( ex . getTargetException ( ) ) instanceof JobExecutionException ) { throw ( ( JobExecutionException ) ( ex . getTargetException ( ) ) ) ; } else { throw new JobMethodInvocationFailedException ( this . methodInvoker , ex . getTargetException ( ) ) ; } } catch ( Exception ex ) { throw new JobMethodInvocationFailedException ( this . methodInvoker , ex ) ; } } } public static class StatefulMethodInvokingJob extends MethodInvokingJobDetailFactoryBean . MethodInvokingJob implements StatefulJob { } }
public class VFSResourceLoader implements ResourceLoader { private final ModuleIdentifier moduleIdentifier ; private final VirtualFile root ; private final String rootName ; private final Manifest manifest ; private final MountHandle mountHandle ; public VFSResourceLoader ( final ModuleIdentifier moduleIdentifier , final String rootName , final VirtualFile root , final MountHandle mountHandle ) throws IOException { } public ClassSpec getClassSpec ( final String name ) throws IOException { } public PackageSpec getPackageSpec ( final String name ) throws IOException { } private static String getDefinedAttribute ( Attributes . Name name , Attributes entryAttribute , Attributes mainAttribute ) { } public String getLibrary ( final String name ) { } public String getRootName ( ) { } public PathFilter getExportFilter ( ) { } public Resource getResource ( final String name ) { try { final VirtualFile file = root . getChild ( name ) ; if ( ! ( file . exists ( ) ) ) { return null ; } <START_BUG> return new VFSResourceLoader . VFSEntryResource ( file , root . toURL ( ) ) ; <END_BUG> } catch ( MalformedURLException e ) { return null ; } } public Collection < String > getPaths ( ) { } static class VFSEntryResource implements Resource { private final VirtualFile entry ; private final URL resourceURL ; VFSEntryResource ( final VirtualFile entry , final URL resourceURL ) { } public String getName ( ) { } public URL getURL ( ) { } public InputStream openStream ( ) throws IOException { } public long getSize ( ) { } } }
public class ConnectionPropertyAdd extends AbstractAddStepHandler implements DescriptionProvider { public static final ConnectionPropertyAdd INSTANCE = new ConnectionPropertyAdd ( ) ; @ Override public ModelNode getModelDescription ( Locale locale ) { } @ Override protected void populateModel ( ModelNode operation , ModelNode modelNode ) throws OperationFailedException { } @ Override protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode recoveryEnvModel , ServiceVerificationHandler verificationHandler , List < ServiceController < ? > > serviceControllers ) throws OperationFailedException { <START_BUG> final String configPropertyValue = Constants . CONNECTION_PROPERTY_VALUE . validateResolvedOperation ( recoveryEnvModel ) . asString ( ) ; <END_BUG> final ModelNode address = operation . require ( OP_ADDR ) ; PathAddress path = PathAddress . pathAddress ( address ) ; final String jndiName = path . getElement ( ( ( path . size ( ) ) - 2 ) ) . getValue ( ) ; final String configPropertyName = PathAddress . pathAddress ( address ) . getLastElement ( ) . getValue ( ) ; ServiceName serviceName = SERVICE_NAME_BASE . append ( jndiName ) . append ( configPropertyName ) ; ServiceName dsServiceName = SERVICE_NAME_BASE . append ( jndiName ) ; final ServiceRegistry registry = context . getServiceRegistry ( true ) ; final ServiceName dataSourceConfigServiceName = SERVICE_NAME_BASE . append ( jndiName ) ; final ServiceController < ? > dataSourceConfigController = registry . getService ( dataSourceConfigServiceName ) ; if ( ( dataSourceConfigController != null ) && ( ! ( ( ( org . jboss . jca . common . api . metadata . ds . DataSource ) ( dataSourceConfigController . getValue ( ) ) ) . isEnabled ( ) ) ) ) { final ServiceTarget serviceTarget = context . getServiceTarget ( ) ; final ConnectionPropertiesService service = new ConnectionPropertiesService ( configPropertyName , configPropertyValue ) ; serviceTarget . addService ( serviceName , service ) . setInitialMode ( ACTIVE ) . addDependency ( dsServiceName , ModifiableDataSource . class , service . getDSInjector ( ) ) . addListener ( verificationHandler ) . install ( ) ; context . addStep ( verificationHandler , VERIFY ) ; } else { context . reloadRequired ( ) ; } } }
public class SwitchStatement extends Statement { public Expression expression ; public Statement [ ] statements ; public BlockScope scope ; public int explicitDeclarations ; public Label breakLabel ; public CaseStatement [ ] cases ; public CaseStatement defaultCase ; public int blockStart ; public int caseCount ; int [ ] constants ; public SyntheticMethodBinding synthetic ; int preSwitchInitStateIndex = - 1 ; int mergedInitStateIndex = - 1 ; public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public StringBuffer printStatement ( int indent , StringBuffer output ) { } public void resolve ( BlockScope upperScope ) { try { boolean isEnumSwitch = false ; TypeBinding expressionType = expression . resolveType ( upperScope ) ; if ( expressionType == null ) return ; expression . computeConversion ( upperScope , expressionType , expressionType ) ; checkType : { if ( expressionType . isBaseType ( ) ) { if ( expression . isConstantValueOfTypeAssignableToType ( expressionType , IntBinding ) ) break checkType ; if ( expressionType . isCompatibleWith ( IntBinding ) ) break checkType ; } else if ( expressionType . isEnum ( ) ) { isEnumSwitch = true ; break checkType ; } else if ( upperScope . isBoxingCompatibleWith ( expressionType , IntBinding ) ) { expression . computeConversion ( upperScope , IntBinding , expressionType ) ; break checkType ; } upperScope . problemReporter ( ) . incorrectSwitchType ( expression , expressionType ) ; return ; } if ( ( statements ) != null ) { scope = new BlockScope ( upperScope ) ; int length ; cases = new CaseStatement [ length = statements . length ] ; this . constants = new int [ length ] ; CaseStatement [ ] duplicateCaseStatements = null ; int duplicateCaseStatementsCounter = 0 ; int counter = 0 ; for ( int i = 0 ; i < length ; i ++ ) { Constant constant ; final Statement statement = statements [ i ] ; if ( ( constant = statement . resolveCase ( scope , expressionType , this ) ) != ( Constant . NotAConstant ) ) { int key = constant . intValue ( ) ; for ( int j = 0 ; j < counter ; j ++ ) { if ( ( this . constants [ j ] ) == key ) { final CaseStatement currentCaseStatement = ( ( CaseStatement ) ( statement ) ) ; if ( duplicateCaseStatements == null ) { scope . problemReporter ( ) . duplicateCase ( cases [ j ] ) ; scope . problemReporter ( ) . duplicateCase ( currentCaseStatement ) ; duplicateCaseStatements = new CaseStatement [ length ] ; duplicateCaseStatements [ ( duplicateCaseStatementsCounter ++ ) ] = cases [ j ] ; duplicateCaseStatements [ ( duplicateCaseStatementsCounter ++ ) ] = currentCaseStatement ; } else { boolean found = false ; searchReportedDuplicate : for ( int k = 2 ; k < duplicateCaseStatementsCounter ; k ++ ) { if ( ( duplicateCaseStatements [ k ] ) == statement ) { found = true ; break searchReportedDuplicate ; } } if ( ! found ) { scope . problemReporter ( ) . duplicateCase ( currentCaseStatement ) ; duplicateCaseStatements [ ( duplicateCaseStatementsCounter ++ ) ] = currentCaseStatement ; } } } } this . constants [ ( counter ++ ) ] = key ; } } if ( length != counter ) { System . arraycopy ( this . constants , 0 , ( this . constants = new int [ counter ] ) , 0 , counter ) ; } } else { if ( ( ( this . bits ) & ( ASTNode . UndocumentedEmptyBlock ) ) != 0 ) { upperScope . problemReporter ( ) . undocumentedEmptyBlock ( this . blockStart , this . sourceEnd ) ; } } if ( ( isEnumSwitch && ( ( defaultCase ) == null ) ) && ( ( upperScope . compilerOptions ( ) . getSeverity ( IncompleteEnumSwitch ) ) != ( ProblemSeverities . Ignore ) ) ) { int constantCount = ( ( this . constants ) == null ) ? 0 : this . constants . length ; if ( ( constantCount == ( caseCount ) ) && ( ( caseCount ) != ( ( ( ReferenceBinding ) ( expressionType ) ) . enumConstantCount ( ) ) ) ) { FieldBinding [ ] enumFields = ( ( ReferenceBinding ) ( expressionType . erasure ( ) ) ) . fields ( ) ; for ( int i = 0 , max = enumFields . length ; i < max ; i ++ ) { FieldBinding enumConstant = enumFields [ i ] ; <START_BUG> if ( ( ( enumConstant . modifiers ) & ( AccEnum ) ) == 0 ) <END_BUG> continue ; findConstant : { for ( int j = 0 ; j < ( caseCount ) ; j ++ ) { if ( ( enumConstant . id ) == ( this . constants [ j ] ) ) break findConstant ; } upperScope . problemReporter ( ) . missingEnumConstantCase ( this , enumConstant ) ; } } } } } finally { if ( ( this . scope ) != null ) this . scope . enclosingCase = null ; } } public void traverse ( ASTVisitor visitor , BlockScope blockScope ) { } public void branchChainTo ( Label label ) { } }
public class EditorsPreferencePage extends PreferencePage implements IWorkbenchPreferencePage { private static final int REUSE_INDENT = 10 ; protected Composite editorReuseGroup ; private Button reuseEditors ; protected Button showMultipleEditorTabs ; protected Button useIPersistableEditor ; private Composite editorReuseIndentGroup ; private Composite editorReuseThresholdGroup ; private IntegerFieldEditor reuseEditorsThreshold ; private Group dirtyEditorReuseGroup ; private Button openNewEditor ; private Button promptToReuseEditor ; private IntegerFieldEditor recentFilesEditor ; private IPropertyChangeListener validityChangeListener = new IPropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent event ) { } } ; private Button promptWhenStillOpenEditor ; protected Control createContents ( Composite parent ) { Composite composite = createComposite ( parent ) ; createEditorHistoryGroup ( composite ) ; createSpace ( composite ) ; createShowMultipleEditorTabsPref ( composite ) ; createUseIPersistablePref ( composite ) ; createPromptWhenStillOpenPref ( composite ) ; createEditorReuseGroup ( composite ) ; <START_BUG> ( ( TabBehaviour ) ( Tweaklets . get ( TabBehaviour . class ) ) ) . setPreferenceVisibility ( editorReuseGroup , showMultipleEditorTabs ) ; <END_BUG> updateValidState ( ) ; setHelpContext ( parent ) ; return composite ; } protected void setHelpContext ( Composite parent ) { } protected void createSpace ( Composite parent ) { } protected void createShowMultipleEditorTabsPref ( Composite composite ) { } protected void createUseIPersistablePref ( Composite composite ) { } protected void createPromptWhenStillOpenPref ( Composite composite ) { } protected Composite createComposite ( Composite parent ) { } public void init ( IWorkbench workbench ) { } protected void performDefaults ( ) { } public boolean performOk ( ) { } protected IPreferenceStore doGetPreferenceStore ( ) { } protected IPreferenceStore getAPIPreferenceStore ( ) { } protected void updateValidState ( ) { } protected void createEditorReuseGroup ( Composite composite ) { } protected void createEditorHistoryGroup ( Composite composite ) { } }
public class SevenZFile { static final int SIGNATURE_HEADER_SIZE = 32 ; private static final int DRAIN_BUF_SIZE = 64 * 1024 ; private RandomAccessFile file ; private final Archive archive ; private int currentEntryIndex = - 1 ; private int currentFolderIndex = - 1 ; private InputStream currentFolderInputStream = null ; private InputStream currentEntryInputStream = null ; private byte [ ] password ; static final byte [ ] sevenZSignature = new byte [ ] { ( ( byte ) ( '7' ) ) , ( ( byte ) ( 'z' ) ) , ( ( byte ) ( 188 ) ) , ( ( byte ) ( 175 ) ) , ( ( byte ) ( 39 ) ) , ( ( byte ) ( 28 ) ) } ; public SevenZFile ( final File filename , final byte [ ] password ) throws IOException { } public SevenZFile ( final File filename ) throws IOException { } public void close ( ) throws IOException { } public SevenZArchiveEntry getNextEntry ( ) throws IOException { } private Archive readHeaders ( byte [ ] password ) throws IOException { } private StartHeader readStartHeader ( final int startHeaderCrc ) throws IOException { } private void readHeader ( final DataInput header , final Archive archive ) throws IOException { } private void readArchiveProperties ( final DataInput input ) throws IOException { } private DataInputStream readEncodedHeader ( final DataInputStream header , final Archive archive , byte [ ] password ) throws IOException { } private void readStreamsInfo ( final DataInput header , final Archive archive ) throws IOException { } private void readPackInfo ( final DataInput header , final Archive archive ) throws IOException { } private void readUnpackInfo ( final DataInput header , final Archive archive ) throws IOException { } private void readSubStreamsInfo ( final DataInput header , final Archive archive ) throws IOException { } private Folder readFolder ( final DataInput header ) throws IOException { } private BitSet readAllOrBits ( final DataInput header , final int size ) throws IOException { } private BitSet readBits ( final DataInput header , final int size ) throws IOException { } private void readFilesInfo ( final DataInput header , final Archive archive ) throws IOException { } private void calculateStreamMap ( final Archive archive ) throws IOException { } private void buildDecodingStream ( ) throws IOException { } private void drainPreviousEntry ( ) throws IOException { } private InputStream buildDecoderStack ( final Folder folder , final long folderOffset , final int firstPackStreamIndex ) throws IOException { } public int read ( ) throws IOException { } public int read ( byte [ ] b ) throws IOException { } public int read ( byte [ ] b , int off , int len ) throws IOException { } private static long readUint64 ( final DataInput in ) throws IOException { <START_BUG> int firstByte = in . readUnsignedByte ( ) ; <END_BUG> int mask = 128 ; long value = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { if ( ( firstByte & mask ) == 0 ) { return value | ( ( firstByte & ( mask - 1 ) ) << ( 8 * i ) ) ; } long nextByte = in . readUnsignedByte ( ) ; value |= nextByte << ( 8 * i ) ; mask >>>= 1 ; } return value ; } }
public class MultivariateNormalDistribution extends AbstractMultivariateRealDistribution { private final double [ ] means ; private final RealMatrix covarianceMatrix ; private final RealMatrix covarianceMatrixInverse ; private final double covarianceMatrixDeterminant ; private final RealMatrix samplingMatrix ; public MultivariateNormalDistribution ( final double [ ] means , final double [ ] [ ] covariances ) throws DimensionMismatchException , NonPositiveDefiniteMatrixException , SingularMatrixException { } public MultivariateNormalDistribution ( RandomGenerator rng , final double [ ] means , final double [ ] [ ] covariances ) throws DimensionMismatchException , NonPositiveDefiniteMatrixException , SingularMatrixException { } public double [ ] getMeans ( ) { } public RealMatrix getCovariances ( ) { } public double density ( final double [ ] vals ) throws DimensionMismatchException { final int dim = getDimension ( ) ; if ( ( vals . length ) != dim ) { throw new DimensionMismatchException ( vals . length , dim ) ; } <START_BUG> return ( ( FastMath . pow ( ( 2 * ( FastMath . PI ) ) , ( ( - dim ) / 2 ) ) ) * ( FastMath . pow ( covarianceMatrixDeterminant , ( - 0.5 ) ) ) ) * ( getExponentTerm ( vals ) ) ; <END_BUG> } public double [ ] getStandardDeviations ( ) { } public double [ ] sample ( ) { } private double getExponentTerm ( final double [ ] values ) { } }
public class ScripActivity extends ActivitySupport < AppMeetPy > { private boolean awesomeAppearance = true ; private AppearanceController contentAC ; private Script script ; private ArgumentFormComponent argumentFormComponent ; private AnswerFormComponent answerFormComponent ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } int script_signature_fetching_errors = 0 ; private void fetchScriptSignature ( ) { view ( script_progress ) . setVisibility ( VISIBLE ) ; application ( ) . getScriptSignature ( script , new ApplicationSupport . ValueObserver < ArgumentFormComponent > ( ) { @ Override public void onSuccess ( ArgumentFormComponent argFormView ) { installArgumentForm ( argFormView ) ; view ( R . id . script_progress ) . setVisibility ( View . GONE ) ; } @ Override public void onFail ( int errorCode ) { view ( R . id . script_progress ) . setVisibility ( View . GONE ) ; <START_BUG> errorCode ++ ; <END_BUG> if ( ( script_signature_fetching_errors ) > 3 ) { toast_UnsupportedErrorCode ( errorCode ) ; } else { fetchScriptSignature ( ) ; } } } ) ; } private void toast_UnsupportedErrorCode ( int errorCode ) { } private void installArgumentForm ( ArgumentFormComponent formComponent ) { } private void releasePreviousAnswers ( ) { } private void executeScript ( Map < String , Object > data ) { } @ Override protected void onResume ( ) { } @ Override protected void onPause ( ) { } @ Override public void onBackPressed ( ) { } private void onSuperBackPressed ( ) { } private AppearanceControllerBuilder . TypeBuilder < Float > circleGrowing ( ) { } }
@ Path ( "/books" ) @ Consumes ( { MediaType . APPLICATION_JSON , MediaType . TEXT_PLAIN } ) @ Produces ( { MediaType . APPLICATION_JSON , MediaType . TEXT_PLAIN } ) public class BookController { @ Autowired private BookService bookService ; private Gson gson = new Gson ( ) ; @ GET public Response findAll ( ) { } @ Path ( "/{isbn}" ) @ GET public Response find ( @ PathParam ( "isbn" ) String isbn ) { Book book = bookService . find ( isbn ) ; if ( book == null ) { return Response . status ( INTERNAL_SERVER_ERROR ) . entity ( "El<seq2seq4repair_space>libro<seq2seq4repair_space>no<seq2seq4repair_space>existe" ) . build ( ) ; } <START_BUG> return Response . ok ( book ) . build ( ) ; <END_BUG> } @ POST public Response save ( String json ) { } @ PUT public Response update ( Book book ) { } @ Path ( "/{isbn}" ) @ DELETE public Response delete ( String isbn ) { } }
public class WebPage extends Page implements INewBrowserWindowListener { private static final long serialVersionUID = 1L ; private static Log log = LogFactory . getLog ( WebPage . class ) ; private static final MetaDataKey MISSING_BODY_TAG_LOGGED_MDK = new MetaDataKey ( WebPage . MissingBodyTagLoggedMetaData . class ) { private static final long serialVersionUID = 1L ; } ; private static final class MissingBodyTagLoggedMetaData implements Serializable { private static final long serialVersionUID = 1L ; Set missingBodyTagsLogged = new HashSet ( 1 ) ; } private static ResourceReference cookiesResource = new ResourceReference ( WebPage . class , "cookies.js" ) ; private BodyContainer bodyContainer ; private URLCompressor compressor ; protected WebPage ( ) { } protected WebPage ( final IModel model ) { } protected WebPage ( final PageMap pageMap ) { } protected WebPage ( final PageMap pageMap , final IModel model ) { } protected WebPage ( final PageParameters parameters ) { } public BodyContainer getBodyContainer ( ) { } public String getMarkupType ( ) { } protected void configureResponse ( ) { } protected final WebRequestCycle getWebRequestCycle ( ) { } protected final BookmarkablePageLink homePageLink ( final String id ) { } private void commonInit ( ) { } public final URLCompressor getUrlCompressor ( ) { } protected void onDetach ( ) { } public void onNewBrowserWindow ( ) { } private final class PageMapChecker extends AbstractBehavior implements IHeaderContributor { private static final long serialVersionUID = 1L ; private Model onUnLoadModel ; public final void renderHead ( final Response response ) { final WebRequestCycle cycle = ( ( WebRequestCycle ) ( getRequestCycle ( ) ) ) ; final IRequestTarget target = cycle . getRequestTarget ( ) ; int initialAccessStackSize = 0 ; if ( ( ( getApplication ( ) . getRequestCycleSettings ( ) . getRenderStrategy ( ) ) == ( IRequestCycleSettings . REDIRECT_TO_RENDER ) ) && ( target instanceof RedirectPageRequestTarget ) ) { initialAccessStackSize = 1 ; } final ArrayListStack accessStack = getPageMap ( ) . getAccessStack ( ) ; CharSequence url = null ; if ( target instanceof IBookmarkablePageRequestTarget ) { IBookmarkablePageRequestTarget current = ( ( IBookmarkablePageRequestTarget ) ( target ) ) ; BookmarkablePageRequestTarget redirect = new BookmarkablePageRequestTarget ( getSession ( ) . createAutoPageMapName ( ) , current . getPageClass ( ) , current . getPageParameters ( ) ) ; url = cycle . urlFor ( redirect ) ; } else { url = urlFor ( INTERFACE ) ; } final BodyContainer body = getBodyContainer ( ) ; final Cookie [ ] cookies = cycle . getWebRequest ( ) . getCookies ( ) ; if ( ( ( cookies == null ) && ( ( accessStack . size ( ) ) > initialAccessStackSize ) ) || ( body == null ) ) { if ( ( ( cookies != null ) && ( body == null ) ) && ( WebPage . log . isWarnEnabled ( ) ) ) { Application app = getApplication ( ) ; WebPage . MissingBodyTagLoggedMetaData meta = ( ( WebPage . MissingBodyTagLoggedMetaData ) ( app . getMetaData ( WebPage . MISSING_BODY_TAG_LOGGED_MDK ) ) ) ; if ( meta == null ) { meta = new WebPage . MissingBodyTagLoggedMetaData ( ) ; app . setMetaData ( WebPage . MISSING_BODY_TAG_LOGGED_MDK , meta ) ; } Class pageClass = WebPage . this . getClass ( ) ; if ( ! ( meta . missingBodyTagsLogged . contains ( pageClass ) ) ) { WebPage . log . warn ( ( ( ( "Page<seq2seq4repair_space>with<seq2seq4repair_space>class<seq2seq4repair_space>" + ( pageClass . getName ( ) ) ) + "<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>have<seq2seq4repair_space>a<seq2seq4repair_space>body<seq2seq4repair_space>tag.<seq2seq4repair_space>It<seq2seq4repair_space>is<seq2seq4repair_space>advisable<seq2seq4repair_space>to<seq2seq4repair_space>have" ) + "<seq2seq4repair_space>a<seq2seq4repair_space>body<seq2seq4repair_space>tag<seq2seq4repair_space>pair,<seq2seq4repair_space>as<seq2seq4repair_space>multi<seq2seq4repair_space>window<seq2seq4repair_space>support<seq2seq4repair_space>might<seq2seq4repair_space>be<seq2seq4repair_space>problematic<seq2seq4repair_space>without." ) ) ; meta . missingBodyTagsLogged . add ( pageClass ) ; } } if ( ( accessStack . size ( ) ) > initialAccessStackSize ) { JavascriptUtils . writeOpenTag ( response ) ; response . write ( "if((history.length<seq2seq4repair_space>==<seq2seq4repair_space>0<seq2seq4repair_space>&&<seq2seq4repair_space>document.all)<seq2seq4repair_space>||<seq2seq4repair_space>(history.length<seq2seq4repair_space>==<seq2seq4repair_space>1<seq2seq4repair_space>&&<seq2seq4repair_space>!document.all)){<seq2seq4repair_space>if<seq2seq4repair_space>(!document.all)<seq2seq4repair_space>window.location.hash='some-random-hash!';<seq2seq4repair_space>document.location.href<seq2seq4repair_space>=<seq2seq4repair_space>'" ) ; response . write ( url ) ; response . write ( "'}" ) ; JavascriptUtils . writeCloseTag ( response ) ; } } else { if ( ( onUnLoadModel ) == null ) { onUnLoadModel = new Model ( ) { private static final long serialVersionUID = 1L ; public Object getObject ( Component component ) { Application application = Application . get ( ) ; return ( ( ( "deleteWicketCookie('pm-" + ( getPageMap ( ) . getName ( ) ) ) + ( application . getApplicationSettings ( ) . getContextPath ( ) ) ) + ( application . getApplicationKey ( ) ) ) + "');" ; } } ; <START_BUG> body . addOnUnLoadModifier ( onUnLoadModel ) ; <END_BUG> } Application application = Application . get ( ) ; final String pageMapName = getPageMap ( ) . getName ( ) ; JavascriptUtils . writeJavascriptUrl ( response , urlFor ( WebPage . cookiesResource ) ) ; JavascriptUtils . writeOpenTag ( response ) ; response . write ( "var<seq2seq4repair_space>pagemapcookie<seq2seq4repair_space>=<seq2seq4repair_space>getWicketCookie('pm-" ) ; response . write ( pageMapName ) ; response . write ( application . getApplicationSettings ( ) . getContextPath ( ) ) ; response . write ( application . getApplicationKey ( ) ) ; response . println ( "');" ) ; response . write ( "if(!pagemapcookie<seq2seq4repair_space>&&<seq2seq4repair_space>pagemapcookie<seq2seq4repair_space>!=<seq2seq4repair_space>'1'){setWicketCookie('pm-" ) ; response . write ( pageMapName ) ; response . write ( application . getApplicationSettings ( ) . getContextPath ( ) ) ; response . write ( application . getApplicationKey ( ) ) ; response . println ( "',1);}" ) ; response . write ( "else<seq2seq4repair_space>{document.location.href<seq2seq4repair_space>=<seq2seq4repair_space>'" ) ; response . write ( url ) ; response . println ( "';}" ) ; JavascriptUtils . writeCloseTag ( response ) ; } } } }
@ Named @ Stateless public class WorkspaceMaterialsTOCBackingBean { @ Inject private WorkspaceMaterialController workspaceMaterialController ; @ Inject private MaterialController materialController ; public List < MaterialNode > getDescendants ( WorkspaceNode rootFolder ) { } public List < MaterialNode > getVisibleDescendants ( WorkspaceNode rootFolder ) { } public List < MaterialNode > getDescendants ( WorkspaceNode rootFolder , Boolean includeHidden ) { List < MaterialNode > materialNodes = new ArrayList < MaterialNode > ( ) ; <START_BUG> List < WorkspaceNode > nodes = workspaceMaterialController . listVisibleWorkspaceNodesByParentAndFolderTypeSortByOrderNumber ( rootFolder , DEFAULT ) ; <END_BUG> for ( WorkspaceNode node : nodes ) { if ( includeHidden || ( ! ( node . getHidden ( ) ) ) ) { appendMaterialNode ( node , materialNodes , includeHidden ) ; } } return materialNodes ; } public List < MaterialNode > getChildren ( WorkspaceNode workspaceNode ) { } public List < MaterialNode > getVisibleChildren ( WorkspaceNode workspaceNode ) { } public List < MaterialNode > getChildren ( WorkspaceNode workspaceNode , Boolean includeHidden ) { } public List < MaterialNode > getChildren ( MaterialNode parent ) { } public List < MaterialNode > getVisibleChildren ( MaterialNode parent ) { } public List < MaterialNode > getChildren ( MaterialNode parent , Boolean includeHidden ) { } private void appendMaterialNode ( WorkspaceNode workspaceNode , List < MaterialNode > materialNodes , Boolean includeHidden ) { } private MaterialNode convertWorkspaceNode ( WorkspaceNode workspaceNode ) { } }
public class DateTimeDV extends AbstractDateTimeDV { public Object getActualValue ( String content , ValidationContext context ) throws InvalidDatatypeValueException { try { <START_BUG> return parse ( content ) ; <END_BUG> } catch ( Exception ex ) { throw new InvalidDatatypeValueException ( "cvc-datatype-valid.1.2.1" , new Object [ ] { content , "dateTime" } ) ; } } protected int [ ] parse ( String str ) throws SchemaDateTimeException { } }
public class MainActivity extends AppCompatActivity implements NavigationDrawerFragment . NotificationPreferences { private static final String TAG = "Main" ; public static final String KEY_FRAGMENT_TITLE = "FragmentTitle" ; public static final String KEY_SHARED_PREF_NOTIF = "sharedPrefNotification" ; private ViewPager viewPager ; private ArrayList < Article > articles ; public ViceAPIService viceService ; private Retrofit retrofit ; private ViewPagerAdapter adapter ; private TabLayout tabLayout ; private String notificationPreferences ; private String popularArticleTitle ; private String popularArticleId ; private NotificationDBHelper notificationHelper ; public static final String AUTHORITY = "martell.com.vice.sync_adapter.StubProvider" ; public static final String ACCOUNT_TYPE = "example.com" ; public static final String ACCOUNT = "default_account" ; Account mAccount ; ContentResolver mResolver ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } private void setupViewPagerOneFragment ( ViewPager viewPager ) { } public static Account createSyncAccount ( Context context ) { } private ArrayList < Boolean > createBoolArrayList ( String notificationPreferences ) { } private void setNavigationDrawer ( ArrayList < Boolean > isCheckedArray ) { } @ Override public void setNotificationPreferences ( String notificationPreferences ) { } @ Override protected void onDestroy ( ) { } public void setNotificationAlarmManager ( ) { Log . i ( MainActivity . TAG , "onCreate:<seq2seq4repair_space>setAlarm<seq2seq4repair_space>was<seq2seq4repair_space>called" ) ; notificationHelper = NotificationDBHelper . getInstance ( this ) ; popularArticleId = notificationHelper . getPopularArticleId ( 0 ) ; popularArticleTitle = notificationHelper . getPopularArticleTitle ( 0 ) ; Log . i ( MainActivity . TAG , ( "popularArticleId:<seq2seq4repair_space>" + ( popularArticleId ) ) ) ; Log . i ( MainActivity . TAG , ( "popularArticleTitle:<seq2seq4repair_space>" + ( popularArticleTitle ) ) ) ; Long alertTime = ( new GregorianCalendar ( ) . getTimeInMillis ( ) ) + ( 7 * 1000 ) ; Long intervalTime = 120 * 1000L ; Intent alertIntent = new Intent ( this , NotificationPublisher . class ) ; alertIntent . putExtra ( "TITLE_KEY" , popularArticleTitle ) ; alertIntent . putExtra ( "ID_KEY" , popularArticleId ) ; TaskStackBuilder tStackBuilder = TaskStackBuilder . create ( this ) ; <START_BUG> tStackBuilder . addParentStack ( ArticleActivity . class ) ; <END_BUG> tStackBuilder . addNextIntent ( alertIntent ) ; AlarmManager alarmManager = ( ( AlarmManager ) ( getSystemService ( ALARM_SERVICE ) ) ) ; alarmManager . setRepeating ( RTC_WAKEUP , alertTime , intervalTime , PendingIntent . getBroadcast ( this , 1 , alertIntent , FLAG_UPDATE_CURRENT ) ) ; } }
public class IRModule extends IRScopeImpl { private static final StaticScope rootObjectScope = IRStaticScopeFactory . newIRLocalScope ( null ) ; private static final String ROOT_METHOD_PREFIX = "[root]:" ; private static Map < String , IRClass > coreClasses ; private IRMethod rootMethod ; private CodeVersion version ; private List < IRModule > modules = new ArrayList < IRModule > ( ) ; private List < IRClass > classes = new ArrayList < IRClass > ( ) ; private List < IRMethod > methods = new ArrayList < IRMethod > ( ) ; private Map < String , Operand > constants = new HashMap < String , Operand > ( ) ; private static IRClass addCoreClass ( String name , IRScope parent , String [ ] coreMethods , StaticScope staticScope ) { } public static void bootStrap ( ) { } public static StaticScope getRootObjectScope ( ) { } public static IRClass getCoreClass ( String n ) { } public static boolean isAModuleRootMethod ( IRMethod m ) { } private void addRootMethod ( ) { String n = ( IRModule . ROOT_METHOD_PREFIX ) + ( getName ( ) ) ; <START_BUG> rootMethod = new IRMethod ( this , n , false , IRStaticScopeFactory . newIRLocalScope ( IRModule . rootObjectScope ) ) ; <END_BUG> rootMethod . addInstr ( new org . jruby . compiler . ir . instructions . ReceiveSelfInstruction ( rootMethod . getSelf ( ) ) ) ; rootMethod . addInstr ( new org . jruby . compiler . ir . instructions . ReceiveClosureInstr ( rootMethod . getImplicitBlockArg ( ) ) ) ; } public List < IRModule > getModules ( ) { } public List < IRClass > getClasses ( ) { } public List < IRMethod > getMethods ( ) { } public Map getConstants ( ) { } public Operand getConstantValue ( String constRef ) { } public void setConstantValue ( String constRef , Operand val ) { } public void addModule ( IRModule m ) { } public void addClass ( IRClass c ) { } public void addMethod ( IRMethod method ) { } @ Override public void runCompilerPassOnNestedScopes ( CompilerPass p ) { } @ Override public IRModule getNearestModule ( ) { } public IRModule ( IRScope lexicalParent , String name , StaticScope scope ) { } public void updateVersion ( ) { } public String getScopeName ( ) { } public CodeVersion getVersion ( ) { } public IRMethod getRootMethod ( ) { } public IRMethod getInstanceMethod ( String name ) { } public IRMethod getClassMethod ( String name ) { } public boolean isACoreClass ( ) { } public boolean isCoreClassType ( String className ) { } public RubyModule getCoreClassModule ( Ruby runtime ) { } public LocalVariable getLocalVariable ( String name , int depth ) { } }
public class Slash extends Checkable < Slash > { @ Override public Slash build ( ) { } @ RequestHandler public RamdRequestHandler slash ( RamdRequest request ) throws Exception { } private static RamdRequestHandler __handler = null ; public static RamdRequestHandler handler ( ) throws Exception { if ( ( Slash . __handler ) == null ) { synchronized ( Slash . class ) { if ( ( Slash . __handler ) == null ) <START_BUG> Slash . __handler = RamdRequestHandler . build ( "/" , "The<seq2seq4repair_space>ramd<seq2seq4repair_space>k/v<seq2seq4repair_space>store<seq2seq4repair_space>subdirectory(subspace)<seq2seq4repair_space>handler" , Slash . class , "slash" , new Class [ ] { RamdRequestHandler . class , RamdRequest . class } ) ; <END_BUG> } } return Slash . __handler ; } }
public class FilenameUtils { public static final char EXTENSION_SEPARATOR = '.' ; public static final String EXTENSION_SEPARATOR_STR = Character . toString ( FilenameUtils . EXTENSION_SEPARATOR ) ; private static final char UNIX_SEPARATOR = '/' ; private static final char WINDOWS_SEPARATOR = '\\' ; private static final char SYSTEM_SEPARATOR = File . separatorChar ; private static final char OTHER_SEPARATOR ; public FilenameUtils ( ) { } static boolean isSystemWindows ( ) { } private static boolean isSeparator ( char ch ) { } public static String normalize ( String filename ) { } public static String normalize ( String filename , boolean unixSeparator ) { } public static String normalizeNoEndSeparator ( String filename ) { } public static String normalizeNoEndSeparator ( String filename , boolean unixSeparator ) { } private static String doNormalize ( String filename , char separator , boolean keepSeparator ) { } public static String concat ( String basePath , String fullFilenameToAdd ) { } public static String separatorsToUnix ( String path ) { } public static String separatorsToWindows ( String path ) { } public static String separatorsToSystem ( String path ) { } public static int getPrefixLength ( String filename ) { } public static int indexOfLastSeparator ( String filename ) { } public static int indexOfExtension ( String filename ) { } public static String getPrefix ( String filename ) { } public static String getPath ( String filename ) { } public static String getPathNoEndSeparator ( String filename ) { } private static String doGetPath ( String filename , int separatorAdd ) { } public static String getFullPath ( String filename ) { } public static String getFullPathNoEndSeparator ( String filename ) { } private static String doGetFullPath ( String filename , boolean includeSeparator ) { } public static String getName ( String filename ) { } public static String getBaseName ( String filename ) { } public static String getExtension ( String filename ) { } public static String removeExtension ( String filename ) { } public static boolean equals ( String filename1 , String filename2 ) { } public static boolean equalsOnSystem ( String filename1 , String filename2 ) { } public static boolean equalsNormalized ( String filename1 , String filename2 ) { } public static boolean equalsNormalizedOnSystem ( String filename1 , String filename2 ) { } public static boolean equals ( String filename1 , String filename2 , boolean normalized , IOCase caseSensitivity ) { if ( ( filename1 == null ) || ( filename2 == null ) ) { <START_BUG> return filename1 == filename2 ; <END_BUG> } if ( normalized ) { filename1 = FilenameUtils . normalize ( filename1 ) ; filename2 = FilenameUtils . normalize ( filename2 ) ; if ( ( filename1 == null ) || ( filename2 == null ) ) { throw new NullPointerException ( "Error<seq2seq4repair_space>normalizing<seq2seq4repair_space>one<seq2seq4repair_space>or<seq2seq4repair_space>both<seq2seq4repair_space>of<seq2seq4repair_space>the<seq2seq4repair_space>file<seq2seq4repair_space>names" ) ; } } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } return caseSensitivity . checkEquals ( filename1 , filename2 ) ; } public static boolean isExtension ( String filename , String extension ) { } public static boolean isExtension ( String filename , String [ ] extensions ) { } public static boolean isExtension ( String filename , Collection < String > extensions ) { } public static boolean wildcardMatch ( String filename , String wildcardMatcher ) { } public static boolean wildcardMatchOnSystem ( String filename , String wildcardMatcher ) { } public static boolean wildcardMatch ( String filename , String wildcardMatcher , IOCase caseSensitivity ) { } static String [ ] splitOnTokens ( String text ) { } }
public class JavaBuilder extends IncrementalProjectBuilder { IProject currentProject ; IJavaProject javaProject ; IWorkspaceRoot workspaceRoot ; ClasspathLocation [ ] classpath ; IContainer outputFolder ; IContainer [ ] sourceFolders ; SimpleLookupTable prereqOutputFolders ; State lastState ; BuildNotifier notifier ; char [ ] [ ] resourceFilters ; public static final String JAVA_EXTENSION = "java" ; public static final String CLASS_EXTENSION = "class" ; public static final String JAR_EXTENSION = "jar" ; public static final String ZIP_EXTENSION = "zip" ; public static final String OPTION_ResourceCopyFilter = "org.eclipse.jdt.core.builder.resourceCopyExclusionFilters" ; public static boolean DEBUG = false ; static final String ProblemMarkerTag = IJavaModelMarker . JAVA_MODEL_PROBLEM_MARKER ; static ArrayList builtProjects = null ; public static IMarker [ ] getProblemsFor ( IResource resource ) { } public static void removeProblemsFor ( IResource resource ) { } public static State readState ( DataInputStream in ) throws IOException { } public static void writeState ( Object state , DataOutputStream out ) throws IOException { } public JavaBuilder ( ) { } protected IProject [ ] build ( int kind , Map ignored , IProgressMonitor monitor ) throws CoreException { } private void buildAll ( ) { } private void buildDeltas ( SimpleLookupTable deltas ) { } private void cleanup ( ) { } private void clearLastState ( ) { } private void createFolder ( IContainer folder ) throws CoreException { } boolean filterResource ( IResource resource ) { } private SimpleLookupTable findDeltas ( ) { notifier . subTask ( Util . bind ( "build.readingDelta" , currentProject . getName ( ) ) ) ; IResourceDelta delta = getDelta ( currentProject ) ; <START_BUG> SimpleLookupTable deltas = new SimpleLookupTable ( ) ; <END_BUG> if ( delta != null ) { deltas . put ( currentProject , delta ) ; } else { if ( JavaBuilder . DEBUG ) System . out . println ( ( "Missing<seq2seq4repair_space>delta<seq2seq4repair_space>for:<seq2seq4repair_space>" + ( currentProject . getName ( ) ) ) ) ; notifier . subTask ( "" ) ; return null ; } Object [ ] keyTable = prereqOutputFolders . keyTable ; for ( int i = 0 , l = keyTable . length ; i < l ; i ++ ) { IProject prereqProject = ( ( IProject ) ( keyTable [ i ] ) ) ; if ( ( prereqProject != null ) && ( lastState . isStructurallyChanged ( prereqProject , getLastState ( prereqProject ) ) ) ) { notifier . subTask ( Util . bind ( "build.readingDelta" , prereqProject . getName ( ) ) ) ; delta = getDelta ( prereqProject ) ; if ( delta != null ) { deltas . put ( prereqProject , delta ) ; } else { if ( JavaBuilder . DEBUG ) System . out . println ( ( "Missing<seq2seq4repair_space>delta<seq2seq4repair_space>for:<seq2seq4repair_space>" + ( prereqProject . getName ( ) ) ) ) ; notifier . subTask ( "" ) ; return null ; } } } notifier . subTask ( "" ) ; return deltas ; } private State getLastState ( IProject project ) { } private IProject [ ] getRequiredProjects ( ) { } private boolean hasClasspathChanged ( ) { } private boolean hasOutputLocationChanged ( ) { } private void initializeBuilder ( ) throws CoreException { } private void recordNewState ( State state ) { } public String toString ( ) { } }
public class LocalFacade { private LocalManager manager ; public LocalFacade ( LocalManager manager ) { } public ArrayList < PackagedInscription > fetchAll ( ) { } public ArrayList < PackagedInscription > fetchNearby ( Location location , double radius ) { } public ArrayList < PackagedInscription > fetchUnblocked ( ) { } public ArrayList < PackagedInscription > fetchNearbyUnblocked ( Location location , double radius ) { } public ArrayList < PackagedInscription > fetchWithinCity ( String cityName ) { } public ArrayList < PackagedInscription > textSearch ( String text , Language lingo ) { } public ArrayList < PackagedInscription > getPackagesByIds ( int [ ] ids ) { <START_BUG> return manager . getPackagesByIds ( int [ ] :: ids ) ; <END_BUG> } public void insertInscriptions ( ArrayList < PackagedInscription > packagedInscriptions ) { } public void setEncounteredTrue ( int id ) { } public void setEncounteredFalse ( int id ) { } public void setOpenedTrue ( int id ) { } public void setOpenedFalse ( int id ) { } public void setFoundTrue ( int id ) { } public void setFoundFalse ( int id ) { } public void setNeverNotifyTrue ( int id ) { } public void setNeverNotifyFalse ( int id ) { } public void setTimeoutLimit ( int id , Date date ) { } public void removeTimeoutLimit ( int id ) { } public void setDateFound ( int id , Date date ) { } public void removeDateFound ( int id ) { } public void setDateLastNotified ( int id , Date date ) { } public void removeDateLastNotified ( int id ) { } public void resetAllPreferences ( ) { } public void dumpAll ( ) { } public void seedDatabase ( ) { } public void dumpTranslations ( ) { } }
public class StorageService implements IEndpointStateChangeSubscriber , StorageServiceMBean { private static Logger logger_ = LoggerFactory . getLogger ( StorageService . class ) ; public static final int RING_DELAY = 30 * 1000 ; public enum Verb { MUTATION , BINARY , READ_REPAIR , READ , REQUEST_RESPONSE , STREAM_INITIATE , STREAM_INITIATE_DONE , STREAM_REPLY , STREAM_REQUEST , RANGE_SLICE , BOOTSTRAP_TOKEN , TREE_REQUEST , TREE_RESPONSE , JOIN , GOSSIP_DIGEST_SYN , GOSSIP_DIGEST_ACK , GOSSIP_DIGEST_ACK2 , DEFINITIONS_ANNOUNCE , DEFINITIONS_UPDATE , TRUNCATE , SCHEMA_CHECK , INDEX_SCAN , REPLICATION_FINISHED , INTERNAL_RESPONSE , COUNTER_MUTATION , UNUSED_1 , UNUSED_2 , UNUSED_3 ; } public static final StorageService . Verb [ ] VERBS = StorageService . Verb . values ( ) ; public static final EnumMap < StorageService . Verb , Stage > verbStages = new EnumMap < StorageService . Verb , Stage > ( StorageService . Verb . class ) { } ; public static final RetryingScheduledThreadPoolExecutor scheduledTasks = new RetryingScheduledThreadPoolExecutor ( "ScheduledTasks" ) ; public static final RetryingScheduledThreadPoolExecutor tasks = new RetryingScheduledThreadPoolExecutor ( "NonPeriodicTasks" ) ; private TokenMetadata tokenMetadata_ = new TokenMetadata ( ) ; private IPartitioner partitioner = DatabaseDescriptor . getPartitioner ( ) ; public VersionedValueFactory valueFactory = new VersionedValue . VersionedValueFactory ( partitioner ) ; public static final StorageService instance = new StorageService ( ) ; public static IPartitioner getPartitioner ( ) { } public Collection < Range > getLocalRanges ( String table ) { } public Range getLocalPrimaryRange ( ) { } private Set < InetAddress > replicatingNodes = Collections . synchronizedSet ( new HashSet < InetAddress > ( ) ) ; private CassandraDaemon daemon ; private InetAddress removingNode ; private boolean isBootstrapMode ; private boolean isClientMode ; private boolean initialized ; private volatile boolean joined = false ; private String operationMode ; private volatile boolean efficientCrossDCWrites ; private MigrationManager migrationManager = new MigrationManager ( ) ; private volatile int totalCFs ; private volatile int remainingCFs ; public void finishBootstrapping ( ) { } public void setToken ( Token token ) { } public StorageService ( ) { } public void registerDaemon ( CassandraDaemon daemon ) { } public void stopGossiping ( ) { } public void startGossiping ( ) { } public void startRPCServer ( ) { } public void stopRPCServer ( ) { } public boolean isRPCServerRunning ( ) { } public void stopClient ( ) { } public boolean isInitialized ( ) { } public synchronized void initClient ( ) throws IOException , ConfigurationException { } public synchronized void initClient ( int delay ) throws IOException , ConfigurationException { } public synchronized void initServer ( ) throws IOException , ConfigurationException { } private void joinTokenRing ( ) throws IOException , ConfigurationException { } public synchronized void joinRing ( ) throws IOException , ConfigurationException { } public boolean isJoined ( ) { } public void setCompactionThroughputMbPerSec ( int value ) { } private void setMode ( String m , boolean log ) { } private void bootstrap ( Token token ) throws IOException { } public boolean isBootstrapMode ( ) { } public TokenMetadata getTokenMetadata ( ) { } public Map < Range , List < String > > getRangeToEndpointMap ( String keyspace ) { } public Map < Range , List < String > > getRangeToRpcaddressMap ( String keyspace ) { if ( keyspace == null ) keyspace = DatabaseDescriptor . getNonSystemTables ( ) . get ( 0 ) ; Map < Range , List < String > > map = new HashMap < Range , List < String > > ( ) ; for ( Map . Entry < Range , List < InetAddress > > entry : getRangeToAddressMap ( keyspace ) . entrySet ( ) ) { List < String > rpcaddrs = new ArrayList < String > ( ) ; for ( InetAddress endpoint : entry . getValue ( ) ) { if ( endpoint . equals ( FBUtilities . getLocalAddress ( ) ) ) <START_BUG> rpcaddrs . add ( DatabaseDescriptor . getRpcAddress ( ) . toString ( ) ) ; <END_BUG> else rpcaddrs . add ( Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) . getApplicationState ( RPC_ADDRESS ) . value ) ; } map . put ( entry . getKey ( ) , rpcaddrs ) ; } return map ; } public Map < Range , List < String > > getPendingRangeToEndpointMap ( String keyspace ) { } public Map < Range , List < InetAddress > > getRangeToAddressMap ( String keyspace ) { } public Map < Token , String > getTokenToEndpointMap ( ) { } private Map < Range , List < InetAddress > > constructRangeToEndpointMap ( String keyspace , List < Range > ranges ) { } public void onChange ( InetAddress endpoint , ApplicationState state , VersionedValue value ) { } private void updateEfficientCrossDCWriteMode ( ) { } private void handleStateBootstrap ( InetAddress endpoint , String [ ] pieces ) { } private void handleStateNormal ( InetAddress endpoint , String [ ] pieces ) { } private void handleStateLeaving ( InetAddress endpoint , String [ ] pieces ) { } private void handleStateLeft ( InetAddress endpoint , String [ ] pieces ) { } private void handleStateMoving ( InetAddress endpoint , String [ ] pieces ) { } private void handleStateRemoving ( InetAddress endpoint , String [ ] pieces ) { } private void excise ( Token token , InetAddress endpoint ) { } private void calculatePendingRanges ( ) { } public static void calculatePendingRanges ( AbstractReplicationStrategy strategy , String table ) { } private Multimap < InetAddress , Range > getNewSourceRanges ( String table , Set < Range > ranges ) { } private void sendReplicationNotification ( InetAddress local , InetAddress remote ) { } private void restoreReplicaCount ( InetAddress endpoint , final InetAddress notifyEndpoint ) { } private Multimap < Range , InetAddress > getChangedRangesForLeaving ( String table , InetAddress endpoint ) { } public void onJoin ( InetAddress endpoint , EndpointState epState ) { } public void onAlive ( InetAddress endpoint , EndpointState state ) { }
public class MatrixAnaglyphGeneratorLUT extends AnaglyphGenerator { private int [ ] leftLUT ; private int [ ] rightLUT ; public MatrixAnaglyphGeneratorLUT ( AnaglyphMatrix left , AnaglyphMatrix right ) { } public static AnaglyphGenerator createTrueAnaglyphGenerator ( ) { } public static AnaglyphGenerator createGrayAnaglyphGenerator ( ) { } public static AnaglyphGenerator createHalfColorAnaglyphGenerator ( ) { } private int [ ] preComputeLUT ( AnaglyphMatrix matrix ) { } public void generateAnaglyph ( int [ ] pixels , int [ ] pixelsAlt ) { for ( int ii = 0 ; ii < ( pixels . length ) ; ++ ii ) { <START_BUG> pixels [ ii ] = ( - 16777216 | ( leftLUT [ ( ( pixels [ ii ] ) & 16777215 ) ] ) ) | ( rightLUT [ ( ( pixels [ ii ] ) & 16777215 ) ] ) ; <END_BUG> } } }
public class HilbertOps { public static void main ( String [ ] args ) { for ( int i = 2 ; i <= 20 ; i ++ ) { double [ ] [ ] H = HilbertOps . generateHilbertMatrix ( i ) ; double [ ] b_ = new double [ i ] ; double [ ] [ ] matrixb = new double [ ] [ ] { b_ } ; Arrays . fill ( b_ , Math . pow ( 0.1 , ( i / 3 ) ) ) ; LUFactorization luFact = LUFactorization . lu_fact ( H ) ; double [ ] luSolution = HilbertOps . solve_lu_b ( luFact , b_ ) ; double [ ] Hx_forLU = matrixVectorMult ( H , luSolution ) ; double normDifferenceLU = HilbertOps . norm ( matrixSubtract ( new double [ ] [ ] { Hx_forLU } , matrixb ) ) ; System . out . println ( "============LU============" ) ; System . out . println ( ( "x_sol:<seq2seq4repair_space>" + ( Arrays . toString ( luSolution ) ) ) ) ; System . out . println ( ( "||LU<seq2seq4repair_space>-<seq2seq4repair_space>H||<seq2seq4repair_space>=<seq2seq4repair_space>" + ( luFact . getError ( ) ) ) ) ; System . out . println ( ( "||Hx<seq2seq4repair_space>-<seq2seq4repair_space>b||<seq2seq4repair_space>=<seq2seq4repair_space>" + normDifferenceLU ) ) ; System . out . println ( ) ; QRFactorization QRHHFact = QRFactorization . qr_fact_househ ( H ) ; double [ ] QRHHSolution = HilbertOps . solve_qr_b ( QRHHFact , b_ ) ; double [ ] Hx_forHH = matrixVectorMult ( H , QRHHSolution ) ; double normDifferenceHH = HilbertOps . norm ( matrixSubtract ( new double [ ] [ ] { Hx_forHH } , matrixb ) ) ; System . out . println ( "======QR<seq2seq4repair_space>Householder=======" ) ; System . out . println ( ( "x_sol:<seq2seq4repair_space>" + ( Arrays . toString ( QRHHSolution ) ) ) ) ; System . out . println ( ( "||QR<seq2seq4repair_space>-<seq2seq4repair_space>H||<seq2seq4repair_space>=<seq2seq4repair_space>" + ( QRHHFact . getError ( ) ) ) ) ; System . out . println ( ( "||Hx<seq2seq4repair_space>-<seq2seq4repair_space>b||<seq2seq4repair_space>=<seq2seq4repair_space>" + normDifferenceHH ) ) ; System . out . println ( ) ; QRFactorization QRGFact = QRFactorization . qr_fact_givens ( H ) ; double [ ] QRGSolution = HilbertOps . solve_qr_b ( QRGFact , b_ ) ; double [ ] Hx_forG = matrixVectorMult ( H , QRGSolution ) ; double normDifferenceG = HilbertOps . norm ( matrixSubtract ( new double [ ] [ ] { Hx_forG } , matrixb ) ) ; System . out . println ( "=========QR<seq2seq4repair_space>Givens=========" ) ; <START_BUG> System . out . println ( ( "x_sol:<seq2seq4repair_space>" + ( Arrays . toString ( luSolution ) ) ) ) ; <END_BUG> System . out . println ( ( "||QR<seq2seq4repair_space>-<seq2seq4repair_space>H||<seq2seq4repair_space>=<seq2seq4repair_space>" + ( QRGFact . getError ( ) ) ) ) ; System . out . println ( ( "||Hx<seq2seq4repair_space>-<seq2seq4repair_space>b||<seq2seq4repair_space>=<seq2seq4repair_space>" + normDifferenceG ) ) ; System . out . println ( ) ; } } public static double [ ] solve_lu_b ( LUFactorization factorization , double [ ] b_ ) { } public static double [ ] solve_qr_b ( QRFactorization factorization , double [ ] b_ ) { } static double [ ] [ ] generateHilbertMatrix ( int width ) { } public static void printMatrix ( double [ ] [ ] matrix ) { } static double norm ( double [ ] [ ] matrix ) { } static void swap ( double [ ] [ ] matrix , int row , int row2 ) { } static void LInverse ( double [ ] [ ] L ) { } static double cosine ( double x , double y ) { } static double sine ( double x , double y ) { } No newline ; at end ; of file ; }
public class DropDownChoice extends AbstractChoice { private static final long serialVersionUID = 122777360064586107L ; public DropDownChoice ( String name , Serializable object , final Collection values ) { } public DropDownChoice ( String name , Serializable object , String expression , final Collection values ) { } public final String getValue ( ) { } public final void onSelectionChanged ( ) { } public final void setValue ( final String value ) { } public final void updateModel ( ) { } protected void onComponentTag ( final ComponentTag tag ) { } protected void onSelectionChanged ( final Object newSelection ) { } private Object internalUpdateModel ( ) { <START_BUG> final String indexOrId = getRequestString ( ) ; <END_BUG> Object object = null ; final List list = getValues ( ) ; if ( ( indexOrId == null ) || ( "" . equals ( indexOrId ) ) ) { setModelObject ( null ) ; } else if ( list instanceof IDetachableChoiceList ) { object = ( ( IDetachableChoiceList ) ( list ) ) . objectForId ( indexOrId ) ; setModelObject ( object ) ; } else { object = list . get ( Integer . parseInt ( indexOrId ) ) ; setModelObject ( object ) ; } return object ; } }
public class XMPPGroupChatSOContainer extends ClientSOContainer { public static final String XMPP_GROUP_CHAT_SHARED_OBJECT_ID = ( XMPPClientSOContainer . class . getName ( ) ) + ".xmppgroupchathandler" ; XMPPConnection connection ; ID sharedObjectID ; XMPPGroupChatSharedObject sharedObject ; MultiUserChat multiuserchat ; IGroupChatContainerConfig gcconfig ; public XMPPGroupChatSOContainer ( IGroupChatContainerConfig config , XMPPConnection conn ) throws Exception { } protected IGroupChatContainerConfig getGroupChatConfig ( ) { } protected void initializeGroupChat ( ) throws XMPPException { } public void dispose ( long time ) { } protected void handleChatMessage ( Message mess ) throws IOException { } protected void handleContainerMessage ( ContainerMessage mess ) throws IOException { } protected void handleIQMessage ( IQ mess ) throws IOException { } protected void handlePresenceMessage ( Presence mess ) throws IOException { } protected void handleXMPPMessage ( Packet aPacket ) throws IOException { } protected void initializeSharedObject ( ) throws Exception { } protected void addSharedObjectToContainer ( ID remote ) throws SharedObjectAddException { <START_BUG> getSharedObjectManager ( ) . addSharedObject ( sharedObjectID , sharedObject , new HashMap ( ) , null ) ; <END_BUG> } protected void cleanUpConnectFail ( ) { } public void joinGroup ( ID remote , Object data ) throws SharedObjectContainerJoinException { } public void leaveGroup ( ) { } protected SOContext makeSharedObjectContext ( SOConfig soconfig , IQueueEnqueue queue ) { } protected void processAsynch ( AsynchConnectionEvent e ) { } protected ISynchAsynchConnection makeConnection ( ID remoteSpace , Object data ) throws ConnectionInstantiationException { } }
public final class Main { public static void main ( String [ ] args ) { } private static StandaloneServer create ( String [ ] args ) { } Properties props = new Properties ( System . getProperties ( ) ) ; private Main ( ) { } private StandaloneServer boot ( final String [ ] args ) { StandaloneServer server = null ; try { ServerEnvironment config = Main . determineEnvironment ( args , props ) ; if ( config == null ) { abort ( null ) ; } else { if ( config . isStandalone ( ) ) { <START_BUG> server = new StandaloneServer ( config ) ; <END_BUG> } else { throw new IllegalStateException ( ) ; } server . start ( ) ; return server ; } } catch ( Throwable t ) { abort ( t ) ; } return null ; } private void abort ( Throwable t ) { } public static ServerEnvironment determineEnvironment ( String [ ] args , Properties systemProperties ) { } private static URL makeURL ( String urlspec ) throws MalformedURLException { } }
public class CleanDatabaseTestSetup extends BaseJDBCTestSetup { public CleanDatabaseTestSetup ( Test test ) { } protected void setUp ( ) throws Exception { } protected void decorateSQL ( Statement s ) throws SQLException { } protected void tearDown ( ) throws Exception { } public static void cleanDatabase ( Connection conn ) throws SQLException { } private static final String [ ] CLEAR_DB_PROPERTIES = new String [ ] { "derby.database.classpath" } ; private static void clearProperties ( Connection conn ) throws SQLException { } private static void removeObjects ( Connection conn ) throws SQLException { DatabaseMetaData dmd = conn . getMetaData ( ) ; SQLException sqle = null ; for ( int count = 0 ; count < 5 ; count ++ ) { List schemas = new ArrayList ( ) ; ResultSet rs = dmd . getSchemas ( ) ; while ( rs . next ( ) ) { String schema = rs . getString ( "TABLE_SCHEM" ) ; if ( schema . startsWith ( "SYS" ) ) continue ; if ( schema . equals ( "SQLJ" ) ) continue ; if ( schema . equals ( "NULLID" ) ) continue ; schemas . add ( schema ) ; } rs . close ( ) ; sqle = null ; for ( Iterator i = schemas . iterator ( ) ; i . hasNext ( ) ; ) { String schema = ( ( String ) ( i . next ( ) ) ) ; try { JDBC . dropSchema ( dmd , schema ) ; } catch ( SQLException e ) { <START_BUG> sqle = null ; <END_BUG> } } if ( sqle == null ) return ; } throw sqle ; } private static final String [ ] COMPRESS_DB_OBJECTS = new String [ ] { "SYS.SYSDEPENDS" } ; private static void compressObjects ( Connection conn ) throws SQLException { } }
public class Test_org_eclipse_swt_widgets_TableItem extends Test_org_eclipse_swt_widgets_Item { public Test_org_eclipse_swt_widgets_TableItem ( String name ) { } public static void main ( String [ ] args ) { } protected void setUp ( ) { } public void test_ConstructorLorg_eclipse_swt_widgets_TableI ( ) { } public void test_ConstructorLorg_eclipse_swt_widgets_TableII ( ) { } public void test_getBackground ( ) { } public void test_getBackgroundI ( ) { } public void test_getBoundsI ( ) { } public void test_getChecked ( ) { } public void test_getFont ( ) { } public void test_getFontI ( ) { } public void test_getForeground ( ) { } public void test_getForegroundI ( ) { } public void test_getGrayed ( ) { } public void test_getImageBoundsI ( ) { } public void test_getImageI ( ) { } public void test_getImageIndent ( ) { } public void test_getParent ( ) { } public void test_getTextI ( ) { } public void test_setBackgroundILorg_eclipse_swt_graphics_Color ( ) { } public void test_setBackgroundLorg_eclipse_swt_graphics_Color ( ) { } public void test_setCheckedZ ( ) { } public void test_setFontLorg_eclipse_swt_graphics_Font ( ) { } public void test_setFontILorg_eclipse_swt_graphics_Font ( ) { } public void test_setForegroundILorg_eclipse_swt_graphics_Color ( ) { } public void test_setForegroundLorg_eclipse_swt_graphics_Color ( ) { } public void test_setGrayedZ ( ) { } public void test_setImage$Lorg_eclipse_swt_graphics_Image ( ) { } public void test_setImageILorg_eclipse_swt_graphics_Image ( ) { } public void test_setImageIndentI ( ) { <START_BUG> if ( ( SwtJunit . isCarbon ) || ( SwtJunit . isGTK ) ) { <END_BUG> tableItem . setImageIndent ( 1 ) ; return ; } assertEquals ( 0 , tableItem . getImageIndent ( ) ) ; tableItem . setImageIndent ( 1 ) ; assertEquals ( 1 , tableItem . getImageIndent ( ) ) ; tableItem . setImageIndent ( ( - 1 ) ) ; assertEquals ( 1 , tableItem . getImageIndent ( ) ) ; } public void test_setText$Ljava_lang_String ( ) { } public void test_setTextILjava_lang_String ( ) { } public static Test suite ( ) { } public static Vector methodNames ( ) { } protected void runTest ( ) throws Throwable { } Table table ; TableItem tableItem ; private void makeCleanEnvironment ( ) { } }
@ FixMethodOrder ( MethodSorters . NAME_ASCENDING ) public abstract class GenericScheduleJobTestParent { private static final Logger logger = LoggerFactory . getLogger ( GenericScheduleJobTestParent . class ) ; private static String TEST_ROOT ; protected static JobTestConfig config ; protected Xenon xenon ; protected Files files ; protected Jobs jobs ; protected Credentials credentials ; protected Scheduler scheduler ; protected Job job ; protected Path testDir ; @ Rule public TestWatcher watcher = new XenonTestWatcher ( ) ; public Path resolve ( Path root , String path ) throws XenonException { } public static void prepareClass ( JobTestConfig testConfig ) { } public static void cleanupClass ( ) throws Exception { } @ Before public void prepare ( ) throws Exception { } @ After public void cleanup ( ) throws XenonException { } protected String getWorkingDir ( String testName ) { } protected Path initJobDirectory ( String workingDir ) throws Exception , XenonException { } protected void checkJobDone ( JobStatus status ) throws JobException { } protected void checkJobOutput ( Job job , Path root ) throws IOException , XenonException { } protected void checkJobOutput ( Job job , Path root , String expectedStdout ) throws IOException , XenonException { } protected void checkJobOutput ( Job job , Path root , String expectedStdout , String expectedWindowsStdout ) throws IOException , XenonException { } protected String readFile ( Path root , String filename ) throws IOException , XenonException { } protected String readFully ( Path p ) throws IOException , XenonException { } protected void writeFully ( Path p , String message ) throws IOException , XenonException { } protected void writeFully ( OutputStream out , String message ) throws IOException { } protected void cleanupJobRecursive ( Path root ) { } protected void cleanupJob ( Job job , Path root , Path ... otherPaths ) throws XenonException { } protected void runJob ( String workingDir , JobDescription description , String expectedOutput ) throws Exception { } protected JobDescription printEnvJobDescription ( String workDir , String value ) { } protected JobDescription echoJobDescription ( String workingDir , String message ) { } protected JobDescription catJobDescription ( String workingDir , String message ) { } protected JobDescription timedJobDescription ( String workingDir , int seconds ) { } protected JobDescription catJobDescription ( String workingDir , Path stdin , String message ) throws IOException , XenonException { } protected JobDescription nonExistingJobDescription ( String workingDir ) { } @ Test public void test30_interactiveJobSubmit ( ) throws Exception { if ( ! ( scheduler . supportsInteractive ( ) ) ) { return ; } String message = "Hello<seq2seq4repair_space>World!<seq2seq4repair_space>test30" ; JobDescription description = catJobDescription ( null , message ) ; description . setInteractive ( true ) ; GenericScheduleJobTestParent . logger . info ( ( ( ( "Submitting<seq2seq4repair_space>interactive<seq2seq4repair_space>job<seq2seq4repair_space>to<seq2seq4repair_space>" + ( scheduler . getScheme ( ) ) ) + "://" ) + ( scheduler . getLocation ( ) ) ) ) ; job = jobs . submitJob ( scheduler , description ) ; GenericScheduleJobTestParent . logger . info ( ( ( ( "Interactive<seq2seq4repair_space>job<seq2seq4repair_space>submitted<seq2seq4repair_space>to<seq2seq4repair_space>" + ( scheduler . getScheme ( ) ) ) + "://" ) + ( scheduler . getLocation ( ) ) ) ) ; Streams streams = jobs . getStreams ( job ) ; PrintWriter w = new PrintWriter ( streams . getStdin ( ) ) ; <START_BUG> w . println ( message ) ; <END_BUG> w . flush ( ) ; w . close ( ) ; String out = Utils . readToString ( streams . getStdout ( ) ) ; String err = Utils . readToString ( streams . getStderr ( ) ) ; JobStatus status = jobs . waitUntilDone ( job , GenericScheduleJobTestParent . config . getJobTimeout ( 30 ) ) ; checkJobDone ( status ) ; assertNotNull ( out ) ; assertNotNull ( err ) ; if ( GenericScheduleJobTestParent . config . targetIsWindows ( ) ) { assertTrue ( ( ( out . length ( ) ) > 0 ) ) ; } else { assertEquals ( message , out ) ; } assertEquals ( 0 , err . length ( ) ) ; } @ Test public void test31_batchJobSubmitWithPolling ( ) throws Exception { } @ Test public void test32_batchJobSubmitWithWait ( ) throws Exception { } protected void submitToQueueWithPolling ( String testName , String queueName , int jobCount ) throws Exception { } @ Test public void test33a_testMultiBatchJobSubmitWithPolling ( ) throws Exception { } @ Test public void test33b_testMultiBatchJobSubmitWithPolling ( ) throws Exception { } @ Test public void test34_batchJobSubmitWithKill ( ) throws Exception { } @ Test public void test35_batchJobSubmitWithKill2 ( ) throws Exception { } @ Test public void test36a_batchJobSubmitWithInput ( ) throws Exception { } @ Test public void test36b_batchJobSubmitWithInput ( ) throws Exception { } @ Test public void test37a_batchJobSubmitWithoutWorkDir ( ) throws Exception { } @ Test public void test37b_batchJobSubmitWithRelativeWorkDir ( ) throws Exception { } @ Test public void test37c_batchJobSubmitWithAbsoluteWorkDir ( ) throws Exception { } @ Test public void test37d_batchJobSubmitWithIncorrectWorkingDir ( ) throws Exception { } @ Test public void test37e_batchJobSubmitWithWorkDirWithSpaces ( ) throws Exception { } public void test38_multipleBatchJobSubmitWithInput ( ) throws Exception { } @ Test public void test39_multipleBatchJobSubmitWithExceptions ( ) throws Exception { } @ Test public void test40_batchJobSubmitWithExitcode ( ) throws Exception { } @ Test public void test40_batchJobSubmitWithNonZeroExitcode ( ) throws Exception { } @ Test public void test41_batchJobSubmitWithEnvironmentVariable ( ) throws Exception { } @ Test public void test41b_batchJobSubmitWithEnvironmentVariable ( ) throws Exception { } @ Test public void test42a_batchJob_parallel_Exception ( ) throws Exception { } @ Test public void test43_submit_JobDescriptionShouldBeCopied_Success ( ) throws Exception { } @ Test public void test44_submit_JobDescriptionShouldBeSame ( ) throws Exception { } }
public abstract class BehavioralFeature extends Feature { public boolean _isQuery ; public Vector _parameter = new Vector ( ) ; public Vector _raisedException = new Vector ( ) ; public BehavioralFeature ( ) { } public BehavioralFeature ( Name name ) { } public BehavioralFeature ( String nameStr ) { } public boolean getIsQuery ( ) { } public void setIsQuery ( boolean x ) throws PropertyVetoException { } public Classifier getReturnType ( ) { } public void setReturnType ( Classifier rt ) throws PropertyVetoException { Parameter p = findParameter ( RETURN_NAME ) ; if ( p == null ) { <START_BUG> p = new Parameter ( rt , Parameter . RETURN_NAME ) ; <END_BUG> addParameter ( p ) ; } else { p . setType ( rt ) ; } } public Parameter findParameter ( Name n ) { } public Vector getParameter ( ) { } public void setParameter ( Vector x ) throws PropertyVetoException { } public void addParameter ( Parameter x ) throws PropertyVetoException { } public void removeParameter ( Parameter x ) throws PropertyVetoException { } public Vector getRaisedException ( ) { } public void setRaisedException ( Vector x ) throws PropertyVetoException { } public void addRaisedException ( MMException x ) throws PropertyVetoException { } public void removeRaisedException ( MMException x ) throws PropertyVetoException { } static final long serialVersionUID = 7697916359219415113L ; }
public class ConfigAccessor { private final String fileName ; private final File configFile ; private FileConfiguration fileConfiguration ; public ConfigAccessor ( File pluginFolder , String fileName ) { } public void reloadFile ( ) { } private InputStream getResource ( String fileName ) { } public FileConfiguration getConfig ( ) { } public void saveConfig ( ) { } public boolean createFile ( ) { if ( ! ( configFile . exists ( ) ) ) { <START_BUG> saveFile ( false ) ; <END_BUG> return true ; } return false ; } private void saveFile ( boolean overwrite ) { } }
public class ExpandItem extends Item { ExpandBar parent ; Control control ; boolean expanded ; boolean hover ; int x ; int y ; int width ; int height ; int imageHeight ; int imageWidth ; static final int TEXT_INSET = 6 ; static final int BORDER = 1 ; static final int CHEVRON_SIZE = 24 ; public ExpandItem ( ExpandBar parent , int style ) { } public ExpandItem ( ExpandBar parent , int style , int index ) { } static ExpandBar checkNull ( ExpandBar control ) { } private void drawChevron ( int hDC , RECT rect ) { } void drawItem ( GC gc , int hTheme , RECT clipRect , boolean drawFocus ) { } void destroyWidget ( ) { } public Control getControl ( ) { } public boolean getExpanded ( ) { } public int getHeaderHeight ( ) { } public int getHeight ( ) { } public ExpandBar getParent ( ) { } int getPreferredWidth ( int hTheme , int hDC ) { } void redraw ( boolean all ) { } void releaseHandle ( ) { } void releaseWidget ( ) { } void setBounds ( int x , int y , int width , int height , boolean move , boolean size ) { } public void setControl ( Control control ) { } public void setExpanded ( boolean expanded ) { checkWidget ( ) ; this . expanded = expanded ; <START_BUG> parent . showItem ( parent . indexOf ( this ) ) ; <END_BUG> } public void setHeight ( int height ) { } public void setImage ( Image image ) { } public void setText ( String string ) { } }
public class Teacher extends Person { private String [ ] subjects ; public Teacher ( String firstname , String surname , int age , String [ ] subjects ) { } public void removeSubject ( String subject ) { String [ ] old = subjects ; String [ ] newSub = new String [ ( old . length ) - 1 ] ; for ( int i = 0 , k = 0 ; i < ( old . length ) ; i ++ ) { if ( ! ( old [ i ] . equals ( subject ) ) ) { k ++ ; newSub [ k ] = old [ i ] ; } } <START_BUG> newSub [ old . length ] = subject ; <END_BUG> subjects = newSub ; } public void setSubjects ( String [ ] subjects ) { } public void addSubject ( String subject ) { } public String [ ] getSubjects ( ) { } }
public class IncomingStreamReader { private static final Logger logger = LoggerFactory . getLogger ( IncomingStreamReader . class ) ; protected final PendingFile localFile ; protected final PendingFile remoteFile ; protected final StreamInSession session ; private final Socket socket ; public IncomingStreamReader ( StreamHeader header , Socket socket ) throws IOException { } public void read ( ) throws IOException { } private SSTableReader streamIn ( DataInput input , PendingFile localFile , PendingFile remoteFile ) throws IOException { ColumnFamilyStore cfs = Table . open ( localFile . desc . ksname ) . getColumnFamilyStore ( localFile . desc . cfname ) ; DecoratedKey key ; SSTableWriter writer = new SSTableWriter ( localFile . getFilename ( ) , remoteFile . estimatedKeys ) ; CompactionController controller = null ; try { BytesReadTracker in = new BytesReadTracker ( input ) ; for ( Pair < Long , Long > section : localFile . sections ) { long length = ( section . right ) - ( section . left ) ; long bytesRead = 0 ; while ( bytesRead < length ) { <START_BUG> in . reset ( ) ; <END_BUG> key = SSTableReader . decodeKey ( StorageService . getPartitioner ( ) , localFile . desc , ByteBufferUtil . readWithShortLength ( in ) ) ; long dataSize = SSTableReader . readRowSize ( in , localFile . desc ) ; ColumnFamily cf = null ; if ( cfs . metadata . getDefaultValidator ( ) . isCommutative ( ) ) { if ( controller == null ) controller = new CompactionController ( cfs , Collections . < SSTableReader > emptyList ( ) , Integer . MAX_VALUE , true ) ; SSTableIdentityIterator iter = new SSTableIdentityIterator ( cfs . metadata , in , key , 0 , dataSize , true ) ; AbstractCompactedRow row = controller . getCompactedRow ( iter ) ; writer . append ( row ) ; writer . updateMaxTimestamp ( row . maxTimestamp ( ) ) ; if ( row instanceof PrecompactedRow ) { cf = ( ( PrecompactedRow ) ( row ) ) . getFullColumnFamily ( ) ; } } else { IndexHelper . skipBloomFilter ( in ) ; IndexHelper . skipIndex ( in ) ; cf = ColumnFamily . create ( cfs . metadata ) ; ColumnFamily . serializer ( ) . deserializeFromSSTableNoColumns ( cf , in ) ; ColumnFamily . serializer ( ) . deserializeColumns ( in , cf , true , true ) ; writer . append ( key , cf ) ; } ColumnFamily cached = cfs . getRawCachedRow ( key ) ; if ( cached != null ) { switch ( remoteFile . type ) { case AES : if ( dataSize > ( DatabaseDescriptor . getInMemoryCompactionLimit ( ) ) ) { IncomingStreamReader . logger . warn ( "Found<seq2seq4repair_space>a<seq2seq4repair_space>cached<seq2seq4repair_space>row<seq2seq4repair_space>over<seq2seq4repair_space>the<seq2seq4repair_space>in<seq2seq4repair_space>memory<seq2seq4repair_space>compaction<seq2seq4repair_space>limit<seq2seq4repair_space>during<seq2seq4repair_space>post-streaming<seq2seq4repair_space>rebuilt;<seq2seq4repair_space>it<seq2seq4repair_space>is<seq2seq4repair_space>highly<seq2seq4repair_space>recommended<seq2seq4repair_space>to<seq2seq4repair_space>avoid<seq2seq4repair_space>huge<seq2seq4repair_space>row<seq2seq4repair_space>on<seq2seq4repair_space>column<seq2seq4repair_space>family<seq2seq4repair_space>with<seq2seq4repair_space>row<seq2seq4repair_space>cache<seq2seq4repair_space>enabled." ) ; cfs . invalidateCachedRow ( key ) ; } else { assert cf != null ; cfs . updateRowCache ( key , cf ) ; } break ; default : cfs . invalidateCachedRow ( key ) ; break ; } } bytesRead += in . getBytesRead ( ) ; remoteFile . progress += in . getBytesRead ( ) ; } } return writer . closeAndOpenReader ( ) ; } finally { writer . cleanupIfNecessary ( ) ; } } private void retry ( ) throws IOException { } }
public class Label { public CodeStream codeStream ; static final int POS_NOT_SET = - 1 ; public int position = Label . POS_NOT_SET ; int [ ] forwardReferences = new int [ 10 ] ; int forwardReferenceCount = 0 ; private boolean isWide = false ; public Label ( ) { } public Label ( CodeStream codeStream ) { } void addForwardReference ( int iPos ) { } void appendForwardReferencesFrom ( Label otherLabel ) { } void branch ( ) { } void branchWide ( ) { } public boolean hasForwardReferences ( ) { } public void inlineForwardReferencesFromLabelsTargeting ( int gotoLocation ) { } public boolean isStandardLabel ( ) { } public void place ( ) { if ( ( position ) == ( Label . POS_NOT_SET ) ) { position = codeStream . position ; codeStream . addLabel ( this ) ; int oldPosition = position ; boolean optimizedBranch = false ; if ( ( forwardReferenceCount ) != 0 ) { if ( optimizedBranch = ( ( ( forwardReferences [ ( ( forwardReferenceCount ) - 1 ) ] ) + 2 ) == ( position ) ) && ( ( codeStream . bCodeStream [ ( ( codeStream . classFileOffset ) - 3 ) ] ) == ( OPC_goto ) ) ) { codeStream . position = position -= 3 ; codeStream . classFileOffset -= 3 ; ( forwardReferenceCount ) -- ; int index = ( codeStream . pcToSourceMapSize ) - 2 ; if ( ( codeStream . lastEntryPC ) == oldPosition ) { codeStream . lastEntryPC = position ; } if ( ( index >= 0 ) && ( ( codeStream . pcToSourceMap [ index ] ) == ( position ) ) ) { codeStream . pcToSourceMapSize -= 2 ; } if ( codeStream . generateLocalVariableTableAttributes ) { LocalVariableBinding [ ] locals = codeStream . locals ; for ( int i = 0 , max = locals . length ; i < max ; i ++ ) { LocalVariableBinding local = locals [ i ] ; if ( ( local != null ) && ( ( local . initializationCount ) > 0 ) ) { if ( ( local . initializationPCs [ ( ( ( ( local . initializationCount ) - 1 ) << 1 ) + 1 ) ] ) == oldPosition ) { if ( ( local . initializationPCs [ ( ( ( local . initializationCount ) - 1 ) << 1 ) ] ) == oldPosition ) { local . initializationPCs [ ( ( ( local . initializationCount ) - 1 ) << 1 ) ] = position ; } local . initializationPCs [ ( ( ( ( local . initializationCount ) - 1 ) << 1 ) + 1 ) ] = position ; } } } } } } for ( int i = 0 ; i < ( forwardReferenceCount ) ; i ++ ) { int offset = ( ( position ) - ( forwardReferences [ i ] ) ) + 1 ; if ( ( offset > 32767 ) && ( ! ( this . codeStream . wideMode ) ) ) { <START_BUG> throw new AbortMethod ( null ) ; <END_BUG> } if ( this . codeStream . wideMode ) { if ( this . isWide ) { codeStream . writeSignedWord ( forwardReferences [ i ] , offset ) ; } else { codeStream . writeSignedShort ( forwardReferences [ i ] , ( ( short ) ( offset ) ) ) ; } } else { codeStream . writeSignedShort ( forwardReferences [ i ] , ( ( short ) ( offset ) ) ) ; } } if ( optimizedBranch ) { for ( int i = 0 ; i < ( codeStream . countLabels ) ; i ++ ) { Label label = codeStream . labels [ i ] ; if ( oldPosition == ( label . position ) ) { label . position = position ; if ( label instanceof CaseLabel ) { int offset = ( position ) - ( ( ( CaseLabel ) ( label ) ) . instructionPosition ) ; for ( int j = 0 ; j < ( label . forwardReferenceCount ) ; j ++ ) { int forwardPosition = label . forwardReferences [ j ] ; codeStream . writeSignedWord ( forwardPosition , offset ) ; } } else { for ( int j = 0 ; j < ( label . forwardReferenceCount ) ; j ++ ) { int forwardPosition = label . forwardReferences [ j ] ; int offset = ( ( position ) - forwardPosition ) + 1 ; if ( ( offset > 32767 ) && ( ! ( this . codeStream . wideMode ) ) ) { throw new AbortMethod ( CodeStream . RESTART_IN_WIDE_MODE ) ; } if ( this . codeStream . wideMode ) { if ( this . isWide ) { codeStream . writeSignedWord ( forwardPosition , offset ) ; } else { codeStream . writeSignedShort ( forwardPosition , ( ( short ) ( offset ) ) ) ; } } else { codeStream . writeSignedShort ( forwardPosition , ( ( short ) ( offset ) ) ) ; } } } } } } } } public String toString ( ) { } public void resetStateForCodeGeneration ( ) { } }
final class TaskRecord extends ThumbnailHolder { final int taskId ; final String affinity ; Intent intent ; Intent affinityIntent ; ComponentName origActivity ; ComponentName realActivity ; int numActivities ; long lastActiveTime ; boolean rootWasReset ; boolean askedCompatMode ; String stringName ; int userId ; int numFullscreen ; final ArrayList < ActivityRecord > mActivities = new ArrayList < ActivityRecord > ( ) ; ActivityStack stack ; private int mTaskType ; boolean mOnTopOfHome = false ; TaskRecord ( int _taskId , ActivityInfo info , Intent _intent ) { } void touchActiveTime ( ) { } long getInactiveDuration ( ) { } void setIntent ( Intent _intent , ActivityInfo info ) { } void disposeThumbnail ( ) { } ActivityRecord getTopActivity ( ) { } ActivityRecord topRunningActivityLocked ( ActivityRecord notTop ) { } final void setFrontOfTask ( ) { boolean foundFront = false ; final int numActivities = mActivities . size ( ) ; <START_BUG> for ( int activityNdx = 0 ; numActivities < activityNdx ; ++ activityNdx ) { <END_BUG> final ActivityRecord r = mActivities . get ( activityNdx ) ; if ( foundFront || ( r . finishing ) ) { r . frontOfTask = false ; } else { r . frontOfTask = true ; foundFront = true ; } } } final void moveActivityToFrontLocked ( ActivityRecord newTop ) { } void addActivityAtBottom ( ActivityRecord r ) { } void addActivityToTop ( ActivityRecord r ) { } void addActivityAtIndex ( int index , ActivityRecord r ) { } boolean removeActivity ( ActivityRecord r ) { } final void performClearTaskAtIndexLocked ( int activityNdx ) { } final void performClearTaskLocked ( ) { } final ActivityRecord performClearTaskLocked ( ActivityRecord newR , int launchFlags ) { } public TaskThumbnails getTaskThumbnailsLocked ( ) { } public Bitmap getTaskTopThumbnailLocked ( ) { } public ActivityRecord removeTaskActivitiesLocked ( int subTaskIndex , boolean taskRequired ) { } boolean isHomeTask ( ) { } boolean isApplicationTask ( ) { } public TaskAccessInfo getTaskAccessInfoLocked ( boolean inclThumbs ) { } final ActivityRecord findActivityInHistoryLocked ( ActivityRecord r ) { } void dump ( PrintWriter pw , String prefix ) { } @ Override public String toString ( ) { } }
public abstract class GlowBaseInventory implements Inventory { private Set < HumanEntity > viewers ; private InventoryHolder owner ; private InventoryType type ; private String title ; private int maxStackSize = 64 ; protected GlowBaseInventory ( ) { } protected void initialize ( InventoryHolder owner , InventoryType type , String title , Set < HumanEntity > viewers ) { } public abstract GlowInventorySlot getSlot ( int slot ) { } public abstract int getSize ( ) { } public abstract Iterator < GlowInventorySlot > slotIterator ( ) { } public void addViewer ( HumanEntity viewer ) { } public void removeViewer ( HumanEntity viewer ) { } public Set < HumanEntity > getViewersSet ( ) { } public SlotType getSlotType ( int slot ) { } public boolean itemPlaceAllowed ( int slot , ItemStack stack ) { } public boolean itemShiftClickAllowed ( int slot , ItemStack stack ) { } public void setTitle ( String title ) { } @ Override public final InventoryType getType ( ) { } @ Override public InventoryHolder getHolder ( ) { } @ Override public final String getName ( ) { } @ Override public final String getTitle ( ) { } @ Override public int getMaxStackSize ( ) { } @ Override public void setMaxStackSize ( int size ) { } @ Override public List < HumanEntity > getViewers ( ) { } @ Override public ListIterator < ItemStack > iterator ( ) { } @ Override public ListIterator < ItemStack > iterator ( int index ) { } @ Override public ItemStack getItem ( int index ) { } @ Override public void setItem ( int index , ItemStack item ) { } @ Override public HashMap < Integer , ItemStack > addItem ( ItemStack ... items ) { } public ItemStack addItemStack ( ItemStack item , boolean ignoreMeta ) { int maxStackSize = ( ( item . getType ( ) ) == null ) ? 64 : item . getType ( ) . getMaxStackSize ( ) ; int toAdd = item . getAmount ( ) ; for ( int i = 0 ; ( toAdd > 0 ) && ( i < ( getSize ( ) ) ) ; i ++ ) { ItemStack slotItem = getItem ( i ) ; if ( ( slotItem != null ) && ( compareItems ( item , slotItem , ignoreMeta ) ) ) { int space = maxStackSize - ( slotItem . getAmount ( ) ) ; if ( space < 0 ) continue ; if ( space > toAdd ) space = toAdd ; slotItem . setAmount ( ( ( slotItem . getAmount ( ) ) + space ) ) ; setItem ( i , slotItem ) ; toAdd -= space ; } } if ( toAdd > 0 ) { for ( int i = 0 ; ( toAdd > 0 ) && ( i < ( getSize ( ) ) ) ; i ++ ) { ItemStack slotItem = getItem ( i ) ; if ( slotItem == null ) { int num = ( toAdd > maxStackSize ) ? maxStackSize : toAdd ; <START_BUG> slotItem . setAmount ( num ) ; <END_BUG> setItem ( i , slotItem ) ; toAdd -= num ; } } } if ( toAdd > 0 ) { ItemStack remaining = new ItemStack ( item ) ; remaining . setAmount ( toAdd ) ; return remaining ; } return null ; } @ Override public HashMap < Integer , ItemStack > removeItem ( ItemStack ... items ) { } public ItemStack removeItemStack ( ItemStack item , boolean ignoreMeta ) { } private boolean compareItems ( ItemStack a , ItemStack b , boolean ignoreMeta ) { } @ Override public ItemStack [ ] getContents ( ) { } @ Override public void setContents ( ItemStack [ ] items ) { } @ Override public boolean contains ( int materialId ) { } @ Override public boolean contains ( Material material ) { } @ Override public boolean contains ( ItemStack item ) { } @ Override public boolean contains ( int materialId , int amount ) { } @ Override public boolean contains ( Material material , int amount ) { } @ Override public boolean contains ( ItemStack item , int amount ) { } @ Override public boolean containsAtLeast ( ItemStack item , int amount ) { } @ Override public HashMap < Integer , ItemStack > all ( int materialId ) { } @ Override public HashMap < Integer , ItemStack > all ( Material material ) { } @ Override public HashMap < Integer , ItemStack > all ( ItemStack item ) { } @ Override public int first ( int materialId ) { } @ Override public int first ( Material material ) { } @ Override public int first ( ItemStack item ) { } @ Override public int firstEmpty ( ) { } @ Override public void remove ( int materialId ) { } @ Override public void remove ( Material material ) { } @ Override public void remove ( ItemStack item ) { } @ Override public void clear ( int index ) { } @ Override public void clear ( ) { } }
public class TestSynchronizedCollection < E > extends AbstractTestCollection < E > { public TestSynchronizedCollection ( String testName ) { } @ Override public Collection < E > makeObject ( ) { <START_BUG> return SynchronizedCollection . decorate ( new ArrayList < E > ( ) ) ; <END_BUG> } @ Override public Collection < E > makeConfirmedCollection ( ) { } @ Override public Collection < E > makeConfirmedFullCollection ( ) { } @ Override public String getCompatibilityVersion ( ) { } }
public class Recorder < T > extends HiddenField < Object > { private static final long serialVersionUID = 1L ; private static final String [ ] EMPTY_IDS = new String [ 0 ] ; private String [ ] ids ; private final Palette < T > palette ; private boolean attached = false ; public Palette < T > getPalette ( ) { } public Recorder ( String id , Palette < T > palette ) { } @ Override protected void onBeforeRender ( ) { } private void initIds ( ) { IChoiceRenderer < T > renderer = getPalette ( ) . getChoiceRenderer ( ) ; <START_BUG> StringBuffer modelStringBuffer = new StringBuffer ( ) ; <END_BUG> Collection < T > modelCollection = getPalette ( ) . getModelCollection ( ) ; if ( modelCollection == null ) { throw new WicketRuntimeException ( ( "Expected<seq2seq4repair_space>getPalette().getModelCollection()<seq2seq4repair_space>to<seq2seq4repair_space>return<seq2seq4repair_space>a<seq2seq4repair_space>non-null<seq2seq4repair_space>value." + "<seq2seq4repair_space>Please<seq2seq4repair_space>make<seq2seq4repair_space>sure<seq2seq4repair_space>you<seq2seq4repair_space>have<seq2seq4repair_space>model<seq2seq4repair_space>object<seq2seq4repair_space>assigned<seq2seq4repair_space>to<seq2seq4repair_space>the<seq2seq4repair_space>palette" ) ) ; } Iterator < T > selection = modelCollection . iterator ( ) ; int i = 0 ; while ( selection . hasNext ( ) ) { modelStringBuffer . append ( renderer . getIdValue ( selection . next ( ) , ( i ++ ) ) ) ; if ( selection . hasNext ( ) ) { modelStringBuffer . append ( "," ) ; } } String modelString = modelStringBuffer . toString ( ) ; setDefaultModel ( new org . apache . wicket . model . Model < String > ( modelString ) ) ; updateIds ( modelString ) ; } @ Override protected void onValid ( ) { } @ SuppressWarnings ( "unchecked" ) public Iterator < T > getSelectedChoices ( ) { } public Iterator < T > getUnselectedChoices ( ) { } @ Override protected void onInvalid ( ) { } private void updateIds ( ) { } private void updateIds ( String value ) { } }
public class BinaryMemtable implements IFlushable < DecoratedKey > { private static Logger logger_ = Logger . getLogger ( BinaryMemtable . class ) ; private int threshold_ = ( ( DatabaseDescriptor . getBMTThreshold ( ) ) * 1024 ) * 1024 ; private AtomicInteger currentSize_ = new AtomicInteger ( 0 ) ; private String table_ ; private String cfName_ ; private boolean isFrozen_ = false ; private Map < DecoratedKey , byte [ ] > columnFamilies_ = new org . cliffc . high_scale_lib . NonBlockingHashMap < DecoratedKey , byte [ ] > ( ) ; Lock lock_ = new ReentrantLock ( ) ; Condition condition_ ; private final IPartitioner partitioner_ = StorageService . getPartitioner ( ) ; BinaryMemtable ( String table , String cfName ) throws IOException { } public int getMemtableThreshold ( ) { } void resolveSize ( int oldSize , int newSize ) { } boolean isThresholdViolated ( ) { } String getColumnFamily ( ) { } void put ( String key , byte [ ] buffer ) throws IOException { } private void resolve ( String key , byte [ ] buffer ) { } public List < DecoratedKey > getSortedKeys ( ) { } public SSTableReader writeSortedContents ( List < DecoratedKey > sortedKeys ) throws IOException { BinaryMemtable . logger_ . info ( ( "Writing<seq2seq4repair_space>" + ( this ) ) ) ; ColumnFamilyStore cfStore = Table . open ( table_ ) . getColumnFamilyStore ( cfName_ ) ; String path = cfStore . getTempSSTablePath ( ) ; SSTableWriter writer = new SSTableWriter ( path , sortedKeys . size ( ) , StorageService . getPartitioner ( ) ) ; for ( DecoratedKey key : sortedKeys ) { byte [ ] bytes = columnFamilies_ . get ( key ) ; assert ( bytes . length ) > 0 ; writer . append ( key , bytes ) ; } <START_BUG> SSTableReader sstable = writer . closeAndOpenReader ( ) ; <END_BUG> BinaryMemtable . logger_ . info ( ( "Completed<seq2seq4repair_space>flushing<seq2seq4repair_space>" + ( writer . getFilename ( ) ) ) ) ; return sstable ; } }
public class UploadData extends AsyncTask < JSONObject , Void , String > { protected static final String SERVER_URL = "http://skappsrv.towson.edu/" ; protected static final String SUBMIT_USER = "wavyleaf/submit_user.php" ; protected static final String SUBMIT_POINT = "wavyleaf/submit_point.php" ; protected static final String SUBMIT_POINT_WITH_PICTURE = "wavyleaf/submit_point_with_pic.php" ; protected static final String ARG_AREA_TYPE = "areatype" ; protected static final String ARG_AREA_VALUE = "areavalue" ; protected static final String ARG_BIRTH_YEAR = "birthyear" ; protected static final String ARG_DATE = "date" ; protected static final String ARG_EDUCATION = "education" ; protected static final String ARG_GENERAL_PLANT_ID = "generalplantid" ; protected static final String ARG_LATITUDE = "latitude" ; protected static final String ARG_LONGITUDE = "longitude" ; protected static final String ARG_NAME = "name" ; protected static final String ARG_NOTES = "notes" ; protected static final String ARG_OUTDOOR_EXPERIENCE = "outdoorexperience" ; protected static final String ARG_PERCENT = "percent" ; protected static final String ARG_PICTURE = "picture" ; protected static final String ARG_TREATMENT = "treatment" ; protected static final String ARG_USER_ID = "user_id" ; protected static final String ARG_WAVYLEAF_ID = "wavyleafid" ; protected static final String ARG_EMAIL = "email" ; private DatabaseListJSONData m_dbListData ; private Context context ; private UploadData . Task task ; public UploadData ( Context context , UploadData . Task task ) { } protected void onPreExecute ( ) { } @ Override protected String doInBackground ( JSONObject ... jsonObjects ) { } @ Override protected void onPostExecute ( String result ) { } protected String getHttpPost ( ) { switch ( task ) { case SUBMIT_POINT : return UploadData . SUBMIT_POINT_WITH_PICTURE ; case SUBMIT_USER : <START_BUG> return this . SUBMIT_USER ; <END_BUG> default : return null ; } } protected void submitToLocalStorage ( String JSONString ) { } protected void deleteFirstEntry ( ) { } public enum Task { SUBMIT_USER , SUBMIT_POINT ; } public enum Flag { SUCCESS , MESSAGE ; @ Override public String toString ( ) { } } }
public final class HtmlHandler extends AbstractMarkupFilter { private static final Logger log = LoggerFactory . getLogger ( HtmlHandler . class ) ; private final ArrayListStack < ComponentTag > stack = new ArrayListStack < ComponentTag > ( ) ; private static final Map < String , Boolean > doesNotRequireCloseTag = new HashMap < String , Boolean > ( ) ; public HtmlHandler ( ) { } public MarkupElement nextTag ( ) throws ParseException { <START_BUG> final ComponentTag tag = ( ( ComponentTag ) ( getParent ( ) . nextTag ( ) ) ) ; <END_BUG> if ( tag == null ) { while ( ( stack . size ( ) ) > 0 ) { final ComponentTag top = stack . peek ( ) ; if ( ! ( HtmlHandler . requiresCloseTag ( top . getName ( ) ) ) ) { stack . pop ( ) ; } else { throw new org . apache . wicket . markup . WicketParseException ( "Tag<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>have<seq2seq4repair_space>a<seq2seq4repair_space>close<seq2seq4repair_space>tag:" , top ) ; } } return tag ; } if ( HtmlHandler . log . isDebugEnabled ( ) ) { HtmlHandler . log . debug ( ( ( ( "tag:<seq2seq4repair_space>" + ( tag . toUserDebugString ( ) ) ) + ",<seq2seq4repair_space>stack:<seq2seq4repair_space>" ) + ( stack ) ) ) ; } if ( tag . isOpen ( ) ) { stack . push ( tag ) ; } else if ( tag . isClose ( ) ) { if ( ( stack . size ( ) ) > 0 ) { ComponentTag top = stack . pop ( ) ; boolean mismatch = ! ( top . hasEqualTagName ( tag ) ) ; if ( mismatch ) { top . setHasNoCloseTag ( true ) ; while ( mismatch && ( ! ( HtmlHandler . requiresCloseTag ( top . getName ( ) ) ) ) ) { top . setHasNoCloseTag ( true ) ; if ( stack . isEmpty ( ) ) { break ; } top = stack . pop ( ) ; mismatch = ! ( top . hasEqualTagName ( tag ) ) ; } if ( mismatch ) { throw new ParseException ( ( ( ( "Tag<seq2seq4repair_space>" + ( top . toUserDebugString ( ) ) ) + "<seq2seq4repair_space>has<seq2seq4repair_space>a<seq2seq4repair_space>mismatched<seq2seq4repair_space>close<seq2seq4repair_space>tag<seq2seq4repair_space>at<seq2seq4repair_space>" ) + ( tag . toUserDebugString ( ) ) ) , top . getPos ( ) ) ; } } tag . setOpenTag ( top ) ; } else { throw new org . apache . wicket . markup . WicketParseException ( "Tag<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>have<seq2seq4repair_space>a<seq2seq4repair_space>matching<seq2seq4repair_space>open<seq2seq4repair_space>tag:" , tag ) ; } } else if ( tag . isOpenClose ( ) ) { tag . setOpenTag ( tag ) ; } return tag ; } public static boolean requiresCloseTag ( final String name ) { } }
public class PlayerFragment extends DialogFragment implements SeekBar . OnSeekBarChangeListener { private final String LOG_TAG = PlayerFragment . class . getSimpleName ( ) ; private ArrayList < TrackParcelable > mTracksList ; private TrackParcelable mTrackParcelable ; private AudioService mAudioService ; private boolean mIsBound ; protected boolean mTwoPane ; private SeekBar mSeekBar ; private TextView mTimeElapsedTextView ; private TextView mTimeRemainingTextView ; private ImageButton mNextButton ; private ImageButton mPlayButton ; private ImageButton mPreviousButton ; private Handler mHandler ; private int mTrackIndex ; public interface Callback { void onNextSelected ( Bundle bundle ) { } void onPreviousSelected ( Bundle bundle ) { } } public PlayerFragment ( ) { } @ Override public void onCreate ( Bundle savedInstanceState ) { } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { } @ Override public void onStart ( ) { } @ Override public void onDestroyView ( ) { } private void configureArtistAlbumTrackTextViews ( View playerView ) { } private void configureImageView ( View playerView ) { } private void configurePreviousButton ( View playerView ) { } private void configureNextButton ( View playerView ) { } protected void stopAndUnbindService ( ) { } private void configurePlayButton ( View playerView ) { } private void handlePlayPauseTapped ( ) { } private void handlePlayTapped ( ) { } private void configureActionBarTitle ( String title ) { } @ Override public void onDestroy ( ) { <START_BUG> doUnbindService ( ) ; <END_BUG> super . onDestroy ( ) ; } @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { } private ServiceConnection mConnection = new ServiceConnection ( ) { public void onServiceConnected ( ComponentName className , IBinder service ) { } public void onServiceDisconnected ( ComponentName className ) { } } ; void doBindService ( ) { } void doUnbindService ( ) { } }
public class TomcatSamlTest { @ Rule public SamlAdapterTestStrategy testStrategy = new SamlAdapterTestStrategy ( "http://localhost:8081/auth" , "http://localhost:8082" , TomcatSamlTest . keycloakRule ) ; @ ClassRule public static AbstractKeycloakRule keycloakRule = new AbstractKeycloakRule ( ) { @ Override protected void configure ( KeycloakSession session , RealmManager manager , RealmModel adminRealm ) { } } ; static Tomcat tomcat = null ; @ BeforeClass public static void initTomcat ( ) throws Exception { TomcatSamlTest . tomcat = new Tomcat ( ) ; String baseDir = TomcatSamlTest . getBaseDirectory ( ) ; TomcatSamlTest . tomcat . setBaseDir ( baseDir ) ; TomcatSamlTest . tomcat . setPort ( 8082 ) ; System . setProperty ( "app.server.base.url" , "http://localhost:8082" ) ; System . setProperty ( "my.host.name" , "localhost" ) ; URL dir = TomcatSamlTest . class . getResource ( "/keycloak-saml/testsaml.json" ) ; File base = new File ( dir . getFile ( ) ) . getParentFile ( ) ; TomcatSamlTest . tomcat . addWebapp ( "/sales-post" , new File ( base , "simple-post" ) . toString ( ) ) ; TomcatSamlTest . tomcat . addWebapp ( "/sales-post-sig" , new File ( base , "signed-post" ) . toString ( ) ) ; TomcatSamlTest . tomcat . addWebapp ( "/sales-post-sig-email" , new File ( base , "signed-post-email" ) . toString ( ) ) ; TomcatSamlTest . tomcat . addWebapp ( "/sales-post-sig-transient" , new File ( base , "signed-post-transient" ) . toString ( ) ) ; TomcatSamlTest . tomcat . addWebapp ( "/sales-post-sig-persistent" , new File ( base , "signed-post-persistent" ) . toString ( ) ) ; TomcatSamlTest . tomcat . addWebapp ( "/sales-metadata" , new File ( base , "signed-metadata" ) . toString ( ) ) ; TomcatSamlTest . tomcat . addWebapp ( "/employee-sig" , new File ( base , "signed-get" ) . toString ( ) ) ; TomcatSamlTest . tomcat . addWebapp ( "/employee2" , new File ( base , "mappers" ) . toString ( ) ) ; TomcatSamlTest . tomcat . addWebapp ( "/employee-sig-front" , new File ( base , "signed-front-get" ) . toString ( ) ) ; TomcatSamlTest . tomcat . addWebapp ( "/bad-client-sales-post-sig" , new File ( base , "bad-client-signed-post" ) . toString ( ) ) ; TomcatSamlTest . tomcat . addWebapp ( "/bad-realm-sales-post-sig" , new File ( base , "bad-realm-signed-post" ) . toString ( ) ) ; TomcatSamlTest . tomcat . addWebapp ( "/sales-post-enc" , new File ( base , "encrypted-post" ) . toString ( ) ) ; <START_BUG> SamlAdapterTestStrategy . uploadSP ( "http://localhost:8081/auth" , TomcatSamlTest . keycloakRule ) ; <END_BUG> TomcatSamlTest . tomcat . start ( ) ; } @ AfterClass public static void shutdownTomcat ( ) throws Exception { } @ Test public void testPostSimpleLoginLogout ( ) { } @ Test public void testPostSimpleLoginLogoutIdpInitiated ( ) { } @ Test public void testPostSignedLoginLogout ( ) { } @ Test public void testPostSignedLoginLogoutTransientNameID ( ) { } @ Test public void testPostSignedLoginLogoutPersistentNameID ( ) { } @ Test public void testPostSignedLoginLogoutEmailNameID ( ) { } @ Test public void testAttributes ( ) throws Exception { } @ Test public void testRedirectSignedLoginLogout ( ) { } @ Test public void testRedirectSignedLoginLogoutFrontNoSSO ( ) { } @ Test public void testRedirectSignedLoginLogoutFront ( ) { } @ Test public void testPostEncryptedLoginLogout ( ) { } @ Test public void testPostBadClientSignature ( ) { } @ Test public void testPostBadRealmSignature ( ) { } @ Test public void testPostSimpleUnauthorized ( ) { } @ Test public void testMetadataPostSignedLoginLogout ( ) throws Exception { } private static String getBaseDirectory ( ) { } }
public class IntegerConverter extends AbstractIntegerConverter < Integer > { private static final long serialVersionUID = 1L ; public static final IConverter < Integer > INSTANCE = new IntegerConverter ( ) ; public Integer convertToObject ( final String value , Locale locale ) { final Number number = parse ( value , Integer . MIN_VALUE , Integer . MAX_VALUE , locale ) ; if ( number == null ) { return null ; } <START_BUG> return new Integer ( number . intValue ( ) ) ; <END_BUG> } @ Override protected Class < Integer > getTargetType ( ) { } }
public class Resources extends DataType implements ResourceCollection { public static final ResourceCollection NONE = new ResourceCollection ( ) { public boolean isFilesystemOnly ( ) { } public Iterator iterator ( ) { } public int size ( ) { } } ; public static final Iterator EMPTY_ITERATOR = new Iterator ( ) { public Object next ( ) { } public boolean hasNext ( ) { } public void remove ( ) { } } ; private class MyCollection extends AbstractCollection { private int size ; MyCollection ( ) { } public int size ( ) { } public Iterator iterator ( ) { } private class MyIterator implements Iterator { private Iterator rci = getNested ( ) . iterator ( ) ; private Iterator ri = null ; public boolean hasNext ( ) { } public Object next ( ) { } public void remove ( ) { } } } private Vector rc ; private Collection coll ; public synchronized void add ( ResourceCollection c ) { } public synchronized Iterator iterator ( ) { } public synchronized int size ( ) { } public boolean isFilesystemOnly ( ) { } public synchronized String toString ( ) { } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { for ( Iterator i = getNested ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof DataType ) { <START_BUG> invokeCircularReferenceCheck ( ( ( DataType ) ( o ) ) , stk , p ) ; <END_BUG> } } setChecked ( true ) ; } } protected void invalidateExistingIterators ( ) { } private ResourceCollection getRef ( ) { } private synchronized void validate ( ) { } private synchronized List getNested ( ) { } }
public class WizardNewFileCreationPage extends WizardPage implements Listener { private static final int SIZING_CONTAINER_GROUP_HEIGHT = 250 ; private IStructuredSelection currentSelection ; private IFile newFile ; private IPath linkTargetPath ; private String initialFileName ; private IPath initialContainerFullPath ; private Composite topLevel ; private ResourceAndContainerGroup resourceGroup ; private Button advancedButton ; private CreateLinkedResourceGroup linkedResourceGroup ; public WizardNewFileCreationPage ( String pageName , IStructuredSelection selection ) { } protected void createAdvancedControls ( Composite parent ) { } public void createControl ( Composite parent ) { } protected void createFile ( IFile fileHandle , InputStream contents , IProgressMonitor monitor ) throws CoreException { } protected IFile createFileHandle ( IPath filePath ) { } protected void createLinkTarget ( ) { } public IFile createNewFile ( ) { } public IPath getContainerFullPath ( ) { } public String getFileName ( ) { } protected InputStream getInitialContents ( ) { } protected String getNewFileLabel ( ) { } protected void handleAdvancedButtonSelect ( ) { } public void handleEvent ( Event event ) { } protected void initialPopulateContainerNameField ( ) { } public void setContainerFullPath ( IPath path ) { } public void setFileName ( String value ) { } protected IStatus validateLinkedResource ( ) { } protected boolean validatePage ( ) { boolean valid = true ; IWorkspace workspace = WorkbenchPlugin . getPluginWorkspace ( ) ; String fileName = getFileName ( ) ; IStatus nameStatus = workspace . validateName ( fileName , IResource . FILE ) ; if ( ! ( nameStatus . isOK ( ) ) ) { setErrorMessage ( nameStatus . getMessage ( ) ) ; return false ; } if ( ! ( resourceGroup . areAllValuesValid ( ) ) ) { if ( ( ( resourceGroup . getProblemType ( ) ) == ( ResourceAndContainerGroup . PROBLEM_RESOURCE_EMPTY ) ) || ( ( resourceGroup . getProblemType ( ) ) == ( ResourceAndContainerGroup . PROBLEM_CONTAINER_EMPTY ) ) ) { setMessage ( resourceGroup . getProblemMessage ( ) ) ; setErrorMessage ( null ) ; } else setErrorMessage ( resourceGroup . getProblemMessage ( ) ) ; valid = false ; } IPath container = workspace . getRoot ( ) . getLocation ( ) . append ( getContainerFullPath ( ) ) ; File systemFile = new File ( container . toOSString ( ) , fileName ) ; if ( systemFile . exists ( ) ) { setErrorMessage ( WorkbenchMessages . format ( "WizardNewFileCreationPage.fileExistsMessage" , new String [ ] { systemFile . getPath ( ) } ) ) ; valid = false ; } IStatus linkedResourceStatus = null ; if ( valid && ( ( linkedResourceGroup ) != null ) ) { linkedResourceStatus = validateLinkedResource ( ) ; <START_BUG> if ( ( linkedResourceStatus . getCode ( ) ) == ( IStatus . ERROR ) ) <END_BUG> valid = false ; } if ( valid && ( ( linkedResourceStatus == null ) || ( linkedResourceStatus . isOK ( ) ) ) ) { setMessage ( null ) ; setErrorMessage ( null ) ; } return valid ; } public void setVisible ( boolean visible ) { } }
public class TopicGeomzRbac { private UUID currentProjectId ; private OpenInfraSchemas schema ; private AttributeValueGeomType geomType ; public TopicGeomzRbac ( UUID currentProjectId , OpenInfraSchemas schema , AttributeValueGeomType geomType ) { } public List < TopicGeomzPojo > read ( OpenInfraHttpMethod httpMethod , UriInfo uriInfo , Locale locale , UUID topicCharacteristicId , int offset , int size ) { new TopicInstanceRbac ( currentProjectId , schema ) . checkPermission ( httpMethod , uriInfo ) ; <START_BUG> return new de . btu . openinfra . backend . db . daos . TopicGeomzDao ( topicCharacteristicId , schema , geomType ) . read ( locale , topicCharacteristicId , offset , size ) ; <END_BUG> } public Long getCount ( OpenInfraHttpMethod httpMethod , UriInfo uriInfo , UUID topicCharacteristicId ) { } }
public class ReloadInterceptor extends BaseInterceptor { boolean fullReload = true ; int dependManagerNote = - 1 ; public ReloadInterceptor ( ) { } public void engineInit ( ContextManager cm ) throws TomcatException { } public void setFullReload ( boolean full ) { } public void addContext ( ContextManager cm , Context context ) throws TomcatException { } public void contextInit ( Context context ) throws TomcatException { } public void reload ( Request req , Context context ) throws TomcatException { } protected void loaderHook ( DependManager dm , Context context ) { ClassLoader cl = context . getClassLoader ( ) ; <START_BUG> ClassLoader loader = DependClassLoader . getDependClassLoader ( dm , cl , context . getAttribute ( ATTRIB_PROTECTION_DOMAIN ) ) ; <END_BUG> context . setClassLoader ( loader ) ; context . setAttribute ( "org.apache.tomcat.classloader" , loader ) ; } public int contextMap ( Request request ) { } }
public class Graph { private HashMap < Integer , Node > NodeSet ; private int nodeSize ; private int edgeSize ; public Graph ( ) { } public Graph ( int nodeSize , int edgeSize ) { } public Graph ( HashMap < Integer , Node > NodeSet , int nodeSize , int edgeSize ) { } public Collection < Node > GetNodeSet ( ) { } public int GetNodeSize ( ) { } public int GetEdgeSize ( ) { } public void SetNodeSet ( HashMap < Integer , Node > NodeSet ) { } public void SetNodeSize ( int nodeSize ) { } public void SetEdgeSize ( int edgeSize ) { } public void InsNode ( Node n ) { } public void DelNode ( Node n ) { <START_BUG> this . NodeSet . remove ( n ) ; <END_BUG> ( this . nodeSize ) -- ; Edge ep = n . GetFirstIn ( ) ; if ( ep != null ) { for ( Edge e = ep ; e != null ; e = e . GetHLink ( ) ) { Node fv = e . GetFromNode ( ) ; for ( Edge e1 = fv . GetFirstOut ( ) ; e1 != null ; e1 = e1 . GetTLink ( ) ) { Edge e2 = e1 . GetTLink ( ) ; Node cfv = e1 . GetToNode ( ) ; if ( cfv . equals ( n ) ) { fv . SetFirstOut ( e2 ) ; break ; } else { Node cfv2 = e2 . GetToNode ( ) ; if ( cfv2 . equals ( n ) ) { e1 . SetTLink ( e2 . GetTLink ( ) ) ; break ; } } } } } ep = n . GetFirstOut ( ) ; if ( ep != null ) { for ( Edge e = ep ; e != null ; e = e . GetTLink ( ) ) { Node tv = e . GetToNode ( ) ; for ( Edge e1 = tv . GetFirstIn ( ) ; e1 != null ; e1 = e1 . GetHLink ( ) ) { Edge e2 = e1 . GetHLink ( ) ; Node ptv = e1 . GetFromNode ( ) ; if ( ptv . equals ( n ) ) { tv . SetFirstIn ( e2 ) ; break ; } else { Node ptv2 = e2 . GetFromNode ( ) ; if ( ptv2 . equals ( n ) ) { e1 . SetHLink ( e2 . GetHLink ( ) ) ; break ; } } } } } } public void InsEdge ( Node fv , Node tv ) { } public void DelEdge ( Node fv , Node tv ) { } public Node FindNode ( int id ) { } public HashSet < Node > GetChildren ( Node n ) { } public HashSet < Node > GetParents ( Node n ) { } public void Display ( ) { } public void Init ( ) { } public void RanGraphGen ( int vsize , int esize ) { } public static void main ( String [ ] args ) { } }
public class ColumnFamilyStoreTest extends CleanupHelper { static byte [ ] bytes1 ; static byte [ ] bytes2 ; @ Test public void testGetColumnWithWrongBF ( ) throws IOException , InterruptedException , ExecutionException { } @ Test public void testEmptyRow ( ) throws Exception { } @ Test public void testSkipStartKey ( ) throws IOException , InterruptedException , ExecutionException { } @ Test public void testIndexScan ( ) throws IOException { } @ Test public void testLargeScan ( ) throws IOException { } @ Test public void testIndexDeletions ( ) throws IOException { } @ Test public void testIndexUpdate ( ) throws IOException { } @ Test public void testIndexCreate ( ) throws IOException , InterruptedException , ExecutionException , ConfigurationException { Table table = Table . open ( "Keyspace1" ) ; RowMutation rm ; rm = new RowMutation ( "Keyspace1" , ByteBufferUtil . bytes ( "k1" ) ) ; rm . add ( new QueryPath ( "Indexed2" , null , ByteBufferUtil . bytes ( "birthdate" ) ) , ByteBufferUtil . bytes ( 1L ) , 1 ) ; rm . apply ( ) ; ColumnFamilyStore cfs = table . getColumnFamilyStore ( "Indexed2" ) ; ColumnDefinition old = cfs . metadata . getColumn_metadata ( ) . get ( ByteBufferUtil . bytes ( "birthdate" ) ) ; <START_BUG> ColumnDefinition cd = new ColumnDefinition ( old . name , old . validator , IndexType . KEYS , "birthdate_index" ) ; <END_BUG> Future < ? > future = cfs . addIndex ( cd ) ; future . get ( ) ; assert ( cfs . getIndexedColumnFamilyStore ( cd . name ) . getSSTables ( ) . size ( ) ) > 0 ; queryBirthdate ( table ) ; ColumnFamilyStore indexedCfs = cfs . getIndexedColumnFamilyStore ( ByteBufferUtil . bytes ( "birthdate" ) ) ; cfs . removeIndex ( ByteBufferUtil . bytes ( "birthdate" ) ) ; assert ! ( indexedCfs . isIndexBuilt ( ) ) ; future = cfs . addIndex ( cd ) ; future . get ( ) ; queryBirthdate ( table ) ; } private void queryBirthdate ( Table table ) throws CharacterCodingException { } @ Test public void testDeleteSuperRowSticksAfterFlush ( ) throws Throwable { } private static void assertRowAndColCount ( int rowCount , int colCount , ByteBuffer sc , boolean isDeleted , Collection < Row > rows ) { } private static String str ( ColumnFamily cf ) { } private static void putColsSuper ( ColumnFamilyStore cfs , DecoratedKey key , ByteBuffer scfName , Column ... cols ) throws Throwable { } private static void putColsStandard ( ColumnFamilyStore cfs , DecoratedKey key , Column ... cols ) throws Throwable { } @ Test public void testDeleteStandardRowSticksAfterFlush ( ) throws Throwable { } private ColumnFamilyStore insertKey1Key2 ( ) throws IOException , InterruptedException , ExecutionException { } @ Test public void testBackupAfterFlush ( ) throws Throwable { } }
public class CartActivity extends ActionBarActivity implements CartManager . OnCartItemsCallback { RecyclerView recyclerView ; Store mPickedStore ; CartManager mCart ; ArrayList < Product > itemsList = new ArrayList < > ( ) ; RecyclerViewAdapter adapter ; private String TAG = "CartActivity" ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case id . checkoutBtn : Intent intent = new Intent ( this , BraintreePaymentActivity . class ) ; intent . putExtra ( EXTRA_CLIENT_TOKEN , mCart . cartToken ) ; <START_BUG> Customization customization = new Customization . CustomizationBuilder ( ) . primaryDescription ( "Shopping<seq2seq4repair_space>cart" ) . secondaryDescription ( ( ( itemsList . size ( ) ) + "<seq2seq4repair_space>Items" ) ) . amount ( ( ( mCart . getTotalPrice ( ) . toString ( ) ) + "" ) ) . submitButtonText ( "Purchase" ) . build ( ) ; <END_BUG> intent . putExtra ( EXTRA_CUSTOMIZATION , customization ) ; startActivityForResult ( intent , 100 ) ; return true ; default : return super . onOptionsItemSelected ( item ) ; } } @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { } public void RunTransaction ( String nonce ) { } @ Override public void OnCartItemsLoaded ( ) { } }
public class Translate { public static void main ( String [ ] args ) throws Exception { <START_BUG> ANTLRInputStream input = new ANTLRInputStream ( System . in ) ; <END_BUG> ArrayInitLexer lexer = new ArrayInitLexer ( input ) ; CommonTokenStream tokens = new CommonTokenStream ( lexer ) ; ArrayInitParser parser = new ArrayInitParser ( tokens ) ; ParseTree tree = parser . init ( ) ; ParseTreeWalker walker = new ParseTreeWalker ( ) ; walker . walk ( new ShortToUnicodeString ( ) , tree ) ; System . out . println ( ) ; } }
public class CheckableListEditor extends DefaultCellEditor implements ActionListener { private JCheckBox checkbox ; private Boolean selected ; public CheckableListEditor ( ) { } public Component getTableCellEditorComponent ( JTable table , Object value , boolean isSelected , int row , int column ) { } public Object getCellEditorValue ( ) { } public void actionPerformed ( ActionEvent e ) { <START_BUG> selected = new Boolean ( checkbox . isSelected ( ) ) ; <END_BUG> fireEditingStopped ( ) ; } public Component getComponent ( ) { } }
public class NormValueSource extends ValueSource { protected final String field ; public NormValueSource ( String field ) { } public String name ( ) { } @ Override public String description ( ) { } @ Override public void createWeight ( Map context , IndexSearcher searcher ) throws IOException { } @ Override public FunctionValues getValues ( Map context , AtomicReaderContext readerContext ) throws IOException { IndexSearcher searcher = ( ( IndexSearcher ) ( context . get ( "searcher" ) ) ) ; final TFIDFSimilarity similarity = IDFValueSource . asTFIDF ( searcher . getSimilarity ( ) , field ) ; if ( similarity == null ) { throw new UnsupportedOperationException ( "requires<seq2seq4repair_space>a<seq2seq4repair_space>TFIDFSimilarity<seq2seq4repair_space>(such<seq2seq4repair_space>as<seq2seq4repair_space>DefaultSimilarity)" ) ; } <START_BUG> final NumericDocValues norms = readerContext . reader ( ) . simpleNormValues ( field ) ; <END_BUG> if ( norms == null ) { return new ConstDoubleDocValues ( 0.0 , this ) ; } return new FloatDocValues ( this ) { @ Override public float floatVal ( int doc ) { return similarity . decodeNormValue ( ( ( byte ) ( norms . get ( doc ) ) ) ) ; } } ; } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } }
public class FreezerFragment extends ListFragment { FoodItemAdapter mAdapter ; @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View freezerView = inflater . inflate ( fragment_layout , container , false ) ; <START_BUG> mAdapter = new FoodItemAdapter ( getActivity ( ) , freezerView ) ; <END_BUG> this . setListAdapter ( mAdapter ) ; Button addButton = ( ( Button ) ( freezerView . findViewById ( add_button ) ) ) ; addButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { Intent addIntent = new Intent ( getActivity ( ) , AddItemActivity . class ) ; startActivityForResult ( addIntent , 2 ) ; } } ) ; Button deleteButton = ( ( Button ) ( freezerView . findViewById ( delete_button ) ) ) ; deleteButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { Toast . makeText ( getActivity ( ) , "Delete-button<seq2seq4repair_space>pressed<seq2seq4repair_space>in<seq2seq4repair_space>freezer" , LENGTH_SHORT ) . show ( ) ; } } ) ; return freezerView ; } }
public class ServletWebRequest extends WebRequest { private final HttpServletRequest httpServletRequest ; private final Url url ; private final String filterPrefix ; private final ErrorAttributes errorAttributes ; public ServletWebRequest ( HttpServletRequest httpServletRequest , String filterPrefix ) { } public ServletWebRequest ( HttpServletRequest httpServletRequest , String filterPrefix , Url url ) { } @ Override public Url getClientUrl ( ) { } private Url setParameters ( Url url ) { } private Url getUrl ( HttpServletRequest request , String filterPrefix ) { } public String getFilterPrefix ( ) { } @ Override public List < Cookie > getCookies ( ) { } @ Override public Locale getLocale ( ) { } @ Override public Time getDateHeader ( String name ) { long value = httpServletRequest . getDateHeader ( name ) ; if ( value == ( - 1 ) ) { return null ; } <START_BUG> return Time . valueOf ( value ) ; <END_BUG> } @ Override public String getHeader ( String name ) { } @ SuppressWarnings ( "unchecked" ) @ Override public List < String > getHeaders ( String name ) { } private Map < String , List < StringValue > > postParameters = null ; private static boolean isMultiPart ( ServletRequest request ) { } protected Map < String , List < StringValue > > generatePostParameters ( ) { } private Map < String , List < StringValue > > getPostRequestParameters ( ) { } private final IRequestParameters postRequestParameters = new IWritableRequestParameters ( ) { public void reset ( ) { } public void setParameterValues ( String key , List < StringValue > values ) { } public Set < String > getParameterNames ( ) { } public StringValue getParameterValue ( String name ) { } public List < StringValue > getParameterValues ( String name ) { } } ; @ Override public IRequestParameters getPostParameters ( ) { } @ Override public Url getUrl ( ) { } @ Override public ServletWebRequest cloneWithUrl ( Url url ) { } public MultipartServletWebRequest newMultipartWebRequest ( Bytes maxSize ) throws FileUploadException { } public MultipartServletWebRequest newMultipartWebRequest ( Bytes maxSize , FileItemFactory factory ) throws FileUploadException { } private static final Logger logger = LoggerFactory . getLogger ( ServletWebRequest . class ) ; @ Override public String getPrefixToContextPath ( ) { } @ Override public Charset getCharset ( ) { } @ Override public HttpServletRequest getContainerRequest ( ) { } @ Override public String getContextPath ( ) { } @ Override public String getFilterPath ( ) { } @ Override public boolean shouldPreserveClientUrl ( ) { } }
public abstract class AbstractServicePublicationTest extends TestCase implements RemoteServicePublication , IDistributionConstants { protected static void assertStringsEqual ( final String [ ] s1 , final String [ ] s2 ) { } protected IContainer container ; protected String [ ] ifaces ; protected ServiceRegistration registration ; protected abstract IContainer createContainer ( ) throws Exception { } protected abstract String [ ] createInterfaces ( ) throws Exception { } protected ServiceReference reference ; public ServiceReference getReference ( ) { } protected void setUp ( ) throws Exception { } void removeFromContainerManager ( IContainer container ) { } protected void tearDown ( ) throws Exception { } public IContainer getContainer ( ) { } public String [ ] getInterfaces ( ) { } public void setContainer ( IContainer container ) { } public void testServicePublication ( ) throws InterruptedException { final BundleContext context = Activator . getDefault ( ) . getContext ( ) ; final Dictionary props = new Hashtable ( ) ; <START_BUG> props . put ( REMOTE_INTERFACES , getInterfaces ( ) ) ; <END_BUG> final ServiceTracker tracker = new ServiceTracker ( context , TestServiceInterface1 . class . getName ( ) , null ) ; tracker . open ( ) ; registration = context . registerService ( TestServiceInterface1 . class . getName ( ) , new TestService1 ( ) , props ) ; tracker . waitForService ( 10000 ) ; final ServiceReference ref = context . getServiceReference ( ServicePublication . class . getName ( ) ) ; assertTrue ( ( ref != null ) ) ; final Object o = ref . getProperty ( SERVICE_INTERFACE_NAME ) ; assertTrue ( ( o instanceof Collection ) ) ; final Collection refIfaces = ( ( Collection ) ( o ) ) ; AbstractServicePublicationTest . assertStringsEqual ( getInterfaces ( ) , ( ( String [ ] ) ( refIfaces . toArray ( new String [ ] { } ) ) ) ) ; Thread . sleep ( 10000 ) ; } public void setInterfaces ( String [ ] interfaces ) { } }
public class TestExplanations extends LuceneTestCase { protected IndexSearcher searcher ; public static final String KEY = "KEY" ; public static final String FIELD = "field" ; public static final QueryParser qp = new QueryParser ( TestExplanations . FIELD , new WhitespaceAnalyzer ( ) ) ; public void tearDown ( ) throws Exception { } public void setUp ( ) throws Exception { super . setUp ( ) ; RAMDirectory directory = new RAMDirectory ( ) ; IndexWriter writer = new IndexWriter ( directory , new WhitespaceAnalyzer ( ) , true , MaxFieldLength . LIMITED ) ; for ( int i = 0 ; i < ( docFields . length ) ; i ++ ) { Document doc = new Document ( ) ; doc . add ( new org . apache . lucene . document . Field ( TestExplanations . KEY , ( "" + i ) , Store . NO , Index . NOT_ANALYZED ) ) ; doc . add ( new org . apache . lucene . document . Field ( TestExplanations . FIELD , docFields [ i ] , Store . NO , Index . ANALYZED ) ) ; writer . addDocument ( doc ) ; } writer . close ( ) ; <START_BUG> searcher = new IndexSearcher ( directory ) ; <END_BUG> } protected String [ ] docFields = new String [ ] { "w1<seq2seq4repair_space>w2<seq2seq4repair_space>w3<seq2seq4repair_space>w4<seq2seq4repair_space>w5" , "w1<seq2seq4repair_space>w3<seq2seq4repair_space>w2<seq2seq4repair_space>w3<seq2seq4repair_space>zz" , "w1<seq2seq4repair_space>xx<seq2seq4repair_space>w2<seq2seq4repair_space>yy<seq2seq4repair_space>w3" , "w1<seq2seq4repair_space>w3<seq2seq4repair_space>xx<seq2seq4repair_space>w2<seq2seq4repair_space>yy<seq2seq4repair_space>w3<seq2seq4repair_space>zz" } ; public Query makeQuery ( String queryText ) throws ParseException { } public void qtest ( String queryText , int [ ] expDocNrs ) throws Exception { } public void qtest ( Query q , int [ ] expDocNrs ) throws Exception { } public void bqtest ( Query q , int [ ] expDocNrs ) throws Exception { } public void bqtest ( String queryText , int [ ] expDocNrs ) throws Exception { } public static class ItemizedFilter extends FieldCacheTermsFilter { private static String [ ] int2str ( int [ ] terms ) { } public ItemizedFilter ( String keyField , int [ ] keys ) { } public ItemizedFilter ( int [ ] keys ) { } } public static Term [ ] ta ( String [ ] s ) { } public SpanTermQuery st ( String s ) { } public SpanNotQuery snot ( SpanQuery i , SpanQuery e ) { } public SpanOrQuery sor ( String s , String e ) { } public SpanOrQuery sor ( SpanQuery s , SpanQuery e ) { } public SpanOrQuery sor ( String s , String m , String e ) { } public SpanOrQuery sor ( SpanQuery s , SpanQuery m , SpanQuery e ) { } public SpanNearQuery snear ( String s , String e , int slop , boolean inOrder ) { } public SpanNearQuery snear ( SpanQuery s , SpanQuery e , int slop , boolean inOrder ) { } public SpanNearQuery snear ( String s , String m , String e , int slop , boolean inOrder ) { } public SpanNearQuery snear ( SpanQuery s , SpanQuery m , SpanQuery e , int slop , boolean inOrder ) { } public SpanFirstQuery sf ( String s , int b ) { } public Query optB ( String q ) throws Exception { } public Query optB ( Query q ) throws Exception { } public Query reqB ( String q ) throws Exception { } public Query reqB ( Query q ) throws Exception { } public void testNoop ( ) { } }
public class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor { public RequestResponseBodyMethodProcessor ( List < HttpMessageConverter < ? > > messageConverters ) { } public boolean supportsParameter ( MethodParameter parameter ) { } public boolean supportsReturnType ( MethodParameter returnType ) { } public Object resolveArgument ( MethodParameter parameter , ModelAndViewContainer mavContainer , NativeWebRequest webRequest , WebDataBinderFactory binderFactory ) throws Exception { Object arg = readWithMessageConverters ( webRequest , parameter , parameter . getParameterType ( ) ) ; Annotation [ ] annotations = parameter . getParameterAnnotations ( ) ; for ( Annotation annot : annotations ) { <START_BUG> if ( "Valid" . equals ( annot . annotationType ( ) . getSimpleName ( ) ) ) { <END_BUG> String name = Conventions . getVariableNameForParameter ( parameter ) ; WebDataBinder binder = binderFactory . createBinder ( webRequest , arg , name ) ; Object hints = AnnotationUtils . getValue ( annot ) ; binder . validate ( ( hints instanceof Object [ ] ? ( ( Object [ ] ) ( hints ) ) : new Object [ ] { hints } ) ) ; BindingResult bindingResult = binder . getBindingResult ( ) ; if ( bindingResult . hasErrors ( ) ) { throw new org . springframework . web . method . annotation . support . MethodArgumentNotValidException ( parameter , bindingResult ) ; } } } return arg ; } public void handleReturnValue ( Object returnValue , MethodParameter returnType , ModelAndViewContainer mavContainer , NativeWebRequest webRequest ) throws IOException , HttpMediaTypeNotAcceptableException { } }
public class RomUpdate implements Constants { public final String TAG = this . getClass ( ) . getSimpleName ( ) ; private static final String PREF_NAME = "ROMUpdate" ; private static String NAME = "rom_name" ; private static String VERSION = "rom_version" ; private static String CODENAME = "rom_codename" ; private static String DIRECT_URL = "rom_direct_url" ; private static String HTTP_URL = "rom_http_url" ; private static String MD5 = "rom_md5" ; private static String CHANGELOG = "rom_changelog" ; private static String ANDROID = "rom_android_ver" ; private static String WEBSITE = "rom_website" ; private static String DEVELOPER = "rom_developer" ; private static String DONATE_LINK = "rom_donate_link" ; private static String FILESIZE = "rom_filesize" ; private static String AVAILABILITY = "update_availability" ; private static String DEF_VALUE = "null" ; public RomUpdate ( ) { } private static SharedPreferences getPrefs ( Context context ) { } public static String getName ( Context context ) { } public static String getVersion ( Context context ) { } public static String getCodename ( Context context ) { } public static String getDirectUrl ( Context context ) { } public static String getHttpUrl ( Context context ) { } public static String getMd5 ( Context context ) { } public static String getChangelog ( Context context ) { } public static String getAndroidVersion ( Context context ) { } public static String getWebsite ( Context context ) { } public static String getDeveloper ( Context context ) { } public static String getDonateLink ( Context context ) { } public static int getFileSize ( Context context ) { } public static boolean getUpdateAvailability ( Context context ) { } public static void setName ( Context context , String name ) { } public static void setVersion ( Context context , String version ) { } public static void setCodename ( Context context , String codename ) { } public static void setDirectUrl ( Context context , String url ) { } public static void setHttpUrl ( Context context , String url ) { } public static void setMd5 ( Context context , String md5 ) { } public static void setChangelog ( Context context , String change ) { } public static void setAndroidVersion ( Context context , String android ) { } public static void setWebsite ( Context context , String website ) { } public static void setDeveloper ( Context context , String developer ) { } public static void setDonateLink ( Context context , String donateLink ) { } public static void setFileSize ( Context context , int size ) { } public static void setUpdateAvailable ( Context context , boolean availability ) { } public static String getFilename ( Context context ) { String filenameSeparator = context . getResources ( ) . getString ( filename_separator ) ; boolean isCodenameUsed = ! ( RomUpdate . getCodename ( context ) . equals ( "null" ) ) ; String codenameDevice = ( isCodenameUsed ) ? ( ( RomUpdate . getCodename ( context ) ) + filenameSeparator ) + ( Utils . getProp ( "ro.ota.device" ) ) : Utils . getProp ( "ro.ota.device" ) ; String result = ( ( ( ( RomUpdate . getName ( context ) ) + filenameSeparator ) + ( RomUpdate . getVersion ( context ) ) ) + filenameSeparator ) + codenameDevice ; <START_BUG> return result ; <END_BUG> } public static File getFullFile ( Context context ) { } }
public class WorldTestCase extends AbstractWorldTestCase { public WorldTestCase ( String name ) { } private final BcelWorld world = new BcelWorld ( ( ( BcweaverTests . TESTDATA_PATH ) + "/tracing.jar" ) ) ; protected World getWorld ( ) { } public void xtestTraceJar ( ) { } public void testIterator ( ) { int abstractPublic = ( Modifier . ABSTRACT ) | ( Modifier . PUBLIC ) ; <START_BUG> ResolvedTypeX iter = world . getCoreType ( TypeX . forName ( "java.util.Iterator" ) ) ; <END_BUG> modifiersTest ( iter , ( abstractPublic | ( Modifier . INTERFACE ) ) ) ; fieldsTest ( iter , NONE ) ; methodsTest ( iter , new Member [ ] { Member . method ( iter , 0 , "hasNext" , "()Z" ) , Member . method ( iter , 0 , "remove" , "()V" ) , Member . method ( iter , 0 , "next" , "()Ljava/lang/Object;" ) } ) ; ResolvedMember remove = iter . lookupMethod ( Member . method ( iter , 0 , "remove" , "()V" ) ) ; assertNotNull ( "iterator<seq2seq4repair_space>doesn't<seq2seq4repair_space>have<seq2seq4repair_space>remove" , remove ) ; modifiersTest ( remove , ( abstractPublic | ( Modifier . INTERFACE ) ) ) ; exceptionsTest ( remove , TypeX . NONE ) ; ResolvedMember clone = iter . lookupMethod ( Member . method ( OBJECT , 0 , "clone" , "()Ljava/lang/Object;" ) ) ; assertNotNull ( "iterator<seq2seq4repair_space>doesn't<seq2seq4repair_space>have<seq2seq4repair_space>clone" , clone ) ; modifiersTest ( clone , ( ( Modifier . PROTECTED ) | ( Modifier . NATIVE ) ) ) ; exceptionsTest ( clone , TypeX . forNames ( new String [ ] { "java.lang.CloneNotSupportedException" } ) ) ; interfacesTest ( iter , ResolvedTypeX . NONE ) ; superclassTest ( iter , OBJECT ) ; pointcutsTest ( iter , NONE ) ; mungersTest ( iter , ShadowMunger . NONE ) ; isInterfaceTest ( iter , true ) ; isClassTest ( iter , false ) ; isAspectTest ( iter , false ) ; } public void testObjectCoersion ( ) { } private void assertCouldBeCoercibleFrom ( String a , String b ) { } private void assertCouldNotBeCoercibleFrom ( String a , String b ) { } }
public class ProgressFeedbackDialog extends Dialog { private IStructuredContentProvider provider ; ListViewer viewer ; public ProgressFeedbackDialog ( IStructuredContentProvider contentProvider ) { } private ILabelProvider getLabelProvider ( ) { } public void refreshViewer ( ) { } protected void configureShell ( Shell newShell ) { } protected Control createDialogArea ( Composite parent ) { setBlockOnOpen ( false ) ; Composite mainArea = ( ( Composite ) ( super . createDialogArea ( parent ) ) ) ; viewer = new ListViewer ( mainArea , SWT . BORDER ) ; GridData data = new GridData ( ( ( ( GridData . FILL_BOTH ) | ( GridData . GRAB_HORIZONTAL ) ) | ( GridData . GRAB_VERTICAL ) ) ) ; <START_BUG> data . widthHint = convertHorizontalDLUsToPixels ( 200 ) ; <END_BUG> data . heightHint = convertVerticalDLUsToPixels ( 100 ) ; viewer . getControl ( ) . setLayoutData ( data ) ; viewer . setContentProvider ( provider ) ; viewer . setLabelProvider ( getLabelProvider ( ) ) ; viewer . setInput ( ProgressFeedbackManager . getFeedbackManager ( ) ) ; viewer . addDoubleClickListener ( new IDoubleClickListener ( ) { public void doubleClick ( DoubleClickEvent event ) { ISelection selection = event . getSelection ( ) ; if ( selection instanceof IStructuredSelection ) { IStructuredSelection structured = ( ( IStructuredSelection ) ( selection ) ) ; if ( ( structured . size ( ) ) > 0 ) { AwaitingFeedbackInfo info = ( ( AwaitingFeedbackInfo ) ( structured . getFirstElement ( ) ) ) ; info . getJob ( ) . schedule ( ) ; } } } } ) ; return mainArea ; } protected void createButtonsForButtonBar ( Composite parent ) { } }
public class ParameterizedTypeBinding extends ReferenceBinding implements Substitution { public ReferenceBinding type ; public TypeBinding [ ] arguments ; public LookupEnvironment environment ; public char [ ] genericTypeSignature ; public ReferenceBinding superclass ; public ReferenceBinding [ ] superInterfaces ; public FieldBinding [ ] fields ; public ReferenceBinding [ ] memberTypes ; public MethodBinding [ ] methods ; public ReferenceBinding enclosingType ; public ParameterizedTypeBinding ( ReferenceBinding type , TypeBinding [ ] arguments , ReferenceBinding enclosingType , LookupEnvironment environment ) { } public void collectSubstitutes ( TypeBinding otherType , Map substitutes ) { } public void computeId ( ) { } public char [ ] constantPoolName ( ) { } public ParameterizedMethodBinding createParameterizedMethod ( MethodBinding originalMethod ) { <START_BUG> return new ParameterizedMethodBinding ( this , originalMethod ) ; <END_BUG> } public String debugName ( ) { } public ReferenceBinding enclosingType ( ) { } public TypeBinding erasure ( ) { } public int fieldCount ( ) { } public FieldBinding [ ] fields ( ) { } public char [ ] genericTypeSignature ( ) { } public MethodBinding getExactConstructor ( TypeBinding [ ] argumentTypes ) { } public MethodBinding getExactMethod ( char [ ] selector , TypeBinding [ ] argumentTypes , CompilationUnitScope refScope ) { } public FieldBinding getField ( char [ ] fieldName , boolean needResolve ) { } public ReferenceBinding getMemberType ( char [ ] typeName ) { } public MethodBinding [ ] getMethods ( char [ ] selector ) { } public boolean hasMemberTypes ( ) { } public boolean implementsMethod ( MethodBinding method ) { } void initialize ( ReferenceBinding someType , TypeBinding [ ] someArguments ) { } protected void initializeArguments ( ) { } public boolean isEquivalentTo ( TypeBinding otherType ) { } public boolean isParameterizedType ( ) { } public ReferenceBinding [ ] memberTypes ( ) { } public MethodBinding [ ] methods ( ) { } public char [ ] qualifiedSourceName ( ) { } public char [ ] readableName ( ) { } ReferenceBinding resolve ( ) { } public char [ ] shortReadableName ( ) { } public char [ ] signature ( ) { } public char [ ] sourceName ( ) { } public TypeBinding substitute ( TypeBinding originalType ) { } public ReferenceBinding superclass ( ) { } public ReferenceBinding [ ] superInterfaces ( ) { } public void swapUnresolved ( UnresolvedReferenceBinding unresolvedType , ReferenceBinding resolvedType , LookupEnvironment env ) { } public ReferenceBinding [ ] syntheticEnclosingInstanceTypes ( ) { } public SyntheticArgumentBinding [ ] syntheticOuterLocalVariables ( ) { } public char [ ] qualifiedPackageName ( ) { } public String toString ( ) { } public TypeVariableBinding [ ] typeVariables ( ) { } }
public class Jaxb2MarshallerTests extends AbstractMarshallerTests { private static final String CONTEXT_PATH = "org.springframework.oxm.jaxb.test" ; private Jaxb2Marshaller marshaller ; private Flights flights ; @ Override public Marshaller createMarshaller ( ) throws Exception { } @ Override protected Object createFlights ( ) { FlightType flight = new FlightType ( ) ; flight . setNumber ( 42L ) ; flights = new Flights ( ) ; <START_BUG> flights . getFlight ( ) . configureBinding ( flight ) ; <END_BUG> return flights ; } @ Test public void marshalSAXResult ( ) throws Exception { } @ Test public void laxyInit ( ) throws Exception { } @ Test public void properties ( ) throws Exception { } @ Test ( expected = IllegalArgumentException . class ) public void noContextPathOrClassesToBeBound ( ) throws Exception { } @ Test ( expected = UncategorizedMappingException . class ) public void testInvalidContextPath ( ) throws Exception { } @ Test ( expected = XmlMappingException . class ) public void marshalInvalidClass ( ) throws Exception { } @ Test public void supportsContextPath ( ) throws Exception { } @ Test public void supportsClassesToBeBound ( ) throws Exception { } @ Test public void marshalAttachments ( ) throws Exception { } }
public class Spinner extends Composite { public static final int LIMIT ; public Spinner ( Composite parent , int style ) { } static int checkStyle ( int style ) { } protected void checkSubclass ( ) { } void createHandle ( int index ) { } public void addModifyListener ( ModifyListener listener ) { } public void addSelectionListener ( SelectionListener listener ) { } void addVerifyListener ( VerifyListener listener ) { } public Point computeSize ( int wHint , int hHint , boolean changed ) { } public Rectangle computeTrim ( int x , int y , int width , int height ) { } public void copy ( ) { } public void cut ( ) { } void deregister ( ) { } int defaultBackground ( ) { } int defaultForeground ( ) { } public int getDigits ( ) { } public int getIncrement ( ) { } public int getMaximum ( ) { } public int getMinimum ( ) { } public int getPageIncrement ( ) { } public int getSelection ( ) { } public String getText ( ) { } public int getTextLimit ( ) { checkWidget ( ) ; <START_BUG> return 0 ; <END_BUG> } boolean hasFocus ( ) { } void hookEvents ( ) { } public void paste ( ) { } int Pt_CB_NUMERIC_CHANGED ( int widget , int info ) { } void register ( ) { } public void removeModifyListener ( ModifyListener listener ) { } public void removeSelectionListener ( SelectionListener listener ) { } void removeVerifyListener ( VerifyListener listener ) { } public void setDigits ( int value ) { } public void setIncrement ( int value ) { } public void setMaximum ( int value ) { } public void setMinimum ( int value ) { } public void setPageIncrement ( int value ) { } public void setSelection ( int value ) { } public void setTextLimit ( int limit ) { } public void setValues ( int selection , int minimum , int maximum , int digits , int increment , int pageIncrement ) { } boolean translateTraversal ( int key_sym , PhKeyEvent_t phEvent ) { } int widgetClass ( ) { } }
public class FieldInfo extends ClassFileStruct implements Comparable , AttributeNamesConstants , IBinaryField , TypeIds { private int accessFlags ; private int attributeBytes ; private Constant constant ; private int [ ] constantPoolOffsets ; private char [ ] descriptor ; private char [ ] name ; private char [ ] signature ; private int signatureUtf8Offset ; private long tagBits ; private Object wrappedConstantValue ; public FieldInfo ( byte [ ] classFileBytes , int [ ] offsets , int offset ) { } public int compareTo ( Object o ) { } private int decodeAnnotation ( int offset ) { } private int decodeElementValue ( int offset ) { } private void decodeStandardAnnotations ( int offset ) { } public Constant getConstant ( ) { } public char [ ] getGenericSignature ( ) { } public int getModifiers ( ) { } public char [ ] getName ( ) { } public long getTagBits ( ) { } public char [ ] getTypeName ( ) { } public Object getWrappedConstantValue ( ) { if ( ( this . wrappedConstantValue ) == null ) { if ( hasConstant ( ) ) { Constant fieldConstant = getConstant ( ) ; switch ( fieldConstant . typeID ( ) ) { case TypeIds . T_int : this . wrappedConstantValue = new Integer ( fieldConstant . intValue ( ) ) ; break ; case TypeIds . T_byte : this . wrappedConstantValue = new Byte ( fieldConstant . byteValue ( ) ) ; break ; case TypeIds . T_short : this . wrappedConstantValue = new Short ( fieldConstant . shortValue ( ) ) ; break ; case TypeIds . T_char : this . wrappedConstantValue = new Character ( fieldConstant . charValue ( ) ) ; break ; case TypeIds . T_float : this . wrappedConstantValue = new Float ( fieldConstant . floatValue ( ) ) ; break ; case TypeIds . T_double : this . wrappedConstantValue = new Double ( fieldConstant . doubleValue ( ) ) ; break ; case TypeIds . T_boolean : this . wrappedConstantValue = Util . toBoolean ( fieldConstant . booleanValue ( ) ) ; break ; case TypeIds . T_long : this . wrappedConstantValue = new Long ( fieldConstant . longValue ( ) ) ; break ; <START_BUG> case T_String : <END_BUG> this . wrappedConstantValue = fieldConstant . stringValue ( ) ; } } } return this . wrappedConstantValue ; } public boolean hasConstant ( ) { } void initialize ( ) { } public boolean isSynthetic ( ) { } private void readConstantAttribute ( ) { } private void readModifierRelatedAttributes ( ) { } protected void reset ( ) { } public int sizeInBytes ( ) { } public void throwFormatException ( ) throws ClassFormatException { } public String toString ( ) { } }
public class PageLink extends Link { private static final long serialVersionUID = 8530958543148278216L ; private final IPageLink pageLink ; public PageLink ( final String name , final IPageLink pageLink ) { } public PageLink ( final String name , final Class c ) { } public void onClick ( ) { <START_BUG> getRequestCycle ( ) . setPage ( pageLink . getPage ( ) ) ; <END_BUG> } public boolean linksTo ( final Page page ) { } }
public class WriteAttributeHandlers { public static class WriteAttributeOperationHandler implements ModelUpdateOperationHandler { public static OperationHandler INSTANCE = new WriteAttributeHandlers . WriteAttributeOperationHandler ( ) ; final ParameterValidator validator ; private WriteAttributeOperationHandler ( ) { } protected WriteAttributeOperationHandler ( ParameterValidator validator ) { } @ Override public Cancellable execute ( final NewOperationContext context , final ModelNode operation , final ResultHandler resultHandler ) { Cancellable cancellable = Cancellable . NULL ; try { final String name = operation . require ( NAME ) . asString ( ) ; final ModelNode value = operation . get ( VALUE ) ; String error = validateValue ( name , value ) ; if ( error != null ) { resultHandler . handleFailed ( new ModelNode ( ) . set ( error ) ) ; } else { <START_BUG> context . getSubModel ( ) . require ( name ) . set ( value ) ; <END_BUG> resultHandler . handleResultComplete ( null ) ; } } catch ( final Exception e ) { resultHandler . handleFailed ( new ModelNode ( ) . set ( e . getMessage ( ) ) ) ; } return cancellable ; } protected String validateValue ( String name , ModelNode value ) { } } public static class ModelTypeValidatingHandler extends WriteAttributeHandlers . WriteAttributeOperationHandler { public ModelTypeValidatingHandler ( final ModelType type ) { } public ModelTypeValidatingHandler ( final ModelType type , final boolean nullable ) { } public ModelTypeValidatingHandler ( final ModelType type , final boolean nullable , final boolean allowExpressions ) { } public ModelTypeValidatingHandler ( final boolean nullable , final boolean allowExpressions , ModelType firstValidType , ModelType ... otherValidTypes ) { } } public static class StringLengthValidatingHandler extends WriteAttributeHandlers . WriteAttributeOperationHandler { public StringLengthValidatingHandler ( final int min ) { } public StringLengthValidatingHandler ( final int min , final boolean nullable ) { } public StringLengthValidatingHandler ( final int min , final int max , final boolean nullable , final boolean allowExpressions ) { } } public static class IntRangeValidatingHandler extends WriteAttributeHandlers . WriteAttributeOperationHandler { public IntRangeValidatingHandler ( final int min ) { } public IntRangeValidatingHandler ( final int min , final boolean nullable ) { } public IntRangeValidatingHandler ( final int min , final int max , final boolean nullable , final boolean allowExpressions ) { } } public static class InetAddressValidatingHandler extends WriteAttributeHandlers . WriteAttributeOperationHandler { public InetAddressValidatingHandler ( final boolean nullable , final boolean allowExpressions ) { } } public static class ListValidatatingHandler extends WriteAttributeHandlers . WriteAttributeOperationHandler { public ListValidatatingHandler ( ParameterValidator elementValidator ) { } public ListValidatatingHandler ( ParameterValidator elementValidator , boolean nullable ) { } public ListValidatatingHandler ( ParameterValidator elementValidator , boolean nullable , int minSize , int maxSize ) { } } }
public class NewFieldTypeMunger extends ResolvedTypeMunger { public NewFieldTypeMunger ( ResolvedMember signature , Set superMethodsCalled ) { } public ResolvedMember getInitMethod ( UnresolvedType aspectType ) { } public void write ( DataOutputStream s ) throws IOException { } public static ResolvedTypeMunger readField ( VersionedDataInputStream s , ISourceContext context ) throws IOException { <START_BUG> ResolvedTypeMunger munger = new NewFieldTypeMunger ( ResolvedMember . readResolvedMember ( s , context ) , readSuperMethodsCalled ( s ) ) ; <END_BUG> if ( ResolvedTypeMunger . persistSourceLocation ) munger . setSourceLocation ( readSourceLocation ( s ) ) ; return munger ; } public ResolvedMember getMatchingSyntheticMember ( Member member , ResolvedType aspectType ) { } }
public class EJB3SubsystemXMLPersister implements XMLElementWriter < SubsystemMarshallingContext > { public static final EJB3SubsystemXMLPersister INSTANCE = new EJB3SubsystemXMLPersister ( ) ; @ Override public void writeContent ( final XMLExtendedStreamWriter writer , final SubsystemMarshallingContext context ) throws XMLStreamException { <START_BUG> context . startSubsystemElement ( EJB3_1_5 . getUriString ( ) , false ) ; <END_BUG> writeElements ( writer , context ) ; writer . writeEndElement ( ) ; } protected void writeElements ( final XMLExtendedStreamWriter writer , final SubsystemMarshallingContext context ) throws XMLStreamException { } private void writeIIOP ( final XMLExtendedStreamWriter writer , final ModelNode model ) throws XMLStreamException { } private void writeThreadPools ( final XMLExtendedStreamWriter writer , final ModelNode threadPoolsModel ) throws XMLStreamException { } protected void writeRemote ( final XMLExtendedStreamWriter writer , final ModelNode model ) throws XMLStreamException { } private void writeAsync ( final XMLExtendedStreamWriter writer , final ModelNode model ) throws XMLStreamException { } private void writeMDB ( final XMLExtendedStreamWriter writer , final ModelNode mdbModelNode ) throws XMLStreamException { } private void writeEntityBean ( final XMLExtendedStreamWriter writer , final ModelNode entityModelNode ) throws XMLStreamException { } private void writeSingletonBean ( final XMLExtendedStreamWriter writer , final ModelNode singletonBeanModel ) throws XMLStreamException { } private void writeStatefulBean ( final XMLExtendedStreamWriter writer , final ModelNode statefulBeanModel ) throws XMLStreamException { } private void writeDefaultSLSBPool ( final XMLExtendedStreamWriter writer , final ModelNode model ) throws XMLStreamException { } private void writeBeanInstancePools ( final XMLExtendedStreamWriter writer , final ModelNode beanInstancePoolModelNode ) throws XMLStreamException { } private void writeStrictMaxPoolConfig ( final XMLExtendedStreamWriter writer , final Property strictMaxPoolModel ) throws XMLStreamException { } private void writeCaches ( XMLExtendedStreamWriter writer , ModelNode model ) throws XMLStreamException { } private void writeClusterPassivationStores ( XMLExtendedStreamWriter writer , ModelNode model ) throws XMLStreamException { } private void writeFilePassivationStores ( XMLExtendedStreamWriter writer , ModelNode model ) throws XMLStreamException { } private void writeTimerService ( final XMLExtendedStreamWriter writer , final ModelNode timerServiceModel ) throws XMLStreamException { } private void writeDatabaseDataStores ( final XMLExtendedStreamWriter writer , final ModelNode timerServiceModel ) throws XMLStreamException { } private void writeFileDataStores ( final XMLExtendedStreamWriter writer , final ModelNode timerServiceModel ) throws XMLStreamException { } private void writeChannelCreationOptions ( final XMLExtendedStreamWriter writer , final ModelNode node ) throws XMLStreamException { } }
public class SingleNameReference extends NameReference implements OperatorIds { public char [ ] token ; public MethodBinding [ ] syntheticAccessors ; public static final int READ = 0 ; public static final int WRITE = 1 ; public SingleNameReference ( char [ ] source , long pos ) { } public FlowInfo analyseAssignment ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , Assignment assignment , boolean isCompound ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , boolean valueRequired ) { } public TypeBinding checkFieldAccess ( BlockScope scope ) { FieldBinding fieldBinding = ( ( FieldBinding ) ( binding ) ) ; bits &= ~ ( ASTNode . RestrictiveFlagMASK ) ; bits |= FIELD ; if ( ! ( ( ( FieldBinding ) ( binding ) ) . isStatic ( ) ) ) { if ( scope . methodScope ( ) . isStatic ) { scope . problemReporter ( ) . staticFieldAccessToNonStaticVariable ( this , fieldBinding ) ; constant = NotAConstant ; return null ; } } <START_BUG> constant = FieldReference . getConstantFor ( fieldBinding , true , this , 0 ) ; <END_BUG> if ( isFieldUseDeprecated ( fieldBinding , scope ) ) scope . problemReporter ( ) . deprecatedField ( fieldBinding , this ) ; MethodScope ms = scope . methodScope ( ) ; if ( ( ( ( ms . enclosingSourceType ( ) ) == ( fieldBinding . declaringClass ) ) && ( ( ms . fieldDeclarationIndex ) != ( ms . NotInFieldDecl ) ) ) && ( ( fieldBinding . id ) >= ( ms . fieldDeclarationIndex ) ) ) { if ( ( ! ( fieldBinding . isStatic ( ) ) ) || ( ms . isStatic ) ) scope . problemReporter ( ) . forwardReference ( this , 0 , scope . enclosingSourceType ( ) ) ; } return fieldBinding . type ; } public void generateAssignment ( BlockScope currentScope , CodeStream codeStream , Assignment assignment , boolean valueRequired ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public void generateCompoundAssignment ( BlockScope currentScope , CodeStream codeStream , Expression expression , int operator , int assignmentImplicitConversion , boolean valueRequired ) { } public void generateCompoundAssignment ( BlockScope currentScope , CodeStream codeStream , MethodBinding writeAccessor , Expression expression , int operator , int assignmentImplicitConversion , boolean valueRequired ) { } public void generatePostIncrement ( BlockScope currentScope , CodeStream codeStream , CompoundAssignment postIncrement , boolean valueRequired ) { } public void generateReceiver ( CodeStream codeStream ) { } public void manageEnclosingInstanceAccessIfNecessary ( BlockScope currentScope ) { } public void manageSyntheticReadAccessIfNecessary ( BlockScope currentScope ) { } public void manageSyntheticWriteAccessIfNecessary ( BlockScope currentScope ) { } public TypeBinding reportError ( BlockScope scope ) { } public TypeBinding resolveType ( BlockScope scope ) { } public String toStringExpression ( ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope scope ) { } public String unboundReferenceErrorName ( ) { } }
public abstract class Session implements IClusterable , IEventSink { private static final long serialVersionUID = 1L ; private static final Logger log = LoggerFactory . getLogger ( Session . class ) ; public static final String SESSION_ATTRIBUTE_NAME = "session" ; private int sequence = 1 ; private int pageId = 0 ; public static boolean exists ( ) { } public static Session get ( ) { } protected ClientInfo clientInfo ; private transient boolean dirty = false ; private final FeedbackMessages feedbackMessages = new FeedbackMessages ( ) ; private String id = null ; private Locale locale ; private MetaDataEntry < ? > [ ] metaData ; private transient boolean sessionInvalidated = false ; private transient ISessionStore sessionStore ; private String style ; private transient Map < String , Serializable > temporarySessionAttributes ; public Session ( Request request ) { } public final void bind ( ) { } public abstract void cleanupFeedbackMessages ( ) { } public final void clear ( ) { } public final void error ( final String message ) { } public final Application getApplication ( ) { } public IAuthorizationStrategy getAuthorizationStrategy ( ) { } public final IClassResolver getClassResolver ( ) { } public abstract ClientInfo getClientInfo ( ) { } public final FeedbackMessages getFeedbackMessages ( ) { } public final String getId ( ) { } public Locale getLocale ( ) { } public final < M extends Serializable > M getMetaData ( final MetaDataKey < M > key ) { } protected boolean isCurrentRequestValid ( RequestCycle lockedRequestCycle ) { } public final IPageFactory getPageFactory ( ) { } public final long getSizeInBytes ( ) { } public final String getStyle ( ) { } public final void info ( final String message ) { } public void invalidate ( ) { if ( ( sessionInvalidated ) == false ) { RequestCycle . get ( ) . getListeners ( ) . add ( new AbstractRequestCycleListener ( ) { @ Override public void onDetach ( final RequestCycle cycle ) { <START_BUG> destroy ( ) ; <END_BUG> } } ) ; } sessionInvalidated = true ; } private void destroy ( ) { } public void invalidateNow ( ) { } public void replaceSession ( ) { } public final boolean isSessionInvalidated ( ) { } public final boolean isTemporary ( ) { } public final void setClientInfo ( ClientInfo clientInfo ) { } public void setLocale ( final Locale locale ) { } public final void setMetaData ( final MetaDataKey < ? > key , final Serializable object ) { } public final Session setStyle ( final String style ) { } public final void warn ( final String message ) { } private void addFeedbackMessage ( String message , int level ) { } protected void detach ( ) { } public final void dirty ( ) { } public final Serializable getAttribute ( final String name ) { } protected final List < String > getAttributeNames ( ) { } protected ISessionStore getSessionStore ( ) { } protected final void removeAttribute ( String name ) { } public final void setAttribute ( String name , Serializable value ) { } public synchronized int nextSequenceValue ( ) { } public synchronized int nextPageId ( ) { } public final IPageManager getPageManager ( ) { } public void onEvent ( IEvent < ? > event ) { } }
public class Combo extends Composite { int menuHandle ; int textLimit = Combo . LIMIT ; String lastText = "" ; public static final int LIMIT ; public Combo ( Composite parent , int style ) { } public void add ( String string ) { } public void add ( String string , int index ) { } public void addModifyListener ( ModifyListener listener ) { } public void addSelectionListener ( SelectionListener listener ) { } public void addVerifyListener ( VerifyListener listener ) { } static int checkStyle ( int style ) { } void checkSelection ( ) { } protected void checkSubclass ( ) { } public void clearSelection ( ) { } public Point computeSize ( int wHint , int hHint , boolean changed ) { } public void copy ( ) { } void copy ( char [ ] buffer ) { } void createHandle ( ) { } public void cut ( ) { } public void deselect ( int index ) { } public void deselectAll ( ) { } public String getItem ( int index ) { } public int getItemCount ( ) { } public int getItemHeight ( ) { } public String [ ] getItems ( ) { } public int getOrientation ( ) { } public Point getSelection ( ) { } public int getSelectionIndex ( ) { } public String getText ( ) { } char [ ] getText ( int start , int end ) { } public int getTextHeight ( ) { } public int getTextLimit ( ) { } public int getVisibleItemCount ( ) { } void hookEvents ( ) { } public int indexOf ( String string ) { } public int indexOf ( String string , int start ) { } String getClipboardText ( ) { } int getCharCount ( ) { } Rect getInset ( ) { } int kEventControlActivate ( int nextHandler , int theEvent , int userData ) { } int kEventProcessCommand ( int nextHandler , int theEvent , int userData ) { } int kEventRawKeyPressed ( int nextHandler , int theEvent , int userData ) { } int kEventControlSetFocusPart ( int nextHandler , int theEvent , int userData ) { } int kEventTextInputUnicodeForKeyEvent ( int nextHandler , int theEvent , int userData ) { } public void paste ( ) { } void releaseWidget ( ) { } public void remove ( int index ) { } public void remove ( int start , int end ) { } public void remove ( String string ) { } public void removeAll ( ) { } public void removeModifyListener ( ModifyListener listener ) { } public void removeSelectionListener ( SelectionListener listener ) { } public void removeVerifyListener ( VerifyListener listener ) { } public void select ( int index ) { } boolean sendKeyEvent ( int type , Event event ) { } public void setItem ( int index , String string ) { } public void setItems ( String [ ] items ) { } public void setOrientation ( int orientation ) { } public void setSelection ( Point selection ) { } public void setText ( String string ) { } void setText ( String string , boolean notify ) { if ( notify ) { if ( ( hooks ( Verify ) ) || ( filters ( Verify ) ) ) { string = verifyText ( string , 0 , getCharCount ( ) , null ) ; if ( string == null ) return ; } } if ( ( ( style ) & ( SWT . READ_ONLY ) ) != 0 ) { int index = indexOf ( string ) ; <START_BUG> if ( ( index != ( - 1 ) ) && ( index == ( getSelectionIndex ( ) ) ) ) { <END_BUG> select ( index ) ; if ( notify ) sendEvent ( Modify ) ; } } else { char [ ] buffer = new char [ string . length ( ) ] ; string . getChars ( 0 , buffer . length , buffer , 0 ) ; int ptr = OS . CFStringCreateWithCharacters ( kCFAllocatorDefault , buffer , buffer . length ) ; if ( ptr == 0 ) error ( ERROR_CANNOT_SET_TEXT ) ; lastText = string ; OS . SetControlData ( handle , kHIComboBoxEditTextPart , kControlEditTextCFStringTag , 4 , new int [ ] { ptr } ) ; OS . CFRelease ( ptr ) ; if ( notify ) sendEvent ( Modify ) ; } } public void setTextLimit ( int limit ) { } public void setVisibleItemCount ( int count ) { } String verifyText ( String string , int start , int end , Event keyEvent ) { } }
public class Shell extends Decorations { int shellHandle ; int tooltipsHandle ; boolean mapped ; boolean moved ; boolean resized ; boolean opened ; int oldX ; int oldY ; int oldWidth ; int oldHeight ; int minWidth ; int minHeight ; Control lastActive ; Region region ; public Shell ( ) { } public Shell ( int style ) { } public Shell ( Display display ) { } public Shell ( Display display , int style ) { } Shell ( Display display , Shell parent , int style , int handle ) { } public Shell ( Shell parent ) { } public Shell ( Shell parent , int style ) { } public static Shell gtk_new ( Display display , int handle ) { } static int checkStyle ( int style ) { } public void addShellListener ( ShellListener listener ) { } void adjustTrim ( ) { } void bringToTop ( boolean force ) { if ( ! ( OS . GTK_WIDGET_VISIBLE ( shellHandle ) ) ) return ; Display display = this . display ; Shell activeShell = display . activeShell ; if ( activeShell == ( this ) ) return ; if ( ! force ) { if ( activeShell == null ) return ; int focusHandle = OS . gtk_window_get_focus ( activeShell . shellHandle ) ; if ( focusHandle != 0 ) { if ( ! ( OS . GTK_WIDGET_HAS_FOCUS ( focusHandle ) ) ) return ; } } if ( activeShell != null ) display . activeShell = null ; int window = OS . GTK_WIDGET_WINDOW ( shellHandle ) ; if ( ( ( ( style ) & ( SWT . ON_TOP ) ) != 0 ) && ( OS . GDK_WINDOWING_X11 ( ) ) ) { int xDisplay = OS . gdk_x11_drawable_get_xdisplay ( window ) ; int xWindow = OS . gdk_x11_drawable_get_xid ( window ) ; OS . gdk_error_trap_push ( ) ; OS . XSetInputFocus ( xDisplay , xWindow , RevertToParent , CurrentTime ) ; OS . gdk_error_trap_pop ( ) ; } else { <START_BUG> OS . gdk_window_focus ( window , OS . gtk_get_current_event_time ( ) ) ; <END_BUG> } display . activeShell = this ; } void checkBorder ( ) { } void checkOpen ( ) { } public void close ( ) { } void closeWidget ( ) { } public Rectangle computeTrim ( int x , int y , int width , int height ) { } void createHandle ( int index ) { } boolean hasBorder ( ) { } void hookEvents ( ) { } public boolean isEnabled ( ) { } public boolean isLayoutDeferred ( ) { } public boolean isVisible ( ) { } void register ( ) { } void releaseChild ( ) { } int topHandle ( ) { } int filterProc ( int xEvent , int gdkEvent , int data ) { } void fixShell ( Shell newShell , Control control ) { } void forceResize ( ) { } public Point getLocation ( ) { } public Point getMinimumSize ( ) { } public Point getSize ( ) { } public boolean getVisible ( ) { } public Region getRegion ( ) { } public int getImeInputMode ( ) { } Shell _getShell ( ) { } public Shell [ ] getShells ( ) { } int gtk_configure_event ( int widget , int event ) { } int gtk_delete_event ( int widget , int event ) { } int gtk_enter_notify_event ( int widget , int event ) { } int gtk_focus ( int widget , int directionType ) { } int gtk_move_focus ( int widget , int directionType ) { } int gtk_focus_in_event ( int widget , int event ) { } int gtk_focus_out_event ( int widget , int event ) { } int gtk_map_event ( int widget , int event ) { } int gtk_size_allocate ( int widget , int allocation ) { } int gtk_realize ( int widget ) { } int gtk_unmap_event ( int widget , int event ) { } int gtk_window_state_event ( int widget , int event ) { } public void open ( ) { } public void removeShellListener ( ShellListener listener ) { } public void setActive ( ) { } void setActiveControl ( Control control ) { } void resizeBounds ( int width , int height , boolean notify ) { } int setBounds ( int x , int y , int width , int height , boolean move , boolean resize ) { } void setCursor ( int cursor ) { } public void setEnabled ( boolean enabled ) { } public void setImeInputMode ( int mode ) { } void setInitialBounds ( ) { } public void setMaximized ( boolean maximized ) { } public void setMenuBar ( Menu menu ) { } public void setMinimized ( boolean minimized ) { } public void setMinimumSize ( int width , int height ) { } public void setMinimumSize ( Point size ) { } public void setRegion ( Region region ) { } public void setText ( String string ) { } public void setVisible ( boolean visible ) { } void setZOrder ( Control sibling , boolean above ) { } int shellMapProc ( int handle , int arg0 , int user_data ) { } void showWidget ( ) { } boolean traverseEscape ( ) { } int trimHeight ( ) { } int trimWidth ( ) { } void deregister ( ) { } public void dispose ( ) { } public void forceActive ( ) { } public Rectangle getBounds ( ) { } void releaseHandle ( ) { } void releaseShells ( ) { } void releaseWidget ( ) { } void setToolTipText ( int widget , String string ) { } }
public class HostControllerBootstrap { private static final Logger log = Logger . getLogger ( "org.jboss.as.host.controller" ) ; static final ServiceName SERVICE_NAME_BASE = JBOSS . append ( "host" , "controller" ) ; static final int DEFAULT_POOL_SIZE = 20 ; private final ServiceContainer serviceContainer = Factory . create ( "host-controller" ) ; private final HostControllerEnvironment environment ; private final byte [ ] authCode ; public HostControllerBootstrap ( final HostControllerEnvironment environment , final byte [ ] authCode ) { } public void start ( ) throws Exception { final File configDir = environment . getDomainConfigurationDir ( ) ; final ConfigurationFile configurationFile = environment . getHostConfigurationFile ( ) ; final ExtensibleConfigurationPersister configurationPersister = HostControllerBootstrap . createHostConfigurationPersister ( configDir , configurationFile ) ; final List < ModelNode > operations = configurationPersister . load ( ) ; final ServiceTarget serviceTarget = serviceContainer ; serviceTarget . addListener ( new org . jboss . msc . service . AbstractServiceListener < Object > ( ) { @ Override public void transition ( final ServiceController < ? extends Object > controller , final ServiceController . Transition transition ) { if ( transition == ( Transition . STARTING_to_START_FAILED ) ) { HostControllerBootstrap . log . errorf ( controller . getStartException ( ) , "Service<seq2seq4repair_space>[%s]<seq2seq4repair_space>failed." , controller . getName ( ) ) ; } } } ) ; registerBaseServices ( serviceTarget ) ; HostControllerBootstrap . DomainModelProxyImpl domainModelProxy = new HostControllerBootstrap . DomainModelProxyImpl ( ) ; final ModelNodeRegistration hostRegistry = HostModelUtil . createHostRegistry ( configurationPersister , environment , domainModelProxy ) ; final ModelNodeRegistration rootRegistration = HostModelUtil . createBootstrapHostRegistry ( hostRegistry , domainModelProxy ) ; DomainModelImpl domainModel = new DomainModelImpl ( rootRegistration , serviceContainer , configurationPersister ) ; domainModelProxy . setDomainModel ( domainModel ) ; final AtomicInteger count = new AtomicInteger ( 1 ) ; final ResultHandler resultHandler = new ResultHandler ( ) { @ Override public void handleResultFragment ( final String [ ] location , final ModelNode result ) { } @ Override public void handleResultComplete ( ) { if ( ( count . decrementAndGet ( ) ) == 0 ) { } } @ Override public void handleFailed ( final ModelNode failureDescription ) { if ( ( count . decrementAndGet ( ) ) == 0 ) { } } @ Override public void handleCancellation ( ) { if ( ( count . decrementAndGet ( ) ) == 0 ) { } } } ; for ( final ModelNode operation : operations ) { count . incrementAndGet ( ) ; operation . get ( OPERATION_HEADERS , ROLLBACK_ON_RUNTIME_FAILURE ) . set ( false ) ; domainModel . execute ( OperationBuilder . Factory . create ( operation ) . build ( ) , resultHandler ) ; } if ( ( count . decrementAndGet ( ) ) == 0 ) { } final String hostName = domainModel . getLocalHostName ( ) ; final ModelNode hostModelNode = domainModel . getHostModel ( ) ; final String mgmtNetwork = hostModelNode . get ( MANAGEMENT_INTERFACE , NATIVE_INTERFACE , INTERFACE ) . asString ( ) ; final int mgmtPort = hostModelNode . get ( MANAGEMENT_INTERFACE , NATIVE_INTERFACE , PORT ) . asInt ( ) ; final ServerInventoryService inventory = new ServerInventoryService ( environment , mgmtPort ) ; serviceTarget . addService ( SERVICE_NAME , inventory ) . addDependency ( ProcessControllerConnectionService . SERVICE_NAME , ProcessControllerConnectionService . class , inventory . getClient ( ) ) . addDependency ( JBOSS_NETWORK_INTERFACE . append ( mgmtNetwork ) , NetworkInterfaceBinding . class , inventory . getInterface ( ) ) . install ( ) ; final HostControllerService hc = new HostControllerService ( hostName , hostModelNode , configurationPersister , hostRegistry ) ; serviceTarget . addService ( HostController . SERVICE_NAME , hc ) . addDependency ( SERVICE_NAME , ServerInventory . class , hc . getServerInventory ( ) ) . addDependency ( ServerToHostOperationHandler . SERVICE_NAME ) . setInitialMode ( ACTIVE ) . install ( ) ; final ServerToHostOperationHandler serverToHost = new ServerToHostOperationHandler ( ) ; serviceTarget . addService ( ServerToHostOperationHandler . SERVICE_NAME , serverToHost ) . addDependency ( SERVICE_NAME , ManagedServerLifecycleCallback . class , serverToHost . getCallbackInjector ( ) ) . install ( ) ; <START_BUG> RemotingServices . installChannelOpenListenerService ( serviceTarget , "server" , ServerToHostOperationHandler . SERVICE_NAME , null ) ; <END_BUG> } private void registerBaseServices ( final ServiceTarget serviceTarget ) { } static ExtensibleConfigurationPersister createHostConfigurationPersister ( final File configDir , final ConfigurationFile configurationFile ) { } static final class HostControllerExecutorService implements Service < Executor > { final InjectedValue < ThreadFactory > threadFactoryValue = new InjectedValue < ThreadFactory > ( ) ; private ScheduledExecutorService executorService ; @ Override public synchronized void start ( final StartContext context ) throws StartException { } @ Override public synchronized void stop ( final StopContext context ) { } @ Override public synchronized ScheduledExecutorService getValue ( ) throws IllegalStateException { } } static final class DomainModelProxyImpl implements DomainModelProxy { private DomainModelImpl domainModel ; public void setDomainModel ( final DomainModelImpl domainModel ) { } @ Override public DomainModelImpl getDomainModel ( ) { } } }
public abstract class FilteredPreferenceDialog extends PreferenceDialog { protected TreeViewer filteredViewer ; protected TreeViewer unfilteredViewer ; private StackLayout stackLayout ; private Composite stackComposite ; private Button showAllCheck ; public FilteredPreferenceDialog ( Shell parentShell , PreferenceManager manager ) { } protected Control createTreeAreaContents ( Composite composite ) { Composite treeArea = new Composite ( composite , SWT . None ) ; GridLayout layout = new GridLayout ( ) ; layout . marginHeight = 0 ; layout . marginWidth = 0 ; treeArea . setLayout ( layout ) ; stackComposite = new Composite ( treeArea , SWT . NONE ) ; stackLayout = new StackLayout ( ) ; stackComposite . setLayout ( stackLayout ) ; stackComposite . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; stackComposite . setFont ( composite . getFont ( ) ) ; layoutTreeAreaControl ( treeArea ) ; filteredViewer = createTreeViewer ( stackComposite , true ) ; if ( WorkbenchActivityHelper . showAll ( ) ) { unfilteredViewer = createTreeViewer ( stackComposite , false ) ; showAllCheck = new Button ( treeArea , SWT . CHECK ) ; showAllCheck . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; showAllCheck . setText ( ActivityMessages . getString ( "ActivityFiltering.showAll" ) ) ; showAllCheck . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { if ( ! ( showAllCheck . getSelection ( ) ) ) { filteredViewer . setExpandedElements ( unfilteredViewer . getExpandedElements ( ) ) ; filteredViewer . setSelection ( unfilteredViewer . getSelection ( ) ) ; stackLayout . topControl = filteredViewer . getControl ( ) ; stackComposite . layout ( ) ; showPage ( getSingleSelection ( filteredViewer . getSelection ( ) ) ) ; } else { unfilteredViewer . setExpandedElements ( filteredViewer . getExpandedElements ( ) ) ; unfilteredViewer . setSelection ( filteredViewer . getSelection ( ) ) ; stackLayout . topControl = unfilteredViewer . getControl ( ) ; stackComposite . layout ( ) ; showPage ( getSingleSelection ( unfilteredViewer . getSelection ( ) ) ) ; } } } ) ; } stackLayout . topControl = filteredViewer . getControl ( ) ; <START_BUG> return stackComposite ; <END_BUG> } private TreeViewer createTreeViewer ( Composite parent , boolean filtering ) { } protected IPreferenceNode findNodeMatching ( String nodeId ) { } protected TreeViewer getTreeViewer ( ) { } protected void updateTreeFont ( Font dialogFont ) { } }
public class ItemGenerator extends Item { private String [ ] subNames = new String [ ] { "VoidPitGenerator" , "SpikeGenerator" , "StarCrystalGenerator" , "SphereGenerator" , "SphereEraser" , "LiquidRemover" , "TreeGenerator" , "LightningSummoner" , "ExplosionGenerator" } ; private String [ ] textureNames = new String [ ] { "voidPitGenerator" , "spikeGenerator" , "starCrystalGenerator" , "sphereGenerator" , "sphereEraser" , "liquidRemover" , "treeGenerator" , "lightningSummoner" , "explosionGenerator" } ; private IIcon [ ] iconArray = new IIcon [ subNames . length ] ; public ItemGenerator ( ) { } @ Override public void addInformation ( ItemStack par1ItemStack , EntityPlayer par2EntityPlayer , List par2List , boolean par4 ) { } @ Override public ItemStack onItemRightClick ( ItemStack stack , World world , EntityPlayer player ) { } @ Override public void getSubItems ( Item item , CreativeTabs tab , List list ) { } @ Override public IIcon getIconFromDamage ( int damage ) { } @ Override public void registerIcons ( IIconRegister register ) { for ( int i = 0 ; i < ( subNames . length ) ; i ++ ) { <START_BUG> this . iconArray [ i ] = register . registerIcon ( ( ( "tragicmc:" + ( textureNames [ i ] ) ) + "_lowRes" ) ) ; <END_BUG> } } @ Override public String getUnlocalizedName ( ItemStack itemstack ) { } }
if ( key . equals ( "name" ) ) { name = value ; if ( name . equals ( "" ) ) { throw new BuildException ( ( "name<seq2seq4repair_space>attribute<seq2seq4repair_space>must<seq2seq4repair_space>not" + "<seq2seq4repair_space>be<seq2seq4repair_space>empty" ) , new Location ( helperImpl . locator ) ) ; } } else if ( key . equals ( "depends" ) ) { depends = value ; } else if ( key . equals ( "if" ) ) { ifCond = value ; } else if ( key . equals ( "unless" ) ) { unlessCond = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "description" ) ) { description = value ; } else { throw new SAXParseException ( ( ( "Unexpected<seq2seq4repair_space>attribute<seq2seq4repair_space>\"" + key ) + "\"" ) , helperImpl . locator ) ; } } if ( name == null ) { throw new SAXParseException ( "target<seq2seq4repair_space>element<seq2seq4repair_space>appears<seq2seq4repair_space>without<seq2seq4repair_space>a<seq2seq4repair_space>name<seq2seq4repair_space>attribute" , helperImpl . locator ) ; } target = new Target ( ) ; target . addDependency ( "" ) ; target . setName ( name ) ; target . setIf ( ifCond ) ; target . setUnless ( unlessCond ) ; target . setDescription ( description ) ; helperImpl . project . addTarget ( name , target ) ; if ( ( id != null ) && ( ! ( id . equals ( "" ) ) ) ) { helperImpl . project . addReference ( id , target ) ; } if ( ( depends . length ( ) ) > 0 ) { target . setDepends ( depends ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { } } private static void handleElement ( ProjectHelperImpl helperImpl , DocumentHandler parent , Target target , String elementName , AttributeList attrs ) throws SAXParseException { } static class DescriptionHandler extends ProjectHelperImpl . AbstractHandler { public DescriptionHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { } public void characters ( char [ ] buf , int start , int count ) { } } static class TaskHandler extends ProjectHelperImpl . AbstractHandler { private Target target ; private TaskContainer container ; private Task task ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable wrapper = null ; public TaskHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , TaskContainer container , RuntimeConfigurable parentWrapper , Target target ) { } public void init ( String tag , AttributeList attrs ) throws SAXParseException { try { task = helperImpl . project . createTask ( tag ) ; } catch ( BuildException e ) { } if ( ( task ) == null ) { task = new UnknownElement ( tag ) ; task . setProject ( helperImpl . project ) ; task . setTaskName ( tag ) ; } task . setLocation ( new Location ( helperImpl . locator ) ) ; helperImpl . configureId ( task , attrs ) ; task . setOwningTarget ( target ) ; container . addTask ( task ) ; task . init ( ) ; wrapper = task . getRuntimeConfigurableWrapper ( ) ; wrapper . setAttributes ( attrs ) ; if ( ( parentWrapper ) != null ) { parentWrapper . addChild ( wrapper ) ; } } public void characters ( char [ ] buf , int start , int count ) { } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { } } static class NestedElementHandler extends ProjectHelperImpl . AbstractHandler { private Object parent ; private Object child ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable childWrapper = null ; private Target target ; public NestedElementHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , Object parent , RuntimeConfigurable parentWrapper , Target target ) { } public void init ( String propType , AttributeList attrs ) throws SAXParseException { Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( helperImpl . project , parentClass ) ; try { <START_BUG> String elementName = propType . toLowerCase ( Locale . US ) ; <END_BUG> if ( ( parent ) instanceof UnknownElement ) { UnknownElement uc = new UnknownElement ( elementName ) ; uc . setProject ( helperImpl . project ) ; ( ( UnknownElement ) ( parent ) ) . addChild ( uc ) ; child = uc ; } else { child = ih . createElement ( helperImpl . project , parent , elementName ) ; } helperImpl . configureId ( child , attrs ) ; childWrapper = new RuntimeConfigurable ( child , propType ) ; childWrapper . setAttributes ( attrs ) ; parentWrapper . addChild ( childWrapper ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void characters ( char [ ] buf , int start , int count ) { } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { } } static class DataTypeHandler extends ProjectHelperImpl . AbstractHandler { private Target target ; private Object element ; private RuntimeConfigurable wrapper = null ; public DataTypeHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , Target target ) { } public void init ( String propType , AttributeList attrs ) throws SAXParseException { try { element = helperImpl . project . createDataType ( propType ) ; if ( ( element ) == null ) { throw new BuildException ( ( "Unknown<seq2seq4repair_space>data<seq2seq4repair_space>type<seq2seq4repair_space>" + propType ) ) ; } wrapper = new RuntimeConfigurable ( element , propType ) ; wrapper . setAttributes ( attrs ) ; target . addDataType ( wrapper ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void characters ( char [ ] buf , int start , int count ) { } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { } }
public class HashCodeBuilder implements Builder < Integer > { private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) ; static Set < IDKey > getRegistry ( ) { } static boolean isRegistered ( Object value ) { } private static void reflectionAppend ( Object object , Class < ? > clazz , HashCodeBuilder builder , boolean useTransients , String [ ] excludeFields ) { } public static int reflectionHashCode ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber , Object object ) { } public static int reflectionHashCode ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber , Object object , boolean testTransients ) { } public static < T > int reflectionHashCode ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber , T object , boolean testTransients , Class < ? super T > reflectUpToClass ) { } public static < T > int reflectionHashCode ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber , T object , boolean testTransients , Class < ? super T > reflectUpToClass , String [ ] excludeFields ) { } public static int reflectionHashCode ( Object object ) { } public static int reflectionHashCode ( Object object , boolean testTransients ) { } public static int reflectionHashCode ( Object object , Collection < String > excludeFields ) { } public static int reflectionHashCode ( Object object , String [ ] excludeFields ) { } static void register ( Object value ) { } static void unregister ( Object value ) { } private final int iConstant ; private int iTotal = 0 ; public HashCodeBuilder ( ) { } public HashCodeBuilder ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber ) { } public HashCodeBuilder append ( boolean value ) { } public HashCodeBuilder append ( boolean [ ] array ) { } public HashCodeBuilder append ( byte value ) { } public HashCodeBuilder append ( byte [ ] array ) { } public HashCodeBuilder append ( char value ) { } public HashCodeBuilder append ( char [ ] array ) { } public HashCodeBuilder append ( double value ) { } public HashCodeBuilder append ( double [ ] array ) { } public HashCodeBuilder append ( float value ) { } public HashCodeBuilder append ( float [ ] array ) { } public HashCodeBuilder append ( int value ) { } public HashCodeBuilder append ( int [ ] array ) { } public HashCodeBuilder append ( long value ) { } public HashCodeBuilder append ( long [ ] array ) { } public HashCodeBuilder append ( Object object ) { } public HashCodeBuilder append ( Object [ ] array ) { } public HashCodeBuilder append ( short value ) { } public HashCodeBuilder append ( short [ ] array ) { } public HashCodeBuilder appendSuper ( int superHashCode ) { } public int toHashCode ( ) { } public Integer build ( ) { <START_BUG> return toHashCode ( ) ; <END_BUG> } @ Override public int hashCode ( ) { } }
public class ManagedBeanDependencyProcessor implements DeploymentUnitProcessor { private static final DotName MANAGED_BEAN_ANNOTATION_NAME = DotName . createSimple ( ManagedBean . class . getName ( ) ) ; private static final ModuleIdentifier JAVASSIST_ID = ModuleIdentifier . create ( "org.javassist" ) ; private static ModuleIdentifier JAVAEE_API_ID = ModuleIdentifier . create ( "javaee.api" ) ; private static ModuleIdentifier JBOSS_LOGGING_ID = ModuleIdentifier . create ( "org.jboss.logging" ) ; public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final Index index = phaseContext . getAttachment ( ANNOTATION_INDEX ) ; if ( index == null ) { return ; } <START_BUG> if ( ( index . getAnnotationTargets ( ManagedBeanDependencyProcessor . MANAGED_BEAN_ANNOTATION_NAME ) ) == null ) { <END_BUG> return ; } phaseContext . addToAttachmentList ( MODULE_DEPENDENCIES , new org . jboss . as . deployment . module . ModuleDependency ( ManagedBeanDependencyProcessor . JAVAEE_API_ID , false , false ) ) ; phaseContext . addToAttachmentList ( MODULE_DEPENDENCIES , new org . jboss . as . deployment . module . ModuleDependency ( ManagedBeanDependencyProcessor . JBOSS_LOGGING_ID , false , false ) ) ; phaseContext . addToAttachmentList ( MODULE_DEPENDENCIES , new org . jboss . as . deployment . module . ModuleDependency ( ManagedBeanDependencyProcessor . JAVASSIST_ID , false , false ) ) ; } public void undeploy ( final DeploymentUnitContext context ) { } }
public class TurtleSpeaker implements ITurtleUpgrade { @ Override public int getUpgradeID ( ) { } @ Override public String getUnlocalisedAdjective ( ) { } @ Override public TurtleUpgradeType getType ( ) { } @ Override public ItemStack getCraftingItem ( ) { } @ Override public IPeripheral createPeripheral ( ITurtleAccess turtle , TurtleSide side ) { <START_BUG> return new com . austinv11 . peripheralsplusplus . tiles . TileEntitySpeaker ( turtle ) ; <END_BUG> } @ Override public TurtleCommandResult useTool ( ITurtleAccess turtle , TurtleSide side , TurtleVerb verb , int direction ) { } @ Override public IIcon getIcon ( ITurtleAccess turtle , TurtleSide side ) { } @ Override public void update ( ITurtleAccess turtle , TurtleSide side ) { } }
public class DeleteResourceElementsOperation extends MultiOperation { protected DeleteResourceElementsOperation ( IJavaElement [ ] elementsToProcess , boolean force ) { } private void deletePackageFragment ( IPackageFragment frag ) throws JavaModelException { IResource res = frag . getResource ( ) ; if ( ( res != null ) && ( ( res . getType ( ) ) == ( IResource . FOLDER ) ) ) { IJavaElement [ ] childrenOfInterest = frag . getChildren ( ) ; if ( ( childrenOfInterest . length ) > 0 ) { IResource [ ] resources = new IResource [ childrenOfInterest . length ] ; for ( int i = 0 ; i < ( childrenOfInterest . length ) ; i ++ ) { <START_BUG> resources [ i ] = childrenOfInterest [ i ] . getCorrespondingResource ( ) ; <END_BUG> } deleteResources ( resources , fForce ) ; } Object [ ] nonJavaResources = frag . getNonJavaResources ( ) ; int actualResourceCount = 0 ; for ( int i = 0 , max = nonJavaResources . length ; i < max ; i ++ ) { if ( ( nonJavaResources [ i ] ) instanceof IResource ) actualResourceCount ++ ; } IResource [ ] actualNonJavaResources = new IResource [ actualResourceCount ] ; for ( int i = 0 , max = nonJavaResources . length , index = 0 ; i < max ; i ++ ) { if ( ( nonJavaResources [ i ] ) instanceof IResource ) actualNonJavaResources [ ( index ++ ) ] = ( ( IResource ) ( nonJavaResources [ i ] ) ) ; } deleteResources ( actualNonJavaResources , fForce ) ; IResource [ ] remainingFiles ; try { remainingFiles = ( ( IFolder ) ( res ) ) . members ( ) ; } catch ( CoreException ce ) { throw new JavaModelException ( ce ) ; } boolean isEmpty = true ; for ( int i = 0 , length = remainingFiles . length ; i < length ; i ++ ) { IResource file = remainingFiles [ i ] ; if ( file instanceof IFile ) { this . deleteResource ( file , ( ( IResource . FORCE ) | ( IResource . KEEP_HISTORY ) ) ) ; } else { isEmpty = false ; } } if ( isEmpty ) { deleteEmptyPackageFragment ( frag , false , frag . getParent ( ) . getResource ( ) ) ; } } } protected String getMainTaskName ( ) { } protected void processElement ( IJavaElement element ) throws JavaModelException { } protected void verify ( IJavaElement element ) throws JavaModelException { } }
public class PackageTest extends JMeterTestCase { private static final transient Logger log = LoggingManager . getLoggerForClass ( ) ; public PackageTest ( String arg0 ) { } private static CSVRead setParams ( String p1 , String p2 ) throws Exception { } private static StringFromFile SFFParams ( String p1 , String p2 , String p3 , String p4 ) throws Exception { } private static SplitFunction SplitParams ( String p1 , String p2 , String p3 ) throws Exception { } private static BeanShell BSHFParams ( String p1 , String p2 , String p3 ) throws Exception { } private static Collection MakeParams ( String p1 , String p2 , String p3 ) { } public static Test suite ( ) throws Exception { <START_BUG> TestSuite allsuites = new TestSuite ( ) ; <END_BUG> TestSuite bsh = new TestSuite ( "BeanShell" ) ; bsh . addTest ( new PackageTest ( "BSH1" ) ) ; allsuites . addTest ( bsh ) ; TestSuite suite = new TestSuite ( "SingleThreaded" ) ; suite . addTest ( new PackageTest ( "CSVParams" ) ) ; suite . addTest ( new PackageTest ( "CSVNoFile" ) ) ; suite . addTest ( new PackageTest ( "CSVSetup" ) ) ; suite . addTest ( new PackageTest ( "CSVRun" ) ) ; suite . addTest ( new PackageTest ( "CSValias" ) ) ; suite . addTest ( new PackageTest ( "CSVBlankLine" ) ) ; allsuites . addTest ( suite ) ; suite . addTest ( new PackageTest ( "CSVSetup" ) ) ; TestSuite par = new ActiveTestSuite ( "Parallel" ) ; par . addTest ( new PackageTest ( "CSVThread1" ) ) ; par . addTest ( new PackageTest ( "CSVThread2" ) ) ; allsuites . addTest ( par ) ; TestSuite sff = new TestSuite ( "StringFromFile" ) ; sff . addTest ( new PackageTest ( "SFFTest1" ) ) ; sff . addTest ( new PackageTest ( "SFFTest2" ) ) ; sff . addTest ( new PackageTest ( "SFFTest3" ) ) ; sff . addTest ( new PackageTest ( "SFFTest4" ) ) ; sff . addTest ( new PackageTest ( "SFFTest5" ) ) ; allsuites . addTest ( sff ) ; TestSuite split = new TestSuite ( "SplitFunction" ) ; split . addTest ( new PackageTest ( "SplitTest1" ) ) ; allsuites . addTest ( split ) ; TestSuite xpath = new TestSuite ( "XPath" ) ; xpath . addTest ( new PackageTest ( "XPathtestColumns" ) ) ; xpath . addTest ( new PackageTest ( "XPathtestDefault" ) ) ; xpath . addTest ( new PackageTest ( "XPathtestNull" ) ) ; xpath . addTest ( new PackageTest ( "XPathtestrowNum" ) ) ; xpath . addTest ( new PackageTest ( "XPathEmpty" ) ) ; xpath . addTest ( new PackageTest ( "XPathFile1" ) ) ; xpath . addTest ( new PackageTest ( "XPathFile2" ) ) ; xpath . addTest ( new PackageTest ( "XPathNoFile" ) ) ; allsuites . addTest ( xpath ) ; TestSuite random = new TestSuite ( "Random" ) ; random . addTest ( new PackageTest ( "RandomTest1" ) ) ; allsuites . addTest ( random ) ; allsuites . addTest ( new PackageTest ( "XPathSetup1" ) ) ; TestSuite par2 = new ActiveTestSuite ( "ParallelXPath1" ) ; par2 . addTest ( new PackageTest ( "XPathThread1" ) ) ; par2 . addTest ( new PackageTest ( "XPathThread2" ) ) ; allsuites . addTest ( par2 ) ; allsuites . addTest ( new PackageTest ( "XPathSetup2" ) ) ; TestSuite par3 = new ActiveTestSuite ( "ParallelXPath2" ) ; par3 . addTest ( new PackageTest ( "XPathThread1" ) ) ; par3 . addTest ( new PackageTest ( "XPathThread2" ) ) ; allsuites . addTest ( par3 ) ; return allsuites ; } private JMeterContext jmctx = null ; private JMeterVariables vars = null ; public void setUp ( ) { } public void BSH1 ( ) throws Exception { } public void SplitTest1 ( ) throws Exception { } public void SFFTest1 ( ) throws Exception { } public void SFFTest2 ( ) throws Exception { } public void SFFTest3 ( ) throws Exception { } public void SFFTest4 ( ) throws Exception { } public void SFFTest5 ( ) throws Exception { } private static CSVRead cr1 ; private static CSVRead cr2 ; private static CSVRead cr3 ; private static CSVRead cr4 ; private static CSVRead cr5 ; private static CSVRead cr6 ; private static class Baton { void pass ( ) { } void done ( ) { } } private static PackageTest . Baton baton = new PackageTest . Baton ( ) ; public void CSVThread1 ( ) throws Exception { } public void CSVThread2 ( ) throws Exception { } public void CSVRun ( ) throws Exception { } public void CSVParams ( ) throws Exception { } public void CSVSetup ( ) throws Exception { } public void CSValias ( ) throws Exception { } public void CSVNoFile ( ) throws Exception { } public void CSVBlankLine ( ) throws Exception { } public void XPathtestNull ( ) throws Exception { } public void XPathtestrowNum ( ) throws Exception { } public void XPathtestColumns ( ) throws Exception { } public void XPathtestDefault ( ) throws Exception { } public void XPathEmpty ( ) throws Exception { } public void XPathNoFile ( ) throws Exception { } public void XPathFile1 ( ) throws Exception { } public void XPathFile2 ( ) throws Exception { } private static XPath sxp1 ; private static XPath sxp2 ; public void XPathSetup1 ( ) throws Exception { } public void XPathSetup2 ( ) throws Exception { } public void XPathThread1 ( ) throws Exception { } public void XPathThread2 ( ) throws Exception { } private XPath setupXPath ( String file , String expr ) throws Exception { } public void RandomTest1 ( ) throws Exception { } }
public class Doorman { private HttpServer httpServer ; private static ProcessPool processPool ; public Doorman ( ProcessPool processPool , int port ) throws IOException { } private void createContextsAndSetExecutor ( HttpServer server ) { RequestHandler requestHandler = new RequestHandler ( ) ; server . createContext ( "/login" , requestHandler ) ; server . createContext ( "/experiment" , requestHandler ) ; server . createContext ( "/annotation" , requestHandler ) ; server . createContext ( "/annotation/field" , requestHandler ) ; server . createContext ( "/annotation/value" , requestHandler ) ; server . createContext ( "/file" , requestHandler ) ; server . createContext ( "/search/" , requestHandler ) ; server . createContext ( "/user" , requestHandler ) ; server . createContext ( "/process" , requestHandler ) ; <START_BUG> server . createContext ( "/process/dummy" ) ; <END_BUG> server . createContext ( "/process/rawtoprofile" , requestHandler ) ; server . createContext ( "/process" , requestHandler ) ; server . createContext ( "/sysadm" , requestHandler ) ; server . createContext ( "/sysadm/annpriv" , requestHandler ) ; server . createContext ( "/genomeRelease" , requestHandler ) ; server . createContext ( "/genomeRelease/" , requestHandler ) ; server . createContext ( "/token" , requestHandler ) ; server . createContext ( "/upload" , requestHandler ) ; server . createContext ( "/download" , requestHandler ) ; server . setExecutor ( new Executor ( ) { @ Override public void execute ( Runnable command ) { try { new Thread ( command ) . start ( ) ; } catch ( Exception e ) { System . err . println ( ( "ERROR<seq2seq4repair_space>when<seq2seq4repair_space>creating<seq2seq4repair_space>new<seq2seq4repair_space>Executor." + ( e . getMessage ( ) ) ) ) ; ErrorLogger . log ( "SERVER" , ( ( "ERROR<seq2seq4repair_space>when<seq2seq4repair_space>creating<seq2seq4repair_space>" + "new<seq2seq4repair_space>Executor." ) + ( e . getMessage ( ) ) ) ) ; } } } ) ; } public void start ( ) { } public static ProcessPool getProcessPool ( ) { } }
public abstract class RequestCycle { private static final ThreadLocal current = new ThreadLocal ( ) ; private static final int DETACH_REQUEST = 6 ; private static final int DONE = 7 ; private static final int HANDLE_EXCEPTION = 5 ; private static final Logger log = LoggerFactory . getLogger ( RequestCycle . class ) ; private static final int NOT_STARTED = 0 ; private static final int PREPARE_REQUEST = 1 ; private static final int PROCESS_EVENTS = 3 ; private static final int RESOLVE_TARGET = 2 ; private static final int RESPOND = 4 ; public static RequestCycle get ( ) { } protected static void set ( RequestCycle cycle ) { } private boolean automaticallyClearFeedbackMessages = true ; private int currentStep = RequestCycle . NOT_STARTED ; private final Response originalResponse ; private boolean redirect ; private final transient ArrayListStack requestTargets = new ArrayListStack ( 3 ) ; private PageParameters pageParameters ; private Session session ; private final long startTime = System . currentTimeMillis ( ) ; protected final Application application ; protected final IRequestCycleProcessor processor ; protected Request request ; protected Response response ; protected RequestCycle ( final Application application , final Request request , final Response response ) { } public final Application getApplication ( ) { } public final ClientInfo getClientInfo ( ) { } public final Response getOriginalResponse ( ) { } public final PageParameters getPageParameters ( ) { } public abstract IRequestCycleProcessor getProcessor ( ) { } public final boolean getRedirect ( ) { } public final Request getRequest ( ) { } public final IRequestTarget getRequestTarget ( ) { } public final Response getResponse ( ) { } public final Page getResponsePage ( ) { } public final Class getResponsePageClass ( ) { } public final Session getSession ( ) { } public final long getStartTime ( ) { } public boolean isRedirect ( ) { } public Page onRuntimeException ( Page page , RuntimeException e ) { } public abstract void redirectTo ( final Page page ) { } public final void request ( ) { } public final void request ( final Component component ) { } public final void request ( IRequestTarget target ) { } public void setAutomaticallyClearFeedbackMessages ( boolean automaticallyClearFeedbackMessages ) { } public final void setRedirect ( final boolean redirect ) { } public final void setRequest ( Request request ) { } public final void setRequestTarget ( IRequestTarget requestTarget ) { } public final Response setResponse ( final Response response ) { } public final void setResponsePage ( final Class pageClass ) { } public final void setResponsePage ( final Class pageClass , final PageParameters pageParameters ) { } public final void setResponsePage ( final Page page ) { } public String toString ( ) { } public final CharSequence urlFor ( final Class pageClass , final PageParameters parameters ) { } public final CharSequence urlFor ( final Component component , final IBehavior behaviour , final RequestListenerInterface listener ) { } public final CharSequence urlFor ( final Component component , final RequestListenerInterface listener ) { } public final CharSequence urlFor ( final IPageMap pageMap , final Class pageClass , final PageParameters parameters ) { } public final CharSequence urlFor ( final IRequestTarget requestTarget ) { } public final CharSequence urlFor ( final Page page ) { } public final CharSequence urlFor ( final ResourceReference resourceReference ) { } public final CharSequence urlFor ( final ResourceReference resourceReference , ValueMap parameters ) { } private void checkReuse ( ) { } private void detach ( ) { } private void prepare ( ) { } private final void processEventsAndRespond ( ) { } private final void respond ( ) { } private final IRequestCycleProcessor safeGetRequestProcessor ( ) { } private boolean sessionExists ( ) { } private final void step ( ) { } private final void steps ( ) { try { IRequestCycleProcessor processor = safeGetRequestProcessor ( ) ; <START_BUG> final int maxSteps = Short . MAX_VALUE ; <END_BUG> for ( int totalSteps = 0 ; ( currentStep ) < ( RequestCycle . DONE ) ; totalSteps ++ ) { if ( totalSteps >= maxSteps ) { throw new IllegalStateException ( ( ( "Request<seq2seq4repair_space>processing<seq2seq4repair_space>executed<seq2seq4repair_space>" + maxSteps ) + "<seq2seq4repair_space>steps,<seq2seq4repair_space>which<seq2seq4repair_space>means<seq2seq4repair_space>it<seq2seq4repair_space>is<seq2seq4repair_space>probably<seq2seq4repair_space>in<seq2seq4repair_space>an<seq2seq4repair_space>infinite<seq2seq4repair_space>loop." ) ) ; } try { step ( ) ; ( currentStep ) ++ ; } catch ( AbstractRestartResponseException e ) { currentStep = RequestCycle . RESPOND ; } } } finally { currentStep = RequestCycle . DETACH_REQUEST ; detach ( ) ; currentStep = RequestCycle . DONE ; } } private final void threadDetach ( ) { } final void setPageParameters ( PageParameters parameters ) { } protected void logRuntimeException ( RuntimeException e ) { } protected abstract ClientInfo newClientInfo ( ) { } protected void onBeginRequest ( ) { } protected void onEndRequest ( ) { } }
public class Map { MapNode [ ] [ ] map ; ArrayList < PaintRectNode > toPaint ; private int MAP_WIDTH ; private int MAP_HEIGHT ; public Point player_starting_coords ; ArrayList < Point > monster_coords ; public ArrayList < Monster > mobs_in_map ; public boolean bonus = false ; public int next_map_index ; public int getMaxMapWidth ( ) { } public int getMaxMapHeight ( ) { } private void build_toPaint ( ) { } Map ( String filename , int next_map_index ) { } void fromBitmap ( String filename ) { } int bytesToInt ( int offset , int byteCount , byte [ ] bytes ) { <START_BUG> ByteBuffer bb = ByteBuffer . allocate ( a ) ; <END_BUG> bb . order ( ByteOrder . LITTLE_ENDIAN ) ; for ( int i = 0 ; ( i < byteCount ) && ( i < ( bytes . length ) ) ; i ++ ) { bb . put ( bytes [ ( i + offset ) ] ) ; } bb . flip ( ) ; return bb . getInt ( ) ; } }
public class SystemMenuSizeFastView extends ContributionItem { private FastViewPane fastViewPane ; public SystemMenuSizeFastView ( FastViewPane fastViewPane ) { } public void dispose ( ) { } public void fill ( Menu menu , int index ) { <START_BUG> MenuItem item = new MenuItem ( menu , SWT . NONE ) ; <END_BUG> item . setText ( WorkbenchMessages . getString ( "PartPane.size" ) ) ; item . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { fastViewPane . moveSash ( ) ; } } ) ; item . setEnabled ( ( ( fastViewPane . getCurrentPane ( ) ) != null ) ) ; } public boolean isDynamic ( ) { } }
public class FriendsSubController extends SplitPane implements Initializable { private MainController application ; @ FXML private Accordion groupsAccordion ; @ FXML private Button btnAddFriend ; @ FXML private HBox boxAddFriend ; @ FXML private TextField friendName ; private Map < String , ObservableList < FriendsSubController . UserHBoxCell > > groups ; private class UserHBoxCell extends HBox { private User user ; private Label label ; private ImageView icon ; private static final String ON_PATH = "IHM/resources/online_icon.png" ; private static final String OFF_PATH = "IHM/resources/offline_icon.png" ; public UserHBoxCell ( final User vUser , final boolean status ) { } public void switchOn ( ) { } public void switchOff ( ) { } public User getUser ( ) { } } public FriendsSubController ( ) { } @ Override public void initialize ( final URL url , final ResourceBundle resourceBundle ) { } public void build ( ) { } public void addGroup ( final Group group ) { } public void addGroups ( final List < Group > groupsParam ) { } public void addUserInGroup ( final User user , final String groupName ) { } public void addUsersInGroup ( final List < User > users , final String groupName ) { } private TitledPane createNewGroup ( final String groupName ) { } public void addFriend ( ) { } public void setApp ( final MainController app ) { } public void connectUser ( final User user ) { } public void disconnectUser ( final User user ) { } public void receiveFriendResponse ( final User sender , final boolean response ) { } public void receiveFriendRequest ( final User sender ) { } private Group getFriendGroup ( ) { } private Group getDefaultGroup ( ) { } private FriendsSubController . UserHBoxCell lookForUser ( final UUID userId ) { } private boolean isMyFriend ( User user ) { List < User > users = getFriendGroup ( ) . getUsers ( ) ; for ( User u : users ) { <START_BUG> if ( u . getUid ( ) . equals ( application . currentUser ( ) . getUid ( ) ) ) { <END_BUG> return true ; } } return false ; } private FriendsSubController . UserHBoxCell lookForUser ( final String login ) { } private String removeUserFromGroup ( final User user ) { } private void moveUserToGroup ( final User user , final String groupName ) { } private void reloadUser ( final User user ) { } }
public class TestExternalValues extends SingleEMFTestCase { public void setUp ( ) { <START_BUG> super . setUp ( CLEAR_TABLES , EntityA . class ) ; <END_BUG> } public void testExternalValues ( ) { } public void testUnrecognizedExternalValue ( ) { } }
public class NavBar extends Fragment implements View . OnClickListener { private LinearLayout mRestore ; private LinearLayout mSave ; private LinearLayout mEdit ; private boolean mEditMode ; private Activity mActivity ; private static final Intent mIntent = new Intent ( "android.intent.action.NAVBAR_EDIT" ) ; @ Override public void onAttach ( Activity activity ) { } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { } @ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { } @ Override public void onDetach ( ) { } @ Override public void onPause ( ) { } @ Override public void onClick ( View v ) { if ( v == ( mEdit ) ) { mEditMode = ! ( mEditMode ) ; toggleEditMode ( mEditMode , false ) ; } else if ( v == ( mSave ) ) { mEditMode = ! ( mEditMode ) ; toggleEditMode ( mEditMode , true ) ; } else if ( v == ( mRestore ) ) { <START_BUG> new android . app . AlertDialog . Builder ( mActivity ) . setTitle ( lockscreen_target_reset_title ) . setIcon ( ic_navbar_restore ) . setMessage ( navigation_bar_reset_message ) . setPositiveButton ( ok , new DialogInterface . OnClickListener ( ) { <END_BUG> public void onClick ( DialogInterface dialog , int id ) { if ( mEditMode ) { toggleEditMode ( false , false ) ; } System . putString ( getActivity ( ) . getContentResolver ( ) , NAV_BUTTONS , null ) ; toggleEditMode ( true , false ) ; toggleEditMode ( false , false ) ; mEditMode = false ; } } ) . setNegativeButton ( cancel , null ) . create ( ) . show ( ) ; } } private void toggleEditMode ( boolean on , boolean save ) { } private void toggleEditSaveViews ( boolean on ) { } }
public class PropertyColumn extends AbstractColumn { private static final long serialVersionUID = 1L ; private final String propertyExpression ; public PropertyColumn ( IModel displayModel , String sortProperty , String propertyExpression ) { } public PropertyColumn ( IModel displayModel , String propertyExpressions ) { } public void populateItem ( Item item , String componentId , IModel model ) { <START_BUG> item . add ( new wicket . markup . html . basic . Label ( item , componentId , createLabelModel ( model ) ) ) ; <END_BUG> } protected IModel createLabelModel ( IModel embeddedModel ) { } public String getPropertyExpression ( ) { } }
final class SortedBytesMergeUtils { private SortedBytesMergeUtils ( ) { } static SortedBytesMergeUtils . MergeContext init ( ValueType type , IndexDocValues [ ] docValues , Comparator < BytesRef > comp , MergeState mergeState ) { } public static final class MergeContext { private final Comparator < BytesRef > comp ; private final BytesRef missingValue = new BytesRef ( ) ; final int sizePerValues ; final ValueType type ; final int [ ] docToEntry ; long [ ] offsets ; public MergeContext ( Comparator < BytesRef > comp , MergeState mergeState , int size , ValueType type ) { } } static List < SortedBytesMergeUtils . SortedSourceSlice > buildSlices ( MergeState mergeState , IndexDocValues [ ] docValues , SortedBytesMergeUtils . MergeContext ctx ) throws IOException { } private static void createOrdMapping ( MergeState mergeState , SortedBytesMergeUtils . SortedSourceSlice currentSlice ) { } static int mergeRecords ( SortedBytesMergeUtils . MergeContext ctx , IndexOutput datOut , List < SortedBytesMergeUtils . SortedSourceSlice > slices ) throws IOException { } private static final class RecordMerger { private final SortedBytesMergeUtils . MergeQueue queue ; private final SortedBytesMergeUtils . SortedSourceSlice [ ] top ; private int numTop ; BytesRef current ; int currentOrd = - 1 ; RecordMerger ( SortedBytesMergeUtils . MergeQueue queue , SortedBytesMergeUtils . SortedSourceSlice [ ] top ) { } private void pullTop ( ) { } private void pushTop ( ) throws IOException { } } static class SortedSourceSlice { final SortedSource source ; final int readerIdx ; final int [ ] docIDToRelativeOrd ; final int [ ] ordMapping ; final int docToOrdStart ; final int docToOrdEnd ; BytesRef current = new BytesRef ( ) ; int relativeOrd = - 1 ; SortedSourceSlice ( int readerIdx , SortedSource source , MergeState state , int [ ] docToOrd ) { } private static int numDocs ( MergeState state , int readerIndex ) { } BytesRef next ( ) { } void writeOrds ( PackedInts . Writer writer ) throws IOException { } } private static final class MissingValueSource extends SortedSource { private BytesRef missingValue ; public MissingValueSource ( SortedBytesMergeUtils . MergeContext ctx ) { } @ Override public int ord ( int docID ) { } @ Override public BytesRef getByOrd ( int ord , BytesRef bytesRef ) { <START_BUG> bytesRef . copy ( missingValue ) ; <END_BUG> return bytesRef ; } @ Override public Reader getDocToOrd ( ) { } @ Override public int getValueCount ( ) { } } private static final class MergeQueue extends PriorityQueue < SortedBytesMergeUtils . SortedSourceSlice > { final Comparator < BytesRef > comp ; public MergeQueue ( int maxSize , Comparator < BytesRef > comp ) { } @ Override protected boolean lessThan ( SortedBytesMergeUtils . SortedSourceSlice a , SortedBytesMergeUtils . SortedSourceSlice b ) { } } }
public final class GC extends Resource { public int handle ; Drawable drawable ; GCData data ; static final int FOREGROUND = 1 << 0 ; static final int BACKGROUND = 1 << 1 ; static final int FONT = 1 << 2 ; static final int LINE_STYLE = 1 << 3 ; static final int LINE_WIDTH = 1 << 4 ; static final int LINE_CAP = 1 << 5 ; static final int LINE_JOIN = 1 << 6 ; static final int ALPHA = 1 << 7 ; static final int CLIPPING = 1 << 8 ; static final int TRANSFORM = 1 << 9 ; static final int DRAW = ( ( ( ( ( ( ( GC . FOREGROUND ) | ( GC . LINE_STYLE ) ) | ( GC . LINE_WIDTH ) ) | ( GC . LINE_CAP ) ) | ( GC . LINE_JOIN ) ) | ( GC . ALPHA ) ) | ( GC . CLIPPING ) ) | ( GC . TRANSFORM ) ; static final int FILL = ( ( ( GC . BACKGROUND ) | ( GC . ALPHA ) ) | ( GC . CLIPPING ) ) | ( GC . TRANSFORM ) ; static final int IMAGE = ( ( GC . ALPHA ) | ( GC . CLIPPING ) ) | ( GC . TRANSFORM ) ; static final double [ ] LINE_DOT_ZERO = new double [ ] { 3 , 3 } ; static final double [ ] LINE_DASH_ZERO = new double [ ] { 18 , 6 } ; static final double [ ] LINE_DASHDOT_ZERO = new double [ ] { 9 , 6 , 3 , 6 } ; static final double [ ] LINE_DASHDOTDOT_ZERO = new double [ ] { 9 , 3 , 3 , 3 , 3 , 3 } ; GC ( ) { } public GC ( Drawable drawable ) { } public GC ( Drawable drawable , int style ) { } static int checkStyle ( int style ) { } void checkGC ( int mask ) { } public void copyArea ( Image image , int x , int y ) { } public void copyArea ( int srcX , int srcY , int width , int height , int destX , int destY ) { } public void copyArea ( int srcX , int srcY , int width , int height , int destX , int destY , boolean paint ) { } public void dispose ( ) { if ( ( handle ) == 0 ) return ; if ( data . device . isDisposed ( ) ) return ; int brush = data . brush ; if ( brush != 0 ) OS . GCHandle_Free ( brush ) ; data . brush = 0 ; <START_BUG> int pen = data . brush ; <END_BUG> if ( pen != 0 ) OS . GCHandle_Free ( pen ) ; data . pen = 0 ; int clip = data . clip ; if ( clip != 0 ) OS . GCHandle_Free ( clip ) ; data . clip = 0 ; int transform = data . transform ; if ( transform != 0 ) OS . GCHandle_Free ( transform ) ; data . transform = 0 ; Image image = data . image ; if ( image != null ) image . memGC = null ; Device device = data . device ; if ( ( drawable ) != null ) drawable . internal_dispose_GC ( handle , data ) ; drawable = null ; handle = 0 ; data . image = null ; if ( device . tracking ) device . dispose_Object ( this ) ; data . device = null ; data = null ; } public void drawArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) { } public void drawFocus ( int x , int y , int width , int height ) { } public void drawImage ( Image image , int x , int y ) { } public void drawImage ( Image image , int srcX , int srcY , int srcWidth , int srcHeight , int destX , int destY , int destWidth , int destHeight ) { } void drawImage ( Image image , int srcX , int srcY , int srcWidth , int srcHeight , int destX , int destY , int destWidth , int destHeight , boolean simple ) { } public void drawLine ( int x1 , int y1 , int x2 , int y2 ) { } public void drawOval ( int x , int y , int width , int height ) { } public void drawPath ( Path path ) { } public void drawPoint ( int x , int y ) { } public void drawPolygon ( int [ ] pointArray ) { } void drawPolyLineSegment ( int [ ] pointArray , boolean closed , boolean stroked ) { } public void drawPolyline ( int [ ] pointArray ) { } public void drawRectangle ( int x , int y , int width , int height ) { } public void drawRectangle ( Rectangle rect ) { } public void drawRoundRectangle ( int x , int y , int width , int height , int arcWidth , int arcHeight ) { } public void drawString ( String string , int x , int y ) { } public void drawString ( String string , int x , int y , boolean isTransparent ) { } public void drawText ( String string , int x , int y ) { } public void drawText ( String string , int x , int y , boolean isTransparent ) { } public void drawText ( String string , int x , int y , int flags ) { } public boolean equals ( Object object ) { }
public class CommandlineJava implements Cloneable { private Commandline vmCommand = new Commandline ( ) ; private Commandline javaCommand = new Commandline ( ) ; private CommandlineJava . SysProperties sysProperties = new CommandlineJava . SysProperties ( ) ; private Path classpath = null ; private String vmVersion ; public static class SysProperties extends Environment implements Cloneable { Properties sys = null ; public String [ ] getVariables ( ) throws BuildException { } public int size ( ) { } public void setSystem ( ) throws BuildException { } public void restoreSystem ( ) throws BuildException { } public Object clone ( ) { } } public CommandlineJava ( ) { } public Argument createArgument ( ) { } public Argument createVmArgument ( ) { } public void addSysproperty ( Environment . Variable sysp ) { } public void setVm ( String vm ) { } public void setVmversion ( String value ) { } public void setClassname ( String classname ) { } public String getClassname ( ) { } public Path createClasspath ( Project p ) { } public String getVmversion ( ) { } public String [ ] getCommandline ( ) { Path fullClasspath = ( ( classpath ) != null ) ? classpath . concatSystemClasspath ( "ignore" ) : null ; int size = ( ( vmCommand . size ( ) ) + ( javaCommand . size ( ) ) ) + ( sysProperties . size ( ) ) ; if ( ( fullClasspath != null ) && ( ( fullClasspath . size ( ) ) > 0 ) ) { size += 2 ; } String [ ] result = new String [ size ] ; System . arraycopy ( vmCommand . getCommandline ( ) , 0 , result , 0 , vmCommand . size ( ) ) ; int pos = vmCommand . size ( ) ; if ( ( sysProperties . size ( ) ) > 0 ) { System . arraycopy ( sysProperties . getVariables ( ) , 0 , result , pos , sysProperties . size ( ) ) ; pos += sysProperties . size ( ) ; } <START_BUG> if ( ( fullClasspath != null ) && ( ( fullClasspath . size ( ) ) > 0 ) ) { <END_BUG> result [ ( pos ++ ) ] = "-classpath" ; result [ ( pos ++ ) ] = fullClasspath . toString ( ) ; } System . arraycopy ( javaCommand . getCommandline ( ) , 0 , result , pos , javaCommand . size ( ) ) ; return result ; } public String toString ( ) { } public int size ( ) { } public Commandline getJavaCommand ( ) { } public Commandline getVmCommand ( ) { } public Path getClasspath ( ) { } public void setSystemProperties ( ) throws BuildException { } public void restoreSystemProperties ( ) throws BuildException { } public CommandlineJava . SysProperties getSystemProperties ( ) { } public Object clone ( ) { } public void clearJavaArgs ( ) { } }
public class ConstructorDeclaration extends AbstractMethodDeclaration { public ExplicitConstructorCall constructorCall ; public static final char [ ] ConstantPoolName = "<init>" . toCharArray ( ) ; public boolean isDefaultConstructor = false ; public ConstructorDeclaration ( CompilationResult compilationResult ) { } public void analyseCode ( ClassScope classScope , InitializationFlowContext initializerFlowContext , FlowInfo flowInfo ) { } public void generateCode ( ClassScope classScope , ClassFile classFile ) { } public void generateSyntheticFieldInitializationsIfNecessary ( MethodScope methodScope , CodeStream codeStream , ReferenceBinding declaringClass ) { } private void internalGenerateCode ( ClassScope classScope , ClassFile classFile ) { classFile . generateMethodInfoHeader ( binding ) ; int methodAttributeOffset = classFile . contentsOffset ; int attributeNumber = classFile . generateMethodInfoAttribute ( binding ) ; if ( ( ! ( binding . isNative ( ) ) ) && ( ! ( binding . isAbstract ( ) ) ) ) { TypeDeclaration declaringType = classScope . referenceContext ; int codeAttributeOffset = classFile . contentsOffset ; classFile . generateCodeAttributeHeader ( ) ; CodeStream codeStream = classFile . codeStream ; codeStream . reset ( this , classFile ) ; ReferenceBinding declaringClass = binding . declaringClass ; int argSlotSize = 1 ; if ( declaringClass . isNestedType ( ) ) { NestedTypeBinding nestedType = ( ( NestedTypeBinding ) ( declaringClass ) ) ; this . scope . extraSyntheticArguments = nestedType . syntheticOuterLocalVariables ( ) ; scope . computeLocalVariablePositions ( ( ( nestedType . enclosingInstancesSlotSize ) + 1 ) , codeStream ) ; argSlotSize += nestedType . enclosingInstancesSlotSize ; argSlotSize += nestedType . outerLocalVariablesSlotSize ; } else { scope . computeLocalVariablePositions ( 1 , codeStream ) ; } if ( ( arguments ) != null ) { for ( int i = 0 , max = arguments . length ; i < max ; i ++ ) { LocalVariableBinding argBinding ; codeStream . addVisibleLocalVariable ( ( argBinding = arguments [ i ] . binding ) ) ; argBinding . recordInitializationStartPC ( 0 ) ; TypeBinding argType ; if ( ( ( argType = argBinding . type ) == ( LongBinding ) ) || ( argType == ( DoubleBinding ) ) ) { argSlotSize += 2 ; } else { argSlotSize ++ ; } } } MethodScope initializerScope = declaringType . initializerScope ; initializerScope . computeLocalVariablePositions ( argSlotSize , codeStream ) ; boolean needFieldInitializations = ( ( constructorCall ) == null ) || ( ( constructorCall . accessMode ) != ( ExplicitConstructorCall . This ) ) ; boolean preInitSyntheticFields = ( scope . environment ( ) . options . targetJDK ) >= ( ClassFileConstants . JDK1_4 ) ; if ( needFieldInitializations && preInitSyntheticFields ) { generateSyntheticFieldInitializationsIfNecessary ( scope , codeStream , declaringClass ) ; } if ( ( constructorCall ) != null ) { constructorCall . generateCode ( scope , codeStream ) ; } if ( needFieldInitializations ) { if ( ! preInitSyntheticFields ) { generateSyntheticFieldInitializationsIfNecessary ( scope , codeStream , declaringClass ) ; } if ( ( declaringType . fields ) != null ) { for ( int i = 0 , max = declaringType . fields . length ; i < max ; i ++ ) { FieldDeclaration fieldDecl ; if ( ! ( ( fieldDecl = declaringType . fields [ i ] ) . isStatic ( ) ) ) { fieldDecl . generateCode ( initializerScope , codeStream ) ; } } } } if ( ( statements ) != null ) { for ( int i = 0 , max = statements . length ; i < max ; i ++ ) { statements [ i ] . generateCode ( scope , codeStream ) ; } } if ( this . needFreeReturn ) { codeStream . return_ ( ) ; } codeStream . exitUserScope ( scope ) ; codeStream . recordPositionsFrom ( 0 , this . bodyEnd ) ; classFile . completeCodeAttribute ( codeAttributeOffset ) ; attributeNumber ++ ; } classFile . completeMethodInfo ( methodAttributeOffset , attributeNumber ) ; if ( ignoreFurtherInvestigation ) { <START_BUG> throw new org . eclipse . jdt . internal . compiler . problem . AbortMethod ( scope . referenceCompilationUnit ( ) . compilationResult ) ; <END_BUG> } } public boolean isConstructor ( ) { } public boolean isDefaultConstructor ( ) { } public boolean isInitializationMethod ( ) { } public boolean isRecursive ( ArrayList visited ) { } public void parseStatements ( Parser parser , CompilationUnitDeclaration unit ) { } public StringBuffer printBody ( int indent , StringBuffer output ) { } public void resolveJavadoc ( ) { } public void resolveStatements ( ) { } public void traverse ( ASTVisitor visitor , ClassScope classScope ) { } }
@ RunWith ( Arquillian . class ) public class PureTestCase extends AbstractMgmtTestBase { public static void setUp ( ) throws Exception { } @ AfterClass public static void tearDown ( ) throws Exception { } @ Deployment public static ResourceAdapterArchive createDeployment ( ) throws Exception { } @ Inject public ServiceContainer serviceContainer ; @ Test public void testRegistryConfiguration ( ) throws Throwable { <START_BUG> ServiceController < ? > controller = serviceContainer . getService ( RA_REPOSISTORY_SERVICE ) ; <END_BUG> assertNotNull ( controller ) ; ResourceAdapterRepository repository = ( ( ResourceAdapterRepository ) ( controller . getValue ( ) ) ) ; assertNotNull ( repository ) ; Set < String > ids = repository . getResourceAdapters ( ) ; assertNotNull ( ids ) ; assertEquals ( 2 , ids . size ( ) ) ; for ( String piId : ids ) { assertNotNull ( piId ) ; System . out . println ( ( "PID:" + piId ) ) ; assertNotNull ( repository . getResourceAdapter ( piId ) ) ; } } @ Test public void testMetadataConfiguration ( ) throws Throwable { } }
final class SubsystemTestDelegate { private final String TEST_NAMESPACE = "urn.org.jboss.test:1.0" ; private final Class < ? > testClass ; private final List < KernelServices > kernelServices = new ArrayList < KernelServices > ( ) ; protected final String mainSubsystemName ; private final Extension mainExtension ; private final Comparator < PathAddress > removeOrderComparator ; private ExtensionRegistry extensionParsingRegistry ; private ModelTestParser testParser ; private boolean addedExtraParsers ; private XMLMapper xmlMapper ; SubsystemTestDelegate ( final Class < ? > testClass , final String mainSubsystemName , final Extension mainExtension , final Comparator < PathAddress > removeOrderComparator ) { } String getMainSubsystemName ( ) { } void initializeParser ( ) throws Exception { } void cleanup ( ) throws Exception { } Extension getMainExtension ( ) { } List < ModelNode > parse ( String subsystemXml ) throws XMLStreamException { } List < ModelNode > parse ( AdditionalParsers additionalParsers , String subsystemXml ) throws XMLStreamException { } String outputModel ( ModelNode model ) throws Exception { } KernelServices installInController ( String subsystemXml ) throws Exception { } KernelServices installInController ( AdditionalInitialization additionalInit , String subsystemXml ) throws Exception { } KernelServices installInController ( List < ModelNode > bootOperations ) throws Exception { } KernelServices installInController ( AdditionalInitialization additionalInit , List < ModelNode > bootOperations ) throws Exception { } KernelServicesBuilder createKernelServicesBuilder ( AdditionalInitialization additionalInit ) { } ProcessType getProcessType ( ) { } void assertRemoveSubsystemResources ( KernelServices kernelServices ) { } void assertRemoveSubsystemResources ( KernelServices kernelServices , Set < PathAddress > ignoredChildAddresses ) { } private void getAllChildAddressesForRemove ( PathAddress address , List < PathAddress > addresses , Resource resource ) { } @ Deprecated void generateLegacySubsystemResourceRegistrationDmr ( ModelTestKernelServices kernelServices , ModelVersion modelVersion ) throws IOException { } ModelNode checkSubsystemModelTransformation ( KernelServices kernelServices , ModelVersion modelVersion ) throws IOException { } private void checkModelAgainstDefinition ( final ModelNode model , ManagementResourceRegistration rr ) { } void addAdditionalParsers ( AdditionalParsers additionalParsers ) { } private ExtensionRegistry cloneExtensionRegistry ( AdditionalInitialization additionalInit ) { } private void validateDescriptionProviders ( AdditionalInitialization additionalInit , ModelTestKernelServices kernelServices ) { ValidationConfiguration arbitraryDescriptors = additionalInit . getModelValidationConfiguration ( ) ; ModelNode address = new ModelNode ( ) ; address . setEmptyList ( ) ; address . add ( "subsystem" , mainSubsystemName ) ; ModelNode op = new ModelNode ( ) ; op . get ( OP ) . set ( "read-resource-description" ) ; op . get ( OP_ADDR ) . set ( address ) ; op . get ( "recursive" ) . set ( true ) ; op . get ( "inherited" ) . set ( false ) ; op . get ( "operations" ) . set ( true ) ; op . get ( "include-aliases" ) . set ( true ) ; ModelNode result = kernelServices . executeOperation ( op ) ; if ( result . hasDefined ( FAILURE_DESCRIPTION ) ) { <START_BUG> throw new RuntimeException ( result . get ( FAILURE_DESCRIPTION ) . asString ( ) ) ; <END_BUG> } ModelNode model = result . get ( RESULT ) ; ModelDescriptionValidator validator = new ModelDescriptionValidator ( address , model , arbitraryDescriptors ) ; List < ModelDescriptionValidator . ValidationFailure > validationMessages = validator . validateResource ( ) ; if ( ( validationMessages . size ( ) ) > 0 ) { final StringBuilder builder = new StringBuilder ( "VALIDATION<seq2seq4repair_space>ERRORS<seq2seq4repair_space>IN<seq2seq4repair_space>MODEL:" ) ; for ( ModelDescriptionValidator . ValidationFailure failure : validationMessages ) { builder . append ( failure ) ; builder . append ( "\n" ) ; } if ( arbitraryDescriptors != null ) { Assert . fail ( ( "Failed<seq2seq4repair_space>due<seq2seq4repair_space>to<seq2seq4repair_space>validation<seq2seq4repair_space>errors<seq2seq4repair_space>in<seq2seq4repair_space>the<seq2seq4repair_space>model.<seq2seq4repair_space>Please<seq2seq4repair_space>fix<seq2seq4repair_space>:-)<seq2seq4repair_space>" + ( builder . toString ( ) ) ) ) ; } } } private class KernelServicesBuilderImpl implements ModelTestBootOperationsBuilder . BootOperationParser , KernelServicesBuilder { private final ModelTestBootOperationsBuilder bootOperationBuilder ; private final AdditionalInitialization additionalInit ; private Map < ModelVersion , SubsystemTestDelegate . LegacyKernelServiceInitializerImpl > legacyControllerInitializers = new HashMap < ModelVersion , SubsystemTestDelegate . LegacyKernelServiceInitializerImpl > ( ) ; public KernelServicesBuilderImpl ( AdditionalInitialization additionalInit ) { } @ Override public KernelServicesBuilder setSubsystemXmlResource ( String resource ) throws IOException , XMLStreamException { } @ Override public KernelServicesBuilder setSubsystemXml ( String subsystemXml ) throws XMLStreamException { } public KernelServicesBuilder setBootOperations ( List < ModelNode > bootOperations ) { } @ Override public KernelServicesBuilder setBootOperations ( ModelNode ... bootOperations ) { } public LegacyKernelServicesInitializer createLegacyKernelServicesBuilder ( AdditionalInitialization additionalInit , ModelVersion modelVersion ) { } public KernelServices build ( ) throws Exception { } @ Override public List < ModelNode > parse ( String subsystemXml ) throws XMLStreamException { } } private class LegacyKernelServiceInitializerImpl implements LegacyKernelServicesInitializer { private final AdditionalInitialization additionalInit ; private String extensionClassName ; private ModelVersion modelVersion ; ChildFirstClassLoaderBuilder classLoaderBuilder = new ChildFirstClassLoaderBuilder ( ) ; public LegacyKernelServiceInitializerImpl ( AdditionalInitialization additionalInit , ModelVersion modelVersion ) { } @ Override public LegacyKernelServicesInitializer setExtensionClassName ( String extensionClassName ) { } @ Override public LegacyKernelServicesInitializer addURL ( URL url ) { } @ Override public LegacyKernelServicesInitializer addSimpleResourceURL ( String resource ) throws MalformedURLException { } @ Override public LegacyKernelServicesInitializer addMavenResourceURL ( String artifactGav ) throws MalformedURLException { } @ Override public SubsystemTestDelegate . LegacyKernelServiceInitializerImpl addParentFirstClassPattern ( String pattern ) { } @ Override public SubsystemTestDelegate . LegacyKernelServiceInitializerImpl addChildFirstClassPattern ( String pattern ) { } private KernelServices install ( List < ModelNode > bootOperations ) throws Exception { } } private final ManagementResourceRegistration MOCK_RESOURCE_REG = new ManagementResourceRegistration ( ) { @ Override public boolean isRuntimeOnly ( ) { } @ Override public boolean isRemote ( ) { } @ Override public OperationEntry getOperationEntry ( PathAddress address , String operationName ) { } @ Override public OperationStepHandler getOperationHandler ( PathAddress address , String operationName ) { } @ Override public DescriptionProvider getOperationDescription ( PathAddress address , String operationName ) { } @ Override public Set < Flag > getOperationFlags ( PathAddress address , String operationName ) { } @ Override public Set < String > getAttributeNames ( PathAddress address ) { } @ Override public AttributeAccess getAttributeAccess ( PathAddress address , String attributeName ) { } @ Override public Set < String > getChildNames ( PathAddress address ) { }
public class PathExtensionContentNegotiationStrategyTests { private NativeWebRequest webRequest ; private MockHttpServletRequest servletRequest ; @ Before public void setup ( ) { } @ Test public void resolveMediaTypesFromMapping ( ) { this . servletRequest . setRequestURI ( "test.html" ) ; PathExtensionContentNegotiationStrategy strategy = new PathExtensionContentNegotiationStrategy ( ) ; List < MediaType > mediaTypes = strategy . resolveMediaTypes ( this . webRequest ) ; assertEquals ( Arrays . asList ( new MediaType ( "text" , "html" ) ) , mediaTypes ) ; <START_BUG> strategy = new PathExtensionContentNegotiationStrategy ( Collections . singletonMap ( "HTML" , "application/xhtml+xml" ) ) ; <END_BUG> mediaTypes = strategy . resolveMediaTypes ( this . webRequest ) ; assertEquals ( Arrays . asList ( new MediaType ( "application" , "xhtml+xml" ) ) , mediaTypes ) ; } @ Test public void resolveMediaTypesFromJaf ( ) { } @ Test public void getMediaTypeFromFilenameNoJaf ( ) { } @ Test public void getMediaTypeFilenameWithContextPath ( ) { } @ Test public void getMediaTypeFilenameWithEncodedURI ( ) { } }
public class StatisticalSampleSender extends AbstractSampleSender implements Serializable { private static final long serialVersionUID = 240L ; private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final int DEFAULT_NUM_SAMPLE_THRESHOLD = 100 ; private static final long DEFAULT_TIME_THRESHOLD = 60000L ; private static final int NUM_SAMPLES_THRESHOLD = JMeterUtils . getPropDefault ( "num_sample_threshold" , StatisticalSampleSender . DEFAULT_NUM_SAMPLE_THRESHOLD ) ; private static final long TIME_THRESHOLD_MS = JMeterUtils . getPropDefault ( "time_threshold" , StatisticalSampleSender . DEFAULT_TIME_THRESHOLD ) ; private static boolean KEY_ON_THREADNAME = JMeterUtils . getPropDefault ( "key_on_threadname" , false ) ; private final int clientConfiguredNumSamplesThreshold = JMeterUtils . getPropDefault ( "num_sample_threshold" , StatisticalSampleSender . DEFAULT_NUM_SAMPLE_THRESHOLD ) ; private final long clientConfiguredTimeThresholdMs = JMeterUtils . getPropDefault ( "time_threshold" , StatisticalSampleSender . DEFAULT_TIME_THRESHOLD ) ; private final boolean clientConfiguredKeyOnThreadName = JMeterUtils . getPropDefault ( "key_on_threadname" , false ) ; private final RemoteSampleListener listener ; private final List < SampleEvent > sampleStore = new ArrayList < SampleEvent > ( ) ; private final Map < String , StatisticalSampleResult > sampleTable = new HashMap < String , StatisticalSampleResult > ( ) ; private volatile transient int numSamplesThreshold ; private volatile transient long timeThresholdMs ; private volatile transient boolean keyOnThreadName ; private transient int sampleCount ; private transient long batchSendTime = - 1 ; @ Deprecated public StatisticalSampleSender ( ) { } StatisticalSampleSender ( RemoteSampleListener listener ) { } @ Override public void testEnded ( String host ) { } @ Override public void sampleOccurred ( SampleEvent e ) { synchronized ( sampleStore ) { String key = StatisticalSampleResult . getKey ( e , keyOnThreadName ) ; StatisticalSampleResult statResult = sampleTable . get ( key ) ; if ( statResult == null ) { <START_BUG> statResult = new StatisticalSampleResult ( e . getResult ( ) , keyOnThreadName ) ; <END_BUG> sampleTable . put ( key , statResult ) ; sampleStore . add ( new SampleEvent ( statResult , e . getThreadGroup ( ) ) ) ; } statResult . add ( e . getResult ( ) ) ; ( sampleCount ) ++ ; boolean sendNow = false ; if ( ( numSamplesThreshold ) != ( - 1 ) ) { if ( ( sampleCount ) >= ( numSamplesThreshold ) ) { sendNow = true ; } } long now = 0 ; if ( ( timeThresholdMs ) != ( - 1 ) ) { now = System . currentTimeMillis ( ) ; if ( ( batchSendTime ) == ( - 1 ) ) { this . batchSendTime = now + ( timeThresholdMs ) ; } if ( ( batchSendTime ) < now ) { sendNow = true ; } } if ( sendNow ) { try { if ( StatisticalSampleSender . log . isDebugEnabled ( ) ) { StatisticalSampleSender . log . debug ( "Firing<seq2seq4repair_space>sample" ) ; } sendBatch ( ) ; if ( ( timeThresholdMs ) != ( - 1 ) ) { this . batchSendTime = now + ( timeThresholdMs ) ; } } catch ( RemoteException err ) { StatisticalSampleSender . log . warn ( "sampleOccurred" , err ) ; } } } } private void sendBatch ( ) throws RemoteException { } private Object readResolve ( ) throws ObjectStreamException { } }
public class SpringMVCViewDecorator extends DefaultDecorator implements Decorator { private View view ; public SpringMVCViewDecorator ( String name , View view ) { } public void render ( Content content , SiteMeshContext context ) { } public void render ( Content content , HttpServletRequest request , HttpServletResponse response , @ SuppressWarnings ( "unused" ) ServletContext servletContext ) { HTMLPage htmlPage = GSPSitemeshPage . content2htmlPage ( content ) ; request . setAttribute ( PAGE , htmlPage ) ; if ( ! ( response . isCommitted ( ) ) ) { boolean dispatched = false ; try { <START_BUG> request . setAttribute ( GSP_SITEMESH_PAGE , new GSPSitemeshPage ( true ) ) ; <END_BUG> request . setAttribute ( ALREADY_APPLIED_KEY , Boolean . TRUE ) ; try { view . render ( Collections . < String , Object > emptyMap ( ) , request , response ) ; dispatched = true ; if ( ! ( response . isCommitted ( ) ) ) { response . getWriter ( ) . flush ( ) ; } } catch ( Exception e ) { cleanRequestAttributes ( request ) ; throw new org . codehaus . groovy . grails . web . pages . exceptions . GroovyPagesException ( ( "Error<seq2seq4repair_space>applying<seq2seq4repair_space>layout<seq2seq4repair_space>:<seq2seq4repair_space>" + ( getName ( ) ) ) , e ) ; } } finally { if ( ! dispatched ) { cleanRequestAttributes ( request ) ; } } } request . removeAttribute ( PAGE ) ; request . removeAttribute ( GSP_SITEMESH_PAGE ) ; } private void cleanRequestAttributes ( HttpServletRequest request ) { } }
public abstract class AbstractTestComparator < T > extends AbstractTestObject { public AbstractTestComparator ( String testName ) { } public abstract List < T > getComparableObjectsOrdered ( ) { } public abstract Comparator < T > makeObject ( ) { } public boolean supportsEmptyCollections ( ) { } public boolean supportsFullCollections ( ) { } public String getCompatibilityVersion ( ) { } protected void reverseObjects ( List < ? > list ) { } protected void randomizeObjects ( List < ? > list ) { } protected void sortObjects ( List < T > list , Comparator < ? super T > comparator ) { } public void testEmptyListSort ( ) { } public void testReverseListSort ( ) { } public void testRandomListSort ( ) { } public void testComparatorIsSerializable ( ) { } public String getCanonicalComparatorName ( Object object ) { <START_BUG> StringBuffer retval = new StringBuffer ( ) ; <END_BUG> retval . append ( "data/test/" ) ; String colName = object . getClass ( ) . getName ( ) ; colName = colName . substring ( ( ( colName . lastIndexOf ( "." ) ) + 1 ) , colName . length ( ) ) ; retval . append ( colName ) ; retval . append ( ".version" ) ; retval . append ( getCompatibilityVersion ( ) ) ; retval . append ( ".obj" ) ; return retval . toString ( ) ; } @ SuppressWarnings ( "unchecked" ) public void testComparatorCompatibility ( ) throws IOException , ClassNotFoundException { } }
public class Voot2Client extends AbstractProvider { private static final Logger LOG = LoggerFactory . getLogger ( GrouperSoapClient . class ) ; public Voot2Client ( Configuration configuration ) { } @ Override public boolean shouldBeQueriedForMemberships ( String schacHomeOrganization ) { } @ Override public boolean shouldBeQueriedForGroup ( String schacHomeOrganization , String groupId ) { <START_BUG> return schacHomeOrganization . equals ( schacHomeOrganization ) ; <END_BUG> } @ Override public List < Group > getGroupMemberships ( String uid ) { } @ Override public Optional < Group > getGroupMembership ( String uid , String groupId ) { } protected List < Group > parseGroups ( String response ) { } protected Optional < Group > parseSingleGroup ( String response ) { } private Group parseGroup ( Map < String , Object > item ) { } }
public class Json2Anchor extends JobConfig implements Tool { private static final class MyMapper extends Mapper < LongWritable , Text , LongWritable , Text > { private JsonParser parser ; private static final LongWritable keyOut = new LongWritable ( ) ; private static final Text valOut = new Text ( ) ; private static final StringBuilder sb = new StringBuilder ( ) ; private static final Pattern HTTP_PATTERN = Pattern . compile ( "http://\\S+?\\s" ) ; @ Override protected void map ( LongWritable key , Text value , Context context ) throws IOException , InterruptedException { } private void extractAnchor ( long pageId , long revisionId , String content , Context context ) throws IOException , InterruptedException { } @ Override protected void setup ( Context context ) throws IOException , InterruptedException { } @ Override protected void cleanup ( Context context ) throws IOException , InterruptedException { } } public static List < Json2Anchor . Link > extractLinks ( String page ) { } public static class Link { private String anchor ; private String target ; private Link ( String anchor , String target ) { } public String getAnchorText ( ) { } public String getTarget ( ) { } public String toString ( ) { } } @ Override public int run ( String [ ] args ) throws Exception { } public static void main ( String [ ] args ) { try { <START_BUG> ToolRunner . run ( new ExtractReferences ( ) , args ) ; <END_BUG> } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
public class RAttributeAttributeGroup extends org . tigris . scarab . om . BaseRAttributeAttributeGroup implements UnsecurePersistent { public void delete ( ScarabUser user ) throws Exception { <START_BUG> ModuleEntity module = getAttributeGroup ( ) . getScarabModule ( ) ; <END_BUG> ScarabSecurity security = SecurityFactory . getInstance ( ) ; if ( security . hasPermission ( ITEM__APPROVE , user , module ) ) { Criteria c = new Criteria ( ) . add ( GROUP_ID , getGroupId ( ) ) . add ( ATTRIBUTE_ID , getAttributeId ( ) ) ; RAttributeAttributeGroupPeer . doDelete ( c ) ; } else { throw new org . tigris . scarab . util . ScarabException ( ScarabConstants . NO_PERMISSION_MESSAGE ) ; } } }
public class WicketMessageResolver implements IComponentResolver { private static final long serialVersionUID = 1L ; public boolean resolve ( final MarkupContainer container , final MarkupStream markupStream , final ComponentTag tag ) { if ( tag instanceof WicketTag ) { WicketTag wtag = ( ( WicketTag ) ( tag ) ) ; if ( ( wtag . isMessageTag ( ) ) && ( ( wtag . getNamespace ( ) ) != null ) ) { String messageKey = wtag . getAttributes ( ) . getString ( "key" ) ; if ( ( messageKey == null ) || ( ( messageKey . trim ( ) . length ( ) ) == 0 ) ) { throw new MarkupException ( "Wrong<seq2seq4repair_space>format<seq2seq4repair_space>of<seq2seq4repair_space><wicket:message<seq2seq4repair_space>key='xxx'>:<seq2seq4repair_space>attribute<seq2seq4repair_space>'key'<seq2seq4repair_space>is<seq2seq4repair_space>missing" ) ; } <START_BUG> final String value = container . getApplication ( ) . getMarkupSettings ( ) . getLocalizer ( ) . getString ( messageKey , container , "" ) ; <END_BUG> final String id = "_message_" + ( container . getPage ( ) . getAutoIndex ( ) ) ; Component component = null ; if ( ( value != null ) && ( ( value . trim ( ) . length ( ) ) > 0 ) ) { component = new WicketMessageResolver . MyLabel ( id , value ) ; } else { component = new WebMarkupContainer ( id ) ; } component . setRenderBodyOnly ( container . getApplication ( ) . getMarkupSettings ( ) . getStripWicketTags ( ) ) ; container . autoAdd ( component ) ; return true ; } } return false ; } public static class MyLabel extends Label { private static final long serialVersionUID = 1L ; public MyLabel ( final String id , final String value ) { } protected void onComponentTag ( ComponentTag tag ) { } } }
public class SendAllMessagesCommand extends FolderCommand { protected SendListManager sendListManager = new SendListManager ( ) ; protected OutboxFolder outboxFolder ; public SendAllMessagesCommand ( FrameController frameController , DefaultCommandReference [ ] references ) { } public void execute ( Worker worker ) throws Exception { FolderCommandReference [ ] r = ( ( FolderCommandReference [ ] ) ( getReferences ( ) ) ) ; outboxFolder = ( ( OutboxFolder ) ( r [ 0 ] . getFolder ( ) ) ) ; Object [ ] uids = outboxFolder . getUids ( worker ) ; for ( int i = 0 ; i < ( uids . length ) ; i ++ ) { <START_BUG> if ( ( outboxFolder . exists ( uids [ i ] ) ) == true ) { <END_BUG> SendableMessage message = ( ( SendableMessage ) ( outboxFolder . getMessage ( uids [ i ] , worker ) ) ) ; sendListManager . add ( message ) ; } } int actAccountUid = - 1 ; Vector sentList = new Vector ( ) ; boolean open = false ; SMTPServer smtpServer = null ; Folder sentFolder = null ; while ( sendListManager . hasMoreMessages ( ) ) { SendableMessage message = sendListManager . getNextMessage ( ) ; if ( ( message . getAccountUid ( ) ) != actAccountUid ) { if ( ( sentList . size ( ) ) != 0 ) { sentList . clear ( ) ; } actAccountUid = message . getAccountUid ( ) ; AccountItem accountItem = MailConfig . getAccountList ( ) . uidGet ( actAccountUid ) ; sentFolder = ( ( Folder ) ( treeModel . getFolder ( Integer . parseInt ( accountItem . getSpecialFoldersItem ( ) . getSent ( ) ) ) ) ) ; smtpServer = new SMTPServer ( accountItem ) ; open = smtpServer . openConnection ( ) ; } if ( open ) { smtpServer . sendMessage ( message ) ; sentList . add ( message . getHeader ( ) . get ( "columba.uid" ) ) ; } } if ( ( sentList . size ( ) ) > 0 ) { moveToSentFolder ( sentList , sentFolder ) ; } } protected void moveToSentFolder ( Vector v , Folder sentFolder ) { } }
@ RunWith ( Arquillian . class ) public class RestEasyIntegrationTestCase { static final String DEPLOYMENT_NAME = "resteasy-osgi-client.war" ; @ ArquillianResource public Deployer deployer ; @ Inject public Bundle bundle ; @ Deployment public static JavaArchive createDeployment ( ) { } @ Deployment ( name = RestEasyIntegrationTestCase . DEPLOYMENT_NAME , managed = false , testable = false ) public static WebArchive endpointWar ( ) { final WebArchive archive = ShrinkWrap . create ( WebArchive . class , RestEasyIntegrationTestCase . DEPLOYMENT_NAME ) ; archive . addClass ( SimpleRestEndpoint . class ) ; <START_BUG> archive . setWebXML ( "osgi/jaxrs/web.xml" ) ; <END_BUG> archive . add ( new Asset ( ) { public InputStream openStream ( ) { ManifestBuilder builder = ManifestBuilder . newInstance ( ) ; builder . addManifestHeader ( "Dependencies" , "org.osgi.core,deployment.jaxrs-osgi-target:0.0.0" ) ; return builder . openStream ( ) ; } } , JarFile . MANIFEST_NAME ) ; return archive ; } @ Test public void testServiceAccess ( ) throws Exception { } private String getHttpResponse ( String message ) throws IOException , ExecutionException , TimeoutException { } public static String formatPossibleIpv6Address ( String address ) { } }
public class TreeView extends JTree { private TreePath selectedPathBeforeDrag ; private TreePath dropTargetPath ; private boolean isInDndMode = false ; private Timer dndAutoExpanderTimer ; public TreeView ( TreeModel model ) { } public final void expand ( AbstractFolder parent ) { <START_BUG> FolderItem item = parent . getFolderItem ( ) ; <END_BUG> XmlElement property = item . getElement ( "property" ) ; if ( property != null ) { String expanded = property . getAttribute ( "expanded" ) ; if ( expanded == null ) { expanded = "true" ; } int row = getRowForPath ( new TreePath ( parent . getPath ( ) ) ) ; if ( expanded . equals ( "true" ) ) { expandRow ( row ) ; } } for ( int i = 0 ; i < ( parent . getChildCount ( ) ) ; i ++ ) { AbstractFolder child = ( ( AbstractFolder ) ( parent . getChildAt ( i ) ) ) ; expand ( child ) ; } } public AbstractFolder getDropTargetFolder ( ) { } void resetDropTargetFolder ( ) { } public AbstractFolder getSelectedNodeBeforeDragAction ( ) { } public boolean isInDndAction ( ) { } private void setUpDndAction ( ) { } private void resetDndAction ( ) { } private class DropHandler extends DropTarget { private boolean canImport ; private Point location ; public void dragOver ( DropTargetDragEvent e ) { } public void dragEnter ( DropTargetDragEvent e ) { } public void dragExit ( DropTargetEvent e ) { } public void drop ( DropTargetDropEvent e ) { } public void dropActionChanged ( DropTargetDragEvent e ) { } } private class TreeLeafActionListener implements ActionListener { private JTree treeParent ; public TreeLeafActionListener ( JTree parent ) { } public void actionPerformed ( ActionEvent e ) { } } }
public class ExampleRunner { public static void main ( String [ ] args ) throws Exception { final ModelControllerClient client = Factory . create ( "localhost" , 9999 ) ; try { final ModelNode domainOp = new ModelNode ( ) ; domainOp . get ( OP ) . set ( READ_RESOURCE_OPERATION ) ; domainOp . get ( OP_ADDR ) . setEmptyList ( ) ; domainOp . get ( RECURSIVE ) . set ( true ) ; domainOp . get ( "proxies" ) . set ( false ) ; ModelNode result = client . execute ( domainOp ) ; if ( ! ( SUCCESS . equals ( result . get ( OUTCOME ) . asString ( ) ) ) ) { throw new org . jboss . as . controller . OperationFailedException ( result . get ( FAILURE_DESCRIPTION ) ) ; } System . out . println ( "--<seq2seq4repair_space>domain<seq2seq4repair_space>configuration" ) ; final ModelNode domainResult = result . get ( RESULT ) . clone ( ) ; System . out . println ( domainResult ) ; System . out . println ( "--" ) ; final ModelNode hostOp = new ModelNode ( ) ; hostOp . get ( OP ) . set ( READ_RESOURCE_OPERATION ) ; hostOp . get ( OP_ADDR ) . setEmptyList ( ) . add ( HOST , "local" ) ; hostOp . get ( RECURSIVE ) . set ( true ) ; hostOp . get ( "proxies" ) . set ( false ) ; result = client . execute ( hostOp ) ; if ( ! ( SUCCESS . equals ( result . get ( OUTCOME ) . asString ( ) ) ) ) { throw new org . jboss . as . controller . OperationFailedException ( result . get ( FAILURE_DESCRIPTION ) ) ; } System . out . println ( "--<seq2seq4repair_space>host<seq2seq4repair_space>configuration" ) ; final ModelNode hostResult = result . get ( RESULT ) . clone ( ) ; <START_BUG> System . out . println ( ) ; <END_BUG> System . out . println ( "--" ) ; } finally { StreamUtils . safeClose ( client ) ; } } }
public class PackedObject extends Packed { public PackedObject ( ) { } public final PackedClass < ? extends PackedObject , ? > type ( ) { } public final < T extends PackedObject > T viewAs ( Class < T > clazz ) { } public final < T extends PackedObject > T copyAs ( Class < T > clazz ) { if ( ! ( clazz . asSubclass ( PackedObject . class ) . isAssignableFrom ( getClass ( ) ) ) ) { throw new ClassCastException ( ( ( "Can<seq2seq4repair_space>only<seq2seq4repair_space>copy<seq2seq4repair_space>the<seq2seq4repair_space>packed<seq2seq4repair_space>object<seq2seq4repair_space>as<seq2seq4repair_space>a<seq2seq4repair_space>" + ( getClass ( ) ) ) + "<seq2seq4repair_space>or<seq2seq4repair_space>it's<seq2seq4repair_space>superclass" ) ) ; } PackedClass < T , ? > type = PackedClass . forClass ( clazz ) ; <START_BUG> return Packed . newView ( type , target , offset , type . getSize ( ) ) ; <END_BUG> } @ Override public String toString ( ) { } private void appendToString ( StringBuilder sb , PackedClass < ? , ? > pc ) { } }
public class CameraActivity extends ActionBarActivity implements SeekBar . OnSeekBarChangeListener { public static final String TAG = CameraActivity . class . getSimpleName ( ) ; public static final int IMAGE_CAPTURE_REQUEST = 100 ; public static final int IMAGE_POST_REQUEST = 200 ; private final String boundary = "---------------------Boundary" ; private final int MIN_HOURS = 6 ; private final int MAX_HOURS = 24 ; private int imageTimer ; private Uri mImageUri ; @ InjectView ( id . imageView ) ImageView mImageView ; @ InjectView ( id . timerTextView ) TextView mTimerTextView ; @ InjectView ( id . seekBar ) SeekBar mSeekBar ; @ InjectView ( id . minHourTextView ) TextView mMinHourTextView ; @ InjectView ( id . maxHourTextView ) TextView mMaxHourTextView ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } private void startCamera ( ) { } @ Override public void onBackPressed ( ) { } private void goBack ( ) { } @ Override public boolean onSupportNavigateUp ( ) { } @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { } @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { } public boolean deleteImage ( ) { } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } private class ImageClass extends AsyncTask < String , String , Integer > { protected Integer doInBackground ( String ... params ) { } } private String generateForSimpleText ( String name , String value ) { } private String generateImageBoilerplateFront ( String filename ) { } private String generateImageBoilerPlateEnd ( ) { } private String getLatitude ( ) { } private String getLongitude ( ) { LocationManager lm = ( ( LocationManager ) ( getSystemService ( LOCATION_SERVICE ) ) ) ; Location location = lm . getLastKnownLocation ( lm . getBestProvider ( new Criteria ( ) , true ) ) ; <START_BUG> return String . valueOf ( location . getLatitude ( ) ) ; <END_BUG> } }
public class Table extends Composite { int modelHandle ; int checkRenderer ; int itemCount ; int columnCount ; int lastIndexOf ; int sortDirection ; int ignoreCell ; TableItem [ ] items ; TableColumn [ ] columns ; TableItem currentItem ; TableColumn sortColumn ; ImageList imageList ; ImageList headerImageList ; boolean firstCustomDraw ; int drawState ; int drawFlags ; GdkColor drawForeground ; boolean ownerDraw ; boolean ignoreSize ; static final int CHECKED_COLUMN = 0 ; static final int GRAYED_COLUMN = 1 ; static final int FOREGROUND_COLUMN = 2 ; static final int BACKGROUND_COLUMN = 3 ; static final int FONT_COLUMN = 4 ; static final int FIRST_COLUMN = ( Table . FONT_COLUMN ) + 1 ; static final int CELL_PIXBUF = 0 ; static final int CELL_TEXT = 1 ; static final int CELL_FOREGROUND = 2 ; static final int CELL_BACKGROUND = 3 ; static final int CELL_FONT = 4 ; static final int CELL_TYPES = ( Table . CELL_FONT ) + 1 ; public Table ( Composite parent , int style ) { } void _addListener ( int eventType , Listener listener ) { } TableItem _getItem ( int index ) { } static int checkStyle ( int style ) { } int cellDataProc ( int tree_column , int cell , int tree_model , int iter , int data ) { } boolean checkData ( TableItem item ) { } protected void checkSubclass ( ) { } public void addSelectionListener ( SelectionListener listener ) { } int calculateWidth ( int column , int iter ) { } public void clear ( int index ) { } public void clear ( int start , int end ) { } public void clear ( int [ ] indices ) { } public void clearAll ( ) { } public Point computeSize ( int wHint , int hHint , boolean changed ) { } void createColumn ( TableColumn column , int index ) { } void createHandle ( int index ) { } void createItem ( TableColumn column , int index ) { } void createItem ( TableItem item , int index ) { if ( ! ( ( 0 <= index ) && ( index <= ( itemCount ) ) ) ) error ( ERROR_INVALID_RANGE ) ; if ( ( itemCount ) == ( items . length ) ) { <START_BUG> int length = ( ( drawCount ) == 0 ) ? ( items . length ) + 4 : Math . max ( 4 , ( ( ( items . length ) * 3 ) / 2 ) ) ; <END_BUG> TableItem [ ] newItems = new TableItem [ length ] ; System . arraycopy ( items , 0 , newItems , 0 , items . length ) ; items = newItems ; } item . handle = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ; if ( ( item . handle ) == 0 ) error ( ERROR_NO_HANDLES ) ; if ( index == ( itemCount ) ) { OS . gtk_list_store_append ( modelHandle , item . handle ) ; } else { OS . gtk_list_store_insert ( modelHandle , item . handle , index ) ; } System . arraycopy ( items , index , items , ( index + 1 ) , ( ( ( itemCount ) ++ ) - index ) ) ; items [ index ] = item ; } void createRenderers ( int columnHandle , int modelIndex , boolean check , int columnStyle ) { } void createWidget ( int index ) { } GdkColor defaultBackground ( ) { } GdkColor defaultForeground ( ) { } void deregister ( ) { } public void deselect ( int index ) { } public void deselect ( int start , int end ) { } public void deselect ( int [ ] indices ) { } public void deselectAll ( ) { } void destroyItem ( TableColumn column ) { } void destroyItem ( TableItem item ) { } boolean dragDetect ( int x , int y , boolean filter , boolean [ ] consume ) { } int eventWindow ( ) { } void fixChildren ( Shell newShell , Shell oldShell , Decorations newDecorations , Decorations oldDecorations , Menu [ ] menus ) { } GdkColor getBackgroundColor ( ) { } public Rectangle getClientArea ( ) { } int getClientWidth ( ) { } public TableColumn getColumn ( int index ) { } public int getColumnCount ( ) { } int [ ] getColumnTypes ( int columnCount ) { } public int [ ] getColumnOrder ( ) { } public TableColumn [ ] getColumns ( ) { } TableItem getFocusItem ( ) { } GdkColor getForegroundColor ( ) { } public int getGridLineWidth ( ) { } public int getHeaderHeight ( ) { } public boolean getHeaderVisible ( ) { } public TableItem getItem ( int index ) { } public TableItem getItem ( Point point ) { } public int getItemCount ( ) { } public int getItemHeight ( ) { } public TableItem [ ] getItems ( ) { } public boolean getLinesVisible ( ) { } int getPixbufRenderer ( int column ) { } public TableItem [ ] getSelection ( ) { } public int getSelectionCount ( ) { } public int getSelectionIndex ( ) { } public int [ ] getSelectionIndices ( ) { } public TableColumn getSortColumn ( ) { } public int getSortDirection ( ) { } int getTextRenderer ( int column ) { } public int getTopIndex ( ) { } int gtk_button_press_event ( int widget , int event ) { } int gtk_button_release_event ( int widget , int event ) { } int gtk_changed ( int widget ) { } int gtk_key_press_event ( int widget , int eventPtr ) { } int gtk_popup_menu ( int widget ) { } int gtk_motion_notify_event ( int widget , int event ) { } int gtk_row_activated ( int tree , int path , int column ) { }
public class ChannelInstanceResourceDefinition extends SimpleResourceDefinition { static PathElement pathElement ( String name ) { } private final boolean runtimeRegistration ; ChannelInstanceResourceDefinition ( String channelName , boolean runtimeRegistration ) { } @ Override public void registerAttributes ( ManagementResourceRegistration registration ) { } public static void addChannelProtocolMetricsRegistrationStep ( OperationContext context , String channelName , String stackName ) { } public static void registerChannelProtocolMetrics ( OperationContext context , String channelName , String stackName ) throws OperationFailedException { if ( stackName == null ) { stackName = ChannelInstanceResourceDefinition . getDefaultStack ( context ) ; } PathAddress address = PathAddress . pathAddress ( PATH ) ; PathAddress stackAddress = address . append ( StackResourceDefinition . pathElement ( stackName ) ) ; ModelNode stack = Tools . readModel ( context . readResourceFromRoot ( stackAddress , true ) ) ; ModelNode transport = stack . get ( TRANSPORT , TRANSPORT_NAME ) . clone ( ) ; <START_BUG> String transportName = transport . get ( TYPE ) . asString ( ) ; <END_BUG> ResourceDefinition transportDefinition = ChannelInstanceResourceDefinition . getProtocolMetricResourceDefinition ( context , channelName , transportName ) ; List < ModelNode > protocolOrdering = stack . get ( PROTOCOLS ) . clone ( ) . asList ( ) ; final List < ResourceDefinition > protocolDefinitions = new ArrayList < ResourceDefinition > ( ) ; for ( ModelNode protocolNameModelNode : protocolOrdering ) { String protocolName = protocolNameModelNode . asString ( ) ; ResourceDefinition protocolDefinition = ChannelInstanceResourceDefinition . getProtocolMetricResourceDefinition ( context , channelName , protocolName ) ; protocolDefinitions . add ( protocolDefinition ) ; } ResourceDefinition relayDefinition = null ; if ( stack . hasDefined ( RELAY ) ) { relayDefinition = ChannelInstanceResourceDefinition . getProtocolMetricResourceDefinition ( context , channelName , "relay.RELAY2" ) ; } ManagementResourceRegistration subsystemRootRegistration = context . getResourceRegistrationForUpdate ( ) ; ManagementResourceRegistration channelRegistration = subsystemRootRegistration . registerSubModel ( new ChannelInstanceResourceDefinition ( channelName , true ) ) ; channelRegistration . registerSubModel ( transportDefinition ) ; for ( ResourceDefinition protocolDefinition : protocolDefinitions ) { channelRegistration . registerSubModel ( protocolDefinition ) ; } if ( stack . hasDefined ( RELAY ) ) { channelRegistration . registerSubModel ( relayDefinition ) ; } } public static void addChannelProtocolMetricsDeregistrationStep ( OperationContext context , String channelName ) { } private static String getDefaultStack ( OperationContext context ) throws OperationFailedException { } private static ResourceDefinition getProtocolMetricResourceDefinition ( OperationContext context , String channelName , String protocolName ) throws OperationFailedException { } private static void addAttributeDefinition ( List < AttributeDefinition > attributes , Map < String , String > map , String protocolName , String name , ModelType type , String description ) { } public static boolean isEquivalentModelTypeAvailable ( Class < ? > type ) { } private static ModelType getEquivalentModelType ( Class < ? > typeClass ) { } private static Field [ ] getProtocolFields ( Class < ? > clazz ) { } public static class ProtocolResources extends ResourceBundle { private static Map < String , String > resources = new HashMap < String , String > ( ) ; public static void addProtocolMapEntries ( Map < String , String > map ) { } @ Override public Object handleGetObject ( String key ) { } @ Override public Enumeration < String > getKeys ( ) { } @ Override protected Set < String > handleKeySet ( ) { } } }
@ RestController public class CoalitionReasoner { public static final Double THRESHOLD = 0.4 ; private static Logger LOG = Logger . getLogger ( CoalitionReasoner . class . toString ( ) ) ; public static long c_id = 1 ; private CoalitionClient coalitionClient = new CoalitionClient ( ) ; private int coalitionStrategyId = 1 ; @ Autowired CoalitionRepository coalitionRepository ; @ Autowired MachineRepository machineRepository ; @ Autowired JobRepository jobRepository ; @ Autowired TaskUsageMappingRepository taskUsageMappingRepository ; @ Autowired ScheduledRepository scheduledRepository ; @ RequestMapping ( method = RequestMethod . GET , path = "/coalitions/init/{time}" ) public Integer initCoalitions ( @ PathVariable long time ) throws Exception { Map < Long , Coalition > coalitionMap = new TreeMap < Long , Coalition > ( ) ; int i = 1 ; List < Coalition > coalitions = createCoalitions ( machineRepository . findAll ( ) , time , coalitionStrategyId ) ; for ( Coalition c : coalitions ) { for ( int type = 0 ; type < ( JobRequester . types . length ) ; type ++ ) { c . setScheduleClass ( type ) ; c . setId ( ( ( CoalitionReasoner . c_id ) ++ ) ) ; coalitionRepository . save ( c ) ; sendCoalitionToComponent ( c , time , type ) ; } } <START_BUG> int size = ( coalitions . size ( ) ) / ( JobRequester . types . length ) ; <END_BUG> CoalitionReasoner . LOG . info ( ( "Coalitions<seq2seq4repair_space>created:<seq2seq4repair_space>" + size ) ) ; int [ ] total = new int [ ] { size , size , size } ; writeResults ( time , new int [ ] { 0 , 0 , 0 } , total , total ) ; return coalitions . size ( ) ; } public void sendCoalition ( Coalition c , long time ) { } public void sendCoalitionToComponent ( Coalition c , Long time , int componentIndex ) { } private void checkDuplicates ( Coalition c ) { } public static void printCoaliion ( Coalition c ) throws IOException { } public void reasonMachineRandomly ( Machine machineProperties , Map < Long , Coalition > coalitionMap , long time ) throws Exception { } public List < Coalition > createCoalitions ( List < Machine > machines , Long time , int coalitionStrategyId ) { } @ RequestMapping ( method = RequestMethod . PUT , path = "/coalitions/update/{time}" ) public void updateAll ( @ PathVariable Long time ) { } private void writeResults ( Long time , int [ ] deleted , int [ ] created , int [ ] total ) { } private boolean isScheduled ( Coalition c ) { } public int update ( Coalition coalition , long time ) { } }
public class SignManager { private SettingManager sm = SettingManager . getInstance ( ) ; private ArrayList < Signs > signs = new ArrayList < > ( ) ; private static SignManager instance = new SignManager ( ) ; private int nextInt ( ) { } private Signs getSignByID ( int id ) { } public static SignManager getInstance ( ) { } public void load ( ) { } public void updateSigns ( ) { } public void updateSign ( int id ) { } public void updateSign ( Location loc ) { } public void removeSign ( int id ) { if ( ( this . getSign ( id ) ) != null ) { <START_BUG> this . signs . remove ( id ) ; <END_BUG> } } public void addSign ( Signs signs ) { } public void createSign ( Location loc , int GameID ) { } public void deleteSign ( int ID ) { } public Signs getSign ( int id ) { } public Signs getSign ( Location loc ) { } }
public class SimulationUI implements MouseEvents { public static final int WIDTH = 150 ; private boolean started = false ; private EventLog eventLog ; private VBox vBox ; private boolean logShown ; private Simulation sim ; public SimulationUI ( ) { } public void sendToeventLog ( String event ) { } public void update ( ) { } public void refresh ( GraphicsContext g ) { } public void startEventDialog ( ) { <START_BUG> if ( ( started ) == false ) { <END_BUG> new ErrorDialog ( "Start<seq2seq4repair_space>simulation<seq2seq4repair_space>before<seq2seq4repair_space>sending<seq2seq4repair_space>event" , "Event<seq2seq4repair_space>Start<seq2seq4repair_space>Error" ) ; return ; } new view . Panes . EventGen ( sim . getModelTrack ( ) ) ; } public void showTrackMenu ( DefaultTrack dt ) { } private String selectedMode ; final ToggleGroup mode = new ToggleGroup ( ) ; private VBox getVisualisationButtons ( ) { } public void addUIElementsToLayout ( BorderPane bp ) { } public void removeUIElementsFromLayout ( BorderPane bp ) { } public void toggleLog ( BorderPane bp ) { } public boolean logShowing ( ) { } public void keyPressed ( String code ) { } @ Override public void mouseClicked ( double x , double y , MouseEvent e ) { } @ Override public void mouseMoved ( double x , double y , MouseEvent e ) { } @ Override public void mouseDragged ( double x , double y , MouseEvent e ) { } @ Override public void mousePressed ( double x , double y , MouseEvent e ) { } @ Override public void mouseReleased ( double x , double y , MouseEvent e ) { } }
public class ImageFigure extends AttributeFigure implements ImageObserver { private String fFileName ; private transient Image fImage ; private Rectangle fDisplayBox ; private static final long serialVersionUID = 148012030121282439L ; private int imageFigureSerializedDataVersion = 1 ; public ImageFigure ( ) { } public ImageFigure ( Image image , String fileName , Point origin ) { } public void basicDisplayBox ( Point origin , Point corner ) { } public HandleEnumeration handles ( ) { } public Rectangle displayBox ( ) { } protected void basicMoveBy ( int x , int y ) { } public void draw ( Graphics g ) { if ( ( fImage ) == null ) { <START_BUG> fImage = Iconkit . instance ( ) . getImage ( fFileName ) ; <END_BUG> } if ( ( fImage ) != null ) { g . drawImage ( fImage , fDisplayBox . x , fDisplayBox . y , fDisplayBox . width , fDisplayBox . height , this ) ; } else { drawGhost ( g ) ; } } private void drawGhost ( Graphics g ) { } public boolean imageUpdate ( Image img , int flags , int x , int y , int w , int h ) { } public void release ( ) { } public void write ( StorableOutput dw ) { } public void read ( StorableInput dr ) throws IOException { } private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { } }
public class JcaExtension implements Extension { public static String SUBSYSTEM_NAME = "jca" ; private static final int MANAGEMENT_API_MAJOR_VERSION = 1 ; private static final int MANAGEMENT_API_MINOR_VERSION = 1 ; private static final int MANAGEMENT_API_MICRO_VERSION = 0 ; private static final String RESOURCE_NAME = ( JcaExtension . class . getPackage ( ) . getName ( ) ) + ".LocalDescriptions" ; protected static final PathElement PATH_SUBSYSTEM = PathElement . pathElement ( SUBSYSTEM , JcaExtension . SUBSYSTEM_NAME ) ; protected static final PathElement PATH_ARCHIVE_VALIDATION = PathElement . pathElement ( Constants . ARCHIVE_VALIDATION , Constants . ARCHIVE_VALIDATION ) ; static StandardResourceDescriptionResolver getResourceDescriptionResolver ( final String ... keyPrefix ) { } @ Override public void initialize ( final ExtensionContext context ) { ROOT_LOGGER . debugf ( "Initializing<seq2seq4repair_space>Connector<seq2seq4repair_space>Extension" ) ; final boolean registerRuntimeOnly = context . isRuntimeOnlyRegistrationValid ( ) ; final SubsystemRegistration subsystem = context . registerSubsystem ( JcaExtension . SUBSYSTEM_NAME , JcaExtension . MANAGEMENT_API_MAJOR_VERSION , JcaExtension . MANAGEMENT_API_MINOR_VERSION , JcaExtension . MANAGEMENT_API_MICRO_VERSION ) ; final ManagementResourceRegistration registration = subsystem . registerSubsystemModel ( INSTANCE ) ; <START_BUG> registration . registerOperationHandler ( DESCRIBE , GenericSubsystemDescribeHandler . INSTANCE , GenericSubsystemDescribeHandler . INSTANCE , false , PRIVATE ) ; <END_BUG> final ManagementResourceRegistration archiveValidation = registration . registerSubModel ( JcaArchiveValidationDefinition . INSTANCE ) ; final ManagementResourceRegistration beanValidation = registration . registerSubModel ( PathElement . pathElement ( Constants . BEAN_VALIDATION , Constants . BEAN_VALIDATION ) , BEAN_VALIDATION_DESC ) ; beanValidation . registerOperationHandler ( ADD , BeanValidationAdd . INSTANCE , ADD_BEAN_VALIDATION_DESC , false ) ; beanValidation . registerOperationHandler ( REMOVE , ReloadRequiredRemoveStepHandler . INSTANCE , REMOVE_BEAN_VALIDATION_DESC , false ) ; for ( final BeanValidationAdd . BeanValidationParameters parameter : BeanValidationParameters . values ( ) ) { beanValidation . registerReadWriteAttribute ( parameter . getAttribute ( ) , null , JcaAttributeWriteHandler . INSTANCE ) ; } final ManagementResourceRegistration cachedConnectionManager = registration . registerSubModel ( PathElement . pathElement ( Constants . CACHED_CONNECTION_MANAGER , Constants . CACHED_CONNECTION_MANAGER ) , CACHED_CONNECTION_MANAGER_DESC ) ; cachedConnectionManager . registerOperationHandler ( ADD , CachedConnectionManagerAdd . INSTANCE , ADD_CACHED_CONNECTION_MANAGER_DESC , false ) ; cachedConnectionManager . registerOperationHandler ( REMOVE , ReloadRequiredRemoveStepHandler . INSTANCE , REMOVE_CACHED_CONNECTION_MANAGER_DESC , false ) ; for ( final CachedConnectionManagerAdd . CcmParameters parameter : CcmParameters . values ( ) ) { if ( parameter != ( CcmParameters . INSTALL ) ) { cachedConnectionManager . registerReadWriteAttribute ( parameter . getAttribute ( ) , null , JcaAttributeWriteHandler . INSTANCE ) ; } else { cachedConnectionManager . registerReadWriteAttribute ( parameter . getAttribute ( ) , null , new ReloadRequiredWriteAttributeHandler ( ) ) ; } } final ManagementResourceRegistration workManager = registration . registerSubModel ( PathElement . pathElement ( Constants . WORKMANAGER ) , WORKMANAGER_DESC ) ; workManager . registerOperationHandler ( ADD , WorkManagerAdd . INSTANCE , ADD_WORKMANAGER_DESC , false ) ; workManager . registerOperationHandler ( REMOVE , ReloadRequiredRemoveStepHandler . INSTANCE , REMOVE_WORKMANAGER_DESC , false ) ; for ( final WorkManagerAdd . WmParameters parameter : WmParameters . values ( ) ) { workManager . registerReadWriteAttribute ( parameter . getAttribute ( ) , null , new ReloadRequiredWriteAttributeHandler ( ) ) ; } workManager . registerSubModel ( BoundedQueueThreadPoolResourceDefinition . create ( Constants . WORKMANAGER_SHORT_RUNNING , STANDARD_THREAD_FACTORY_RESOLVER , STANDARD_HANDOFF_EXECUTOR_RESOLVER , EXECUTOR . append ( Constants . WORKMANAGER_SHORT_RUNNING ) , registerRuntimeOnly ) ) ; workManager . registerSubModel ( BoundedQueueThreadPoolResourceDefinition . create ( Constants . WORKMANAGER_LONG_RUNNING , STANDARD_THREAD_FACTORY_RESOLVER , STANDARD_HANDOFF_EXECUTOR_RESOLVER , EXECUTOR . append ( Constants . WORKMANAGER_LONG_RUNNING ) , registerRuntimeOnly ) ) ; final ManagementResourceRegistration bootstrapContext = registration . registerSubModel ( PathElement . pathElement ( Constants . BOOTSTRAP_CONTEXT ) , BOOTSTRAP_CONTEXT_DESC ) ; bootstrapContext . registerOperationHandler ( ADD , BootstrapContextAdd . INSTANCE , ADD_BOOTSTRAP_CONTEXT_DESC , false ) ; bootstrapContext . registerOperationHandler ( REMOVE , ReloadRequiredRemoveStepHandler . INSTANCE , REMOVE_BOOTSTRAP_CONTEXT_DESC , false ) ; for ( final BootstrapContextAdd . BootstrapCtxParameters parameter : BootstrapCtxParameters . values ( ) ) { bootstrapContext . registerReadWriteAttribute ( parameter . getAttribute ( ) , null , new ReloadRequiredWriteAttributeHandler ( ) ) ; } subsystem . registerXMLElementWriter ( JcaExtension . ConnectorSubsystemParser . INSTANCE ) ; } @ Override public void initializeParsers ( final ExtensionParsingContext context ) { } static final class ConnectorSubsystemParser implements XMLStreamConstants , XMLElementReader < List < ModelNode > > , XMLElementWriter < SubsystemMarshallingContext > { static final JcaExtension . ConnectorSubsystemParser INSTANCE = new JcaExtension . ConnectorSubsystemParser ( ) ; @ Override public void writeContent ( XMLExtendedStreamWriter writer , SubsystemMarshallingContext context ) throws XMLStreamException { } private void writeArchiveValidation ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { } private void writeBeanValidation ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { } private void writeCachedConnectionManager ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { } private void writeWorkManagers ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { } private void writeBootstrapContexts ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { } @ Override public void readElement ( final XMLExtendedStreamReader reader , final List < ModelNode > list ) throws XMLStreamException { } private ModelNode parseArchiveValidation ( final XMLExtendedStreamReader reader , final ModelNode parentOperation ) throws XMLStreamException { } private void parseWorkManager ( final XMLExtendedStreamReader reader , final ModelNode parentAddress , final List < ModelNode > list , final ModelNode node , boolean defaultWm ) throws XMLStreamException { } private ModelNode parseBeanValidation ( final XMLExtendedStreamReader reader , final ModelNode parentOperation ) throws XMLStreamException { } private ModelNode parseCcm ( final XMLExtendedStreamReader reader , final ModelNode parentOperation ) throws XMLStreamException { } private void parseBootstrapContexts ( final XMLExtendedStreamReader reader , final ModelNode parentAddress , final List < ModelNode > list ) throws XMLStreamException { } public String rawAttributeText ( XMLStreamReader reader , String attributeName ) { } } }
class LRSProxyMap extends AbstractLRSProxyMap { private static final Localizer _loc = Localizer . forPackage ( LRSProxyMap . class ) ; private final LRSMapFieldStrategy _strat ; public LRSProxyMap ( LRSMapFieldStrategy strat ) { } protected synchronized int count ( ) { } protected boolean hasKey ( Object key ) { } protected boolean hasValue ( Object value ) { } private boolean has ( final Object obj , final boolean key ) { } protected Collection keys ( final Object obj ) { } protected Object value ( final Object obj ) { final OpenJPAStateManager sm = assertOwner ( ) ; final JDBCStore store = getStore ( ) ; if ( ( _strat . getFieldMapping ( ) . getElement ( ) . getValueMappedBy ( ) ) != null ) { Object val = _strat . deriveValue ( store , obj ) ; if ( hasValue ( val ) ) return val ; return null ; } final JDBCFetchConfiguration fetch = store . getFetchConfiguration ( ) ; final ClassMapping [ ] clss = _strat . getIndependentValueMappings ( true ) ; final Joins [ ] resJoins = new Joins [ Math . max ( 1 , clss . length ) ] ; Union union = store . getSQLFactory ( ) . newUnion ( Math . max ( 1 , clss . length ) ) ; <START_BUG> union . setSingleResult ( true ) ; <END_BUG> if ( ( fetch . getSubclassFetchMode ( _strat . getFieldMapping ( ) . getElementMapping ( ) . getTypeMapping ( ) ) ) != ( JDBCFetchConfiguration . EAGER_JOIN ) ) union . abortUnion ( ) ; union . select ( new Union . Selector ( ) { public void select ( Select sel , int idx ) { ClassMapping cls = ( ( clss . length ) == 0 ) ? null : clss [ idx ] ; sel . whereForeignKey ( _strat . getJoinForeignKey ( cls ) , sm . getObjectId ( ) , _strat . getFieldMapping ( ) . getDefiningMapping ( ) , store ) ; if ( ( _strat . getFieldMapping ( ) . getKey ( ) . getValueMappedBy ( ) ) != null ) resJoins [ idx ] = _strat . joinValueRelation ( sel . newJoins ( ) , cls ) ; Object key = _strat . toKeyDataStoreValue ( obj , store ) ; Column [ ] cols = _strat . getKeyColumns ( cls ) ; Object [ ] vals = ( ( cols . length ) == 1 ) ? null : ( ( Object [ ] ) ( key ) ) ; SQLBuffer sql = new SQLBuffer ( store . getDBDictionary ( ) ) ; for ( int i = 0 ; i < ( cols . length ) ; i ++ ) { if ( i > 0 ) sql . append ( "<seq2seq4repair_space>AND<seq2seq4repair_space>" ) ; sql . append ( sel . getColumnAlias ( cols [ i ] , resJoins [ idx ] ) ) ; if ( vals == null ) sql . append ( ( key == null ? "<seq2seq4repair_space>IS<seq2seq4repair_space>" : "<seq2seq4repair_space>=<seq2seq4repair_space>" ) ) . appendValue ( key , cols [ i ] ) ; else sql . append ( ( ( vals [ i ] ) == null ? "<seq2seq4repair_space>IS<seq2seq4repair_space>" : "<seq2seq4repair_space>=<seq2seq4repair_space>" ) ) . appendValue ( vals [ i ] , cols [ i ] ) ; } sel . where ( sql , resJoins [ idx ] ) ; if ( ( resJoins [ idx ] ) == null ) resJoins [ idx ] = _strat . joinValueRelation ( sel . newJoins ( ) , cls ) ; _strat . selectValue ( sel , cls , sm , store , fetch , resJoins [ idx ] ) ; } } ) ; Result res = null ; try { res = union . execute ( store , fetch ) ; if ( res . next ( ) ) return _strat . loadValue ( sm , store , fetch , res , resJoins [ res . indexOf ( ) ] ) ; return null ; } catch ( SQLException se ) { throw SQLExceptions . getStore ( se , store . getDBDictionary ( ) ) ; } finally { if ( res != null ) res . close ( ) ; } } protected Iterator itr ( ) { } private OpenJPAStateManager assertOwner ( ) { } private JDBCStore getStore ( ) { } private class ResultIterator implements Iterator , Closeable { private final OpenJPAStateManager _sm ; private final JDBCStore _store ; private final JDBCFetchConfiguration _fetch ; private final Result [ ] _res ; private final Joins [ ] _joins ; private Boolean _next = null ; public ResultIterator ( OpenJPAStateManager sm , JDBCStore store , JDBCFetchConfiguration fetch , Result [ ] res , Joins [ ] joins ) { } public boolean hasNext ( ) { } public Object next ( ) { } public void remove ( ) { } public void close ( ) { } } private static class Entry implements Map . Entry { public Object key ; public Object val ; public Object getKey ( ) { } public Object getValue ( ) { } public Object setValue ( Object val ) { } } }
@ Entity @ Table ( name = "Order" ) public class Cart implements Serializable { @ GeneratedValue ( strategy = GenerationType . AUTO ) @ Id private int id ; @ NotNull @ OneToMany private List < Item > itemList ; private double totalPrice ; private int cartAmount ; @ ManyToOne private User client ; public Cart ( int id , List < Item > itemList , double totalPrice , User client , int cartAmount ) { } public Cart ( ) { } public int getId ( ) { } public void setId ( int id ) { } public List < Item > getItemList ( ) { } public void setItemList ( List < Item > itemList ) { } public double getTotalPrice ( ) { } public void setTotalPrice ( double totalPrice ) { } public User getClient ( ) { } public void setClient ( User client ) { } public double getCartAmount ( ) { } public void setCartAmount ( int cartAmount ) { } public void calculateTotalPrice ( ) { double totalPrice = 0 ; for ( int i = 0 ; i < ( this . itemList . size ( ) ) ; i ++ ) { Item item = this . itemList . get ( i ) ; <START_BUG> totalPrice += item . getChosenPrice ( ) ; <END_BUG> } this . totalPrice = totalPrice ; } public void calculateCartAmount ( ) { } }
public class SubscribeSpotify implements MqttCallback { MqttClient client ; MqttMessage message ; int playCounter = 0 ; PlayMusic musicPlayer = new PlayMusic ( ) ; public static void main ( String [ ] args ) { } public void activateSubscriptionForSpotify ( ) { try { client = new MqttClient ( "tcp://test.mosquitto.org:1883" , "Sending" ) ; client . connect ( ) ; if ( client . isConnected ( ) ) System . out . println ( "client<seq2seq4repair_space>connected" ) ; client . setCallback ( this ) ; <START_BUG> client . subscribe ( local ) ; <END_BUG> } catch ( MqttException e ) { e . printStackTrace ( ) ; } } @ Override public void connectionLost ( Throwable arg0 ) { } @ Override public void deliveryComplete ( IMqttDeliveryToken arg0 ) { } @ Override public void messageArrived ( String arg0 , MqttMessage arg1 ) throws Exception { } }
public abstract class DefaultCompilerAdapter extends AbstractLogEnabled implements CompilerAdapter { protected boolean m_debug ; protected boolean m_optimize ; protected boolean m_deprecation ; protected boolean m_depend ; protected boolean m_verbose ; protected Javac m_attributes ; protected Path m_bootclasspath ; protected Path m_compileClasspath ; protected File [ ] m_compileList ; protected File m_destDir ; protected String m_encoding ; protected Path m_extdirs ; protected boolean m_includeAntRuntime ; protected boolean m_includeJavaRuntime ; protected String m_memoryInitialSize ; protected String m_memoryMaximumSize ; protected File m_baseDir ; protected Path src ; protected String target ; public void setJavac ( Javac attributes ) { } public Javac getJavac ( ) { } protected Commandline setupJavacCommand ( ) throws TaskException { } protected Commandline setupJavacCommand ( boolean debugLevelCheck ) throws TaskException { } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd , boolean useDebugLevel ) throws TaskException { } protected Commandline setupModernJavacCommand ( ) throws TaskException { } protected Commandline setupModernJavacCommandlineSwitches ( Commandline cmd ) throws TaskException { } protected Path getCompileClasspath ( ) throws TaskException { } protected void addCurrentCompilerArgs ( Commandline cmd ) { } protected int executeExternalCompile ( String [ ] args , int firstFileName ) throws TaskException { String [ ] commandArray = null ; File tmpFile = null ; try { <START_BUG> if ( ( Commandline . toString ( args ) . length ( ) ) > 4096 ) { <END_BUG> PrintWriter out = null ; try { tmpFile = File . createTempFile ( "jikes" , "" , new File ( "." ) ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = firstFileName ; i < ( args . length ) ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ firstFileName + 1 ] ; System . arraycopy ( args , 0 , commandArray , 0 , firstFileName ) ; commandArray [ firstFileName ] = "@" + ( tmpFile . getAbsolutePath ( ) ) ; } catch ( IOException e ) { throw new TaskException ( "Error<seq2seq4repair_space>creating<seq2seq4repair_space>temporary<seq2seq4repair_space>file" , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = args ; } try { final Execute2 exe = new Execute2 ( ) ; setupLogger ( exe ) ; exe . setWorkingDirectory ( m_baseDir ) ; exe . setCommandline ( commandArray ) ; return exe . execute ( ) ; } catch ( IOException e ) { throw new TaskException ( ( ( "Error<seq2seq4repair_space>running<seq2seq4repair_space>" + ( args [ 0 ] ) ) + "<seq2seq4repair_space>compiler" ) , e ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } protected void logAndAddFilesToCompile ( Commandline cmd ) { } }
public class JConsoleCLIPlugin extends JConsolePlugin { private static final int DEFAULT_MAX_THREADS = 6 ; private static final AtomicInteger executorCount = new AtomicInteger ( ) ; CliGuiContext cliGuiCtx ; private JPanel jconsolePanel ; private boolean initComplete = false ; private boolean isConnected = false ; @ Override public Map < String , JPanel > getTabs ( ) { } private boolean connectCommandContext ( CommandContext cmdCtx ) throws Exception { JConsoleContext jcCtx = this . getContext ( ) ; MBeanServerConnection mbeanServerConn = jcCtx . getMBeanServerConnection ( ) ; if ( mbeanServerConn instanceof RemotingMBeanServerConnection ) { return connectUsingRemoting ( cmdCtx , ( ( RemotingMBeanServerConnection ) ( mbeanServerConn ) ) ) ; } else { try { <START_BUG> cmdCtx . connectController ( "localhost" , 9999 ) ; <END_BUG> } catch ( Exception e ) { String message = "CLI<seq2seq4repair_space>GUI<seq2seq4repair_space>unable<seq2seq4repair_space>to<seq2seq4repair_space>connect<seq2seq4repair_space>to<seq2seq4repair_space>JBoss<seq2seq4repair_space>AS<seq2seq4repair_space>with<seq2seq4repair_space>localhost:9999<seq2seq4repair_space>\n" ; message += "Go<seq2seq4repair_space>to<seq2seq4repair_space>Connection<seq2seq4repair_space>-><seq2seq4repair_space>New<seq2seq4repair_space>Connection<seq2seq4repair_space>and<seq2seq4repair_space>enter<seq2seq4repair_space>a<seq2seq4repair_space>Remote<seq2seq4repair_space>Process<seq2seq4repair_space>\n" ; message += "of<seq2seq4repair_space>the<seq2seq4repair_space>form<seq2seq4repair_space>service:jmx:remoting-jmx://{host_name}:{port}<seq2seq4repair_space>where<seq2seq4repair_space>\n" ; message += "{host_name}<seq2seq4repair_space>and<seq2seq4repair_space>{port}<seq2seq4repair_space>are<seq2seq4repair_space>the<seq2seq4repair_space>address<seq2seq4repair_space>of<seq2seq4repair_space>the<seq2seq4repair_space>native<seq2seq4repair_space>management<seq2seq4repair_space>\n" ; message += "interface<seq2seq4repair_space>of<seq2seq4repair_space>the<seq2seq4repair_space>AS7<seq2seq4repair_space>installation<seq2seq4repair_space>being<seq2seq4repair_space>monitored." ; JOptionPane . showMessageDialog ( null , message ) ; return false ; } } return true ; } private boolean connectUsingRemoting ( CommandContext cmdCtx , RemotingMBeanServerConnection rmtMBeanSvrConn ) throws IOException , CliInitializationException { } private ExecutorService createExecutor ( ) { } @ Override public SwingWorker < ? , ? > newSwingWorker ( ) { } private void configureMyJInternalFrame ( ) { } private String getJBossServerName ( ) { } }
public class RegistrySharedObject extends BaseSharedObject implements IRemoteServiceContainerAdapter { protected RemoteServiceRegistryImpl localRegistry ; protected final Map remoteRegistrys = Collections . synchronizedMap ( new HashMap ( ) ) ; protected final List serviceListeners = new ArrayList ( ) ; protected final Map localServiceRegistrations = new HashMap ( ) ; public RegistrySharedObject ( ) { } public void dispose ( ID containerID ) { } public void addRemoteServiceListener ( IRemoteServiceListener listener ) { } public void removeRemoteServiceListener ( IRemoteServiceListener listener ) { } public IRemoteService getRemoteService ( IRemoteServiceReference reference ) { } public IRemoteServiceReference [ ] getRemoteServiceReferences ( ID [ ] idFilter , String clazz , String filter ) { } protected ID [ ] getTargetsFromProperties ( Dictionary properties ) { } public IRemoteServiceRegistration registerRemoteService ( String [ ] clazzes , Object service , Dictionary properties ) { } public boolean ungetRemoteService ( IRemoteServiceReference ref ) { } protected ISharedObjectContext getSOContext ( ) { } public void initialize ( ) throws SharedObjectInitException { } protected void handleContainerDisconnectedEvent ( IContainerDisconnectedEvent event ) { } protected void sendRegistryUpdate ( ID targetContainerID ) { } protected void handleContainerConnectedEvent ( IContainerConnectedEvent event ) { } private Request createRequest ( RemoteServiceRegistrationImpl remoteRegistration , IRemoteCall call , IRemoteCallListener listener ) { } protected void fireRemoteServiceListeners ( IRemoteServiceEvent event ) { } private RemoteServiceRegistrationImpl getRemoteServiceRegistrationImpl ( IRemoteServiceReference reference ) { } private IRemoteFilter createRemoteFilterFromString ( String filter ) { } private void addReferencesFromRegistry ( String clazz , IRemoteFilter remoteFilter , RemoteServiceRegistryImpl registry , List references ) { } protected Object callSynch ( RemoteServiceRegistrationImpl registration , IRemoteCall call ) throws ECFException { } protected void fireCallStartEvent ( IRemoteCallListener listener , final long requestId , final IRemoteServiceReference reference , final IRemoteCall call ) { } protected void fireCallCompleteEvent ( IRemoteCallListener listener , final long requestId , final Object response , final boolean hadException , final Throwable exception ) { } static String checkServiceClass ( final String [ ] clazzes , final Object serviceObject ) { } private static boolean extensiveCheckServiceClass ( String clazz , Class serviceClazz ) { } private static final String FIRE_REQUEST = "handleFireRequest" ; private static final String FIRE_REQUEST_ERROR_MESSAGE = Messages . RegistrySharedObject_EXCEPTION_SENDING_FIRE_REQUEST ; private static final int FIRE_REQUEST_ERROR_CODE = 202 ; private static final String CALL_REQUEST = "handleCallRequest" ; private static final String CALL_REQUEST_ERROR_MESSAGE = Messages . RegistrySharedObject_EXCEPTION_SENDING_CALL_REQUEST ; private static final int CALL_REQUEST_ERROR_CODE = 203 ; private static final String CALL_REQUEST_TIMEOUT_ERROR_MESSAGE = Messages . RegistrySharedObject_EXCEPTION_TIMEOUT_FOR_CALL_REQUEST ; private static final int CALL_REQUEST_TIMEOUT_ERROR_CODE = 204 ; private static final String UNREGISTER = "handleUnregister" ; private static final String UNREGISTER_ERROR_MESSAGE = Messages . RegistrySharedObject_EXCEPTION_SENDING_SERVICE_UNREGISTER ; private static final int UNREGISTER_ERROR_CODE = 206 ; private static final String MSG_INVOKE_ERROR_MESSAGE = Messages . RegistrySharedObject_EXCEPTION_SHARED_OBJECT_INVOKE ; private static final int MSG_INVOKE_ERROR_CODE = 207 ; private static final String SERVICE_INVOKE_ERROR_MESSAGE = Messages . RegistrySharedObject_EXCEPTION_INVOKING_SERVICE ; private static final int SERVICE_INVOKE_ERROR_CODE = 208 ; private static final String HANDLE_REQUEST_ERROR_MESSAGE = Messages . RegistrySharedObject_EXCEPTION_LOCALLY_INVOKING_REMOTE_CALL ; private static final int HANDLE_REQUEST_ERROR_CODE = 209 ; private static final String CALL_RESPONSE = "handleCallResponse" ; private static final String CALL_RESPONSE_ERROR_MESSAGE = Messages . RegistrySharedObject_EXCEPTION_SENDING_RESPONSE ; private static final int CALL_RESPONSE_ERROR_CODE = 210 ; private static final String REQUEST_NOT_FOUND_ERROR_MESSAGE = Messages . RegistrySharedObject_EXCEPTION_REQUEST_NOT_FOUND ; private static final int REQUEST_NOT_FOUND_ERROR_CODE = 211 ; private static final long RESPONSE_WAIT_INTERVAL = 5000 ; private static final String ADD_REGISTRATION = "handleAddRegistration" ; private static final String ADD_REGISTRATION_ERROR_MESSAGE = Messages . RegistrySharedObject_EXCEPTION_SENDING_ADD_SERVICE ; private static final int ADD_REGISTRATION_ERROR_CODE = 212 ; private static final String REGISTRY_UPDATE_REQUEST = "handleRegistryUpdateRequest" ; protected void sendRegistryUpdateRequest ( ) { } protected void handleRegistryUpdateRequest ( ID remoteContainerID ) { } protected void sendAddRegistration ( ID receiver , RemoteServiceRegistrationImpl reg ) { } protected void handleAddRegistration ( ID remoteContainerID , final RemoteServiceRegistrationImpl registration ) { } private void localRegisterService ( RemoteServiceRegistrationImpl registration ) { <START_BUG> final Object localServiceRegistrationValue = registration . getProperty ( LOCAL_SERVICE_REGISTRATION ) ; <END_BUG> if ( localServiceRegistrationValue != null ) { final BundleContext context = Activator . getDefault ( ) . getContext ( ) ; if ( context == null ) return ; final RemoteServiceImpl remoteServiceImpl = new RemoteServiceImpl ( this , registration ) ; Object service ; try { service = remoteServiceImpl . getProxy ( ) ; } catch ( final ECFException e ) { e . printStackTrace ( ) ; log ( "localRegisterService" , e ) ; return ; } final Hashtable properties = new Hashtable ( ) ; final String [ ] keys = registration . getPropertyKeys ( ) ; for ( int i = 0 ; i < ( keys . length ) ; i ++ ) { final Object value = registration . getProperty ( keys [ i ] ) ; if ( value != null ) { properties . put ( keys [ i ] , value ) ; } } final ID remoteContainerID = registration . getContainerID ( ) ; properties . put ( SERVICE_REGISTRATION_CONTAINER_ID , remoteContainerID . getName ( ) ) ; properties . put ( REMOTE_SERVICE , remoteServiceImpl ) ; final ServiceRegistration serviceRegistration = context . registerService ( registration . getClasses ( ) , service , properties ) ; addLocalServiceRegistration ( remoteContainerID , serviceRegistration ) ; } } private void addLocalServiceRegistration ( ID remoteContainerID , ServiceRegistration registration ) { } protected long sendCallRequest ( RemoteServiceRegistrationImpl remoteRegistration , final IRemoteCall call ) throws IOException { } protected void handleCallRequest ( Request request ) { } protected void sendCallRequestWithListener ( RemoteServiceRegistrationImpl remoteRegistration , IRemoteCall call , IRemoteCallListener listener ) { } protected void sendCallResponse ( ID responseTarget , Response response ) { } protected void handleCallResponse ( Response response ) { } protected Request sendFireRequest ( RemoteServiceRegistrationImpl remoteRegistration , IRemoteCall call ) throws ECFException { } protected void handleFireRequest ( Request request ) { } protected void sendUnregister ( RemoteServiceRegistrationImpl serviceRegistration ) { } private void unregisterServiceRegistrationsForContainer ( ID containerID ) { } private void unregisterAllServiceRegistrations ( ) { } protected void handleUnregister ( ID containerID , Long serviceId ) { } protected IRemoteServiceUnregisteredEvent createUnregisteredEvent ( final RemoteServiceRegistrationImpl registration ) { } protected IRemoteServiceRegisteredEvent createRegisteredEvent ( final RemoteServiceRegistrationImpl registration ) { }
public class CastExpression extends Expression { public Expression expression ; public Expression type ; public TypeBinding expectedType ; public CastExpression ( Expression expression , Expression type ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public static void checkNeedForAssignedCast ( BlockScope scope , TypeBinding expectedType , CastExpression rhs ) { } public static void checkNeedForEnclosingInstanceCast ( BlockScope scope , Expression enclosingInstance , TypeBinding enclosingInstanceType , TypeBinding memberType ) { } public static void checkNeedForArgumentCast ( BlockScope scope , int operator , int operatorSignature , Expression expression , int expressionTypeId ) { } public static void checkNeedForArgumentCasts ( BlockScope scope , Expression receiver , TypeBinding receiverType , MethodBinding binding , Expression [ ] arguments , TypeBinding [ ] argumentTypes , final InvocationSite invocationSite ) { } public static void checkNeedForArgumentCasts ( BlockScope scope , int operator , int operatorSignature , Expression left , int leftTypeId , boolean leftIsCast , Expression right , int rightTypeId , boolean rightIsCast ) { } private static void checkAlternateBinding ( BlockScope scope , Expression receiver , TypeBinding receiverType , MethodBinding binding , Expression [ ] arguments , TypeBinding [ ] originalArgumentTypes , TypeBinding [ ] alternateArgumentTypes , final InvocationSite invocationSite ) { } public boolean checkUnsafeCast ( Scope scope , TypeBinding castType , TypeBinding expressionType , TypeBinding match , boolean isNarrowing ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { int pc = codeStream . position ; boolean needRuntimeCheckcast = ( ( this . bits ) & ( ASTNode . GenerateCheckcast ) ) != 0 ; if ( ( constant ) != ( Constant . NotAConstant ) ) { if ( valueRequired || needRuntimeCheckcast ) { codeStream . generateConstant ( constant , implicitConversion ) ; if ( needRuntimeCheckcast ) { codeStream . checkcast ( this . resolvedType ) ; } if ( ! valueRequired ) { codeStream . pop ( ) ; } } codeStream . recordPositionsFrom ( pc , this . sourceStart ) ; return ; } expression . generateCode ( currentScope , codeStream , ( valueRequired || needRuntimeCheckcast ) ) ; <START_BUG> if ( needRuntimeCheckcast && ( ( this . expression . postConversionType ( currentScope ) ) != ( this . resolvedType ) ) ) { <END_BUG> codeStream . checkcast ( this . resolvedType ) ; } if ( valueRequired ) { codeStream . generateImplicitConversion ( implicitConversion ) ; } else if ( needRuntimeCheckcast ) { codeStream . pop ( ) ; } codeStream . recordPositionsFrom ( pc , this . sourceStart ) ; } public Expression innermostCastedExpression ( ) { } public LocalVariableBinding localVariableBinding ( ) { } public int nullStatus ( FlowInfo flowInfo ) { } public Constant optimizedBooleanConstant ( ) { } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public TypeBinding resolveType ( BlockScope scope ) { } public void setExpectedType ( TypeBinding expectedType ) { } private boolean isIndirectlyUsed ( ) { } public void tagAsNeedCheckCast ( ) { } public void tagAsUnnecessaryCast ( Scope scope , TypeBinding castType ) { } public void traverse ( ASTVisitor visitor , BlockScope blockScope ) { } }
public final class Requester { public static final String USER_AGENT = "Mozilla/5.0" ; private static final RequestBody EMPTY_BODY = RequestBody . create ( null , new byte [ 0 ] ) ; private final DubtrackAPIImpl dubtrack ; private final OkHttpClient client ; public Requester ( DubtrackAPIImpl dubtrack ) { } public Response get ( String url ) throws IOException { } public Response post ( String url ) throws IOException { } public Response post ( String url , Map < String , String > data ) throws IOException { } public Response post ( String url , Map < String , String > data , Map < String , String > headers ) throws IOException { FormBody . Builder builder = new FormBody . Builder ( ) ; for ( Map . Entry < String , String > entry : data . entrySet ( ) ) { String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; <START_BUG> builder . addEncoded ( key , value ) ; <END_BUG> } RequestBody body = builder . build ( ) ; Request . Builder b = new Request . Builder ( ) . url ( url ) . addHeader ( "Content-Type" , body . contentType ( ) . type ( ) ) . addHeader ( "Content-Length" , String . valueOf ( body . contentLength ( ) ) ) . post ( body ) ; if ( headers != null ) { for ( Map . Entry < String , String > entry : headers . entrySet ( ) ) { String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; b . addHeader ( key , value ) ; } } b = appendCookies ( b ) ; return request ( b . build ( ) ) ; } public Response put ( String url , Map < String , String > data ) throws IOException { } public Response put ( String url , Map < String , String > data , Map < String , String > headers ) throws IOException { } public Response delete ( String url ) throws IOException { } public Response delete ( String url , Map < String , String > data ) throws IOException { } public Response delete ( String url , Map < String , String > data , Map < String , String > headers ) throws IOException { } private Response request ( Request request ) throws IOException { } private Request . Builder appendCookies ( Request . Builder builder ) { } }
public class JspC extends MatchingTask { private static final String FAIL_MSG = "Compile<seq2seq4repair_space>failed,<seq2seq4repair_space>messages<seq2seq4repair_space>should<seq2seq4repair_space>have<seq2seq4repair_space>been<seq2seq4repair_space>provided." ; private int verbose = 0 ; protected ArrayList compileList = new ArrayList ( ) ; protected boolean failOnError = true ; private Path classpath ; private File destDir ; private String iepluginid ; private boolean mapped ; private String packageName ; private Path src ; private File uribase ; private File uriroot ; public void setClasspath ( Path cp ) throws TaskException { } public void setClasspathRef ( Reference r ) throws TaskException { } public void setDestdir ( File destDir ) { } public void setFailonerror ( boolean fail ) { } public void setIeplugin ( String iepluginid_ ) { } public void setMapped ( boolean mapped_ ) { } public void setPackage ( String pkg ) { } public void setSrcdir ( Path srcDir ) throws TaskException { } public void setUribase ( File uribase ) { } public void setUriroot ( File uriroot ) { } public void setVerbose ( int i ) { } public Path getClasspath ( ) { } public ArrayList getCompileList ( ) { } public File getDestdir ( ) { } public boolean getFailonerror ( ) { } public String getIeplugin ( ) { } public String getPackage ( ) { } public Path getSrcDir ( ) { } public File getUribase ( ) { } public File getUriroot ( ) { } public int getVerbose ( ) { } public boolean isMapped ( ) { } public Path createClasspath ( ) throws TaskException { if ( ( classpath ) == null ) <START_BUG> classpath = new Path ( getProject ( ) ) ; <END_BUG> return classpath . createPath ( ) ; } public void execute ( ) throws TaskException { } protected void resetFileLists ( ) { } protected void scanDir ( File srcDir , File destDir , String [ ] files ) { } }
public class World extends GLWorld { public ArrayList < GameObject > objects ; public ArrayList < Logic > logics ; public ArrayList < Drawable > drawables ; public HashMap < String , List < GameObject > > namedObjects ; public float deltaTime ; public boolean running ; public GLBackendController controller ; public World ( GLBackendController controller ) { } @ Override public void update ( float deltaTime ) { } @ Override public void draw ( float deltaTime ) { } public void addObject ( GameObject object ) { if ( ! ( namedObjects . containsKey ( object . name ) ) ) { namedObjects . put ( object . name , new ArrayList < GameObject > ( ) ) ; namedObjects . get ( object . name ) . add ( object ) ; } if ( object instanceof Drawable ) { drawables . add ( ( ( Drawable ) ( object ) ) ) ; <START_BUG> controller . loadObject ( object ) ; <END_BUG> } objects . add ( object ) ; } public void addLogic ( Logic logic ) { } public List < GameObject > findObjectsOfType ( Class < ? extends GameObject > type ) { } public List < GameObject > findObjectsByName ( String name ) { } @ Override public void pause ( ) { } @ Override public void resume ( ) { } @ Override public void dispose ( ) { } }
public class SendMessageCommand extends Command { private SendMessageDialog sendMessageDialog ; private boolean showComposer = false ; private ComposerController composerController ; public SendMessageCommand ( ICommandReference reference ) { } private void showInvalidRecipientMessage ( String recipient ) { } private boolean validArguments ( ComposerCommandReference reference ) { } public void execute ( IWorkerStatusController worker ) throws Exception { ComposerCommandReference r = ( ( ComposerCommandReference ) ( getReference ( ) ) ) ; if ( ! ( validArguments ( r ) ) ) return ; worker . setDisplayText ( MailResourceLoader . getString ( "statusbar" , "message" , "send_message_compose" ) ) ; composerController = r . getComposerController ( ) ; if ( ( composerController . getView ( ) . getFrame ( ) ) != null ) { composerController . getView ( ) . getFrame ( ) . setVisible ( false ) ; } sendMessageDialog = new SendMessageDialog ( worker ) ; ComposerModel model = ( ( ComposerModel ) ( composerController . getModel ( ) ) ) ; AccountItem item = model . getAccountItem ( ) ; AbstractMessageFolder sentFolder = ( ( AbstractMessageFolder ) ( FolderTreeModel . getInstance ( ) . getFolder ( item . getSpecialFoldersItem ( ) . getInteger ( "sent" ) ) ) ) ; SendableMessage message = null ; try { <START_BUG> message = new org . columba . mail . composer . MessageComposer ( model ) . compose ( worker ) ; <END_BUG> } catch ( JSCFException e1 ) { if ( e1 instanceof CancelledException ) { showComposer = true ; return ; } else { JOptionPane . showMessageDialog ( null , e1 . getMessage ( ) ) ; showComposer = true ; return ; } } worker . setDisplayText ( MailResourceLoader . getString ( "statusbar" , "message" , "send_message_connect" ) ) ; final SMTPServer server = new SMTPServer ( item ) ; try { worker . setDisplayText ( MailResourceLoader . getString ( "statusbar" , "message" , "send_message" ) ) ; IWorkerStatusChangeListener listener = new IWorkerStatusChangeListener ( ) { public void workerStatusChanged ( WorkerStatusChangedEvent e ) { if ( e . getSource ( ) . cancelled ( ) ) { try { server . dropConnection ( ) ; } catch ( IOException e1 ) { } } } } ; worker . addWorkerStatusChangeListener ( listener ) ; server . sendMessage ( message , worker ) ; worker . removeWorkerStatusChangeListener ( listener ) ; if ( worker . cancelled ( ) ) { showComposer = true ; return ; } Flags flags = new Flags ( ) ; flags . setSeen ( true ) ; message . getHeader ( ) . setFlags ( flags ) ; ComposerCommandReference ref = new ComposerCommandReference ( composerController , sentFolder ) ; ref . setMessage ( message ) ; SaveMessageCommand c = new SaveMessageCommand ( ref ) ; CommandProcessor . getInstance ( ) . addOp ( c ) ; MailFolderCommandReference ref2 = model . getSourceReference ( ) ; if ( ( ref2 != null ) && ( ( ( IMailbox ) ( ref2 . getSourceFolder ( ) ) ) . exists ( ref2 . getUids ( ) [ 0 ] ) ) ) { ref2 . setMarkVariant ( MARK_AS_ANSWERED ) ; MarkMessageCommand c1 = new MarkMessageCommand ( ref2 ) ; CommandProcessor . getInstance ( ) . addOp ( c1 ) ; } worker . setDisplayText ( MailResourceLoader . getString ( "statusbar" , "message" , "send_message_closing" ) ) ; server . closeConnection ( ) ; worker . setDisplayText ( MailResourceLoader . getString ( "statusbar" , "message" , "send_message_success" ) ) ; } catch ( Exception e ) { showComposer = true ; throw e ; } } public void updateGUI ( ) throws Exception { } }
public class CorsResponseHelper { private static Logger LOGGER = Context . getCurrentLogger ( ) ; public boolean allowAllRequestedHeaders = true ; public boolean allowedCredentials = false ; public Set < String > allowedHeaders = null ; public Set < String > allowedOrigins = SetUtils . newHashSet ( "*" ) ; public Set < String > exposedHeaders = null ; public void addCorsResponseHeaders ( Request request , Response response ) { String origin = request . getHeaders ( ) . getFirstValue ( "Origin" , true ) ; if ( origin == null ) { return ; } Set < Method > allowedMethods = new java . util . HashSet ( response . getAllowedMethods ( ) ) ; response . getAllowedMethods ( ) . clear ( ) ; if ( ( ! ( allowedOrigins . contains ( "*" ) ) ) && ( ! ( allowedOrigins . contains ( origin ) ) ) ) { CorsResponseHelper . LOGGER . fine ( ( ( "Origin<seq2seq4repair_space>" + origin ) + "<seq2seq4repair_space>not<seq2seq4repair_space>allowed<seq2seq4repair_space>for<seq2seq4repair_space>CORS<seq2seq4repair_space>request" ) ) ; return ; } boolean isPreflightRequest = OPTIONS . equals ( request . getMethod ( ) ) ; if ( isPreflightRequest ) { if ( ( ( SUCCESS_OK . equals ( response . getStatus ( ) ) ) || ( SUCCESS_NO_CONTENT . equals ( response . getStatus ( ) ) ) ) || ( CLIENT_ERROR_METHOD_NOT_ALLOWED . equals ( response . getStatus ( ) ) ) ) { response . setStatus ( SUCCESS_OK ) ; } else { CorsResponseHelper . LOGGER . fine ( "The<seq2seq4repair_space>CORS<seq2seq4repair_space>preflight<seq2seq4repair_space>request<seq2seq4repair_space>failed<seq2seq4repair_space>in<seq2seq4repair_space>server<seq2seq4repair_space>resource." ) ; return ; } Method requestedMethod = request . getAccessControlRequestMethod ( ) ; if ( requestedMethod == null ) { CorsResponseHelper . LOGGER . fine ( "A<seq2seq4repair_space>CORS<seq2seq4repair_space>preflight<seq2seq4repair_space>request<seq2seq4repair_space>should<seq2seq4repair_space>specified<seq2seq4repair_space>header<seq2seq4repair_space>'Access-Control-Request-Method'" ) ; return ; } if ( ! ( allowedMethods . contains ( requestedMethod ) ) ) { CorsResponseHelper . LOGGER . fine ( "The<seq2seq4repair_space>CORS<seq2seq4repair_space>preflight<seq2seq4repair_space>request<seq2seq4repair_space>ask<seq2seq4repair_space>for<seq2seq4repair_space>methods<seq2seq4repair_space>not<seq2seq4repair_space>allowed<seq2seq4repair_space>in<seq2seq4repair_space>header<seq2seq4repair_space>'Access-Control-Request-Method'" ) ; return ; } Set < String > requestedHeaders = request . getAccessControlRequestHeaders ( ) ; if ( requestedHeaders == null ) { requestedHeaders = SetUtils . newHashSet ( ) ; } if ( ( ! ( allowAllRequestedHeaders ) ) && ( ( ( allowedHeaders ) == null ) || ( ! ( isAllHeadersAllowed ( allowedHeaders , requestedHeaders ) ) ) ) ) { CorsResponseHelper . LOGGER . fine ( "The<seq2seq4repair_space>CORS<seq2seq4repair_space>preflight<seq2seq4repair_space>request<seq2seq4repair_space>ask<seq2seq4repair_space>for<seq2seq4repair_space>headers<seq2seq4repair_space>not<seq2seq4repair_space>allowed<seq2seq4repair_space>in<seq2seq4repair_space>header<seq2seq4repair_space>'Access-Control-Request-Headers'" ) ; return ; } response . setAccessControlAllowMethods ( allowedMethods ) ; response . setAccessControlAllowHeaders ( requestedHeaders ) ; } else { if ( ( ( exposedHeaders ) != null ) && ( ! ( exposedHeaders . isEmpty ( ) ) ) ) { response . setAccessControlExposeHeaders ( exposedHeaders ) ; } } if ( allowedCredentials ) { <START_BUG> response . setAccessControlAllowCredential ( true ) ; <END_BUG> } if ( ( ! ( allowedCredentials ) ) && ( allowedOrigins . contains ( "*" ) ) ) { response . setAccessControlAllowOrigin ( "*" ) ; } else { response . setAccessControlAllowOrigin ( origin ) ; } } public Set < String > getAllowedHeaders ( ) { } public Set < String > getAllowedOrigins ( ) { } public Set < String > getExposedHeaders ( ) { } private boolean isAllHeadersAllowed ( Set < String > allowHeaders , Set < String > requestedHeaders ) { } public boolean isAllowAllRequestedHeaders ( ) { } public boolean isAllowedCredentials ( ) { } public void setAllowAllRequestedHeaders ( boolean allowAllRequestedHeaders ) { } public void setAllowedCredentials ( boolean allowedCredentials ) { } public void setAllowedHeaders ( Set < String > allowedHeaders ) { } public void setAllowedOrigins ( Set < String > allowedOrigins ) { } public void setExposedHeaders ( Set < String > exposedHeaders ) { } }
public interface GroupMapper { public Collection < Group > findByUserId ( long userId ) { } <START_BUG> public Group save ( Group group ) ; <END_BUG> }
public class SendMessageDialog extends JDialog implements ActionListener , WorkerStatusChangeListener { private JProgressBar progressBar ; private JButton cancelButton ; private JLabel label ; private WorkerStatusController worker ; public SendMessageDialog ( WorkerStatusController worker ) throws HeadlessException { } protected void initComponents ( ) { } protected void layoutComponents ( ) { } public void workerStatusChanged ( WorkerStatusChangedEvent e ) { } public void actionPerformed ( ActionEvent arg0 ) { <START_BUG> if ( arg0 . equals ( "CANCEL" ) ) { <END_BUG> worker . cancel ( ) ; setVisible ( false ) ; } } public void setWorker ( WorkerStatusController worker ) { } }
public class ForStatement extends Statement { public Statement [ ] initializations ; public Expression condition ; public Statement [ ] increments ; public Statement action ; public boolean neededScope ; public BlockScope scope ; private Label breakLabel ; private Label continueLabel ; int preCondInitStateIndex = - 1 ; int condIfTrueInitStateIndex = - 1 ; int mergedInitStateIndex = - 1 ; public ForStatement ( Statement [ ] initializations , Expression condition , Statement [ ] increments , Statement action , boolean neededScope , int s , int e ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { breakLabel = new Label ( ) ; continueLabel = new Label ( ) ; if ( ( initializations ) != null ) { int count = initializations . length ; int i = 0 ; while ( i < count ) { flowInfo = initializations [ ( i ++ ) ] . analyseCode ( scope , flowContext , flowInfo ) ; } } preCondInitStateIndex = currentScope . methodScope ( ) . recordInitializationStates ( flowInfo ) ; boolean conditionIsInlinedToTrue = ( ( condition ) == null ) || ( ( ( condition . constant ) != ( NotAConstant ) ) && ( ( condition . constant . booleanValue ( ) ) == true ) ) ; boolean conditionIsInlinedToFalse = ( ! conditionIsInlinedToTrue ) && ( ( ( condition . constant ) != ( NotAConstant ) ) && ( ( condition . constant . booleanValue ( ) ) == false ) ) ; LoopingFlowContext condLoopContext = null ; if ( ( condition ) != null ) { if ( ! conditionIsInlinedToTrue ) { flowInfo = condition . analyseCode ( scope , ( condLoopContext = new LoopingFlowContext ( flowContext , this , null , null , scope ) ) , flowInfo ) ; } } LoopingFlowContext loopingContext ; FlowInfo actionInfo ; if ( ( ( action ) == null ) || ( action . isEmptyBlock ( ) ) ) { if ( condLoopContext != null ) condLoopContext . complainOnFinalAssignmentsInLoop ( scope , flowInfo ) ; if ( conditionIsInlinedToTrue ) { return DeadEnd ; } else { if ( conditionIsInlinedToFalse ) { continueLabel = null ; } actionInfo = flowInfo . initsWhenTrue ( ) . copy ( ) ; loopingContext = new LoopingFlowContext ( flowContext , this , breakLabel , continueLabel , scope ) ; } } else { loopingContext = new LoopingFlowContext ( flowContext , this , breakLabel , continueLabel , scope ) ; FlowInfo initsWhenTrue = flowInfo . initsWhenTrue ( ) ; condIfTrueInitStateIndex = currentScope . methodScope ( ) . recordInitializationStates ( initsWhenTrue ) ; actionInfo = ( conditionIsInlinedToFalse ) ? DeadEnd : initsWhenTrue . copy ( ) ; <START_BUG> if ( ! ( actionInfo . complainIfUnreachable ( action , scope ) ) ) { <END_BUG> actionInfo = action . analyseCode ( scope , loopingContext , actionInfo ) ; } if ( ( ( actionInfo == ( DeadEnd ) ) || ( actionInfo . isFakeReachable ( ) ) ) && ( ( ( loopingContext . initsOnContinue ) == ( DeadEnd ) ) || ( loopingContext . initsOnContinue . isFakeReachable ( ) ) ) ) { continueLabel = null ; } else { if ( condLoopContext != null ) condLoopContext . complainOnFinalAssignmentsInLoop ( scope , flowInfo ) ; loopingContext . complainOnFinalAssignmentsInLoop ( scope , actionInfo ) ; actionInfo = actionInfo . mergedWith ( loopingContext . initsOnContinue . unconditionalInits ( ) ) ; } } if ( ( ( continueLabel ) != null ) && ( ( increments ) != null ) ) { LoopingFlowContext loopContext = new LoopingFlowContext ( flowContext , this , null , null , scope ) ; int i = 0 ; int count = increments . length ; while ( i < count ) actionInfo = increments [ ( i ++ ) ] . analyseCode ( scope , loopContext , actionInfo ) ; loopContext . complainOnFinalAssignmentsInLoop ( scope , flowInfo ) ; } FlowInfo mergedInfo ; if ( conditionIsInlinedToTrue ) { mergedInitStateIndex = currentScope . methodScope ( ) . recordInitializationStates ( ( mergedInfo = loopingContext . initsOnBreak ) ) ; return mergedInfo ; } mergedInfo = flowInfo . initsWhenFalse ( ) . unconditionalInits ( ) . mergedWith ( loopingContext . initsOnBreak . unconditionalInits ( ) ) ; mergedInitStateIndex = currentScope . methodScope ( ) . recordInitializationStates ( mergedInfo ) ; return mergedInfo ; } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public void resetStateForCodeGeneration ( ) { } public void resolve ( BlockScope upperScope ) { } public String toString ( int tab ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope blockScope ) { } }
final class Behaviors implements IDetachable { private static final long serialVersionUID = 1L ; private final Component component ; public Behaviors ( Component component ) { } public void add ( Behavior ... behaviors ) { } private void internalAdd ( final Behavior behavior ) { component . data_add ( behavior ) ; <START_BUG> if ( behavior . isStateless ( component ) ) { <END_BUG> getBehaviorId ( behavior ) ; } } @ SuppressWarnings ( "unchecked" ) public < M extends Behavior > List < M > getBehaviors ( Class < M > type ) { } public void remove ( Behavior behavior ) { } public final void detach ( ) { } private boolean internalRemove ( final Behavior behavior ) { } private void removeBehaviorsIdList ( ) { } private Behaviors . BehaviorIdList getBehaviorsIdList ( boolean createIfNotFound ) { } private static class BehaviorIdList extends ArrayList < Behavior > { private static final long serialVersionUID = 1L ; public BehaviorIdList ( ) { } } public final int getBehaviorId ( Behavior behavior ) { } public final Behavior getBehaviorById ( int id ) { } }
public class CoreContainer { protected static Logger log = Logger . getLogger ( CoreContainer . class . getName ( ) ) ; protected final Map < String , SolrCore > cores = new LinkedHashMap < String , SolrCore > ( ) ; protected boolean persistent = false ; protected String adminPath = null ; protected String managementPath = null ; protected CoreAdminHandler coreAdminHandler = null ; protected File configFile = null ; protected String libDir = null ; protected ClassLoader libLoader = null ; protected SolrResourceLoader loader = null ; protected WeakReference < SolrCore > adminCore = null ; protected Properties containerProperties ; public CoreContainer ( ) { } public Properties getContainerProperties ( ) { } public static class Initializer { protected String solrConfigFilename = null ; protected boolean abortOnConfigurationError = true ; public boolean isAbortOnConfigurationError ( ) { } public void setAbortOnConfigurationError ( boolean abortOnConfigurationError ) { } public String getSolrConfigFilename ( ) { } public void setSolrConfigFilename ( String solrConfigFilename ) { } public CoreContainer initialize ( ) throws IOException , ParserConfigurationException , SAXException { CoreContainer cores = null ; String instanceDir = SolrResourceLoader . locateInstanceDir ( ) ; File fconf = new File ( instanceDir , ( ( solrConfigFilename ) == null ? "solr.xml" : solrConfigFilename ) ) ; CoreContainer . log . info ( ( "looking<seq2seq4repair_space>for<seq2seq4repair_space>solr.xml:<seq2seq4repair_space>" + ( fconf . getAbsolutePath ( ) ) ) ) ; if ( fconf . exists ( ) ) { cores = new CoreContainer ( ) ; cores . load ( instanceDir , fconf ) ; abortOnConfigurationError = false ; for ( SolrCore c : cores . getCores ( ) ) { if ( c . getSolrConfig ( ) . getBool ( "abortOnConfigurationError" , false ) ) { abortOnConfigurationError = true ; break ; } } solrConfigFilename = cores . getConfigFile ( ) . getName ( ) ; } else { cores = new CoreContainer ( new SolrResourceLoader ( instanceDir ) ) ; SolrConfig cfg = ( ( solrConfigFilename ) == null ) ? new SolrConfig ( ) : new SolrConfig ( solrConfigFilename ) ; <START_BUG> CoreDescriptor dcore = new CoreDescriptor ( cores , "" , cfg . getResourceLoader ( ) . getInstanceDir ( ) ) ; <END_BUG> SolrCore singlecore = new SolrCore ( null , null , cfg , null , dcore ) ; abortOnConfigurationError = cfg . getBool ( "abortOnConfigurationError" , abortOnConfigurationError ) ; cores . register ( "" , singlecore , false ) ; cores . setPersistent ( false ) ; solrConfigFilename = cfg . getName ( ) ; } return cores ; } } public CoreContainer ( String dir , File configFile ) throws IOException , ParserConfigurationException , SAXException { } public CoreContainer ( SolrResourceLoader loader ) { } public void load ( String dir , File configFile ) throws IOException , ParserConfigurationException , SAXException { } private Properties readProperties ( Config cfg , Node node ) throws XPathExpressionException { } public void shutdown ( ) { } @ Override protected void finalize ( ) { } public SolrCore register ( String name , SolrCore core , boolean returnPrev ) { } public SolrCore create ( CoreDescriptor dcore ) throws IOException , ParserConfigurationException , SAXException { } public Collection < SolrCore > getCores ( ) { } public Collection < String > getCoreNames ( ) { } public Collection < String > getCoreNames ( SolrCore core ) { } public void reload ( String name ) throws IOException , ParserConfigurationException , SAXException { } public void swap ( String n0 , String n1 ) { } public SolrCore remove ( String name ) { } public SolrCore getCore ( String name ) { } public void setAdminCore ( SolrCore core ) { } public SolrCore getAdminCore ( ) { } protected CoreAdminHandler createMultiCoreHandler ( ) { } public CoreAdminHandler getMultiCoreHandler ( ) { } public boolean isPersistent ( ) { } public void setPersistent ( boolean persistent ) { } public String getAdminPath ( ) { } public void setAdminPath ( String adminPath ) { } public String getManagementPath ( ) { } public void setManagementPath ( String path ) { } public File getConfigFile ( ) { } public void persist ( ) { } public void persistFile ( File file ) { } void persist ( Writer writer ) throws IOException { } void persist ( Writer writer , List < String > aliases , CoreDescriptor dcore ) throws IOException { } private void writeProperties ( Writer writer , Properties props ) throws IOException { } public static void fileCopy ( File src , File dest ) throws IOException { } }
public class GBPRenderer implements AutoCloseable { private static final Logger LOG = LoggerFactory . getLogger ( GBPRenderer . class ) ; private DataBroker dataBroker ; protected ServiceRegistration nicConsoleRegistration ; private GBPRendererDataChangeListener gBPRendererDataChangeListener ; public GBPRenderer ( DataBroker dataBroker ) { } public void init ( ) { } @ Override public void close ( ) throws Exception { GBPRenderer . LOG . info ( "GBPRenderer<seq2seq4repair_space>Closed" ) ; if ( ( dataBroker ) != null ) { <START_BUG> deleteNode ( INTENTS_IID ) ; <END_BUG> } if ( ( nicConsoleRegistration ) != null ) { nicConsoleRegistration . unregister ( ) ; } if ( ( gBPRendererDataChangeListener ) != null ) { gBPRendererDataChangeListener . close ( ) ; } } private void deleteNode ( InstanceIdentifier < ? > iid ) { } }
public class ArrayInitializer extends Expression { public Expression [ ] expressions ; public ArrayBinding binding ; public ArrayInitializer ( ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { int pc = codeStream . position ; int expressionLength = ( ( expressions ) == null ) ? 0 : expressions . length ; codeStream . generateInlinedValue ( expressionLength ) ; <START_BUG> codeStream . newArray ( currentScope , binding ) ; <END_BUG> if ( ( expressions ) != null ) { int elementsTypeID = ( ( binding . dimensions ) > 1 ) ? - 1 : binding . leafComponentType . id ; for ( int i = 0 ; i < expressionLength ; i ++ ) { Expression expr ; if ( ( ( expr = expressions [ i ] ) . constant ) != ( NotAConstant ) ) { switch ( elementsTypeID ) { case TypeIds . T_int : case TypeIds . T_short : case TypeIds . T_byte : case TypeIds . T_char : case TypeIds . T_long : if ( ( expr . constant . longValue ( ) ) != 0 ) { codeStream . dup ( ) ; codeStream . generateInlinedValue ( i ) ; expr . generateCode ( currentScope , codeStream , true ) ; codeStream . arrayAtPut ( elementsTypeID , false ) ; } break ; case TypeIds . T_float : case TypeIds . T_double : double constantValue = expr . constant . doubleValue ( ) ; if ( ( constantValue == ( - 0.0 ) ) || ( constantValue != 0 ) ) { codeStream . dup ( ) ; codeStream . generateInlinedValue ( i ) ; expr . generateCode ( currentScope , codeStream , true ) ; codeStream . arrayAtPut ( elementsTypeID , false ) ; } break ; case TypeIds . T_boolean : if ( ( expr . constant . booleanValue ( ) ) != false ) { codeStream . dup ( ) ; codeStream . generateInlinedValue ( i ) ; expr . generateCode ( currentScope , codeStream , true ) ; codeStream . arrayAtPut ( elementsTypeID , false ) ; } break ; default : if ( ! ( expr instanceof NullLiteral ) ) { codeStream . dup ( ) ; codeStream . generateInlinedValue ( i ) ; expr . generateCode ( currentScope , codeStream , true ) ; codeStream . arrayAtPut ( elementsTypeID , false ) ; } } } else if ( ! ( expr instanceof NullLiteral ) ) { codeStream . dup ( ) ; codeStream . generateInlinedValue ( i ) ; expr . generateCode ( currentScope , codeStream , true ) ; codeStream . arrayAtPut ( elementsTypeID , false ) ; } } } if ( ! valueRequired ) { codeStream . pop ( ) ; } codeStream . recordPositionsFrom ( pc , this . sourceStart ) ; } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public TypeBinding resolveTypeExpecting ( BlockScope scope , TypeBinding expectedTb ) { } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } }
public class KEYRecord extends Record { private static KEYRecord member = new KEYRecord ( ) ; private int flags ; private int proto ; private int alg ; private byte [ ] key ; private int footprint = - 1 ; public static final int FLAG_NOCONF = 32768 ; public static final int FLAG_NOAUTH = 16384 ; public static final int FLAG_NOKEY = 49152 ; public static final int OWNER_ZONE = 256 ; public static final int OWNER_HOST = 512 ; public static final int OWNER_USER = 0 ; public static final int PROTOCOL_TLS = 1 ; public static final int PROTOCOL_EMAIL = 2 ; public static final int PROTOCOL_DNSSEC = 3 ; public static final int PROTOCOL_IPSEC = 4 ; public static final int PROTOCOL_ANY = 255 ; private KEYRecord ( ) { } private KEYRecord ( Name name , int dclass , long ttl ) { } static KEYRecord getMember ( ) { } public KEYRecord ( Name name , int dclass , long ttl , int flags , int proto , int alg , byte [ ] key ) { } Record rrFromWire ( Name name , int type , int dclass , long ttl , int length , DataByteInputStream in ) throws IOException { } Record rdataFromString ( Name name , int dclass , long ttl , Tokenizer st , Name origin ) throws IOException { KEYRecord rec = new KEYRecord ( name , dclass , ttl ) ; rec . flags = st . getUInt16 ( ) ; rec . proto = st . getUInt8 ( ) ; rec . alg = st . getUInt8 ( ) ; if ( ! ( ( ( rec . flags ) & ( KEYRecord . FLAG_NOKEY ) ) == ( KEYRecord . FLAG_NOKEY ) ) ) <START_BUG> rec . key = base64 . fromString ( remainingStrings ( st ) ) ; <END_BUG> else rec . key = null ; return rec ; } public String rdataToString ( ) { } public int getFlags ( ) { } public int getProtocol ( ) { } public int getAlgorithm ( ) { } public byte [ ] getKey ( ) { } public int getFootprint ( ) { } void rrToWire ( DataByteOutputStream out , Compression c , boolean canonical ) { } }
public class PathFileList implements FileList { private String m_path ; public void setPath ( final String path ) { } public FileObject [ ] listFiles ( final TaskContext context ) throws TaskException { FileSystemManager fileSystemManager = ( ( FileSystemManager ) ( context . getService ( FileSystemManager . class ) ) ) ; final String [ ] elements = FileUtils . parsePath ( m_path ) ; final FileObject [ ] result = new FileObject [ elements . length ] ; for ( int i = 0 ; i < ( elements . length ) ; i ++ ) { String element = elements [ i ] ; try { <START_BUG> result [ i ] = fileSystemManager . resolveFile ( element ) ; <END_BUG> } catch ( FileSystemException e ) { throw new TaskException ( e . getMessage ( ) , e ) ; } } return result ; } }
public class SessionManagerAdapterTestCase { private final SessionManager < LocalSessionContext > manager = mock ( SessionManager . class ) ; private final SessionListener listener = mock ( SessionListener . class ) ; private SessionManagerAdapter adapter = new SessionManagerAdapter ( this . manager ) ; @ Before public void init ( ) { } @ Test public void parse ( ) { } @ Test public void format ( ) { } @ Test public void start ( ) { } @ Test public void stop ( ) { } @ Test public void setDefaultSessionTimeout ( ) { } @ Test public void createSessionNoSessionId ( ) { } @ Test public void createSessionSpecifiedSessionId ( ) { } @ Test public void createSessionAlreadyExists ( ) { } @ Test public void getSession ( ) { } @ Test public void getSessionNoSessionId ( ) { } @ Test public void getSessionNotExists ( ) { HttpServerExchange exchange = new HttpServerExchange ( null ) ; Batcher batcher = mock ( Batcher . class ) ; Batch batch = mock ( Batch . class ) ; SessionConfig config = mock ( SessionConfig . class ) ; String requestedSessionId = "session.route1" ; String sessionId = "session" ; when ( config . findSessionId ( exchange ) ) . thenReturn ( requestedSessionId ) ; when ( this . manager . findSession ( sessionId ) ) . thenReturn ( null ) ; when ( this . manager . getBatcher ( ) ) . thenReturn ( batcher ) ; when ( batcher . startBatch ( ) ) . thenReturn ( batch ) ; Session sessionAdapter = this . adapter . getSession ( exchange , config ) ; assertNull ( sessionAdapter ) ; <START_BUG> verify ( batch ) . discard ( ) ; <END_BUG> } @ Test public void activeSessions ( ) { } @ Test public void getTransientSessions ( ) { } @ Test public void getActiveSessions ( ) { } @ Test public void getAllSessions ( ) { } @ Test public void getSessionByIdentifier ( ) { } @ Test public void getSessionByIdentifierNotExists ( ) { } }
public class RunTestNotifier extends Notifier { private final Statement fNext ; public RunTestNotifier ( Statement next ) { } @ Override public void run ( EachTestNotifier context ) { context . fireTestStarted ( ) ; try { fNext . evaluate ( ) ; } catch ( AssumptionViolatedException e ) { <START_BUG> context . addIgnorance ( e ) ; <END_BUG> } catch ( Throwable e ) { context . addFailure ( e ) ; } finally { context . fireTestFinished ( ) ; } } }
public class EntityPresenter extends AbstractActivity implements Presenter < Synapse > , EntityView . Presenter { private Synapse place ; private EntityView view ; private GlobalApplicationState globalApplicationState ; private AuthenticationController authenticationController ; private SynapseClientAsync synapseClient ; private NodeModelCreator nodeModelCreator ; private String entityId ; private Long versionNumber ; private AdapterFactory adapterFactory ; private EntityArea area ; private String areaToken ; private CookieProvider cookies ; private SynapseJSNIUtils synapseJsniUtils ; public static final String ENTITY_BACKGROUND_IMAGE_NAME = "entity_background_image_3141592653.png" ; @ Inject public EntityPresenter ( EntityView view , GlobalApplicationState globalApplicationState , AuthenticationController authenticationController , SynapseClientAsync synapseClient , NodeModelCreator nodeModelCreator , AdapterFactory adapterFactory , CookieProvider cookies , SynapseJSNIUtils synapseJsniUtils ) { } @ Override public void start ( AcceptsOneWidget panel , EventBus eventBus ) { } @ Override public void setPlace ( Synapse place ) { } public void updateArea ( EntityArea area , String areaToken ) { } @ Override public String mayStop ( ) { } @ Override public void refresh ( ) { } public void loadBackgroundImage ( final String projectEntityId ) { synapseClient . getRootWikiId ( projectEntityId , ENTITY . toString ( ) , new com . google . gwt . user . client . rpc . AsyncCallback < String > ( ) { @ Override public void onSuccess ( String rootWikiId ) { if ( rootWikiId != null ) { WikiPageKey wikiKey = new WikiPageKey ( projectEntityId , ENTITY . toString ( ) , rootWikiId ) ; loadBackgroundImage ( wikiKey ) ; } } @ Override public void onFailure ( Throwable e ) { <START_BUG> onFailure ( e ) ; <END_BUG> } } ) ; } public void loadBackgroundImage ( final WikiPageKey rootPageKey ) { } public static void filterToDownloadARs ( EntityBundle bundle ) { } }
public class FileSet extends DataType implements Cloneable { private PatternSet defaultPatterns = new PatternSet ( ) ; private Vector additionalPatterns = new Vector ( ) ; private File dir ; private boolean useDefaultExcludes = true ; private boolean isCaseSensitive = true ; private String dataTypeName = "fileset" ; public FileSet ( ) { } protected FileSet ( FileSet fileset ) { } public void setRefid ( Reference r ) throws BuildException { } public void setDir ( File dir ) throws BuildException { } public File getDir ( Project p ) { } public PatternSet createPatternSet ( ) { } public NameEntry createInclude ( ) { } public NameEntry createIncludesFile ( ) { } public NameEntry createExclude ( ) { } public NameEntry createExcludesFile ( ) { } public void setIncludes ( String includes ) { } public void setExcludes ( String excludes ) { } public void setIncludesfile ( File incl ) throws BuildException { } public void setExcludesfile ( File excl ) throws BuildException { } public void setDefaultexcludes ( boolean useDefaultExcludes ) { } public void setCaseSensitive ( boolean isCaseSensitive ) { } protected final void setDataTypeName ( String name ) { } public DirectoryScanner getDirectoryScanner ( Project p ) { } public void setupDirectoryScanner ( FileScanner ds , Project p ) { } protected FileSet getRef ( Project p ) { if ( ! ( checked ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; <START_BUG> if ( ! ( o . getClass ( ) . equals ( getClass ( ) ) ) ) { <END_BUG> String msg = ( ( ref . getRefId ( ) ) + "<seq2seq4repair_space>doesn\'t<seq2seq4repair_space>denote<seq2seq4repair_space>a<seq2seq4repair_space>" ) + ( dataTypeName ) ; throw new BuildException ( msg ) ; } else { return ( ( FileSet ) ( o ) ) ; } } public Object clone ( ) { } }
public class CustomResourceLoadingApplication extends WicketExampleApplication { private static final Log log = LogFactory . getLog ( CustomResourceLoadingApplication . class ) ; private final class CustomResourceStreamLocator extends AbstractResourceStreamLocator { private ClassLoaderResourceStreamLocator classLoaderLocator = new ClassLoaderResourceStreamLocator ( ) ; protected IResourceStream locate ( Class clazz , String path ) { if ( CustomResourceLoadingApplication . log . isDebugEnabled ( ) ) { CustomResourceLoadingApplication . log . debug ( ( ( "Attempting<seq2seq4repair_space>to<seq2seq4repair_space>locate<seq2seq4repair_space>resource<seq2seq4repair_space>'" + path ) + "'<seq2seq4repair_space>using<seq2seq4repair_space>classloader<seq2seq4repair_space>the<seq2seq4repair_space>servlet<seq2seq4repair_space>context" ) ) ; } String location ; if ( clazz == ( AlternativePageFromWebContext . class ) ) { String extension = path . substring ( ( ( path . lastIndexOf ( '.' ) ) + 1 ) ) ; String simpleFileName = Strings . lastPathComponent ( clazz . getName ( ) , '.' ) ; location = ( ( "/WEB-INF/templates/" + simpleFileName ) + "." ) + extension ; } else { location = "/WEB-INF/templates/" + path ; } URL url ; try { <START_BUG> url = getWicketServlet ( ) . getServletContext ( ) . getResource ( location ) ; <END_BUG> if ( url != null ) { return new UrlResourceStream ( url ) ; } } catch ( MalformedURLException e ) { throw new WicketRuntimeException ( e ) ; } return classLoaderLocator . locate ( clazz , path ) ; } } public CustomResourceLoadingApplication ( ) { } public Class getHomePage ( ) { } protected void init ( ) { } }
public class ResourceAvailableCondition extends AbstractAvailableCondition implements Condition { private String m_resource ; public void setResource ( final String resource ) { } public boolean evaluate ( final TaskContext context ) throws TaskException { if ( ( m_resource ) == null ) { throw new TaskException ( "Resource<seq2seq4repair_space>was<seq2seq4repair_space>not<seq2seq4repair_space>specified." ) ; } <START_BUG> final ClassLoader classLoader = buildClassLoader ( ) ; <END_BUG> final InputStream instr = classLoader . getResourceAsStream ( m_resource ) ; if ( instr != null ) { IOUtil . shutdownStream ( instr ) ; return true ; } return false ; } }
public class ManualPanel extends JPanel { private static final String MANUAL_TXT_FILENAME = "manual.txt" ; private static final long serialVersionUID = 1L ; private final Logger logger = LoggerFactory . getLogger ( this . getClass ( ) . getName ( ) ) ; private JList < String > searchJList = new JList < > ( ) ; private DefaultListModel < String > searchJListModel = new DefaultListModel < > ( ) ; private JSplitPane splitPane ; @ SuppressWarnings ( "serial" ) public ManualPanel ( Main main ) { } public void initSplitPaneDivider ( ) { } private void saveSearchToList ( String tfText ) { } private Command runQuery ( Main main , String tfText ) { try { <START_BUG> String prefix = Config . getPropety ( AUTOMATED_SEARCH_PREFIX , "tmpsc<seq2seq4repair_space>online<seq2seq4repair_space>bo" ) . trim ( ) ; <END_BUG> String line = String . format ( "s<seq2seq4repair_space>%s<seq2seq4repair_space>%s" , prefix , tfText ) ; logger . info ( ( "Now<seq2seq4repair_space>running<seq2seq4repair_space>search:<seq2seq4repair_space>" + line ) ) ; return main . processLine ( line ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public void saveToFile ( ) { } }
public abstract class AbstractReadOnlyModel < T > implements IModel < T > { private static final long serialVersionUID = 1L ; public abstract T getObject ( ) { } public final void setObject ( final T object ) { } @ Override public String toString ( ) { <START_BUG> StringBuffer sb = new StringBuffer ( "Model:classname=[" ) ; <END_BUG> sb . append ( getClass ( ) . getName ( ) ) . append ( "]" ) ; return sb . toString ( ) ; } public void detach ( ) { } }
public abstract class WorldLoadedTickHandler { private boolean isLoaded = false ; protected void onTickInGame ( World [ ] worlds , Side side ) { } protected void onTickInGUI ( World [ ] worlds , Side side ) { <START_BUG> if ( ( this . isLoaded ) && ( ( worlds . length ) < 0 ) ) { <END_BUG> this . isLoaded = false ; FMLCommonHandler . instance ( ) . bus ( ) . post ( new WorldUnloadedEvent ( ) ) ; } } }
public class XQDTUriResolver implements IXQDTUriResolver { public URI resolveModuleImport ( URI baseUri , String uri , String [ ] hints ) { } public URI resolveUri ( URI baseUri , String uriString ) { } public ISourceModule locateSourceModule ( URI uri , IScriptProject project ) { IPath projectLoc = project . getProject ( ) . getLocation ( ) ; IPath path = new Path ( uri . getPath ( ) ) ; if ( projectLoc . isPrefixOf ( path ) ) { IPath packageAbolutePath = path . removeLastSegments ( 1 ) ; IPath packageRelativePath = packageAbolutePath . removeFirstSegments ( projectLoc . segmentCount ( ) ) . makeRelative ( ) . setDevice ( null ) ; IModelElement folder = null ; if ( ( packageRelativePath . segmentCount ( ) ) == 0 ) { folder = project ; } else { try { <START_BUG> folder = project . findScriptFolder ( packageRelativePath . makeAbsolute ( ) ) ; <END_BUG> } catch ( ModelException e ) { e . printStackTrace ( ) ; } } if ( folder != null ) { File f = new File ( path . toOSString ( ) ) ; if ( f . exists ( ) ) { return DLTKCore . createSourceModuleFrom ( ( ( IContainer ) ( folder . getResource ( ) ) ) . getFile ( new Path ( path . lastSegment ( ) ) ) ) ; } } } return null ; } }
public final class XpandBackendFacade { private final String _xpandFile ; private final MiddleEnd _middleEnd ; private final String _fileEncoding ; private final Collection < MetaModel > _mms ; private final Collection < Outlet > _outlets ; private static Log log = LogFactory . getLog ( XpandBackendFacade . class ) ; public static Object executeStatement ( String code , Collection < MetaModel > mms , Map < String , Object > variables , Collection < Outlet > outlets , XpandProtectedRegionResolver resolver ) { } public static Object executeStatement ( String code , String fileEncoding , Collection < MetaModel > mms , Map < String , Object > variables , Collection < Outlet > outlets , XpandProtectedRegionResolver resolver ) { } public static Object executeStatement ( String code , String fileEncoding , Collection < MetaModel > mms , Map < String , Object > variables , Collection < Outlet > outlets , List < String > advice , XpandProtectedRegionResolver resolver ) { } public Object executeStatement ( String code , Map < String , Object > variables , List < String > advice , XpandProtectedRegionResolver resolver ) { } public static void registerOutlets ( ExecutionContext ctx , Collection < Outlet > outlets ) { } public static void registerProtectedRegionResolver ( ExecutionContext ctx , XpandProtectedRegionResolver resolver ) { } private static class InMemoryPpAdapter implements InMemoryPostprocessor { private final PostProcessor _oldPp ; private final Outlet _outlet ; public InMemoryPpAdapter ( PostProcessor oldPp , Outlet outlet ) { } public CharSequence process ( CharSequence unprocessed , String uri ) { } } private static class FileHandleImpl implements FileHandle { private CharSequence _buffer ; private final Outlet _outlet ; private final File _file ; public FileHandleImpl ( CharSequence buffer , Outlet outlet , File file ) { } public CharSequence getBuffer ( ) { } public String getFileEncoding ( ) { } public Outlet getOutlet ( ) { } public File getTargetFile ( ) { } public boolean isAppend ( ) { } public boolean isOverwrite ( ) { } public void setBuffer ( CharSequence buffer ) { } public void writeAndClose ( ) { } } private static class UriBasedPpAdapter implements UriBasedPostprocessor { private final PostProcessor _oldPp ; private final Outlet _outlet ; public UriBasedPpAdapter ( PostProcessor oldPp , Outlet outlet ) { } public void process ( String uri ) { } } public static XpandBackendFacade createForFile ( String xpandFilename , String fileEncoding , Collection < MetaModel > mms , Collection < Outlet > outlets ) { } private XpandExecutionContext createXpandExecutionContext ( String fileEncoding , Collection < MetaModel > mms , Collection < Outlet > outlets ) { fileEncoding = OldHelper . normalizedFileEncoding ( fileEncoding ) ; final Output output = new OutputImpl ( ) ; for ( Outlet outlet : outlets ) output . addOutlet ( outlet ) ; final XpandExecutionContextImpl ctx = new XpandExecutionContextImpl ( output , null ) ; for ( MetaModel mm : mms ) ctx . registerMetaModel ( mm ) ; <START_BUG> ctx . setFileEncoding ( fileEncoding ) ; <END_BUG> return ctx ; } private Map < Class < ? > , Object > createSpecificParameters ( String fileEncoding , Collection < MetaModel > mms , Collection < Outlet > outlets ) { } private XpandBackendFacade ( String xpandFilename , String fileEncoding , Collection < MetaModel > mms , Collection < Outlet > outlets ) { } public Collection < NamedFunction > getContributedFunctions ( ) { } public FunctionDefContext getFunctionDefContext ( ) { } }
public class ActionExit extends UMLAction { public static ActionExit SINGLETON = new ActionExit ( ) ; private boolean active = false ; protected ActionExit ( ) { } public void actionPerformed ( ActionEvent ae ) { <START_BUG> ProjectBrowser pb = ProjectBrowser . TheInstance ; <END_BUG> Project p = ProjectManager . getManager ( ) . getCurrentProject ( ) ; if ( ( ( p != null ) && ( p . needsSave ( ) ) ) && ( ! ( active ) ) ) { active = true ; String t = MessageFormat . format ( Argo . localize ( "Actions" , "template.exit.save_changes_to" ) , new Object [ ] { p . getName ( ) } ) ; int response = JOptionPane . showConfirmDialog ( pb , t , t , JOptionPane . YES_NO_CANCEL_OPTION ) ; if ( response == ( JOptionPane . CANCEL_OPTION ) ) { active = false ; return ; } if ( response == ( JOptionPane . YES_OPTION ) ) { boolean safe = false ; if ( ActionSaveProject . SINGLETON . shouldBeEnabled ( ) ) { safe = ActionSaveProject . SINGLETON . trySave ( true ) ; } if ( ! safe ) { safe = ActionSaveProjectAs . SINGLETON . trySave ( false ) ; } if ( ! safe ) { active = false ; return ; } } active = false ; } if ( ! ( active ) ) { Configuration . save ( ) ; ArgoSecurityManager . getInstance ( ) . setAllowExit ( true ) ; System . exit ( 0 ) ; } } }
public final class WorkbenchKeyboard { private static final boolean DEBUG = Policy . DEBUG_KEY_BINDINGS ; private static final boolean DEBUG_VERBOSE = Policy . DEBUG_KEY_BINDINGS_VERBOSE ; private static final int MULTI_KEY_ASSIST_SHELL_MAX_HEIGHT = 175 ; private static final int MULTI_KEY_ASSIST_SHELL_MAX_WIDTH = 300 ; static final String OUT_OF_ORDER_KEYS = "OutOfOrderKeys" ; static KeySequence outOfOrderKeys ; private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle . getBundle ( WorkbenchKeyboard . class . getName ( ) ) ; public static List generatePossibleKeyStrokes ( Event event ) { } private static void initializeOutOfOrderKeys ( ) { } private static boolean isOutOfOrderKey ( List keyStrokes ) { } private final IActivityManager activityManager ; private final ICommandManager commandManager ; private final Listener keyDownFilter = new Listener ( ) { public void handleEvent ( Event event ) { } } ; private Shell multiKeyAssistShell = null ; private long startTime = Long . MAX_VALUE ; private final KeyBindingState state ; private final IWindowListener windowListener = new IWindowListener ( ) { public void windowActivated ( IWorkbenchWindow window ) { } public void windowClosed ( IWorkbenchWindow window ) { } public void windowDeactivated ( IWorkbenchWindow window ) { } public void windowOpened ( IWorkbenchWindow window ) { } } ; private final IWorkbench workbench ; public WorkbenchKeyboard ( Workbench associatedWorkbench , IActivityManager associatedActivityManager , ICommandManager associatedCommandManager ) { } private void checkActiveWindow ( IWorkbenchWindow window ) { } private void closeMultiKeyAssistShell ( ) { } private static boolean isEnabled ( ICommand command ) { } private boolean executeCommand ( String commandId ) throws CommandException { } private void filterKeySequenceBindings ( Event event ) { } public Listener getKeyDownFilter ( ) { } private String getPerfectMatch ( KeySequence keySequence ) { } private void incrementState ( KeySequence sequence ) { } private boolean isPartialMatch ( KeySequence keySequence ) { } private boolean isPerfectMatch ( KeySequence keySequence ) { } private final void logException ( CommandException e ) { } private void openMultiKeyAssistShell ( final Display display ) { } public boolean press ( List potentialKeyStrokes , Event event ) throws CommandException { } void processKeyEvent ( List keyStrokes , Event event ) { boolean eatKey = false ; if ( ! ( keyStrokes . isEmpty ( ) ) ) { try { eatKey = press ( keyStrokes , event ) ; } catch ( CommandException e ) { logException ( e ) ; eatKey = true ; } } if ( eatKey ) { switch ( event . type ) { case SWT . KeyDown : event . doit = false ; break ; case SWT . Traverse : event . detail = SWT . TRAVERSE_NONE ; <START_BUG> event . doit = true ; <END_BUG> break ; default : } event . type = SWT . NONE ; } } private void resetState ( ) { } }
public class JMeterThread implements Serializable , Runnable { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final long serialVersionUID = 23L ; private int initialDelay = 0 ; private Controller controller ; private boolean running ; private HashTree testTree ; private transient TestCompiler compiler ; private JMeterThreadMonitor monitor ; private String threadName ; private transient JMeterContext threadContext ; private transient JMeterVariables threadVars ; private Collection testListeners ; private transient ListenerNotifier notifier ; private int threadNum = 0 ; private long startTime = 0 ; private long endTime = 0 ; private boolean scheduler = false ; private ThreadGroup threadGroup ; private StandardJMeterEngine engine = null ; private boolean onErrorStopTest ; private boolean onErrorStopThread ; public static final String PACKAGE_OBJECT = "JMeterThread.pack" ; public static final String LAST_SAMPLE_OK = "JMeterThread.last_sample_ok" ; public JMeterThread ( ) { } public JMeterThread ( HashTree test , JMeterThreadMonitor monitor , ListenerNotifier note ) { } public void setInitialContext ( JMeterContext context ) { } public boolean isScheduled ( ) { } public void setScheduled ( boolean sche ) { } public void setStartTime ( long stime ) { } public long getStartTime ( ) { } public void setEndTime ( long etime ) { } public long getEndTime ( ) { } private void stopScheduler ( ) { } private void startScheduler ( ) { } public void setThreadName ( String threadName ) { } private static final boolean startEarlier = JMeterUtils . getPropDefault ( "jmeterthread.startearlier" , true ) ; private static final boolean reversePostProcessors = JMeterUtils . getPropDefault ( "jmeterthread.reversePostProcessors" , false ) ; public void run ( ) { } private List getSampleListeners ( SamplePackage samplePack , SamplePackage transactionPack , TransactionSampler transactionSampler ) { } protected void initRun ( ) { } private void threadStarted ( ) { } private void threadFinished ( ) { } private static class ThreadListenerTraverser implements HashTreeTraverser { private boolean isStart = false ; private ThreadListenerTraverser ( boolean start ) { } public void addNode ( Object node , HashTree subTree ) { } public void subtractNode ( ) { } public void processPath ( ) { } } public String getThreadName ( ) { } public void stop ( ) { } private void stopTest ( ) { } private void stopThread ( ) { } private void checkAssertions ( List assertions , SampleResult result ) { } private void runPostProcessors ( List extractors ) { } private void delay ( List timers ) { } private void notifyTestListeners ( ) { } private void notifyListeners ( List listeners , SampleResult result ) { <START_BUG> SampleEvent event = new SampleEvent ( result , controller . getPropertyAsString ( NAME ) ) ; <END_BUG> notifier . notifyListeners ( event , listeners ) ; } public void setInitialDelay ( int delay ) { } private void rampUpDelay ( ) { } public int getThreadNum ( ) { } public void setThreadNum ( int threadNum ) { } private class IterationListener implements LoopIterationListener { public void iterationStart ( LoopIterationEvent iterEvent ) { } } public void setEngine ( StandardJMeterEngine engine ) { } public void setOnErrorStopTest ( boolean b ) { } public void setOnErrorStopThread ( boolean b ) { } public ThreadGroup getThreadGroup ( ) { } public void setThreadGroup ( ThreadGroup group ) { } }
public class TableJDBCSeq extends AbstractJDBCSeq implements Configurable { public static final String ACTION_DROP = "drop" ; public static final String ACTION_ADD = "add" ; public static final String ACTION_GET = "get" ; public static final String ACTION_SET = "set" ; public static final String DEFAULT_TABLE = "OPENJPA_SEQUENCE_TABLE" ; private static final Localizer _loc = Localizer . forPackage ( TableJDBCSeq . class ) ; private transient JDBCConfiguration _conf = null ; private transient Log _log = null ; private int _alloc = 50 ; private int _intValue = 1 ; private final HashMap < ClassMapping , TableJDBCSeq . Status > _stat = new HashMap < ClassMapping , TableJDBCSeq . Status > ( ) ; private String _table = TableJDBCSeq . DEFAULT_TABLE ; private String _seqColumnName = "SEQUENCE_VALUE" ; private String _pkColumnName = "ID" ; private String [ ] _uniqueColumnNames ; private String _uniqueConstraintName ; private Column _seqColumn = null ; private Column _pkColumn = null ; public String getTable ( ) { } public void setTable ( String name ) { } public void setTableName ( String name ) { } public String getSequenceColumn ( ) { } public void setSequenceColumn ( String sequenceColumn ) { } public String getPrimaryKeyColumn ( ) { } public void setPrimaryKeyColumn ( String primaryKeyColumn ) { } public int getAllocate ( ) { } public void setAllocate ( int alloc ) { } public int getInitialValue ( ) { } public void setInitialValue ( int intValue ) { } public void setUniqueColumns ( String columnNames ) { } public String getUniqueColumns ( ) { } public void setIncrement ( int inc ) { } public JDBCConfiguration getConfiguration ( ) { } public void setConfiguration ( Configuration conf ) { } public void startConfiguration ( ) { } public void endConfiguration ( ) { } public void addSchema ( ClassMapping mapping , SchemaGroup group ) { Schema [ ] schemas = group . getSchemas ( ) ; for ( int i = 0 ; i < ( schemas . length ) ; i ++ ) { String schemaName = Strings . getPackageName ( _table ) ; if ( ( schemaName . length ( ) ) == 0 ) schemaName = Schemas . getNewTableSchema ( _conf ) ; if ( schemaName == null ) schemaName = schemas [ i ] . getName ( ) ; Schema schema = group . getSchema ( schemaName ) ; if ( schema == null ) schema = group . addSchema ( schemaName ) ; Table copy = schema . importTable ( _pkColumn . getTable ( ) ) ; Unique [ ] uniques = _pkColumn . getTable ( ) . getUniques ( ) ; for ( Unique u : uniques ) { <START_BUG> copy . importUnique ( u , _conf . getDBDictionaryInstance ( ) ) ; <END_BUG> } _pkColumn . resetTableName ( ( ( schemaName + "." ) + ( _pkColumn . getTableName ( ) ) ) ) ; _conf . getDBDictionaryInstance ( ) . createIndexIfNecessary ( schema , _table , _pkColumn ) ; } } protected Object nextInternal ( JDBCStore store , ClassMapping mapping ) throws Exception { } protected Object currentInternal ( JDBCStore store , ClassMapping mapping ) throws Exception { } protected void allocateInternal ( int count , JDBCStore store , ClassMapping mapping ) throws SQLException { } protected TableJDBCSeq . Status getStatus ( ClassMapping mapping ) { } protected Column addPrimaryKeyColumn ( Table table ) { } protected Object getPrimaryKey ( ClassMapping mapping ) { } private void buildTable ( ) { } private void allocateSequence ( JDBCStore store , ClassMapping mapping , TableJDBCSeq . Status stat , int alloc , boolean updateStatSeq ) throws SQLException { } private void insertSequence ( ClassMapping mapping , Connection conn ) throws SQLException { } protected long getSequence ( ClassMapping mapping , Connection conn ) throws SQLException { } protected boolean setSequence ( ClassMapping mapping , TableJDBCSeq . Status stat , int inc , boolean updateStatSeq , Connection conn ) throws SQLException { } public String resolveTableName ( ClassMapping mapping , Table table ) { } public void refreshTable ( ) throws SQLException { } public void dropTable ( ) throws SQLException { } public static void main ( String [ ] args ) throws Exception { } public static boolean run ( JDBCConfiguration conf , String [ ] args , Options opts ) throws Exception { } public static boolean run ( JDBCConfiguration conf , String [ ] args , String action ) throws Exception { } protected static class Status implements Serializable { public long seq = 1L ; public long max = 0L ; } protected PreparedStatement prepareStatement ( Connection conn , SQLBuffer buf ) throws SQLException { } protected int executeUpdate ( JDBCConfiguration conf , Connection conn , PreparedStatement stmnt , SQLBuffer buf , int opcode ) throws SQLException { } protected ResultSet executeQuery ( JDBCConfiguration conf , Connection conn , PreparedStatement stmnt , SQLBuffer buf ) throws SQLException { } protected long getSequence ( ResultSet rs , DBDictionary dict ) throws SQLException { } public void setUniqueConstraintName ( String _uniqueConstraintName ) { } public String getUniqueConstraintName ( ) { } protected class AllocateSequenceRunnable implements Runnable { JDBCStore store = null ; ClassMapping mapping = null ; TableJDBCSeq . Status stat = null ; int alloc ; boolean updateStatSeq ; AllocateSequenceRunnable ( JDBCStore store , ClassMapping mapping , TableJDBCSeq . Status stat , int alloc , boolean updateStatSeq ) { } public void run ( ) throws RuntimeException { } } protected class CurrentSequenceRunnable implements Runnable { private JDBCStore _store ; private ClassMapping _mapping ; CurrentSequenceRunnable ( JDBCStore store , ClassMapping mapping ) { } public void run ( ) throws RuntimeException { } } }
public class Tree extends Composite { NSTableColumn firstColumn ; NSTableColumn checkColumn ; NSTextFieldCell dataCell ; NSButtonCell buttonCell ; NSTableHeaderView headerView ; TreeItem [ ] items ; int itemCount ; TreeColumn [ ] columns ; TreeColumn sortColumn ; int columnCount ; int sortDirection ; boolean ignoreExpand ; boolean ignoreSelect ; boolean ignoreRedraw ; boolean reloadPending ; Rectangle imageBounds ; TreeItem insertItem ; boolean insertBefore ; static int NEXT_ID ; static final int FIRST_COLUMN_MINIMUM_WIDTH = 5 ; static final int IMAGE_GAP = 3 ; static final int TEXT_GAP = 2 ; static final int CELL_GAP = 1 ; public Tree ( Composite parent , int style ) { } void _addListener ( int eventType , Listener listener ) { } TreeItem _getItem ( TreeItem parentItem , int index , boolean create ) { } int accessibilityAttributeValue ( int id , int sel , int arg0 ) { } public void addSelectionListener ( SelectionListener listener ) { } public void addTreeListener ( TreeListener listener ) { } int calculateWidth ( TreeItem [ ] items , int index , GC gc , boolean recurse ) { } NSSize cellSize ( int id , int sel ) { } boolean canDragRowsWithIndexes_atPoint ( int id , int sel , int arg0 , int arg1 ) { } boolean checkData ( TreeItem item ) { } static int checkStyle ( int style ) { } protected void checkSubclass ( ) { } void checkItems ( ) { } void clear ( TreeItem parentItem , int index , boolean all ) { } void clearAll ( TreeItem parentItem , boolean all ) { } public void clear ( int index , boolean all ) { } public void clearAll ( boolean all ) { } void clearCachedWidth ( TreeItem [ ] items ) { } void collapseItem_collapseChildren ( int id , int sel , int itemID , boolean children ) { } public Point computeSize ( int wHint , int hHint , boolean changed ) { } void createColumn ( TreeItem item , int index ) { } void createHandle ( ) { } void createItem ( TreeColumn column , int index ) { } void createItem ( TreeItem item , TreeItem parentItem , int index ) { } void createWidget ( ) { } Color defaultBackground ( ) { } NSFont defaultNSFont ( ) { } Color defaultForeground ( ) { } public void deselectAll ( ) { } void deregister ( ) { } public void deselect ( TreeItem item ) { } void destroyItem ( TreeColumn column ) { } void destroyItem ( TreeItem item ) { } boolean dragDetect ( int x , int y , boolean filter , boolean [ ] consume ) { } void drawWithFrame_inView ( int id , int sel , int cellFrame , int view ) { } void drawInteriorWithFrame_inView ( int id , int sel , int cellFrame , int view ) { } void expandItem_expandChildren ( int id , int sel , int itemID , boolean children ) { } NSRect expansionFrameWithFrame_inView ( int id , int sel , NSRect cellRect , int view ) { if ( ( toolTipText ) == null ) <START_BUG> return cellRect ; <END_BUG> return new NSRect ( ) ; } Widget findTooltip ( NSPoint pt ) { } int getCheckColumnWidth ( ) { } public Rectangle getClientArea ( ) { } TreeColumn getColumn ( id id ) { } public TreeColumn getColumn ( int index ) { } public int getColumnCount ( ) { } public int [ ] getColumnOrder ( ) { } public TreeColumn [ ] getColumns ( ) { } public int getGridLineWidth ( ) { } public int getHeaderHeight ( ) { } public boolean getHeaderVisible ( ) { } public TreeItem getItem ( int index ) { } public TreeItem getItem ( Point point ) { } public int getItemCount ( ) { } int getItemCount ( TreeItem item ) { } public int getItemHeight ( ) { } public TreeItem [ ] getItems ( ) { } public boolean getLinesVisible ( ) { } public TreeItem getParentItem ( ) { } public TreeItem [ ] getSelection ( ) { } public int getSelectionCount ( ) { } public TreeColumn getSortColumn ( ) { } public int getSortDirection ( ) { } public TreeItem getTopItem ( ) { } void highlightSelectionInClipRect ( int id , int sel , int rect ) { } int hitTestForEvent ( int id , int sel , int event , NSRect rect , int controlView ) { } int image ( int id , int sel ) { } NSRect imageRectForBounds ( int id , int sel , NSRect cellFrame ) { } int indexOf ( NSTableColumn column ) { } public int indexOf ( TreeColumn column ) { } public int indexOf ( TreeItem item ) { } boolean isTrim ( NSView view ) { } int menuForEvent ( int id , int sel , int theEvent ) { } void mouseDown ( int id , int sel , int theEvent ) { } int nextState ( int id , int sel ) { } int outlineView_child_ofItem ( int id , int sel , int outlineView , int index , int itemID ) { } void outlineView_didClickTableColumn ( int id , int sel , int outlineView , int tableColumn ) { } int outlineView_objectValueForTableColumn_byItem ( int id , int sel , int outlineView , int tableColumn , int itemID ) { } boolean outlineView_isItemExpandable ( int id , int sel , int outlineView , int item ) { } int outlineView_numberOfChildrenOfItem ( int id , int sel , int outlineView , int item ) { } void outlineView_willDisplayCell_forTableColumn_item ( int id , int sel , int outlineView , int cell , int tableColumn , int itemID ) { } void outlineViewColumnDidMove ( int id , int sel , int aNotification ) { } void outlineViewColumnDidResize ( int id , int sel , int aNotification ) { }
public class ModelFormatter { private boolean promptExceptionMessage ( Exception e ) { } public Vector < Double > formatFluxBoundsfromGeneExpressionData ( File file , Model model , SimpleProgressBar pb ) throws Exception { } Vector < Double > parseGeneExpressionDataSPOT ( File file , Model model , boolean originalSPOT , SimpleProgressBar pb ) throws Exception { } public void formatParamsForSPOT ( ArrayList < Map < Integer , Double > > sMatrix , ArrayList < Double > lb , ArrayList < Double > ub , ArrayList < Integer > vNetIdxs , ArrayList < Double > geneExprData , ArrayList < Map < Integer , Double > > result_sMatrix , ArrayList < Double > result_lb , ArrayList < Double > result_ub , ArrayList < Double > result_geneExprData ) { try { ArrayList < Map < Integer , Double > > result_s = sMatrix ; vNetIdxs . clear ( ) ; result_sMatrix . clear ( ) ; result_lb . clear ( ) ; result_ub . clear ( ) ; int n = 0 ; for ( int i = 0 ; i < ( lb . size ( ) ) ; ++ i ) { if ( ( lb . get ( i ) ) < 0.0 ) { vNetIdxs . add ( ( i + n ) ) ; result_lb . add ( 0.0 ) ; result_ub . add ( Math . abs ( ub . get ( i ) ) ) ; result_lb . add ( 0.0 ) ; result_ub . add ( ( - ( lb . get ( i ) ) ) ) ; result_geneExprData . add ( geneExprData . get ( i ) ) ; result_geneExprData . add ( geneExprData . get ( i ) ) ; ArrayList < Map < Integer , Double > > new_S = new ArrayList < Map < Integer , Double > > ( ) ; for ( Map < Integer , Double > con : result_s ) { Map < Integer , Double > new_con = new HashMap < Integer , Double > ( ) ; for ( Map . Entry < Integer , Double > term : con . entrySet ( ) ) { int key = term . getKey ( ) ; <START_BUG> new_con . put ( ( key > ( i + n ) ? ( key + n ) + 1 : key ) , term . getValue ( ) ) ; <END_BUG> } if ( con . containsKey ( ( i + n ) ) ) { new_con . put ( ( ( i + n ) + 0 ) , ( ( con . get ( ( i + n ) ) ) * ( ( ub . get ( i ) ) < 0.0 ? - 1.0 : 1.0 ) ) ) ; new_con . put ( ( ( i + n ) + 1 ) , ( ( con . get ( ( i + n ) ) ) * ( - 1.0 ) ) ) ; } new_S . add ( new_con ) ; } result_s = new_S ; ++ n ; } else { result_lb . add ( lb . get ( i ) ) ; result_ub . add ( ub . get ( i ) ) ; result_geneExprData . add ( geneExprData . get ( i ) ) ; } } for ( Map < Integer , Double > con : result_s ) result_sMatrix . add ( con ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static void main ( String [ ] args ) { } }
public class GameController { private final RetroMachines game ; private GameScreen gameScreen ; private RetroMan retroMan ; private RetroLevel level ; private EvaluationController evaControl ; private Date levelBegin ; private float tempStepCounter ; public GameController ( RetroMachines game ) { } public void startLevel ( int levelId ) { } public void abortLevel ( ) { } public void levelFinished ( ) { } private void dispose ( ) { } private void saveProgress ( ) { } public void jumpRetroMan ( ) { } public void interactRetroMan ( ) { if ( ! ( retroMan . canJump ( ) ) ) { return ; } Vector2 elementPosition = retroMan . nextPosition ( ) ; GameElement element = level . getGameElement ( elementPosition ) ; if ( ( ( retroMan . hasPickedUpElement ( ) ) && ( element == null ) ) && ( level . isValidGameElementPosition ( elementPosition ) ) ) { GameElement previous = retroMan . layDownElement ( ) ; level . placeGameElement ( previous , elementPosition ) ; } else if ( ( ! ( retroMan . hasPickedUpElement ( ) ) ) && ( element != null ) ) { retroMan . pickupElement ( element ) ; <START_BUG> level . removeGameElement ( elementPosition ) ; <END_BUG> } } public void goLeftRetroMan ( ) { } public void goRightRetroMan ( ) { } public RetroMan getRetroMan ( ) { } public void update ( float deltaTime ) { } private void collisionDetection ( ) { } public void evaluationClicked ( ) { } }
public class CreateFilterOnToAction extends AbstractColumbaAction implements SelectionListener { public CreateFilterOnToAction ( FrameMediator frameMediator ) { } public void actionPerformed ( ActionEvent evt ) { FolderCommandReference [ ] r = ( ( org . columba . mail . gui . frame . MailFrameMediator ) ( getFrameMediator ( ) ) ) . getTableSelection ( ) ; <START_BUG> CreateFilterOnMessageCommand c = new CreateFilterOnMessageCommand ( r , CreateFilterOnMessageCommand . FILTER_ON_TO ) ; <END_BUG> processor . addOp ( c ) ; } public void selectionChanged ( SelectionChangedEvent e ) { } }
public class Launcher { public static final String ANTHOME_PROPERTY = MagicNames . ANT_HOME ; public static final String ANTLIBDIR_PROPERTY = "ant.library.dir" ; public static final String ANT_PRIVATEDIR = ".ant" ; public static final String ANT_PRIVATELIB = "lib" ; public static final String USER_LIBDIR = ( ( Launcher . ANT_PRIVATEDIR ) + ( File . separatorChar ) ) + ( Launcher . ANT_PRIVATELIB ) ; public static final String MAIN_CLASS = "org.apache.tools.ant.Main" ; public static final String USER_HOMEDIR = "user.home" ; private static final String JAVA_CLASS_PATH = "java.class.path" ; public static void main ( String [ ] args ) { } private void addPath ( String path , boolean getJars , List libPathURLs ) throws MalformedURLException { StringTokenizer tokenizer = new StringTokenizer ( path , File . pathSeparator ) ; while ( tokenizer . hasMoreElements ( ) ) { String elementName = tokenizer . nextToken ( ) ; File element = new File ( elementName ) ; if ( ( ( elementName . indexOf ( "%" ) ) != ( - 1 ) ) && ( ! ( element . exists ( ) ) ) ) { continue ; } if ( getJars && ( element . isDirectory ( ) ) ) { URL [ ] dirURLs = Locator . getLocationURLs ( element ) ; for ( int j = 0 ; j < ( dirURLs . length ) ; ++ j ) { libPathURLs . add ( dirURLs [ j ] ) ; } } try { <START_BUG> libPathURLs . add ( new URL ( Locator . encodeUri ( element . toURL ( ) . toString ( ) ) ) ) ; <END_BUG> } catch ( UnsupportedEncodingException ex ) { throw new MalformedURLException ( ex . toString ( ) ) ; } } } private void run ( String [ ] args ) throws MalformedURLException , LaunchException { } }
public class PasswordDialog extends JDialog implements ActionListener { private char [ ] password ; private boolean bool = false ; private JPasswordField passwordField ; private JCheckBox checkbox ; private JButton okButton ; private JButton cancelButton ; private JButton helpButton ; public PasswordDialog ( ) { } protected JPanel createButtonPanel ( ) { } public void showDialog ( String message , String password , boolean save ) { JLabel hostLabel = new JLabel ( message ) ; passwordField = new JPasswordField ( password , 40 ) ; checkbox = new JCheckBox ( MailResourceLoader . getString ( "dialog" , "password" , "save_password" ) ) ; checkbox . setSelected ( save ) ; checkbox . setActionCommand ( "SAVE" ) ; checkbox . addActionListener ( this ) ; setTitle ( MailResourceLoader . getString ( "dialog" , "password" , "dialog_title" ) ) ; JPanel centerPanel = new JPanel ( ) ; centerPanel . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; getContentPane ( ) . add ( centerPanel , BorderLayout . CENTER ) ; GridBagLayout mainLayout = new GridBagLayout ( ) ; centerPanel . setLayout ( mainLayout ) ; GridBagConstraints mainConstraints = new GridBagConstraints ( ) ; <START_BUG> JLabel iconLabel = new JLabel ( ImageLoader . getImageIcon ( "pgp-signature-nokey.png" ) ) ; <END_BUG> mainConstraints . anchor = GridBagConstraints . NORTHWEST ; mainConstraints . weightx = 1.0 ; mainConstraints . gridwidth = GridBagConstraints . RELATIVE ; mainConstraints . fill = GridBagConstraints . HORIZONTAL ; mainLayout . setConstraints ( iconLabel , mainConstraints ) ; centerPanel . add ( iconLabel ) ; mainConstraints . gridwidth = GridBagConstraints . REMAINDER ; mainConstraints . anchor = GridBagConstraints . WEST ; mainConstraints . insets = new Insets ( 0 , 5 , 0 , 0 ) ; mainLayout . setConstraints ( hostLabel , mainConstraints ) ; centerPanel . add ( hostLabel ) ; mainConstraints . insets = new Insets ( 5 , 5 , 0 , 0 ) ; mainLayout . setConstraints ( passwordField , mainConstraints ) ; centerPanel . add ( passwordField ) ; mainConstraints . insets = new Insets ( 5 , 5 , 0 , 0 ) ; mainLayout . setConstraints ( checkbox , mainConstraints ) ; centerPanel . add ( checkbox ) ; JPanel bottomPanel = new JPanel ( ) ; bottomPanel . setLayout ( new BorderLayout ( ) ) ; JPanel buttonPanel = createButtonPanel ( ) ; bottomPanel . add ( buttonPanel , BorderLayout . CENTER ) ; getContentPane ( ) . add ( bottomPanel , BorderLayout . SOUTH ) ; getRootPane ( ) . setDefaultButton ( okButton ) ; getRootPane ( ) . registerKeyboardAction ( this , "CANCEL" , KeyStroke . getKeyStroke ( KeyEvent . VK_ESCAPE , 0 ) , JComponent . WHEN_IN_FOCUSED_WINDOW ) ; pack ( ) ; setLocationRelativeTo ( null ) ; setVisible ( true ) ; requestFocus ( ) ; passwordField . requestFocus ( ) ; } public char [ ] getPassword ( ) { } public boolean success ( ) { } public boolean getSave ( ) { } public void actionPerformed ( ActionEvent e ) { } }
void firePerspectiveChanged ( IWorkbenchPage page , IPerspectiveDescriptor perspective , IWorkbenchPartReference partRef , String changeId ) { } void firePerspectiveClosed ( IWorkbenchPage page , IPerspectiveDescriptor perspective ) { } void firePerspectiveOpened ( IWorkbenchPage page , IPerspectiveDescriptor perspective ) { } void firePerspectiveSavedAs ( IWorkbenchPage page , IPerspectiveDescriptor oldPerspective , IPerspectiveDescriptor newPerspective ) { } public WWinActionBars getActionBars ( ) { } public IWorkbenchPage getActivePage ( ) { } WorkbenchPage getActiveWorkbenchPage ( ) { } protected Composite getPageComposite ( ) { } public MenuManager getMenuManager ( ) { } public int getNumber ( ) { } public IWorkbenchPage [ ] getPages ( ) { } public IPartService getPartService ( ) { } protected Layout getLayout ( ) { } public ISelectionService getSelectionService ( ) { } public boolean getShellActivated ( ) { } public StatusLineManager getStatusLineManager ( ) { } public IWorkbench getWorkbench ( ) { } public String getToolbarLabel ( String actionSetId ) { } private boolean hardClose ( ) { } public boolean isApplicationMenu ( String menuID ) { } boolean isWorkbenchCoolItemId ( String id ) { } void lockCoolBar ( boolean lock ) { } public boolean okToClose ( ) { } public IWorkbenchPage openPage ( final String perspId , final IAdaptable input ) throws WorkbenchException { } public IWorkbenchPage openPage ( IAdaptable input ) throws WorkbenchException { } public void removePageListener ( IPageListener l ) { } public void removePerspectiveListener ( org . eclipse . ui . IPerspectiveListener l ) { } private IStatus unableToRestorePage ( IMemento pageMem ) { } public IStatus restoreState ( IMemento memento , IPerspectiveDescriptor activeDescriptor ) { } private boolean restoreOldCoolBar ( IMemento coolbarMem ) { } private boolean readLayout ( IMemento memento , ArrayList itemIds , ArrayList wrapIndicies ) { } private IContributionItem findAlphabeticalOrder ( String startId , String itemId , IContributionManager mgr ) { } public void run ( boolean fork , boolean cancelable , IRunnableWithProgress runnable ) throws InterruptedException , InvocationTargetException { } private boolean saveAllPages ( boolean bConfirm ) { } public IStatus saveState ( IMemento memento ) { } public void setActivePage ( final IWorkbenchPage in ) { } protected boolean toolBarChildrenExist ( ) { } private void trackShellActivation ( Shell shell ) { } private void trackShellResize ( Shell newShell ) { } public void updateActionBars ( ) { } private boolean updatesDeferred ( ) { } public final void largeUpdateStart ( ) { } public final void largeUpdateEnd ( ) { } public void updateActionSets ( ) { } private void createProgressIndicator ( Shell shell ) { } class PageList { private List pagesInCreationOrder ; private List pageInActivationOrder ; private Object active ; public PageList ( ) { } public boolean add ( Object object ) { } public Iterator iterator ( ) { } public boolean contains ( Object object ) { } public boolean remove ( Object object ) { } public boolean isEmpty ( ) { } public IWorkbenchPage [ ] getPages ( ) { } public void setActive ( Object page ) { } public WorkbenchPage getActive ( ) { } public WorkbenchPage getNextActive ( ) { } } WorkbenchWindowConfigurer getWindowConfigurer ( ) { } private WorkbenchAdvisor getAdvisor ( ) { } private WorkbenchWindowAdvisor getWindowAdvisor ( ) { } private ActionBarAdvisor getActionBarAdvisor ( ) { } private Workbench getWorkbenchImpl ( ) { } public void fillActionBars ( int flags ) { } public void fillActionBars ( IActionBarConfigurer proxyBars , int flags ) { } protected void initializeBounds ( ) { } protected Rectangle getConstrainedShellBounds ( Rectangle preferredSize ) { } protected Point getInitialLocation ( Point size ) { } protected Point getInitialSize ( ) { } public void setCoolBarVisible ( boolean visible ) { } public boolean getCoolBarVisible ( ) { } public void setPerspectiveBarVisible ( boolean visible ) { } public boolean getPerspectiveBarVisible ( ) { } public void setStatusLineVisible ( boolean visible ) { } public boolean getStatusLineVisible ( ) { } private void updateLayoutDataForContents ( ) { } public boolean getShowFastViewBars ( ) { } private void setLayoutDataForContents ( ) { updateLayoutDataForContents ( ) ; if ( ( getWindowConfigurer ( ) . getShowFastViewBars ( ) ) && ( ( fastViewBar ) != null ) ) { fastViewBar . addDockingListener ( new IChangeListener ( ) { public void update ( boolean changed ) { Control reference = null ; int side = fastViewBar . getSide ( ) ; <START_BUG> fastViewBar . getControl ( ) . setLayoutData ( new org . eclipse . ui . internal . layout . TrimLayoutData ( ( side != ( SWT . BOTTOM ) ) , SWT . DEFAULT , SWT . DEFAULT ) ) ; <END_BUG> if ( ( side == ( SWT . BOTTOM ) ) && ( getWindowConfigurer ( ) . getShowStatusLine ( ) ) ) { reference = getStatusLineManager ( ) . getControl ( ) ; } defaultLayout . addTrim ( fastViewBar . getControl ( ) , side , reference ) ; WorkbenchPage page = getActiveWorkbenchPage ( ) ; if ( page != null ) { Perspective persp = page . getActivePerspective ( ) ; IViewReference activeFastView = persp . getActiveFastView ( ) ; if ( activeFastView != null ) { persp . setActiveFastView ( null ) ; persp . setActiveFastView ( activeFastView ) ; } } LayoutUtil . resize ( fastViewBar . getControl ( ) ) ; } } ) ; } } public FastViewBar getFastViewBar ( ) { } public PerspectiveBarManager getPerspectiveBar ( ) { } public ActionPresentation getActionPresentation ( ) { } protected boolean showTopSeperator ( ) { } protected StatusLineManager createStatusLineManager ( ) { } protected void createStatusLine ( Shell shell ) { } public void updateFastViewBar ( ) { } public ProgressRegion getProgressRegion ( ) { } public void addToTrim ( Control control , int side ) { } public IExtensionTracker getExtensionTracker ( ) { } public CustomizePerspectiveDialog createCustomizePerspectiveDialog ( Perspective persp ) { } IAdaptable getDefaultPageInput ( ) { } public void addPerspectiveReorderListener ( IReorderListener listener ) { } }
public class ShutdownManager { Vector list ; public ShutdownManager ( ) { } public void register ( ShutdownPluginInterface plugin ) { } public void shutdown ( ) { for ( int i = 0 ; i < ( list . size ( ) ) ; i ++ ) { ShutdownPluginInterface plugin = ( ( ShutdownPluginInterface ) ( list . get ( i ) ) ) ; <START_BUG> plugin . run ( ) ; <END_BUG> } System . exit ( 1 ) ; } }
public class StompMessageConverter { private static final Charset STOMP_CHARSET = Charset . forName ( "UTF-8" ) ; public static final byte LF = 10 ; public static final byte CR = 13 ; private static final byte COLON = ':' ; public Message < ? > toMessage ( Object stompContent ) { } private int findIndexOfPayload ( byte [ ] bytes ) { } public byte [ ] fromMessage ( Message < ? > message ) { byte [ ] payload ; if ( ( message . getPayload ( ) ) instanceof byte [ ] ) { payload = ( ( byte [ ] ) ( message . getPayload ( ) ) ) ; } else { throw new IllegalArgumentException ( ( "stompContent<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>byte[]:<seq2seq4repair_space>" + ( message . getPayload ( ) . getClass ( ) ) ) ) ; } ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; StompHeaderAccessor stompHeaders = StompHeaderAccessor . wrap ( message ) ; try { out . write ( stompHeaders . getCommand ( ) . toString ( ) . getBytes ( "UTF-8" ) ) ; out . write ( StompMessageConverter . LF ) ; <START_BUG> for ( Map . Entry < String , List < String > > entry : stompHeaders . toNativeHeaderMap ( ) . entrySet ( ) ) { <END_BUG> String key = entry . getKey ( ) ; key = replaceAllOutbound ( key ) ; for ( String value : entry . getValue ( ) ) { out . write ( key . getBytes ( "UTF-8" ) ) ; out . write ( StompMessageConverter . COLON ) ; value = replaceAllOutbound ( value ) ; out . write ( value . getBytes ( "UTF-8" ) ) ; out . write ( StompMessageConverter . LF ) ; } } out . write ( StompMessageConverter . LF ) ; out . write ( payload ) ; out . write ( 0 ) ; return out . toByteArray ( ) ; } catch ( IOException e ) { throw new StompConversionException ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>serialize<seq2seq4repair_space>" + message ) , e ) ; } } private String replaceAllOutbound ( String key ) { } private class Parser { private final String content ; private int offset ; public Parser ( String content ) { } public boolean hasNext ( ) { } public String nextToken ( byte delimiter ) { } } }
public final class UniquePredicate < T > implements Serializable , Predicate < T > { private static final long serialVersionUID = - 3319417438027438040L ; private final Set < T > iSet = new HashSet < T > ( ) ; public static < T > Predicate < T > uniquePredicate ( ) { } public UniquePredicate ( ) { } <START_BUG> public boolean evaluate ( T object ) { <END_BUG> return iSet . add ( object ) ; } }
public class ParseStuff { private static boolean useNodeParser ; public static void main ( String [ ] args ) throws RecognitionException { } public static void parseWithNodeParser ( String s ) throws RecognitionException { ANTLRStringStream stream = new ANTLRStringStream ( s ) ; Xpand3NodeLexer lexer = new Xpand3NodeLexer ( stream ) ; CommonTokenStream tokenStream = new CommonTokenStream ( lexer ) ; Xpand3NodeParser xpand3NodeParser = new Xpand3NodeParser ( tokenStream ) ; <START_BUG> Node rootNode = xpand3NodeParser . file ( ) ; <END_BUG> Node2AstTransformer node2AstTransformer = new Node2AstTransformer ( ) ; node2AstTransformer . doSwitch ( rootNode ) ; } private static void checkFor ( int extensions ) throws RecognitionException { } }
public class Spaceship implements Serializable { private BlockPos origin ; private WorldServer worldS ; private BlockMap blockMap ; private SpaceshipAssembler assembler ; private boolean canBeRemoved = true ; public static final int maxShipSize = 27000 ; @ Deprecated public Spaceship ( final BlockPos minSpan , final BlockPos origin , final BlockPos maxSpan , WorldServer worldS ) { } @ Deprecated public Spaceship ( int [ ] originMeasurement ) { } public Spaceship ( BlockPos initial , WorldServer worldS ) throws Exception { } public Spaceship ( BlockMap blocks , WorldServer worldS ) { } public Spaceship ( String s , WorldServer worldS ) throws Exception { } private void initializeBase ( ) { } public BlockPos getOrigin ( ) { } public boolean canBeRemoved ( ) { } public int getNavigatorCount ( ) { } public ArrayList < BlockPos > getPositions ( ) { } public BlockMap getBlockMap ( ) { } @ Deprecated public int [ ] getOriginMeasurementArray ( ) { } @ Deprecated public void readOriginMeasurementArray ( int [ ] array ) { } @ Deprecated private void setMeasurements ( final BlockPos minPos , final BlockPos maxPos ) { } public void setTarget ( BlockPos position ) { <START_BUG> moveTo ( position . subtract ( origin ) , LEFT , worldS ) ; <END_BUG> } public void setTarget ( BlockPos position , WorldServer world ) { } public void moveTo ( BlockPos addDirection ) { } public void moveTo ( BlockPos addDirection , WorldServer world ) { } public void moveTo ( BlockPos addDirection , int turn , WorldServer world ) { } private void moveTo ( BlockPos addDirection , World world , final int turn ) { } private void moveMeasurements ( BlockPos addDirection , int turn ) { } @ Deprecated private void moveEntities ( BlockPos addDirection ) { } @ Override public String toString ( ) { } public WorldServer getWorld ( ) { } public Boolean containsBlock ( BlockPos pos ) { } public boolean removeBlock ( BlockPos pos ) { } private void removeSpaceshipPart ( BlockPos pos ) { } public void addBlock ( final BlockPos pos ) { } private void addSpaceshipPart ( BlockPos pos ) { } public void refreshParts ( ) { } public boolean isNeighboringBlock ( final BlockPos pos ) { } public String toData ( ) { } public void fromData ( String data ) throws Exception { } public boolean measuresEquals ( Spaceship ship ) { } public void debugMap ( ) { } }
public class BoyerMooreSearchMatcher implements SearchMatcher { public BoyerMooreSearchMatcher ( String pattern , String replace , boolean ignoreCase , boolean reverseSearch , boolean beanshell , String replaceMethod ) { } public int [ ] nextMatch ( CharIndexed text , boolean start , boolean end , boolean firstTime ) { } public String substitute ( String text ) throws Exception { if ( beanshell ) { replaceNS . setVariable ( "_0" , text ) ; Object obj = BeanShell . runCachedBlock ( replaceMethod , null , replaceNS ) ; if ( obj == null ) <START_BUG> return null ; <END_BUG> else return obj . toString ( ) ; } else return replace ; } public int match ( CharIndexed text ) { } private char [ ] pattern ; private String replace ; private boolean ignoreCase ; private boolean reverseSearch ; private boolean beanshell ; private String replaceMethod ; private NameSpace replaceNS ; private int [ ] skip ; private int [ ] suffix ; private void generateSkipArray ( ) { } private static final int getSkipIndex ( char ch ) { } private void generateSuffixArray ( ) { } }
